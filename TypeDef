/*******************************************************************************
        => 数据类型
*******************************************************************************/

        U(u) unsigned           // 无符号
        L(l) long               // 长整型
// ____________________________________________________________
// 后缀大小写都可以，可以单独使用(100U)，也可以组合使用(100UL)后缀就是
// 告诉编译器该常数的属性。  默认为有符号INT型，加了u就是无符号的，加了l
// 就是long型。 做下移位就知道结果了。 以0x80为例，左移次数过多编译器会提
// 示你符号位被改变，即负数被移位成正数。 加个u的话就被编译器识别为无符号
// 数，可以随意移位。 不会影响符号位。
// ____________________________________________________________
// 在32位编译器中，int和long都是占4个字节
// unsigned int  0～4294967295
// unsigned long 0～4294967295
// unsigned int和unsigned long并没有区别



/*******************************************************************************
        => Cortex_M 符号扩展
*******************************************************************************/
// LDRB 不需要符号位扩展： 运行结果（R0 = 0x80）
// Address: 0x08000102          Value: 0x80
MOV     R0, #0
MOV     R1, #0x100
LDRB    R0, [R1, #0x2]


// 符号位扩展（最高位为：0正， 1负）
// 如果字节数为（0x80），采用（LDRSB）指令读出时，
// 则这一数值将被转换成（0xFFFFFF80），再放置到目的寄存器中
// LDRSB 进行符号位扩展： 运行结果（0xFFFFFF80）
// Address: 0x08000102          Value: 0x80
MOV     R0, #0
MOV     R1, #0x100
LDRSB   R0, [R1, #0x2]





/*******************************************************************************
        => Cortex_M 数据类型
*******************************************************************************/
//      Load            Store           Type
        LDRB            STRB            8- bit unsigned
        LDRSB           STRB            8- bit signed
        LDRH            STRH            16-bit unsigned
        LDRSH           STRSH           16-bit signed
        LDR             STR             32-bit
        LDM             STM             32-bt Multiple 
        LDRD            STRD            64-bit Double-word 
        POP             PUSH            32-bit Stack operations 




