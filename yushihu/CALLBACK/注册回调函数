float add(float a, float b)
{
        return (a + b);
}
int main(void)
{
        // 函数指针的声明
        float (*fnptr_add)(float a, float b);
        
        // 函数指针的使用
        fnptr_add = add;
        float sum = fnptr_add(1, 2);
}
// SystemClock_Config();
void (*fnptr_systemclock_config)(void);         // 函数指针的声明
fnptr_systemclock_config = SystemClock_Config;  // 函数指针的赋值
fnptr_systemclock_config();                     // 函数指针的使用






//______________________________________________________________________________
//      => 函数指针注册函数
//______________________________________________________________________________
void (*fnptr_print)(const char *);              // 声明函数指针

                                                 // 注册函数指针
void log_info_register_callback(void (*fnptr)(const char *)
{
        fnptr_print = fnptr;
}
void log_info_unregister_callback(void)         // 反注册函数指针
{
        fnptr_print = NULL;
}

// 输出日志信息， 并追加时间戳
// string  = 原始的日志信息
void log_info(const char *string)
{
        // sprintf(); 格式化字符串（输出到字符缓冲区）
        char buffer[256];
        sprintf(buffer, "[%u] %s\r\n", HAL_GetTick(), string);
        if (fnptr_print != NULL) {
                fnptr_print(buffer);
        }
}

--------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>

void usart1_print(const char *string)
{
        HAL_UART_Transmit(huart1, (uint8_t *)str, strlen(str), HA_MAX_DELAY);
}
int main(void)
{
        // 注册回调函数
        log_info_register_callback(usart1_print);
        // 使用回调函数
        log_info("Program started ...");
        log_info("Delay 1000MS ...");
        HAL_Delay(1000);
        log_info("Delay complete ...");
}





//______________________________________________________________________________
//      => STM32 DMA 回调函数
//______________________________________________________________________________
typedef enum {
        HAL_DMA_XFER_CPLT_CB_ID         = 0x00U,        // 传输完成标志位
        HAL_DMA_XFER_HALFCPLT_CB_ID     = 0x01U,        // 半传输完成标志位
        HAL_DMA_XFER_ERROR_CB_ID        = 0x02U,        // 传输出错标志位
        HAL_DMA_XFER_ABORT_CB_ID        = 0x03U,        // Abort
        HAL_DMA_XFER_ALL_CB_ID          = 0x04U,        // All
} HAL_DMA_CallbackIDTypeDef;
HAL_StatusTypeDef    HAL_DMA_RegisterCallback(          // 注册
        DMA_HandleTypeDef               *hdma,          // DMA通道句柄指针
        HAL_DMA_CallbackIDTypeDef       CallbackID,     // 类型
        void (*pCallback)(DMA_HandleTypeDef  *_hdma))   // 函数指针
HAL_StatusTypeDef    HAL_DMA_UnRegisterCallback(        // 反注册
        DMA_HandleTypeDef               *hdma,
        HAL_DMA_CallbackIDTypeDef       CallbackID)



// ____________________________________________________________
// 配置DMA中断   -> 初始化DMA   -> 注册回调函数   -> 启动DMA
// ____________________________________________________________

DMA_HandleTypeDef hdma_memory_to_memory; // 内存到内存传输
uint8_t         src[1024];              // 数据源
uint8_t         dst[1024];              // 数据目的
uint8_t         flagDMAXferCplt;        // DMA传输完成标志


int main(void)
{
        uint32_t i;
        for (i = 0; i < 1024; i++) {
                src[i] = (uint8_t)(i % 256);
        }
        
        HAL_Init();
        // 配置DMA1通道1的中断源
        HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
        HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
        
        // 初始化DMA
        hdma_memory_to_memory.Instance = DMA1_Channel1;
        hdma_memory_to_memory.Init.Direction = DMA_MEMORY_TO_MEMORY;
        hdma_memory_to_memory.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
        hdma_memory_to_memory.Init.MemInc = DMA_MINC_ENABLE;
        hdma_memory_to_memory.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
        hdma_memory_to_memory.Init.PeriphInc = DMA_PINC_ENABLE;
        hdma_memory_to_memory.Init.Priority = DMA_PRIORITY_MEDIUM;
        __HAL_RCC_DMA1_CLK_ENABLE();
        HAL_DMA_Init(&hdma_memory_to_memory);
        
        // 注册回调函数
        HAL_DMA_RegisterCallback(       &hdma_memory_to_memory, 
                                        HAL_DMA_XFER_CPLT_CB_ID,
                                        DMA_M2M_XferCpltCallback);
        HAL_DMA_RegisterCallback(       &hdma_memory_to_memory, 
                                        HAL_DMA_XFER_HALFCPLT_CB_ID,
                                        DMA_M2M_XferHalfCpltCallback);
        HAL_DMA_RegisterCallback(       &hdma_memory_to_memory, 
                                        HAL_DMA_XFER_ERROR_CB_ID,
                                        DMA_M2M_XferErrorCallback);
                                        
        // 启动DMA
        HAL_DMA_Start_IT(       &hdma_memory_to_memory,
                                (uint32_t)src,          // 源地址
                                (uint32_t)dst,          // 目的地址
                                1024);                  // 数据长度
        
        while (1) {
                if (flagDMAXferCplt == 1) {
                        break;
                }
        }
        
        while (1) {
        }
}


// DMA1中断服务程序
void DMA1_Channel1_IRQHandler(void)
{
        HAL_DMA_IRQHandler(&hdma_memory_to_memory);
}
// DMA1传输完成回调函数
static void DMA_M2M_XferCpltCallback(DMA_HandleTypeDef *hdma)
{
        if (hdma->Instance == hdma_memory_to_memory.Instance) {
                flagDMAXferCplt = 1;
        }
        
}
// DMA1传输Half完成回调函数
static void DMA_M2M_XferHalfCpltCallback(DMA_HandleTypeDef *hdma)
{
}
// DMA1传输Error回调函数
static void DMA_M2M_XferErrorCallback(DMA_HandleTypeDef *hdma)
{
}




//______________________________________________________________________________
//      => EXTI
//______________________________________________________________________________

PA0 ---------> |------|
PB0 ---------> |      |            |-------|            |------|
PC0 ---------> |      | ---------> | EXTI0 | ---------> |      | ---------> EXTI0_IRQHandler
... ---------> |      |            |-------|            |      |
PG0 ---------> |------|                                 |      |
                                                        | NVIC |
PA1 ---------> |------|                                 |      |
PB1 ---------> |      |            |-------|            |      |
PC1 ---------> |      | ---------> | EXTI1 | ---------> |      | ---------> EXTI1_IRQHandler
... ---------> |      |            |-------|            |------|
PG1 ---------> |------|



// 外部中断编程步骤
// ____________________________________________________________
1. // 为EXTI的一条线声明一个句柄
        EXTI_HandleTypeDef      hexti;
2. // 配置EXTI线的基本参数
   EXTI_ConfigTypeDef exticonfig;
   exticonfig.Line    = EXTI_LINE_0;            // 根据GPIO的引脚编号选择那个EXTI线
   exticonfig.Trigger = EXTI_TRIGGER_RISING;    // 选择EXTI的触发条件（上升沿，下降沿，还是双边沿触发）
   exticonfig.Mode    = EXTI_MODE_INTERRUPT;    // 选择EXTI的触发模式（是触发中断，还是产生事件，还是既触发中断也产生事件）
   __HAL_RCC_AFIO_CLK_ENABLE();                 // 开启AFIO时钟
   exticonfig.GPIOSel = EXTI_GPIOA;             // 如果是 EXTI0 ~ EXTI15 ， 需要配置GPIO的端口号
   HAL_EXTI_SetConfigLine(&hexti, &exticonfig); // 初始化EXTI模块
3. // 编写回调函数
   比如： void EXTI0_CallbackFun() {}
4. // 注册回调函数
   HAL_EXTI_RegisterCallbcak(&hexti, ..., EXTI0_Callback);
5. // 实现中为响应函数
   void EXTI0_IRQHandler(void)
   {
        HAL_EXTI_IRQHandler(&hexti);
   }
   
   
   
// 外部中断编程
// ____________________________________________________________
EXTI_HandleTypeDef      hEXTILine0;
int main(void)
{
        GPIO_InitTypeDef        gpioinit;
        gpioinit.Pin    = GPIO_PIN_0 | GPIO_PIN_1;
        gpioinit.Mode   = GPIO_MODE_INPUT;
        gpioinit.Pull   = GPIO_NOPULL;
        __HAL_GPIOA_CLK_ENABLE();
        HAL_GPIO_Init(GPIO, &gpioinit);
        
        // 配置EXTI线0
        EXTI_ConfigTypeDef exticonfig;
        exticonfig.Line = EXTI_LINE_0;
        exticonfig.Trigger = EXTI_TRIGGER_RISING_FALLING;
        exticonfig.Mode = EXTI_MODE_INTERRUPT;
        exticonfig.GPIOSel = EXTI_GPIOA;
        __HAL_RCC_AFIO_CLK_ENABLE();    // EXTI模块需要AFIO时钟
        HAL_EXTI_SetConfigLine(&hEXTILine0, &exticonfig);
        
        // 注册回用户自己编写调函数
        HAL_EXTI_RegisterCallbcak(&hEXTILine0, HAL_EXTI_COMMON_CB_ID, EXTIO_User_Callback);
        
        // 打开EXTI0（线0）中断
        HAL_NVIC_EnableIRQ(EXTI0_IRQn);
        

}
// 用户回调函数
// ____________________________________________________________
void EXTIO_User_Callback(void)
{
        ........
}
// EXTI0 中断服务程序
// ____________________________________________________________
void EXTI0_IRQHandler(void)
{
        HAL_EXTI_IRQHandler(&hEXTILine0);
}
