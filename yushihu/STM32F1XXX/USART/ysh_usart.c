#include "ysh_usart.h"



/*******************************************************************************
  函数名称: void uart_setup(void)
  输入参数: 无
  输出参数: 无
  函数功能: UART__初始化设置(1位停止位，无奇偶校验位，8位数据位)
  +_______________________________________________________________+
  |    STM32F10x__f_PCLK = 72 MHz                                 |
  |_______________________________________________________________|
  |    115200        39.0625         0%          BRR = 0x0271     |
  |    9600          468.75          0%          BRR = 0x1D4C     |
  |_______________________________________________________________|
*******************************************************************************/
void usart_setup(void)
{
        //因USART默认的利用功能为（PA9, PA10）， 所以AFIO不用打开 
        //RCC->APB2ENR    |=  (1 << 0);         // AFIO 时钟开启
        //RCC->APB2RSTR   |=  (1 << 0);         // AFIO  - RESET
        //RCC->APB2RSTR   &= ~(1 << 0);         // AFIO  - StopReset
        //
        RCC->APB2ENR    |=  (1 << 2);           // GPIO 时钟开启
        RCC->APB2RSTR   |=  (1 << 2);           // GPIOA - RESET
        RCC->APB2RSTR   &= ~(1 << 2);           // GPIOA - StopReset
        GPIOA->CRH      &=  (0xFFFFF00F);       // 清除相关的位
        GPIOA->CRH      |=  (0x000000B0);       // TX(PA.09)复用推挽输出__50MHz__
        GPIOA->CRH      |=  (0x00000400);       // RX(PA.10)浮空输入（也可以上拉输入）
        //
        RCC->APB2ENR    |=  (1 << 14);          // 打开USART1时钟
        RCC->APB2RSTR   |=  (1 << 14);          // USART1 - RESET
        RCC->APB2RSTR   &= ~(1 << 14);          // USART1 - StopReset
        USART1->CR1     |=  (BIT_13);           // USART模块使能
        USART1->CR1     &= ~(BIT_12);           // 1个起始位, 8个数据位
        USART1->CR2     &= ~(BIT_13 + BIT_12);  // 1个停止位
        USART1->CR1     |=  (BIT_03 + BIT_02);  // 发送使能 | 接收使能
        USART1->BRR      =  (0x0271);           // 72MHz@(115200bps)
}
/*******************************************************************************
  函数名称: void uart_send_string(void)
  输入参数: 无
  输出参数: 无
  函数功能: 串口向上位机发送一串字符
  +_______________________________________________________________+
  |    uint8_t tx_buf[] = "ERROR_CODE = 0x00\n";                  |
  |    uint8_t *pbuf = tx_buf;                                    |
  |_______________________________________________________________|
*******************************************************************************/
void usart_send_string(void)
{
        uint8_t tx_buf[] = "ERROR_CODE = 0x00\n";
        uint8_t *pbuf    = tx_buf;
        uint16_t timeout = 50000;
        // 如果字符不是尾0（循环继续发送字符）
        while (*pbuf != '\0') {
                // 发送一个字节（如果数据还没有传输到移位寄存器）， 超时检测
                while ((USART1->SR & BIT_07) == 0) {
                        if (0 == timeout--) {
                                return;
                        }
                }
                timeout     = 50000;
                USART1->DR  = *pbuf++;
        }
        // 等待最后一个字节发送完成
        while ((USART1->SR & BIT_06) == 0) {
                if (0 == timeout--) {
                        return;
                }
        }
}
