ARM GAS  /tmp/ccTLI8H2.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"thread.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text._thread_cleanup_execute,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.thumb
  19              		.thumb_func
  20              		.fpu softvfp
  22              	_thread_cleanup_execute:
  23              	.LFB15:
  24              		.file 1 "rtthread/src/thread.c"
   1:rtthread/src/thread.c **** /*
   2:rtthread/src/thread.c ****  * Copyright (c) 2006-2021, RT-Thread Development Team
   3:rtthread/src/thread.c ****  *
   4:rtthread/src/thread.c ****  * SPDX-License-Identifier: Apache-2.0
   5:rtthread/src/thread.c ****  *
   6:rtthread/src/thread.c ****  * Change Logs:
   7:rtthread/src/thread.c ****  * Date           Author       Notes
   8:rtthread/src/thread.c ****  * 2006-03-28     Bernard      first version
   9:rtthread/src/thread.c ****  * 2006-04-29     Bernard      implement thread timer
  10:rtthread/src/thread.c ****  * 2006-04-30     Bernard      added THREAD_DEBUG
  11:rtthread/src/thread.c ****  * 2006-05-27     Bernard      fixed the rt_thread_yield bug
  12:rtthread/src/thread.c ****  * 2006-06-03     Bernard      fixed the thread timer init bug
  13:rtthread/src/thread.c ****  * 2006-08-10     Bernard      fixed the timer bug in thread_sleep
  14:rtthread/src/thread.c ****  * 2006-09-03     Bernard      changed rt_timer_delete to rt_timer_detach
  15:rtthread/src/thread.c ****  * 2006-09-03     Bernard      implement rt_thread_detach
  16:rtthread/src/thread.c ****  * 2008-02-16     Bernard      fixed the rt_thread_timeout bug
  17:rtthread/src/thread.c ****  * 2010-03-21     Bernard      change the errno of rt_thread_delay/sleep to
  18:rtthread/src/thread.c ****  *                             RT_EOK.
  19:rtthread/src/thread.c ****  * 2010-11-10     Bernard      add cleanup callback function in thread exit.
  20:rtthread/src/thread.c ****  * 2011-09-01     Bernard      fixed rt_thread_exit issue when the current
  21:rtthread/src/thread.c ****  *                             thread preempted, which reported by Jiaxing Lee.
  22:rtthread/src/thread.c ****  * 2011-09-08     Bernard      fixed the scheduling issue in rt_thread_startup.
  23:rtthread/src/thread.c ****  * 2012-12-29     Bernard      fixed compiling warning.
  24:rtthread/src/thread.c ****  * 2016-08-09     ArdaFu       add thread suspend and resume hook.
  25:rtthread/src/thread.c ****  * 2017-04-10     armink       fixed the rt_thread_delete and rt_thread_detach
  26:rtthread/src/thread.c ****                                bug when thread has not startup.
  27:rtthread/src/thread.c ****  * 2018-11-22     Jesven       yield is same to rt_schedule
  28:rtthread/src/thread.c ****  *                             add support for tasks bound to cpu
  29:rtthread/src/thread.c ****  */
  30:rtthread/src/thread.c **** 
  31:rtthread/src/thread.c **** #include <rthw.h>
  32:rtthread/src/thread.c **** #include <rtthread.h>
  33:rtthread/src/thread.c **** 
  34:rtthread/src/thread.c **** extern rt_list_t rt_thread_priority_table[RT_THREAD_PRIORITY_MAX];
ARM GAS  /tmp/ccTLI8H2.s 			page 2


  35:rtthread/src/thread.c **** extern struct rt_thread *rt_current_thread;
  36:rtthread/src/thread.c **** extern rt_list_t rt_thread_defunct;
  37:rtthread/src/thread.c **** 
  38:rtthread/src/thread.c **** #ifdef RT_USING_HOOK
  39:rtthread/src/thread.c **** 
  40:rtthread/src/thread.c **** static void (*rt_thread_suspend_hook)(rt_thread_t thread);
  41:rtthread/src/thread.c **** static void (*rt_thread_resume_hook) (rt_thread_t thread);
  42:rtthread/src/thread.c **** static void (*rt_thread_inited_hook) (rt_thread_t thread);
  43:rtthread/src/thread.c **** 
  44:rtthread/src/thread.c **** /**
  45:rtthread/src/thread.c ****  * @ingroup Hook
  46:rtthread/src/thread.c ****  * This function sets a hook function when the system suspend a thread.
  47:rtthread/src/thread.c ****  *
  48:rtthread/src/thread.c ****  * @param hook the specified hook function
  49:rtthread/src/thread.c ****  *
  50:rtthread/src/thread.c ****  * @note the hook function must be simple and never be blocked or suspend.
  51:rtthread/src/thread.c ****  */
  52:rtthread/src/thread.c **** void rt_thread_suspend_sethook(void (*hook)(rt_thread_t thread))
  53:rtthread/src/thread.c **** {
  54:rtthread/src/thread.c ****     rt_thread_suspend_hook = hook;
  55:rtthread/src/thread.c **** }
  56:rtthread/src/thread.c **** 
  57:rtthread/src/thread.c **** /**
  58:rtthread/src/thread.c ****  * @ingroup Hook
  59:rtthread/src/thread.c ****  * This function sets a hook function when the system resume a thread.
  60:rtthread/src/thread.c ****  *
  61:rtthread/src/thread.c ****  * @param hook the specified hook function
  62:rtthread/src/thread.c ****  *
  63:rtthread/src/thread.c ****  * @note the hook function must be simple and never be blocked or suspend.
  64:rtthread/src/thread.c ****  */
  65:rtthread/src/thread.c **** void rt_thread_resume_sethook(void (*hook)(rt_thread_t thread))
  66:rtthread/src/thread.c **** {
  67:rtthread/src/thread.c ****     rt_thread_resume_hook = hook;
  68:rtthread/src/thread.c **** }
  69:rtthread/src/thread.c **** 
  70:rtthread/src/thread.c **** /**
  71:rtthread/src/thread.c ****  * @ingroup Hook
  72:rtthread/src/thread.c ****  * This function sets a hook function when a thread is initialized.
  73:rtthread/src/thread.c ****  *
  74:rtthread/src/thread.c ****  * @param hook the specified hook function
  75:rtthread/src/thread.c ****  */
  76:rtthread/src/thread.c **** void rt_thread_inited_sethook(void (*hook)(rt_thread_t thread))
  77:rtthread/src/thread.c **** {
  78:rtthread/src/thread.c ****     rt_thread_inited_hook = hook;
  79:rtthread/src/thread.c **** }
  80:rtthread/src/thread.c **** 
  81:rtthread/src/thread.c **** #endif
  82:rtthread/src/thread.c **** 
  83:rtthread/src/thread.c **** /* must be invoke witch rt_hw_interrupt_disable */
  84:rtthread/src/thread.c **** static void _thread_cleanup_execute(rt_thread_t thread)
  85:rtthread/src/thread.c **** {
  25              		.loc 1 85 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              	.LVL0:
  30 0000 38B5     		push	{r3, r4, r5, lr}
ARM GAS  /tmp/ccTLI8H2.s 			page 3


  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 16
  33              		.cfi_offset 3, -16
  34              		.cfi_offset 4, -12
  35              		.cfi_offset 5, -8
  36              		.cfi_offset 14, -4
  37 0002 0446     		mov	r4, r0
  86:rtthread/src/thread.c ****     register rt_base_t level;
  87:rtthread/src/thread.c **** 
  88:rtthread/src/thread.c ****     level = rt_hw_interrupt_disable();
  38              		.loc 1 88 0
  39 0004 FFF7FEFF 		bl	rt_hw_interrupt_disable
  40              	.LVL1:
  41 0008 0546     		mov	r5, r0
  42              	.LVL2:
  89:rtthread/src/thread.c **** 
  90:rtthread/src/thread.c ****     /* invoke thread cleanup */
  91:rtthread/src/thread.c ****     if (thread->cleanup != RT_NULL)
  43              		.loc 1 91 0
  44 000a 236F     		ldr	r3, [r4, #112]
  45 000c 0BB1     		cbz	r3, .L2
  92:rtthread/src/thread.c ****         thread->cleanup(thread);
  46              		.loc 1 92 0
  47 000e 2046     		mov	r0, r4
  48              	.LVL3:
  49 0010 9847     		blx	r3
  50              	.LVL4:
  51              	.L2:
  93:rtthread/src/thread.c **** 
  94:rtthread/src/thread.c ****     rt_hw_interrupt_enable(level);
  52              		.loc 1 94 0
  53 0012 2846     		mov	r0, r5
  54 0014 FFF7FEFF 		bl	rt_hw_interrupt_enable
  55              	.LVL5:
  95:rtthread/src/thread.c **** }
  56              		.loc 1 95 0
  57 0018 38BD     		pop	{r3, r4, r5, pc}
  58              		.cfi_endproc
  59              	.LFE15:
  61              		.section	.text.rt_thread_exit,"ax",%progbits
  62              		.align	1
  63              		.global	rt_thread_exit
  64              		.syntax unified
  65              		.thumb
  66              		.thumb_func
  67              		.fpu softvfp
  69              	rt_thread_exit:
  70              	.LFB16:
  96:rtthread/src/thread.c **** 
  97:rtthread/src/thread.c **** void rt_thread_exit(void)
  98:rtthread/src/thread.c **** {
  71              		.loc 1 98 0
  72              		.cfi_startproc
  73              		@ args = 0, pretend = 0, frame = 0
  74              		@ frame_needed = 0, uses_anonymous_args = 0
  75 0000 38B5     		push	{r3, r4, r5, lr}
  76              	.LCFI1:
ARM GAS  /tmp/ccTLI8H2.s 			page 4


  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 3, -16
  79              		.cfi_offset 4, -12
  80              		.cfi_offset 5, -8
  81              		.cfi_offset 14, -4
  99:rtthread/src/thread.c ****     struct rt_thread *thread;
 100:rtthread/src/thread.c ****     register rt_base_t level;
 101:rtthread/src/thread.c **** 
 102:rtthread/src/thread.c ****     /* get current thread */
 103:rtthread/src/thread.c ****     thread = rt_current_thread;
  82              		.loc 1 103 0
  83 0002 144B     		ldr	r3, .L9
  84 0004 1C68     		ldr	r4, [r3]
  85              	.LVL6:
 104:rtthread/src/thread.c **** 
 105:rtthread/src/thread.c ****     /* disable interrupt */
 106:rtthread/src/thread.c ****     level = rt_hw_interrupt_disable();
  86              		.loc 1 106 0
  87 0006 FFF7FEFF 		bl	rt_hw_interrupt_disable
  88              	.LVL7:
  89 000a 0546     		mov	r5, r0
  90              	.LVL8:
 107:rtthread/src/thread.c **** 
 108:rtthread/src/thread.c ****     _thread_cleanup_execute(thread);
  91              		.loc 1 108 0
  92 000c 2046     		mov	r0, r4
  93              	.LVL9:
  94 000e FFF7FEFF 		bl	_thread_cleanup_execute
  95              	.LVL10:
 109:rtthread/src/thread.c **** 
 110:rtthread/src/thread.c ****     /* remove from schedule */
 111:rtthread/src/thread.c ****     rt_schedule_remove_thread(thread);
  96              		.loc 1 111 0
  97 0012 2046     		mov	r0, r4
  98 0014 FFF7FEFF 		bl	rt_schedule_remove_thread
  99              	.LVL11:
 112:rtthread/src/thread.c ****     /* change stat */
 113:rtthread/src/thread.c ****     thread->stat = RT_THREAD_CLOSE;
 100              		.loc 1 113 0
 101 0018 0423     		movs	r3, #4
 102 001a 84F83430 		strb	r3, [r4, #52]
 114:rtthread/src/thread.c **** 
 115:rtthread/src/thread.c ****     /* remove it from timer list */
 116:rtthread/src/thread.c ****     rt_timer_detach(&thread->thread_timer);
 103              		.loc 1 116 0
 104 001e 04F14400 		add	r0, r4, #68
 105 0022 FFF7FEFF 		bl	rt_timer_detach
 106              	.LVL12:
 117:rtthread/src/thread.c **** 
 118:rtthread/src/thread.c ****     if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
 107              		.loc 1 118 0
 108 0026 2046     		mov	r0, r4
 109 0028 FFF7FEFF 		bl	rt_object_is_systemobject
 110              	.LVL13:
 111 002c 0128     		cmp	r0, #1
 112 002e 0DD0     		beq	.L8
 119:rtthread/src/thread.c ****     {
ARM GAS  /tmp/ccTLI8H2.s 			page 5


 120:rtthread/src/thread.c ****         rt_object_detach((rt_object_t)thread);
 121:rtthread/src/thread.c ****     }
 122:rtthread/src/thread.c ****     else
 123:rtthread/src/thread.c ****     {
 124:rtthread/src/thread.c ****         /* insert to defunct thread list */
 125:rtthread/src/thread.c ****         rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
 113              		.loc 1 125 0
 114 0030 04F11402 		add	r2, r4, #20
 115              	.LVL14:
 116              	.LBB16:
 117              	.LBB17:
 118              		.file 2 "rtthread/include/rtservice.h"
   1:rtthread/include/rtservice.h **** /*
   2:rtthread/include/rtservice.h ****  * Copyright (c) 2006-2021, RT-Thread Development Team
   3:rtthread/include/rtservice.h ****  *
   4:rtthread/include/rtservice.h ****  * SPDX-License-Identifier: Apache-2.0
   5:rtthread/include/rtservice.h ****  *
   6:rtthread/include/rtservice.h ****  * Change Logs:
   7:rtthread/include/rtservice.h ****  * Date           Author       Notes
   8:rtthread/include/rtservice.h ****  * 2006-03-16     Bernard      the first version
   9:rtthread/include/rtservice.h ****  * 2006-09-07     Bernard      move the kservice APIs to rtthread.h
  10:rtthread/include/rtservice.h ****  * 2007-06-27     Bernard      fix the rt_list_remove bug
  11:rtthread/include/rtservice.h ****  * 2012-03-22     Bernard      rename kservice.h to rtservice.h
  12:rtthread/include/rtservice.h ****  * 2017-11-15     JasonJia     Modify rt_slist_foreach to rt_slist_for_each_entry.
  13:rtthread/include/rtservice.h ****  *                             Make code cleanup.
  14:rtthread/include/rtservice.h ****  */
  15:rtthread/include/rtservice.h **** 
  16:rtthread/include/rtservice.h **** #ifndef __RT_SERVICE_H__
  17:rtthread/include/rtservice.h **** #define __RT_SERVICE_H__
  18:rtthread/include/rtservice.h **** 
  19:rtthread/include/rtservice.h **** #ifdef __cplusplus
  20:rtthread/include/rtservice.h **** extern "C" {
  21:rtthread/include/rtservice.h **** #endif
  22:rtthread/include/rtservice.h **** 
  23:rtthread/include/rtservice.h **** /**
  24:rtthread/include/rtservice.h ****  * @addtogroup KernelService
  25:rtthread/include/rtservice.h ****  */
  26:rtthread/include/rtservice.h **** 
  27:rtthread/include/rtservice.h **** /**@{*/
  28:rtthread/include/rtservice.h **** 
  29:rtthread/include/rtservice.h **** /**
  30:rtthread/include/rtservice.h ****  * rt_container_of - return the member address of ptr, if the type of ptr is the
  31:rtthread/include/rtservice.h ****  * struct type.
  32:rtthread/include/rtservice.h ****  */
  33:rtthread/include/rtservice.h **** #define rt_container_of(ptr, type, member) \
  34:rtthread/include/rtservice.h ****     ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))
  35:rtthread/include/rtservice.h **** 
  36:rtthread/include/rtservice.h **** 
  37:rtthread/include/rtservice.h **** /**
  38:rtthread/include/rtservice.h ****  * @brief initialize a list object
  39:rtthread/include/rtservice.h ****  */
  40:rtthread/include/rtservice.h **** #define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }
  41:rtthread/include/rtservice.h **** 
  42:rtthread/include/rtservice.h **** /**
  43:rtthread/include/rtservice.h ****  * @brief initialize a list
  44:rtthread/include/rtservice.h ****  *
  45:rtthread/include/rtservice.h ****  * @param l list to be initialized
ARM GAS  /tmp/ccTLI8H2.s 			page 6


  46:rtthread/include/rtservice.h ****  */
  47:rtthread/include/rtservice.h **** rt_inline void rt_list_init(rt_list_t *l)
  48:rtthread/include/rtservice.h **** {
  49:rtthread/include/rtservice.h ****     l->next = l->prev = l;
  50:rtthread/include/rtservice.h **** }
  51:rtthread/include/rtservice.h **** 
  52:rtthread/include/rtservice.h **** /**
  53:rtthread/include/rtservice.h ****  * @brief insert a node after a list
  54:rtthread/include/rtservice.h ****  *
  55:rtthread/include/rtservice.h ****  * @param l list to insert it
  56:rtthread/include/rtservice.h ****  * @param n new node to be inserted
  57:rtthread/include/rtservice.h ****  */
  58:rtthread/include/rtservice.h **** rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
  59:rtthread/include/rtservice.h **** {
  60:rtthread/include/rtservice.h ****     l->next->prev = n;
 119              		.loc 2 60 0
 120 0034 084B     		ldr	r3, .L9+4
 121 0036 1968     		ldr	r1, [r3]
 122 0038 4A60     		str	r2, [r1, #4]
  61:rtthread/include/rtservice.h ****     n->next = l->next;
 123              		.loc 2 61 0
 124 003a 6161     		str	r1, [r4, #20]
  62:rtthread/include/rtservice.h **** 
  63:rtthread/include/rtservice.h ****     l->next = n;
 125              		.loc 2 63 0
 126 003c 1A60     		str	r2, [r3]
  64:rtthread/include/rtservice.h ****     n->prev = l;
 127              		.loc 2 64 0
 128 003e A361     		str	r3, [r4, #24]
 129              	.LVL15:
 130              	.L6:
 131              	.LBE17:
 132              	.LBE16:
 126:rtthread/src/thread.c ****     }
 127:rtthread/src/thread.c **** 
 128:rtthread/src/thread.c ****     /* switch to next task */
 129:rtthread/src/thread.c ****     rt_schedule();
 133              		.loc 1 129 0
 134 0040 FFF7FEFF 		bl	rt_schedule
 135              	.LVL16:
 130:rtthread/src/thread.c **** 
 131:rtthread/src/thread.c ****     /* enable interrupt */
 132:rtthread/src/thread.c ****     rt_hw_interrupt_enable(level);
 136              		.loc 1 132 0
 137 0044 2846     		mov	r0, r5
 138 0046 FFF7FEFF 		bl	rt_hw_interrupt_enable
 139              	.LVL17:
 133:rtthread/src/thread.c **** }
 140              		.loc 1 133 0
 141 004a 38BD     		pop	{r3, r4, r5, pc}
 142              	.LVL18:
 143              	.L8:
 120:rtthread/src/thread.c ****     }
 144              		.loc 1 120 0
 145 004c 2046     		mov	r0, r4
 146 004e FFF7FEFF 		bl	rt_object_detach
 147              	.LVL19:
ARM GAS  /tmp/ccTLI8H2.s 			page 7


 148 0052 F5E7     		b	.L6
 149              	.L10:
 150              		.align	2
 151              	.L9:
 152 0054 00000000 		.word	rt_current_thread
 153 0058 00000000 		.word	rt_thread_defunct
 154              		.cfi_endproc
 155              	.LFE16:
 157              		.section	.text._rt_thread_init,"ax",%progbits
 158              		.align	1
 159              		.syntax unified
 160              		.thumb
 161              		.thumb_func
 162              		.fpu softvfp
 164              	_rt_thread_init:
 165              	.LFB17:
 134:rtthread/src/thread.c **** 
 135:rtthread/src/thread.c **** static rt_err_t _rt_thread_init(struct rt_thread *thread,
 136:rtthread/src/thread.c ****                                 const char       *name,
 137:rtthread/src/thread.c ****                                 void (*entry)(void *parameter),
 138:rtthread/src/thread.c ****                                 void             *parameter,
 139:rtthread/src/thread.c ****                                 void             *stack_start,
 140:rtthread/src/thread.c ****                                 rt_uint32_t       stack_size,
 141:rtthread/src/thread.c ****                                 rt_uint8_t        priority,
 142:rtthread/src/thread.c ****                                 rt_uint32_t       tick)
 143:rtthread/src/thread.c **** {
 166              		.loc 1 143 0
 167              		.cfi_startproc
 168              		@ args = 16, pretend = 0, frame = 0
 169              		@ frame_needed = 0, uses_anonymous_args = 0
 170              	.LVL20:
 171 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 172              	.LCFI2:
 173              		.cfi_def_cfa_offset 20
 174              		.cfi_offset 4, -20
 175              		.cfi_offset 5, -16
 176              		.cfi_offset 6, -12
 177              		.cfi_offset 7, -8
 178              		.cfi_offset 14, -4
 179 0002 83B0     		sub	sp, sp, #12
 180              	.LCFI3:
 181              		.cfi_def_cfa_offset 32
 182 0004 0446     		mov	r4, r0
 183 0006 0898     		ldr	r0, [sp, #32]
 184              	.LVL21:
 185 0008 0999     		ldr	r1, [sp, #36]
 186              	.LVL22:
 187 000a 9DF82850 		ldrb	r5, [sp, #40]	@ zero_extendqisi2
 188 000e 0B9E     		ldr	r6, [sp, #44]
 144:rtthread/src/thread.c ****     /* init thread list */
 145:rtthread/src/thread.c ****     rt_list_init(&(thread->tlist));
 189              		.loc 1 145 0
 190 0010 04F11407 		add	r7, r4, #20
 191              	.LVL23:
 192              	.LBB18:
 193              	.LBB19:
  49:rtthread/include/rtservice.h **** }
ARM GAS  /tmp/ccTLI8H2.s 			page 8


 194              		.loc 2 49 0
 195 0014 A761     		str	r7, [r4, #24]
 196 0016 6761     		str	r7, [r4, #20]
 197              	.LVL24:
 198              	.LBE19:
 199              	.LBE18:
 146:rtthread/src/thread.c **** 
 147:rtthread/src/thread.c ****     thread->entry = (void *)entry;
 200              		.loc 1 147 0
 201 0018 2262     		str	r2, [r4, #32]
 148:rtthread/src/thread.c ****     thread->parameter = parameter;
 202              		.loc 1 148 0
 203 001a 6362     		str	r3, [r4, #36]
 149:rtthread/src/thread.c **** 
 150:rtthread/src/thread.c ****     /* stack init */
 151:rtthread/src/thread.c ****     thread->stack_addr = stack_start;
 204              		.loc 1 151 0
 205 001c A062     		str	r0, [r4, #40]
 152:rtthread/src/thread.c ****     thread->stack_size = stack_size;
 206              		.loc 1 152 0
 207 001e E162     		str	r1, [r4, #44]
 153:rtthread/src/thread.c **** 
 154:rtthread/src/thread.c ****     /* init thread stack */
 155:rtthread/src/thread.c ****     rt_memset(thread->stack_addr, '#', thread->stack_size);
 208              		.loc 1 155 0
 209 0020 0A46     		mov	r2, r1
 210              	.LVL25:
 211 0022 2321     		movs	r1, #35
 212 0024 FFF7FEFF 		bl	rt_memset
 213              	.LVL26:
 156:rtthread/src/thread.c **** #ifdef ARCH_CPU_STACK_GROWS_UPWARD
 157:rtthread/src/thread.c ****     thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
 158:rtthread/src/thread.c ****                                           (void *)((char *)thread->stack_addr),
 159:rtthread/src/thread.c ****                                           (void *)rt_thread_exit);
 160:rtthread/src/thread.c **** #else
 161:rtthread/src/thread.c ****     thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
 162:rtthread/src/thread.c ****                                           (rt_uint8_t *)((char *)thread->stack_addr + thread->stack
 214              		.loc 1 162 0
 215 0028 A16A     		ldr	r1, [r4, #40]
 216 002a E36A     		ldr	r3, [r4, #44]
 217 002c 1A1F     		subs	r2, r3, #4
 161:rtthread/src/thread.c ****                                           (rt_uint8_t *)((char *)thread->stack_addr + thread->stack
 218              		.loc 1 161 0
 219 002e 104B     		ldr	r3, .L13
 220 0030 0A44     		add	r2, r2, r1
 221 0032 616A     		ldr	r1, [r4, #36]
 222 0034 206A     		ldr	r0, [r4, #32]
 223 0036 FFF7FEFF 		bl	rt_hw_stack_init
 224              	.LVL27:
 225 003a E061     		str	r0, [r4, #28]
 163:rtthread/src/thread.c ****                                           (void *)rt_thread_exit);
 164:rtthread/src/thread.c **** #endif
 165:rtthread/src/thread.c **** 
 166:rtthread/src/thread.c ****     /* priority init */
 167:rtthread/src/thread.c ****     RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
 168:rtthread/src/thread.c ****     thread->init_priority    = priority;
 226              		.loc 1 168 0
ARM GAS  /tmp/ccTLI8H2.s 			page 9


 227 003c 84F83650 		strb	r5, [r4, #54]
 169:rtthread/src/thread.c ****     thread->current_priority = priority;
 228              		.loc 1 169 0
 229 0040 84F83550 		strb	r5, [r4, #53]
 170:rtthread/src/thread.c **** 
 171:rtthread/src/thread.c ****     thread->number_mask = 0;
 230              		.loc 1 171 0
 231 0044 0025     		movs	r5, #0
 232 0046 A563     		str	r5, [r4, #56]
 172:rtthread/src/thread.c **** #if RT_THREAD_PRIORITY_MAX > 32
 173:rtthread/src/thread.c ****     thread->number = 0;
 174:rtthread/src/thread.c ****     thread->high_mask = 0;
 175:rtthread/src/thread.c **** #endif
 176:rtthread/src/thread.c **** 
 177:rtthread/src/thread.c ****     /* tick init */
 178:rtthread/src/thread.c ****     thread->init_tick      = tick;
 233              		.loc 1 178 0
 234 0048 E663     		str	r6, [r4, #60]
 179:rtthread/src/thread.c ****     thread->remaining_tick = tick;
 235              		.loc 1 179 0
 236 004a 2664     		str	r6, [r4, #64]
 180:rtthread/src/thread.c **** 
 181:rtthread/src/thread.c ****     /* error and flags */
 182:rtthread/src/thread.c ****     thread->error = RT_EOK;
 237              		.loc 1 182 0
 238 004c 2563     		str	r5, [r4, #48]
 183:rtthread/src/thread.c ****     thread->stat  = RT_THREAD_INIT;
 239              		.loc 1 183 0
 240 004e 84F83450 		strb	r5, [r4, #52]
 184:rtthread/src/thread.c **** 
 185:rtthread/src/thread.c ****     /* initialize cleanup function and user data */
 186:rtthread/src/thread.c ****     thread->cleanup   = 0;
 241              		.loc 1 186 0
 242 0052 2567     		str	r5, [r4, #112]
 187:rtthread/src/thread.c ****     thread->user_data = 0;
 243              		.loc 1 187 0
 244 0054 6567     		str	r5, [r4, #116]
 188:rtthread/src/thread.c **** 
 189:rtthread/src/thread.c ****     /* initialize thread timer */
 190:rtthread/src/thread.c ****     rt_timer_init(&(thread->thread_timer),
 245              		.loc 1 190 0
 246 0056 0195     		str	r5, [sp, #4]
 247 0058 0095     		str	r5, [sp]
 248 005a 2346     		mov	r3, r4
 249 005c 054A     		ldr	r2, .L13+4
 250 005e 2146     		mov	r1, r4
 251 0060 04F14400 		add	r0, r4, #68
 252 0064 FFF7FEFF 		bl	rt_timer_init
 253              	.LVL28:
 191:rtthread/src/thread.c ****                   thread->name,
 192:rtthread/src/thread.c ****                   rt_thread_timeout,
 193:rtthread/src/thread.c ****                   thread,
 194:rtthread/src/thread.c ****                   0,
 195:rtthread/src/thread.c ****                   RT_TIMER_FLAG_ONE_SHOT);
 196:rtthread/src/thread.c **** 
 197:rtthread/src/thread.c ****     RT_OBJECT_HOOK_CALL(rt_thread_inited_hook, (thread));
 198:rtthread/src/thread.c **** 
ARM GAS  /tmp/ccTLI8H2.s 			page 10


 199:rtthread/src/thread.c ****     return RT_EOK;
 200:rtthread/src/thread.c **** }
 254              		.loc 1 200 0
 255 0068 2846     		mov	r0, r5
 256 006a 03B0     		add	sp, sp, #12
 257              	.LCFI4:
 258              		.cfi_def_cfa_offset 20
 259              		@ sp needed
 260 006c F0BD     		pop	{r4, r5, r6, r7, pc}
 261              	.LVL29:
 262              	.L14:
 263 006e 00BF     		.align	2
 264              	.L13:
 265 0070 00000000 		.word	rt_thread_exit
 266 0074 00000000 		.word	rt_thread_timeout
 267              		.cfi_endproc
 268              	.LFE17:
 270              		.section	.text.rt_thread_timeout,"ax",%progbits
 271              		.align	1
 272              		.global	rt_thread_timeout
 273              		.syntax unified
 274              		.thumb
 275              		.thumb_func
 276              		.fpu softvfp
 278              	rt_thread_timeout:
 279              	.LFB30:
 201:rtthread/src/thread.c **** 
 202:rtthread/src/thread.c **** /**
 203:rtthread/src/thread.c ****  * @addtogroup Thread
 204:rtthread/src/thread.c ****  */
 205:rtthread/src/thread.c **** 
 206:rtthread/src/thread.c **** /**@{*/
 207:rtthread/src/thread.c **** 
 208:rtthread/src/thread.c **** /**
 209:rtthread/src/thread.c ****  * This function will initialize a thread, normally it's used to initialize a
 210:rtthread/src/thread.c ****  * static thread object.
 211:rtthread/src/thread.c ****  *
 212:rtthread/src/thread.c ****  * @param thread the static thread object
 213:rtthread/src/thread.c ****  * @param name the name of thread, which shall be unique
 214:rtthread/src/thread.c ****  * @param entry the entry function of thread
 215:rtthread/src/thread.c ****  * @param parameter the parameter of thread enter function
 216:rtthread/src/thread.c ****  * @param stack_start the start address of thread stack
 217:rtthread/src/thread.c ****  * @param stack_size the size of thread stack
 218:rtthread/src/thread.c ****  * @param priority the priority of thread
 219:rtthread/src/thread.c ****  * @param tick the time slice if there are same priority thread
 220:rtthread/src/thread.c ****  *
 221:rtthread/src/thread.c ****  * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 222:rtthread/src/thread.c ****  */
 223:rtthread/src/thread.c **** rt_err_t rt_thread_init(struct rt_thread *thread,
 224:rtthread/src/thread.c ****                         const char       *name,
 225:rtthread/src/thread.c ****                         void (*entry)(void *parameter),
 226:rtthread/src/thread.c ****                         void             *parameter,
 227:rtthread/src/thread.c ****                         void             *stack_start,
 228:rtthread/src/thread.c ****                         rt_uint32_t       stack_size,
 229:rtthread/src/thread.c ****                         rt_uint8_t        priority,
 230:rtthread/src/thread.c ****                         rt_uint32_t       tick)
 231:rtthread/src/thread.c **** {
ARM GAS  /tmp/ccTLI8H2.s 			page 11


 232:rtthread/src/thread.c ****     /* thread check */
 233:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 234:rtthread/src/thread.c ****     RT_ASSERT(stack_start != RT_NULL);
 235:rtthread/src/thread.c **** 
 236:rtthread/src/thread.c ****     /* initialize thread object */
 237:rtthread/src/thread.c ****     rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
 238:rtthread/src/thread.c **** 
 239:rtthread/src/thread.c ****     return _rt_thread_init(thread,
 240:rtthread/src/thread.c ****                            name,
 241:rtthread/src/thread.c ****                            entry,
 242:rtthread/src/thread.c ****                            parameter,
 243:rtthread/src/thread.c ****                            stack_start,
 244:rtthread/src/thread.c ****                            stack_size,
 245:rtthread/src/thread.c ****                            priority,
 246:rtthread/src/thread.c ****                            tick);
 247:rtthread/src/thread.c **** }
 248:rtthread/src/thread.c **** 
 249:rtthread/src/thread.c **** /**
 250:rtthread/src/thread.c ****  * This function will return self thread object
 251:rtthread/src/thread.c ****  *
 252:rtthread/src/thread.c ****  * @return the self thread object
 253:rtthread/src/thread.c ****  */
 254:rtthread/src/thread.c **** rt_thread_t rt_thread_self(void)
 255:rtthread/src/thread.c **** {
 256:rtthread/src/thread.c ****     return rt_current_thread;
 257:rtthread/src/thread.c **** }
 258:rtthread/src/thread.c **** 
 259:rtthread/src/thread.c **** /**
 260:rtthread/src/thread.c ****  * This function will start a thread and put it to system ready queue
 261:rtthread/src/thread.c ****  *
 262:rtthread/src/thread.c ****  * @param thread the thread to be started
 263:rtthread/src/thread.c ****  *
 264:rtthread/src/thread.c ****  * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 265:rtthread/src/thread.c ****  */
 266:rtthread/src/thread.c **** rt_err_t rt_thread_startup(rt_thread_t thread)
 267:rtthread/src/thread.c **** {
 268:rtthread/src/thread.c ****     /* thread check */
 269:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 270:rtthread/src/thread.c ****     RT_ASSERT((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_INIT);
 271:rtthread/src/thread.c ****     RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 272:rtthread/src/thread.c **** 
 273:rtthread/src/thread.c ****     /* set current priority to initialize priority */
 274:rtthread/src/thread.c ****     thread->current_priority = thread->init_priority;
 275:rtthread/src/thread.c **** 
 276:rtthread/src/thread.c ****     /* calculate priority attribute */
 277:rtthread/src/thread.c **** #if RT_THREAD_PRIORITY_MAX > 32
 278:rtthread/src/thread.c ****     thread->number      = thread->current_priority >> 3;            /* 5bit */
 279:rtthread/src/thread.c ****     thread->number_mask = 1L << thread->number;
 280:rtthread/src/thread.c ****     thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
 281:rtthread/src/thread.c **** #else
 282:rtthread/src/thread.c ****     thread->number_mask = 1L << thread->current_priority;
 283:rtthread/src/thread.c **** #endif
 284:rtthread/src/thread.c **** 
 285:rtthread/src/thread.c ****     RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
 286:rtthread/src/thread.c ****                                    thread->name, thread->init_priority));
 287:rtthread/src/thread.c ****     /* change thread stat */
 288:rtthread/src/thread.c ****     thread->stat = RT_THREAD_SUSPEND;
ARM GAS  /tmp/ccTLI8H2.s 			page 12


 289:rtthread/src/thread.c ****     /* then resume it */
 290:rtthread/src/thread.c ****     rt_thread_resume(thread);
 291:rtthread/src/thread.c ****     if (rt_thread_self() != RT_NULL)
 292:rtthread/src/thread.c ****     {
 293:rtthread/src/thread.c ****         /* do a scheduling */
 294:rtthread/src/thread.c ****         rt_schedule();
 295:rtthread/src/thread.c ****     }
 296:rtthread/src/thread.c **** 
 297:rtthread/src/thread.c ****     return RT_EOK;
 298:rtthread/src/thread.c **** }
 299:rtthread/src/thread.c **** 
 300:rtthread/src/thread.c **** /**
 301:rtthread/src/thread.c ****  * This function will detach a thread. The thread object will be removed from
 302:rtthread/src/thread.c ****  * thread queue and detached/deleted from system object management.
 303:rtthread/src/thread.c ****  *
 304:rtthread/src/thread.c ****  * @param thread the thread to be deleted
 305:rtthread/src/thread.c ****  *
 306:rtthread/src/thread.c ****  * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 307:rtthread/src/thread.c ****  */
 308:rtthread/src/thread.c **** rt_err_t rt_thread_detach(rt_thread_t thread)
 309:rtthread/src/thread.c **** {
 310:rtthread/src/thread.c ****     rt_base_t lock;
 311:rtthread/src/thread.c **** 
 312:rtthread/src/thread.c ****     /* thread check */
 313:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 314:rtthread/src/thread.c ****     RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 315:rtthread/src/thread.c ****     RT_ASSERT(rt_object_is_systemobject((rt_object_t)thread));
 316:rtthread/src/thread.c **** 
 317:rtthread/src/thread.c ****     if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_CLOSE)
 318:rtthread/src/thread.c ****         return RT_EOK;
 319:rtthread/src/thread.c **** 
 320:rtthread/src/thread.c ****     if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_INIT)
 321:rtthread/src/thread.c ****     {
 322:rtthread/src/thread.c ****         /* remove from schedule */
 323:rtthread/src/thread.c ****         rt_schedule_remove_thread(thread);
 324:rtthread/src/thread.c ****     }
 325:rtthread/src/thread.c **** 
 326:rtthread/src/thread.c ****     _thread_cleanup_execute(thread);
 327:rtthread/src/thread.c **** 
 328:rtthread/src/thread.c ****     /* release thread timer */
 329:rtthread/src/thread.c ****     rt_timer_detach(&(thread->thread_timer));
 330:rtthread/src/thread.c **** 
 331:rtthread/src/thread.c ****     /* change stat */
 332:rtthread/src/thread.c ****     thread->stat = RT_THREAD_CLOSE;
 333:rtthread/src/thread.c **** 
 334:rtthread/src/thread.c ****     if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
 335:rtthread/src/thread.c ****     {
 336:rtthread/src/thread.c ****         rt_object_detach((rt_object_t)thread);
 337:rtthread/src/thread.c ****     }
 338:rtthread/src/thread.c ****     else
 339:rtthread/src/thread.c ****     {
 340:rtthread/src/thread.c ****         /* disable interrupt */
 341:rtthread/src/thread.c ****         lock = rt_hw_interrupt_disable();
 342:rtthread/src/thread.c ****         /* insert to defunct thread list */
 343:rtthread/src/thread.c ****         rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
 344:rtthread/src/thread.c ****         /* enable interrupt */
 345:rtthread/src/thread.c ****         rt_hw_interrupt_enable(lock);
ARM GAS  /tmp/ccTLI8H2.s 			page 13


 346:rtthread/src/thread.c ****     }
 347:rtthread/src/thread.c **** 
 348:rtthread/src/thread.c ****     return RT_EOK;
 349:rtthread/src/thread.c **** }
 350:rtthread/src/thread.c **** 
 351:rtthread/src/thread.c **** #ifdef RT_USING_HEAP
 352:rtthread/src/thread.c **** /**
 353:rtthread/src/thread.c ****  * This function will create a thread object and allocate thread object memory
 354:rtthread/src/thread.c ****  * and stack.
 355:rtthread/src/thread.c ****  *
 356:rtthread/src/thread.c ****  * @param name the name of thread, which shall be unique
 357:rtthread/src/thread.c ****  * @param entry the entry function of thread
 358:rtthread/src/thread.c ****  * @param parameter the parameter of thread enter function
 359:rtthread/src/thread.c ****  * @param stack_size the size of thread stack
 360:rtthread/src/thread.c ****  * @param priority the priority of thread
 361:rtthread/src/thread.c ****  * @param tick the time slice if there are same priority thread
 362:rtthread/src/thread.c ****  *
 363:rtthread/src/thread.c ****  * @return the created thread object
 364:rtthread/src/thread.c ****  */
 365:rtthread/src/thread.c **** rt_thread_t rt_thread_create(const char *name,
 366:rtthread/src/thread.c ****                              void (*entry)(void *parameter),
 367:rtthread/src/thread.c ****                              void       *parameter,
 368:rtthread/src/thread.c ****                              rt_uint32_t stack_size,
 369:rtthread/src/thread.c ****                              rt_uint8_t  priority,
 370:rtthread/src/thread.c ****                              rt_uint32_t tick)
 371:rtthread/src/thread.c **** {
 372:rtthread/src/thread.c ****     struct rt_thread *thread;
 373:rtthread/src/thread.c ****     void *stack_start;
 374:rtthread/src/thread.c **** 
 375:rtthread/src/thread.c ****     thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
 376:rtthread/src/thread.c ****                                                     name);
 377:rtthread/src/thread.c ****     if (thread == RT_NULL)
 378:rtthread/src/thread.c ****         return RT_NULL;
 379:rtthread/src/thread.c **** 
 380:rtthread/src/thread.c ****     stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
 381:rtthread/src/thread.c ****     if (stack_start == RT_NULL)
 382:rtthread/src/thread.c ****     {
 383:rtthread/src/thread.c ****         /* allocate stack failure */
 384:rtthread/src/thread.c ****         rt_object_delete((rt_object_t)thread);
 385:rtthread/src/thread.c **** 
 386:rtthread/src/thread.c ****         return RT_NULL;
 387:rtthread/src/thread.c ****     }
 388:rtthread/src/thread.c **** 
 389:rtthread/src/thread.c ****     _rt_thread_init(thread,
 390:rtthread/src/thread.c ****                     name,
 391:rtthread/src/thread.c ****                     entry,
 392:rtthread/src/thread.c ****                     parameter,
 393:rtthread/src/thread.c ****                     stack_start,
 394:rtthread/src/thread.c ****                     stack_size,
 395:rtthread/src/thread.c ****                     priority,
 396:rtthread/src/thread.c ****                     tick);
 397:rtthread/src/thread.c **** 
 398:rtthread/src/thread.c ****     return thread;
 399:rtthread/src/thread.c **** }
 400:rtthread/src/thread.c **** 
 401:rtthread/src/thread.c **** /**
 402:rtthread/src/thread.c ****  * This function will delete a thread. The thread object will be removed from
ARM GAS  /tmp/ccTLI8H2.s 			page 14


 403:rtthread/src/thread.c ****  * thread queue and deleted from system object management in the idle thread.
 404:rtthread/src/thread.c ****  *
 405:rtthread/src/thread.c ****  * @param thread the thread to be deleted
 406:rtthread/src/thread.c ****  *
 407:rtthread/src/thread.c ****  * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 408:rtthread/src/thread.c ****  */
 409:rtthread/src/thread.c **** rt_err_t rt_thread_delete(rt_thread_t thread)
 410:rtthread/src/thread.c **** {
 411:rtthread/src/thread.c ****     rt_base_t lock;
 412:rtthread/src/thread.c **** 
 413:rtthread/src/thread.c ****     /* thread check */
 414:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 415:rtthread/src/thread.c ****     RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 416:rtthread/src/thread.c ****     RT_ASSERT(rt_object_is_systemobject((rt_object_t)thread) == RT_FALSE);
 417:rtthread/src/thread.c **** 
 418:rtthread/src/thread.c ****     if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_CLOSE)
 419:rtthread/src/thread.c ****         return RT_EOK;
 420:rtthread/src/thread.c **** 
 421:rtthread/src/thread.c ****     if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_INIT)
 422:rtthread/src/thread.c ****     {
 423:rtthread/src/thread.c ****         /* remove from schedule */
 424:rtthread/src/thread.c ****         rt_schedule_remove_thread(thread);
 425:rtthread/src/thread.c ****     }
 426:rtthread/src/thread.c **** 
 427:rtthread/src/thread.c ****     _thread_cleanup_execute(thread);
 428:rtthread/src/thread.c **** 
 429:rtthread/src/thread.c ****     /* release thread timer */
 430:rtthread/src/thread.c ****     rt_timer_detach(&(thread->thread_timer));
 431:rtthread/src/thread.c **** 
 432:rtthread/src/thread.c ****     /* disable interrupt */
 433:rtthread/src/thread.c ****     lock = rt_hw_interrupt_disable();
 434:rtthread/src/thread.c **** 
 435:rtthread/src/thread.c ****     /* change stat */
 436:rtthread/src/thread.c ****     thread->stat = RT_THREAD_CLOSE;
 437:rtthread/src/thread.c **** 
 438:rtthread/src/thread.c ****     /* insert to defunct thread list */
 439:rtthread/src/thread.c ****     rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
 440:rtthread/src/thread.c **** 
 441:rtthread/src/thread.c ****     /* enable interrupt */
 442:rtthread/src/thread.c ****     rt_hw_interrupt_enable(lock);
 443:rtthread/src/thread.c **** 
 444:rtthread/src/thread.c ****     return RT_EOK;
 445:rtthread/src/thread.c **** }
 446:rtthread/src/thread.c **** #endif
 447:rtthread/src/thread.c **** 
 448:rtthread/src/thread.c **** /**
 449:rtthread/src/thread.c ****  * This function will let current thread yield processor, and scheduler will
 450:rtthread/src/thread.c ****  * choose a highest thread to run. After yield processor, the current thread
 451:rtthread/src/thread.c ****  * is still in READY state.
 452:rtthread/src/thread.c ****  *
 453:rtthread/src/thread.c ****  * @return RT_EOK
 454:rtthread/src/thread.c ****  */
 455:rtthread/src/thread.c **** rt_err_t rt_thread_yield(void)
 456:rtthread/src/thread.c **** {
 457:rtthread/src/thread.c ****     register rt_base_t level;
 458:rtthread/src/thread.c ****     struct rt_thread *thread;
 459:rtthread/src/thread.c **** 
ARM GAS  /tmp/ccTLI8H2.s 			page 15


 460:rtthread/src/thread.c ****     /* disable interrupt */
 461:rtthread/src/thread.c ****     level = rt_hw_interrupt_disable();
 462:rtthread/src/thread.c **** 
 463:rtthread/src/thread.c ****     /* set to current thread */
 464:rtthread/src/thread.c ****     thread = rt_current_thread;
 465:rtthread/src/thread.c **** 
 466:rtthread/src/thread.c ****     /* if the thread stat is READY and on ready queue list */
 467:rtthread/src/thread.c ****     if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_READY &&
 468:rtthread/src/thread.c ****         thread->tlist.next != thread->tlist.prev)
 469:rtthread/src/thread.c ****     {
 470:rtthread/src/thread.c ****         /* remove thread from thread list */
 471:rtthread/src/thread.c ****         rt_list_remove(&(thread->tlist));
 472:rtthread/src/thread.c **** 
 473:rtthread/src/thread.c ****         /* put thread to end of ready queue */
 474:rtthread/src/thread.c ****         rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
 475:rtthread/src/thread.c ****                               &(thread->tlist));
 476:rtthread/src/thread.c **** 
 477:rtthread/src/thread.c ****         /* enable interrupt */
 478:rtthread/src/thread.c ****         rt_hw_interrupt_enable(level);
 479:rtthread/src/thread.c **** 
 480:rtthread/src/thread.c ****         rt_schedule();
 481:rtthread/src/thread.c **** 
 482:rtthread/src/thread.c ****         return RT_EOK;
 483:rtthread/src/thread.c ****     }
 484:rtthread/src/thread.c **** 
 485:rtthread/src/thread.c ****     /* enable interrupt */
 486:rtthread/src/thread.c ****     rt_hw_interrupt_enable(level);
 487:rtthread/src/thread.c **** 
 488:rtthread/src/thread.c ****     return RT_EOK;
 489:rtthread/src/thread.c **** }
 490:rtthread/src/thread.c **** 
 491:rtthread/src/thread.c **** /**
 492:rtthread/src/thread.c ****  * This function will let current thread sleep for some ticks.
 493:rtthread/src/thread.c ****  *
 494:rtthread/src/thread.c ****  * @param tick the sleep ticks
 495:rtthread/src/thread.c ****  *
 496:rtthread/src/thread.c ****  * @return RT_EOK
 497:rtthread/src/thread.c ****  */
 498:rtthread/src/thread.c **** rt_err_t rt_thread_sleep(rt_tick_t tick)
 499:rtthread/src/thread.c **** {
 500:rtthread/src/thread.c ****     register rt_base_t temp;
 501:rtthread/src/thread.c ****     struct rt_thread *thread;
 502:rtthread/src/thread.c **** 
 503:rtthread/src/thread.c ****     /* disable interrupt */
 504:rtthread/src/thread.c ****     temp = rt_hw_interrupt_disable();
 505:rtthread/src/thread.c ****     /* set to current thread */
 506:rtthread/src/thread.c ****     thread = rt_current_thread;
 507:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 508:rtthread/src/thread.c ****     RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 509:rtthread/src/thread.c **** 
 510:rtthread/src/thread.c ****     /* suspend thread */
 511:rtthread/src/thread.c ****     rt_thread_suspend(thread);
 512:rtthread/src/thread.c **** 
 513:rtthread/src/thread.c ****     /* reset the timeout of thread timer and start it */
 514:rtthread/src/thread.c ****     rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
 515:rtthread/src/thread.c ****     rt_timer_start(&(thread->thread_timer));
 516:rtthread/src/thread.c **** 
ARM GAS  /tmp/ccTLI8H2.s 			page 16


 517:rtthread/src/thread.c ****     /* enable interrupt */
 518:rtthread/src/thread.c ****     rt_hw_interrupt_enable(temp);
 519:rtthread/src/thread.c **** 
 520:rtthread/src/thread.c ****     rt_schedule();
 521:rtthread/src/thread.c **** 
 522:rtthread/src/thread.c ****     /* clear error number of this thread to RT_EOK */
 523:rtthread/src/thread.c ****     if (thread->error == -RT_ETIMEOUT)
 524:rtthread/src/thread.c ****         thread->error = RT_EOK;
 525:rtthread/src/thread.c **** 
 526:rtthread/src/thread.c ****     return RT_EOK;
 527:rtthread/src/thread.c **** }
 528:rtthread/src/thread.c **** 
 529:rtthread/src/thread.c **** /**
 530:rtthread/src/thread.c ****  * This function will let current thread delay for some ticks.
 531:rtthread/src/thread.c ****  *
 532:rtthread/src/thread.c ****  * @param tick the delay ticks
 533:rtthread/src/thread.c ****  *
 534:rtthread/src/thread.c ****  * @return RT_EOK
 535:rtthread/src/thread.c ****  */
 536:rtthread/src/thread.c **** rt_err_t rt_thread_delay(rt_tick_t tick)
 537:rtthread/src/thread.c **** {
 538:rtthread/src/thread.c ****     return rt_thread_sleep(tick);
 539:rtthread/src/thread.c **** }
 540:rtthread/src/thread.c **** 
 541:rtthread/src/thread.c **** /**
 542:rtthread/src/thread.c ****  * This function will let current thread delay until (*tick + inc_tick).
 543:rtthread/src/thread.c ****  *
 544:rtthread/src/thread.c ****  * @param tick the tick of last wakeup.
 545:rtthread/src/thread.c ****  * @param inc_tick the increment tick
 546:rtthread/src/thread.c ****  *
 547:rtthread/src/thread.c ****  * @return RT_EOK
 548:rtthread/src/thread.c ****  */
 549:rtthread/src/thread.c **** rt_err_t rt_thread_delay_until(rt_tick_t *tick, rt_tick_t inc_tick)
 550:rtthread/src/thread.c **** {
 551:rtthread/src/thread.c ****     register rt_base_t level;
 552:rtthread/src/thread.c ****     struct rt_thread *thread;
 553:rtthread/src/thread.c **** 
 554:rtthread/src/thread.c ****     RT_ASSERT(tick != RT_NULL);
 555:rtthread/src/thread.c **** 
 556:rtthread/src/thread.c ****     /* set to current thread */
 557:rtthread/src/thread.c ****     thread = rt_thread_self();
 558:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 559:rtthread/src/thread.c ****     RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 560:rtthread/src/thread.c **** 
 561:rtthread/src/thread.c ****     /* disable interrupt */
 562:rtthread/src/thread.c ****     level = rt_hw_interrupt_disable();
 563:rtthread/src/thread.c **** 
 564:rtthread/src/thread.c ****     if (rt_tick_get() - *tick < inc_tick)
 565:rtthread/src/thread.c ****     {
 566:rtthread/src/thread.c ****         *tick = *tick + inc_tick - rt_tick_get();
 567:rtthread/src/thread.c **** 
 568:rtthread/src/thread.c ****         /* suspend thread */
 569:rtthread/src/thread.c ****         rt_thread_suspend(thread);
 570:rtthread/src/thread.c **** 
 571:rtthread/src/thread.c ****         /* reset the timeout of thread timer and start it */
 572:rtthread/src/thread.c ****         rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, tick);
 573:rtthread/src/thread.c ****         rt_timer_start(&(thread->thread_timer));
ARM GAS  /tmp/ccTLI8H2.s 			page 17


 574:rtthread/src/thread.c **** 
 575:rtthread/src/thread.c ****         /* enable interrupt */
 576:rtthread/src/thread.c ****         rt_hw_interrupt_enable(level);
 577:rtthread/src/thread.c **** 
 578:rtthread/src/thread.c ****         rt_schedule();
 579:rtthread/src/thread.c **** 
 580:rtthread/src/thread.c ****         /* clear error number of this thread to RT_EOK */
 581:rtthread/src/thread.c ****         if (thread->error == -RT_ETIMEOUT)
 582:rtthread/src/thread.c ****         {
 583:rtthread/src/thread.c ****             thread->error = RT_EOK;
 584:rtthread/src/thread.c ****         }
 585:rtthread/src/thread.c ****     }
 586:rtthread/src/thread.c ****     else
 587:rtthread/src/thread.c ****     {
 588:rtthread/src/thread.c ****         rt_hw_interrupt_enable(level);
 589:rtthread/src/thread.c ****     }
 590:rtthread/src/thread.c **** 
 591:rtthread/src/thread.c ****     /* get the wakeup tick */
 592:rtthread/src/thread.c ****     *tick = rt_tick_get();
 593:rtthread/src/thread.c **** 
 594:rtthread/src/thread.c ****     return RT_EOK;
 595:rtthread/src/thread.c **** }
 596:rtthread/src/thread.c **** 
 597:rtthread/src/thread.c **** /**
 598:rtthread/src/thread.c ****  * This function will let current thread delay for some milliseconds.
 599:rtthread/src/thread.c ****  *
 600:rtthread/src/thread.c ****  * @param ms the delay ms time
 601:rtthread/src/thread.c ****  *
 602:rtthread/src/thread.c ****  * @return RT_EOK
 603:rtthread/src/thread.c ****  */
 604:rtthread/src/thread.c **** rt_err_t rt_thread_mdelay(rt_int32_t ms)
 605:rtthread/src/thread.c **** {
 606:rtthread/src/thread.c ****     rt_tick_t tick;
 607:rtthread/src/thread.c **** 
 608:rtthread/src/thread.c ****     tick = rt_tick_from_millisecond(ms);
 609:rtthread/src/thread.c **** 
 610:rtthread/src/thread.c ****     return rt_thread_sleep(tick);
 611:rtthread/src/thread.c **** }
 612:rtthread/src/thread.c **** 
 613:rtthread/src/thread.c **** /**
 614:rtthread/src/thread.c ****  * This function will control thread behaviors according to control command.
 615:rtthread/src/thread.c ****  *
 616:rtthread/src/thread.c ****  * @param thread the specified thread to be controlled
 617:rtthread/src/thread.c ****  * @param cmd the control command, which includes
 618:rtthread/src/thread.c ****  *  RT_THREAD_CTRL_CHANGE_PRIORITY for changing priority level of thread;
 619:rtthread/src/thread.c ****  *  RT_THREAD_CTRL_STARTUP for starting a thread;
 620:rtthread/src/thread.c ****  *  RT_THREAD_CTRL_CLOSE for delete a thread;
 621:rtthread/src/thread.c ****  *  RT_THREAD_CTRL_BIND_CPU for bind the thread to a CPU.
 622:rtthread/src/thread.c ****  * @param arg the argument of control command
 623:rtthread/src/thread.c ****  *
 624:rtthread/src/thread.c ****  * @return RT_EOK
 625:rtthread/src/thread.c ****  */
 626:rtthread/src/thread.c **** rt_err_t rt_thread_control(rt_thread_t thread, int cmd, void *arg)
 627:rtthread/src/thread.c **** {
 628:rtthread/src/thread.c ****     register rt_base_t temp;
 629:rtthread/src/thread.c **** 
 630:rtthread/src/thread.c ****     /* thread check */
ARM GAS  /tmp/ccTLI8H2.s 			page 18


 631:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 632:rtthread/src/thread.c ****     RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 633:rtthread/src/thread.c **** 
 634:rtthread/src/thread.c ****     switch (cmd)
 635:rtthread/src/thread.c ****     {
 636:rtthread/src/thread.c ****     case RT_THREAD_CTRL_CHANGE_PRIORITY:
 637:rtthread/src/thread.c ****         /* disable interrupt */
 638:rtthread/src/thread.c ****         temp = rt_hw_interrupt_disable();
 639:rtthread/src/thread.c **** 
 640:rtthread/src/thread.c ****         /* for ready thread, change queue */
 641:rtthread/src/thread.c ****         if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_READY)
 642:rtthread/src/thread.c ****         {
 643:rtthread/src/thread.c ****             /* remove thread from schedule queue first */
 644:rtthread/src/thread.c ****             rt_schedule_remove_thread(thread);
 645:rtthread/src/thread.c **** 
 646:rtthread/src/thread.c ****             /* change thread priority */
 647:rtthread/src/thread.c ****             thread->current_priority = *(rt_uint8_t *)arg;
 648:rtthread/src/thread.c **** 
 649:rtthread/src/thread.c ****             /* recalculate priority attribute */
 650:rtthread/src/thread.c **** #if RT_THREAD_PRIORITY_MAX > 32
 651:rtthread/src/thread.c ****             thread->number      = thread->current_priority >> 3;            /* 5bit */
 652:rtthread/src/thread.c ****             thread->number_mask = 1 << thread->number;
 653:rtthread/src/thread.c ****             thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
 654:rtthread/src/thread.c **** #else
 655:rtthread/src/thread.c ****             thread->number_mask = 1 << thread->current_priority;
 656:rtthread/src/thread.c **** #endif
 657:rtthread/src/thread.c **** 
 658:rtthread/src/thread.c ****             /* insert thread to schedule queue again */
 659:rtthread/src/thread.c ****             rt_schedule_insert_thread(thread);
 660:rtthread/src/thread.c ****         }
 661:rtthread/src/thread.c ****         else
 662:rtthread/src/thread.c ****         {
 663:rtthread/src/thread.c ****             thread->current_priority = *(rt_uint8_t *)arg;
 664:rtthread/src/thread.c **** 
 665:rtthread/src/thread.c ****             /* recalculate priority attribute */
 666:rtthread/src/thread.c **** #if RT_THREAD_PRIORITY_MAX > 32
 667:rtthread/src/thread.c ****             thread->number      = thread->current_priority >> 3;            /* 5bit */
 668:rtthread/src/thread.c ****             thread->number_mask = 1 << thread->number;
 669:rtthread/src/thread.c ****             thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
 670:rtthread/src/thread.c **** #else
 671:rtthread/src/thread.c ****             thread->number_mask = 1 << thread->current_priority;
 672:rtthread/src/thread.c **** #endif
 673:rtthread/src/thread.c ****         }
 674:rtthread/src/thread.c **** 
 675:rtthread/src/thread.c ****         /* enable interrupt */
 676:rtthread/src/thread.c ****         rt_hw_interrupt_enable(temp);
 677:rtthread/src/thread.c ****         break;
 678:rtthread/src/thread.c **** 
 679:rtthread/src/thread.c ****     case RT_THREAD_CTRL_STARTUP:
 680:rtthread/src/thread.c ****         return rt_thread_startup(thread);
 681:rtthread/src/thread.c **** 
 682:rtthread/src/thread.c ****     case RT_THREAD_CTRL_CLOSE:
 683:rtthread/src/thread.c **** 
 684:rtthread/src/thread.c ****         if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
 685:rtthread/src/thread.c ****         {
 686:rtthread/src/thread.c ****             return rt_thread_detach(thread);
 687:rtthread/src/thread.c ****         }
ARM GAS  /tmp/ccTLI8H2.s 			page 19


 688:rtthread/src/thread.c **** #ifdef RT_USING_HEAP
 689:rtthread/src/thread.c ****         else
 690:rtthread/src/thread.c ****         {
 691:rtthread/src/thread.c ****             return rt_thread_delete(thread);
 692:rtthread/src/thread.c ****         }
 693:rtthread/src/thread.c **** #endif
 694:rtthread/src/thread.c **** 
 695:rtthread/src/thread.c ****     default:
 696:rtthread/src/thread.c ****         break;
 697:rtthread/src/thread.c ****     }
 698:rtthread/src/thread.c **** 
 699:rtthread/src/thread.c ****     return RT_EOK;
 700:rtthread/src/thread.c **** }
 701:rtthread/src/thread.c **** 
 702:rtthread/src/thread.c **** /**
 703:rtthread/src/thread.c ****  * This function will suspend the specified thread.
 704:rtthread/src/thread.c ****  *
 705:rtthread/src/thread.c ****  * @param thread the thread to be suspended
 706:rtthread/src/thread.c ****  *
 707:rtthread/src/thread.c ****  * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 708:rtthread/src/thread.c ****  *
 709:rtthread/src/thread.c ****  * @note if suspend self thread, after this function call, the
 710:rtthread/src/thread.c ****  * rt_schedule() must be invoked.
 711:rtthread/src/thread.c ****  */
 712:rtthread/src/thread.c **** rt_err_t rt_thread_suspend(rt_thread_t thread)
 713:rtthread/src/thread.c **** {
 714:rtthread/src/thread.c ****     register rt_base_t temp;
 715:rtthread/src/thread.c **** 
 716:rtthread/src/thread.c ****     /* thread check */
 717:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 718:rtthread/src/thread.c ****     RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 719:rtthread/src/thread.c **** 
 720:rtthread/src/thread.c ****     RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));
 721:rtthread/src/thread.c **** 
 722:rtthread/src/thread.c ****     if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_READY)
 723:rtthread/src/thread.c ****     {
 724:rtthread/src/thread.c ****         RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, 0x%2x\n",
 725:rtthread/src/thread.c ****                                        thread->stat));
 726:rtthread/src/thread.c **** 
 727:rtthread/src/thread.c ****         return -RT_ERROR;
 728:rtthread/src/thread.c ****     }
 729:rtthread/src/thread.c **** 
 730:rtthread/src/thread.c ****     /* disable interrupt */
 731:rtthread/src/thread.c ****     temp = rt_hw_interrupt_disable();
 732:rtthread/src/thread.c **** 
 733:rtthread/src/thread.c ****     /* change thread stat */
 734:rtthread/src/thread.c ****     rt_schedule_remove_thread(thread);
 735:rtthread/src/thread.c ****     thread->stat = RT_THREAD_SUSPEND | (thread->stat & ~RT_THREAD_STAT_MASK);
 736:rtthread/src/thread.c **** 
 737:rtthread/src/thread.c ****     /* stop thread timer anyway */
 738:rtthread/src/thread.c ****     rt_timer_stop(&(thread->thread_timer));
 739:rtthread/src/thread.c **** 
 740:rtthread/src/thread.c ****     /* enable interrupt */
 741:rtthread/src/thread.c ****     rt_hw_interrupt_enable(temp);
 742:rtthread/src/thread.c **** 
 743:rtthread/src/thread.c ****     RT_OBJECT_HOOK_CALL(rt_thread_suspend_hook, (thread));
 744:rtthread/src/thread.c ****     return RT_EOK;
ARM GAS  /tmp/ccTLI8H2.s 			page 20


 745:rtthread/src/thread.c **** }
 746:rtthread/src/thread.c **** 
 747:rtthread/src/thread.c **** /**
 748:rtthread/src/thread.c ****  * This function will resume a thread and put it to system ready queue.
 749:rtthread/src/thread.c ****  *
 750:rtthread/src/thread.c ****  * @param thread the thread to be resumed
 751:rtthread/src/thread.c ****  *
 752:rtthread/src/thread.c ****  * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 753:rtthread/src/thread.c ****  */
 754:rtthread/src/thread.c **** rt_err_t rt_thread_resume(rt_thread_t thread)
 755:rtthread/src/thread.c **** {
 756:rtthread/src/thread.c ****     register rt_base_t temp;
 757:rtthread/src/thread.c **** 
 758:rtthread/src/thread.c ****     /* thread check */
 759:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 760:rtthread/src/thread.c ****     RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 761:rtthread/src/thread.c **** 
 762:rtthread/src/thread.c ****     RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));
 763:rtthread/src/thread.c **** 
 764:rtthread/src/thread.c ****     if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_SUSPEND)
 765:rtthread/src/thread.c ****     {
 766:rtthread/src/thread.c ****         RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
 767:rtthread/src/thread.c ****                                        thread->stat));
 768:rtthread/src/thread.c **** 
 769:rtthread/src/thread.c ****         return -RT_ERROR;
 770:rtthread/src/thread.c ****     }
 771:rtthread/src/thread.c **** 
 772:rtthread/src/thread.c ****     /* disable interrupt */
 773:rtthread/src/thread.c ****     temp = rt_hw_interrupt_disable();
 774:rtthread/src/thread.c **** 
 775:rtthread/src/thread.c ****     /* remove from suspend list */
 776:rtthread/src/thread.c ****     rt_list_remove(&(thread->tlist));
 777:rtthread/src/thread.c **** 
 778:rtthread/src/thread.c ****     rt_timer_stop(&thread->thread_timer);
 779:rtthread/src/thread.c **** 
 780:rtthread/src/thread.c ****     /* enable interrupt */
 781:rtthread/src/thread.c ****     rt_hw_interrupt_enable(temp);
 782:rtthread/src/thread.c **** 
 783:rtthread/src/thread.c ****     /* insert to schedule ready list */
 784:rtthread/src/thread.c ****     rt_schedule_insert_thread(thread);
 785:rtthread/src/thread.c **** 
 786:rtthread/src/thread.c ****     RT_OBJECT_HOOK_CALL(rt_thread_resume_hook, (thread));
 787:rtthread/src/thread.c ****     return RT_EOK;
 788:rtthread/src/thread.c **** }
 789:rtthread/src/thread.c **** 
 790:rtthread/src/thread.c **** /**
 791:rtthread/src/thread.c ****  * This function is the timeout function for thread, normally which is invoked
 792:rtthread/src/thread.c ****  * when thread is timeout to wait some resource.
 793:rtthread/src/thread.c ****  *
 794:rtthread/src/thread.c ****  * @param parameter the parameter of thread timeout function
 795:rtthread/src/thread.c ****  */
 796:rtthread/src/thread.c **** void rt_thread_timeout(void *parameter)
 797:rtthread/src/thread.c **** {
 280              		.loc 1 797 0
 281              		.cfi_startproc
 282              		@ args = 0, pretend = 0, frame = 0
 283              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccTLI8H2.s 			page 21


 284              	.LVL30:
 285 0000 10B5     		push	{r4, lr}
 286              	.LCFI5:
 287              		.cfi_def_cfa_offset 8
 288              		.cfi_offset 4, -8
 289              		.cfi_offset 14, -4
 290              	.LVL31:
 798:rtthread/src/thread.c ****     struct rt_thread *thread;
 799:rtthread/src/thread.c **** 
 800:rtthread/src/thread.c ****     thread = (struct rt_thread *)parameter;
 801:rtthread/src/thread.c **** 
 802:rtthread/src/thread.c ****     /* thread check */
 803:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 804:rtthread/src/thread.c ****     RT_ASSERT((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_SUSPEND);
 805:rtthread/src/thread.c ****     RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 806:rtthread/src/thread.c **** 
 807:rtthread/src/thread.c ****     /* set error number */
 808:rtthread/src/thread.c ****     thread->error = -RT_ETIMEOUT;
 291              		.loc 1 808 0
 292 0002 6FF00102 		mvn	r2, #1
 293 0006 0263     		str	r2, [r0, #48]
 809:rtthread/src/thread.c **** 
 810:rtthread/src/thread.c ****     /* remove from suspend list */
 811:rtthread/src/thread.c ****     rt_list_remove(&(thread->tlist));
 294              		.loc 1 811 0
 295 0008 00F11402 		add	r2, r0, #20
 296              	.LVL32:
 297              	.LBB20:
 298              	.LBB21:
  65:rtthread/include/rtservice.h **** }
  66:rtthread/include/rtservice.h **** 
  67:rtthread/include/rtservice.h **** /**
  68:rtthread/include/rtservice.h ****  * @brief insert a node before a list
  69:rtthread/include/rtservice.h ****  *
  70:rtthread/include/rtservice.h ****  * @param n new node to be inserted
  71:rtthread/include/rtservice.h ****  * @param l list to insert it
  72:rtthread/include/rtservice.h ****  */
  73:rtthread/include/rtservice.h **** rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
  74:rtthread/include/rtservice.h **** {
  75:rtthread/include/rtservice.h ****     l->prev->next = n;
  76:rtthread/include/rtservice.h ****     n->prev = l->prev;
  77:rtthread/include/rtservice.h **** 
  78:rtthread/include/rtservice.h ****     l->prev = n;
  79:rtthread/include/rtservice.h ****     n->next = l;
  80:rtthread/include/rtservice.h **** }
  81:rtthread/include/rtservice.h **** 
  82:rtthread/include/rtservice.h **** /**
  83:rtthread/include/rtservice.h ****  * @brief remove node from list.
  84:rtthread/include/rtservice.h ****  * @param n the node to remove from the list.
  85:rtthread/include/rtservice.h ****  */
  86:rtthread/include/rtservice.h **** rt_inline void rt_list_remove(rt_list_t *n)
  87:rtthread/include/rtservice.h **** {
  88:rtthread/include/rtservice.h ****     n->next->prev = n->prev;
 299              		.loc 2 88 0
 300 000c 4169     		ldr	r1, [r0, #20]
 301 000e 8469     		ldr	r4, [r0, #24]
 302 0010 4C60     		str	r4, [r1, #4]
ARM GAS  /tmp/ccTLI8H2.s 			page 22


  89:rtthread/include/rtservice.h ****     n->prev->next = n->next;
 303              		.loc 2 89 0
 304 0012 8169     		ldr	r1, [r0, #24]
 305 0014 4469     		ldr	r4, [r0, #20]
 306 0016 0C60     		str	r4, [r1]
  90:rtthread/include/rtservice.h **** 
  91:rtthread/include/rtservice.h ****     n->next = n->prev = n;
 307              		.loc 2 91 0
 308 0018 8261     		str	r2, [r0, #24]
 309 001a 4261     		str	r2, [r0, #20]
 310              	.LVL33:
 311              	.LBE21:
 312              	.LBE20:
 812:rtthread/src/thread.c **** 
 813:rtthread/src/thread.c ****     /* insert to schedule ready list */
 814:rtthread/src/thread.c ****     rt_schedule_insert_thread(thread);
 313              		.loc 1 814 0
 314 001c FFF7FEFF 		bl	rt_schedule_insert_thread
 315              	.LVL34:
 815:rtthread/src/thread.c **** 
 816:rtthread/src/thread.c ****     /* do schedule */
 817:rtthread/src/thread.c ****     rt_schedule();
 316              		.loc 1 817 0
 317 0020 FFF7FEFF 		bl	rt_schedule
 318              	.LVL35:
 818:rtthread/src/thread.c **** }
 319              		.loc 1 818 0
 320 0024 10BD     		pop	{r4, pc}
 321              		.cfi_endproc
 322              	.LFE30:
 324              		.section	.text.rt_thread_init,"ax",%progbits
 325              		.align	1
 326              		.global	rt_thread_init
 327              		.syntax unified
 328              		.thumb
 329              		.thumb_func
 330              		.fpu softvfp
 332              	rt_thread_init:
 333              	.LFB18:
 231:rtthread/src/thread.c ****     /* thread check */
 334              		.loc 1 231 0
 335              		.cfi_startproc
 336              		@ args = 16, pretend = 0, frame = 0
 337              		@ frame_needed = 0, uses_anonymous_args = 0
 338              	.LVL36:
 339 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 340              	.LCFI6:
 341              		.cfi_def_cfa_offset 20
 342              		.cfi_offset 4, -20
 343              		.cfi_offset 5, -16
 344              		.cfi_offset 6, -12
 345              		.cfi_offset 7, -8
 346              		.cfi_offset 14, -4
 347 0002 85B0     		sub	sp, sp, #20
 348              	.LCFI7:
 349              		.cfi_def_cfa_offset 40
 350 0004 0546     		mov	r5, r0
ARM GAS  /tmp/ccTLI8H2.s 			page 23


 351 0006 0C46     		mov	r4, r1
 352 0008 1646     		mov	r6, r2
 353 000a 1F46     		mov	r7, r3
 237:rtthread/src/thread.c **** 
 354              		.loc 1 237 0
 355 000c 0A46     		mov	r2, r1
 356              	.LVL37:
 357 000e 0121     		movs	r1, #1
 358              	.LVL38:
 359 0010 FFF7FEFF 		bl	rt_object_init
 360              	.LVL39:
 239:rtthread/src/thread.c ****                            name,
 361              		.loc 1 239 0
 362 0014 0D9B     		ldr	r3, [sp, #52]
 363 0016 0393     		str	r3, [sp, #12]
 364 0018 9DF83030 		ldrb	r3, [sp, #48]	@ zero_extendqisi2
 365 001c 0293     		str	r3, [sp, #8]
 366 001e 0B9B     		ldr	r3, [sp, #44]
 367 0020 0193     		str	r3, [sp, #4]
 368 0022 0A9B     		ldr	r3, [sp, #40]
 369 0024 0093     		str	r3, [sp]
 370 0026 3B46     		mov	r3, r7
 371 0028 3246     		mov	r2, r6
 372 002a 2146     		mov	r1, r4
 373 002c 2846     		mov	r0, r5
 374 002e FFF7FEFF 		bl	_rt_thread_init
 375              	.LVL40:
 247:rtthread/src/thread.c **** 
 376              		.loc 1 247 0
 377 0032 05B0     		add	sp, sp, #20
 378              	.LCFI8:
 379              		.cfi_def_cfa_offset 20
 380              		@ sp needed
 381 0034 F0BD     		pop	{r4, r5, r6, r7, pc}
 382              		.cfi_endproc
 383              	.LFE18:
 385              		.section	.text.rt_thread_self,"ax",%progbits
 386              		.align	1
 387              		.global	rt_thread_self
 388              		.syntax unified
 389              		.thumb
 390              		.thumb_func
 391              		.fpu softvfp
 393              	rt_thread_self:
 394              	.LFB19:
 255:rtthread/src/thread.c ****     return rt_current_thread;
 395              		.loc 1 255 0
 396              		.cfi_startproc
 397              		@ args = 0, pretend = 0, frame = 0
 398              		@ frame_needed = 0, uses_anonymous_args = 0
 399              		@ link register save eliminated.
 257:rtthread/src/thread.c **** 
 400              		.loc 1 257 0
 401 0000 014B     		ldr	r3, .L20
 402 0002 1868     		ldr	r0, [r3]
 403 0004 7047     		bx	lr
 404              	.L21:
ARM GAS  /tmp/ccTLI8H2.s 			page 24


 405 0006 00BF     		.align	2
 406              	.L20:
 407 0008 00000000 		.word	rt_current_thread
 408              		.cfi_endproc
 409              	.LFE19:
 411              		.section	.text.rt_thread_detach,"ax",%progbits
 412              		.align	1
 413              		.global	rt_thread_detach
 414              		.syntax unified
 415              		.thumb
 416              		.thumb_func
 417              		.fpu softvfp
 419              	rt_thread_detach:
 420              	.LFB21:
 309:rtthread/src/thread.c ****     rt_base_t lock;
 421              		.loc 1 309 0
 422              		.cfi_startproc
 423              		@ args = 0, pretend = 0, frame = 0
 424              		@ frame_needed = 0, uses_anonymous_args = 0
 425              	.LVL41:
 317:rtthread/src/thread.c ****         return RT_EOK;
 426              		.loc 1 317 0
 427 0000 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 428 0004 03F00F03 		and	r3, r3, #15
 429 0008 042B     		cmp	r3, #4
 430 000a 26D0     		beq	.L27
 309:rtthread/src/thread.c ****     rt_base_t lock;
 431              		.loc 1 309 0
 432 000c 10B5     		push	{r4, lr}
 433              	.LCFI9:
 434              		.cfi_def_cfa_offset 8
 435              		.cfi_offset 4, -8
 436              		.cfi_offset 14, -4
 437 000e 0446     		mov	r4, r0
 320:rtthread/src/thread.c ****     {
 438              		.loc 1 320 0
 439 0010 E3B9     		cbnz	r3, .L30
 440              	.LVL42:
 441              	.L24:
 326:rtthread/src/thread.c **** 
 442              		.loc 1 326 0
 443 0012 2046     		mov	r0, r4
 444 0014 FFF7FEFF 		bl	_thread_cleanup_execute
 445              	.LVL43:
 329:rtthread/src/thread.c **** 
 446              		.loc 1 329 0
 447 0018 04F14400 		add	r0, r4, #68
 448 001c FFF7FEFF 		bl	rt_timer_detach
 449              	.LVL44:
 332:rtthread/src/thread.c **** 
 450              		.loc 1 332 0
 451 0020 0423     		movs	r3, #4
 452 0022 84F83430 		strb	r3, [r4, #52]
 334:rtthread/src/thread.c ****     {
 453              		.loc 1 334 0
 454 0026 2046     		mov	r0, r4
 455 0028 FFF7FEFF 		bl	rt_object_is_systemobject
ARM GAS  /tmp/ccTLI8H2.s 			page 25


 456              	.LVL45:
 457 002c 0128     		cmp	r0, #1
 458 002e 10D0     		beq	.L31
 341:rtthread/src/thread.c ****         /* insert to defunct thread list */
 459              		.loc 1 341 0
 460 0030 FFF7FEFF 		bl	rt_hw_interrupt_disable
 461              	.LVL46:
 343:rtthread/src/thread.c ****         /* enable interrupt */
 462              		.loc 1 343 0
 463 0034 04F11402 		add	r2, r4, #20
 464              	.LVL47:
 465              	.LBB22:
 466              	.LBB23:
  60:rtthread/include/rtservice.h ****     n->next = l->next;
 467              		.loc 2 60 0
 468 0038 094B     		ldr	r3, .L32
 469 003a 1968     		ldr	r1, [r3]
 470 003c 4A60     		str	r2, [r1, #4]
  61:rtthread/include/rtservice.h **** 
 471              		.loc 2 61 0
 472 003e 6161     		str	r1, [r4, #20]
  63:rtthread/include/rtservice.h ****     n->prev = l;
 473              		.loc 2 63 0
 474 0040 1A60     		str	r2, [r3]
  64:rtthread/include/rtservice.h **** }
 475              		.loc 2 64 0
 476 0042 A361     		str	r3, [r4, #24]
 477              	.LVL48:
 478              	.LBE23:
 479              	.LBE22:
 345:rtthread/src/thread.c ****     }
 480              		.loc 1 345 0
 481 0044 FFF7FEFF 		bl	rt_hw_interrupt_enable
 482              	.LVL49:
 483              	.L23:
 349:rtthread/src/thread.c **** 
 484              		.loc 1 349 0
 485 0048 0020     		movs	r0, #0
 486 004a 10BD     		pop	{r4, pc}
 487              	.LVL50:
 488              	.L30:
 323:rtthread/src/thread.c ****     }
 489              		.loc 1 323 0
 490 004c FFF7FEFF 		bl	rt_schedule_remove_thread
 491              	.LVL51:
 492 0050 DFE7     		b	.L24
 493              	.L31:
 336:rtthread/src/thread.c ****     }
 494              		.loc 1 336 0
 495 0052 2046     		mov	r0, r4
 496 0054 FFF7FEFF 		bl	rt_object_detach
 497              	.LVL52:
 498 0058 F6E7     		b	.L23
 499              	.LVL53:
 500              	.L27:
 501              	.LCFI10:
 502              		.cfi_def_cfa_offset 0
ARM GAS  /tmp/ccTLI8H2.s 			page 26


 503              		.cfi_restore 4
 504              		.cfi_restore 14
 349:rtthread/src/thread.c **** 
 505              		.loc 1 349 0
 506 005a 0020     		movs	r0, #0
 507              	.LVL54:
 508 005c 7047     		bx	lr
 509              	.L33:
 510 005e 00BF     		.align	2
 511              	.L32:
 512 0060 00000000 		.word	rt_thread_defunct
 513              		.cfi_endproc
 514              	.LFE21:
 516              		.section	.text.rt_thread_yield,"ax",%progbits
 517              		.align	1
 518              		.global	rt_thread_yield
 519              		.syntax unified
 520              		.thumb
 521              		.thumb_func
 522              		.fpu softvfp
 524              	rt_thread_yield:
 525              	.LFB22:
 456:rtthread/src/thread.c ****     register rt_base_t level;
 526              		.loc 1 456 0
 527              		.cfi_startproc
 528              		@ args = 0, pretend = 0, frame = 0
 529              		@ frame_needed = 0, uses_anonymous_args = 0
 530 0000 10B5     		push	{r4, lr}
 531              	.LCFI11:
 532              		.cfi_def_cfa_offset 8
 533              		.cfi_offset 4, -8
 534              		.cfi_offset 14, -4
 461:rtthread/src/thread.c **** 
 535              		.loc 1 461 0
 536 0002 FFF7FEFF 		bl	rt_hw_interrupt_disable
 537              	.LVL55:
 464:rtthread/src/thread.c **** 
 538              		.loc 1 464 0
 539 0006 144B     		ldr	r3, .L39
 540 0008 1B68     		ldr	r3, [r3]
 541              	.LVL56:
 467:rtthread/src/thread.c ****         thread->tlist.next != thread->tlist.prev)
 542              		.loc 1 467 0
 543 000a 93F83420 		ldrb	r2, [r3, #52]	@ zero_extendqisi2
 544 000e 02F00F02 		and	r2, r2, #15
 545 0012 012A     		cmp	r2, #1
 546 0014 03D1     		bne	.L35
 468:rtthread/src/thread.c ****     {
 547              		.loc 1 468 0 discriminator 1
 548 0016 5A69     		ldr	r2, [r3, #20]
 549 0018 9969     		ldr	r1, [r3, #24]
 467:rtthread/src/thread.c ****         thread->tlist.next != thread->tlist.prev)
 550              		.loc 1 467 0 discriminator 1
 551 001a 8A42     		cmp	r2, r1
 552 001c 03D1     		bne	.L38
 553              	.L35:
 486:rtthread/src/thread.c **** 
ARM GAS  /tmp/ccTLI8H2.s 			page 27


 554              		.loc 1 486 0
 555 001e FFF7FEFF 		bl	rt_hw_interrupt_enable
 556              	.LVL57:
 557              	.L36:
 489:rtthread/src/thread.c **** 
 558              		.loc 1 489 0
 559 0022 0020     		movs	r0, #0
 560 0024 10BD     		pop	{r4, pc}
 561              	.LVL58:
 562              	.L38:
 471:rtthread/src/thread.c **** 
 563              		.loc 1 471 0
 564 0026 03F11404 		add	r4, r3, #20
 565              	.LVL59:
 566              	.LBB24:
 567              	.LBB25:
  88:rtthread/include/rtservice.h ****     n->prev->next = n->next;
 568              		.loc 2 88 0
 569 002a 5160     		str	r1, [r2, #4]
  89:rtthread/include/rtservice.h **** 
 570              		.loc 2 89 0
 571 002c 9A69     		ldr	r2, [r3, #24]
 572 002e 5969     		ldr	r1, [r3, #20]
 573 0030 1160     		str	r1, [r2]
 574              		.loc 2 91 0
 575 0032 9C61     		str	r4, [r3, #24]
 576 0034 5C61     		str	r4, [r3, #20]
 577              	.LVL60:
 578              	.LBE25:
 579              	.LBE24:
 474:rtthread/src/thread.c ****                               &(thread->tlist));
 580              		.loc 1 474 0
 581 0036 93F83510 		ldrb	r1, [r3, #53]	@ zero_extendqisi2
 582 003a 084A     		ldr	r2, .L39+4
 583 003c 02EBC102 		add	r2, r2, r1, lsl #3
 584              	.LVL61:
 585              	.LBB26:
 586              	.LBB27:
  75:rtthread/include/rtservice.h ****     n->prev = l->prev;
 587              		.loc 2 75 0
 588 0040 5168     		ldr	r1, [r2, #4]
 589 0042 0C60     		str	r4, [r1]
  76:rtthread/include/rtservice.h **** 
 590              		.loc 2 76 0
 591 0044 5168     		ldr	r1, [r2, #4]
 592 0046 9961     		str	r1, [r3, #24]
  78:rtthread/include/rtservice.h ****     n->next = l;
 593              		.loc 2 78 0
 594 0048 5460     		str	r4, [r2, #4]
  79:rtthread/include/rtservice.h **** }
 595              		.loc 2 79 0
 596 004a 5A61     		str	r2, [r3, #20]
 597              	.LVL62:
 598              	.LBE27:
 599              	.LBE26:
 478:rtthread/src/thread.c **** 
 600              		.loc 1 478 0
ARM GAS  /tmp/ccTLI8H2.s 			page 28


 601 004c FFF7FEFF 		bl	rt_hw_interrupt_enable
 602              	.LVL63:
 480:rtthread/src/thread.c **** 
 603              		.loc 1 480 0
 604 0050 FFF7FEFF 		bl	rt_schedule
 605              	.LVL64:
 482:rtthread/src/thread.c ****     }
 606              		.loc 1 482 0
 607 0054 E5E7     		b	.L36
 608              	.L40:
 609 0056 00BF     		.align	2
 610              	.L39:
 611 0058 00000000 		.word	rt_current_thread
 612 005c 00000000 		.word	rt_thread_priority_table
 613              		.cfi_endproc
 614              	.LFE22:
 616              		.section	.text.rt_thread_suspend,"ax",%progbits
 617              		.align	1
 618              		.global	rt_thread_suspend
 619              		.syntax unified
 620              		.thumb
 621              		.thumb_func
 622              		.fpu softvfp
 624              	rt_thread_suspend:
 625              	.LFB28:
 713:rtthread/src/thread.c ****     register rt_base_t temp;
 626              		.loc 1 713 0
 627              		.cfi_startproc
 628              		@ args = 0, pretend = 0, frame = 0
 629              		@ frame_needed = 0, uses_anonymous_args = 0
 630              	.LVL65:
 631 0000 38B5     		push	{r3, r4, r5, lr}
 632              	.LCFI12:
 633              		.cfi_def_cfa_offset 16
 634              		.cfi_offset 3, -16
 635              		.cfi_offset 4, -12
 636              		.cfi_offset 5, -8
 637              		.cfi_offset 14, -4
 722:rtthread/src/thread.c ****     {
 638              		.loc 1 722 0
 639 0002 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 640 0006 03F00F03 		and	r3, r3, #15
 641 000a 012B     		cmp	r3, #1
 642 000c 17D1     		bne	.L43
 643 000e 0446     		mov	r4, r0
 731:rtthread/src/thread.c **** 
 644              		.loc 1 731 0
 645 0010 FFF7FEFF 		bl	rt_hw_interrupt_disable
 646              	.LVL66:
 647 0014 0546     		mov	r5, r0
 648              	.LVL67:
 734:rtthread/src/thread.c ****     thread->stat = RT_THREAD_SUSPEND | (thread->stat & ~RT_THREAD_STAT_MASK);
 649              		.loc 1 734 0
 650 0016 2046     		mov	r0, r4
 651              	.LVL68:
 652 0018 FFF7FEFF 		bl	rt_schedule_remove_thread
 653              	.LVL69:
ARM GAS  /tmp/ccTLI8H2.s 			page 29


 735:rtthread/src/thread.c **** 
 654              		.loc 1 735 0
 655 001c 94F93430 		ldrsb	r3, [r4, #52]
 656 0020 23F00F03 		bic	r3, r3, #15
 657 0024 43F00203 		orr	r3, r3, #2
 658 0028 84F83430 		strb	r3, [r4, #52]
 738:rtthread/src/thread.c **** 
 659              		.loc 1 738 0
 660 002c 04F14400 		add	r0, r4, #68
 661 0030 FFF7FEFF 		bl	rt_timer_stop
 662              	.LVL70:
 741:rtthread/src/thread.c **** 
 663              		.loc 1 741 0
 664 0034 2846     		mov	r0, r5
 665 0036 FFF7FEFF 		bl	rt_hw_interrupt_enable
 666              	.LVL71:
 744:rtthread/src/thread.c **** }
 667              		.loc 1 744 0
 668 003a 0020     		movs	r0, #0
 669              	.LVL72:
 670              	.L41:
 745:rtthread/src/thread.c **** 
 671              		.loc 1 745 0
 672 003c 38BD     		pop	{r3, r4, r5, pc}
 673              	.LVL73:
 674              	.L43:
 727:rtthread/src/thread.c ****     }
 675              		.loc 1 727 0
 676 003e 4FF0FF30 		mov	r0, #-1
 677              	.LVL74:
 678 0042 FBE7     		b	.L41
 679              		.cfi_endproc
 680              	.LFE28:
 682              		.section	.text.rt_thread_sleep,"ax",%progbits
 683              		.align	1
 684              		.global	rt_thread_sleep
 685              		.syntax unified
 686              		.thumb
 687              		.thumb_func
 688              		.fpu softvfp
 690              	rt_thread_sleep:
 691              	.LFB23:
 499:rtthread/src/thread.c ****     register rt_base_t temp;
 692              		.loc 1 499 0
 693              		.cfi_startproc
 694              		@ args = 0, pretend = 0, frame = 8
 695              		@ frame_needed = 0, uses_anonymous_args = 0
 696              	.LVL75:
 697 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 698              	.LCFI13:
 699              		.cfi_def_cfa_offset 20
 700              		.cfi_offset 4, -20
 701              		.cfi_offset 5, -16
 702              		.cfi_offset 6, -12
 703              		.cfi_offset 7, -8
 704              		.cfi_offset 14, -4
 705 0002 83B0     		sub	sp, sp, #12
ARM GAS  /tmp/ccTLI8H2.s 			page 30


 706              	.LCFI14:
 707              		.cfi_def_cfa_offset 32
 708 0004 02AD     		add	r5, sp, #8
 709 0006 45F8040D 		str	r0, [r5, #-4]!
 504:rtthread/src/thread.c ****     /* set to current thread */
 710              		.loc 1 504 0
 711 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 712              	.LVL76:
 713 000e 0746     		mov	r7, r0
 714              	.LVL77:
 506:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 715              		.loc 1 506 0
 716 0010 0E4B     		ldr	r3, .L49
 717 0012 1C68     		ldr	r4, [r3]
 718              	.LVL78:
 511:rtthread/src/thread.c **** 
 719              		.loc 1 511 0
 720 0014 2046     		mov	r0, r4
 721              	.LVL79:
 722 0016 FFF7FEFF 		bl	rt_thread_suspend
 723              	.LVL80:
 514:rtthread/src/thread.c ****     rt_timer_start(&(thread->thread_timer));
 724              		.loc 1 514 0
 725 001a 04F14406 		add	r6, r4, #68
 726 001e 2A46     		mov	r2, r5
 727 0020 0021     		movs	r1, #0
 728 0022 3046     		mov	r0, r6
 729 0024 FFF7FEFF 		bl	rt_timer_control
 730              	.LVL81:
 515:rtthread/src/thread.c **** 
 731              		.loc 1 515 0
 732 0028 3046     		mov	r0, r6
 733 002a FFF7FEFF 		bl	rt_timer_start
 734              	.LVL82:
 518:rtthread/src/thread.c **** 
 735              		.loc 1 518 0
 736 002e 3846     		mov	r0, r7
 737 0030 FFF7FEFF 		bl	rt_hw_interrupt_enable
 738              	.LVL83:
 520:rtthread/src/thread.c **** 
 739              		.loc 1 520 0
 740 0034 FFF7FEFF 		bl	rt_schedule
 741              	.LVL84:
 523:rtthread/src/thread.c ****         thread->error = RT_EOK;
 742              		.loc 1 523 0
 743 0038 236B     		ldr	r3, [r4, #48]
 744 003a 13F1020F 		cmn	r3, #2
 745 003e 02D0     		beq	.L48
 746              	.L46:
 527:rtthread/src/thread.c **** 
 747              		.loc 1 527 0
 748 0040 0020     		movs	r0, #0
 749 0042 03B0     		add	sp, sp, #12
 750              	.LCFI15:
 751              		.cfi_remember_state
 752              		.cfi_def_cfa_offset 20
 753              		@ sp needed
ARM GAS  /tmp/ccTLI8H2.s 			page 31


 754 0044 F0BD     		pop	{r4, r5, r6, r7, pc}
 755              	.LVL85:
 756              	.L48:
 757              	.LCFI16:
 758              		.cfi_restore_state
 524:rtthread/src/thread.c **** 
 759              		.loc 1 524 0
 760 0046 0023     		movs	r3, #0
 761 0048 2363     		str	r3, [r4, #48]
 762 004a F9E7     		b	.L46
 763              	.L50:
 764              		.align	2
 765              	.L49:
 766 004c 00000000 		.word	rt_current_thread
 767              		.cfi_endproc
 768              	.LFE23:
 770              		.section	.text.rt_thread_delay,"ax",%progbits
 771              		.align	1
 772              		.global	rt_thread_delay
 773              		.syntax unified
 774              		.thumb
 775              		.thumb_func
 776              		.fpu softvfp
 778              	rt_thread_delay:
 779              	.LFB24:
 537:rtthread/src/thread.c ****     return rt_thread_sleep(tick);
 780              		.loc 1 537 0
 781              		.cfi_startproc
 782              		@ args = 0, pretend = 0, frame = 0
 783              		@ frame_needed = 0, uses_anonymous_args = 0
 784              	.LVL86:
 785 0000 08B5     		push	{r3, lr}
 786              	.LCFI17:
 787              		.cfi_def_cfa_offset 8
 788              		.cfi_offset 3, -8
 789              		.cfi_offset 14, -4
 538:rtthread/src/thread.c **** }
 790              		.loc 1 538 0
 791 0002 FFF7FEFF 		bl	rt_thread_sleep
 792              	.LVL87:
 539:rtthread/src/thread.c **** 
 793              		.loc 1 539 0
 794 0006 08BD     		pop	{r3, pc}
 795              		.cfi_endproc
 796              	.LFE24:
 798              		.section	.text.rt_thread_mdelay,"ax",%progbits
 799              		.align	1
 800              		.global	rt_thread_mdelay
 801              		.syntax unified
 802              		.thumb
 803              		.thumb_func
 804              		.fpu softvfp
 806              	rt_thread_mdelay:
 807              	.LFB26:
 605:rtthread/src/thread.c ****     rt_tick_t tick;
 808              		.loc 1 605 0
 809              		.cfi_startproc
ARM GAS  /tmp/ccTLI8H2.s 			page 32


 810              		@ args = 0, pretend = 0, frame = 0
 811              		@ frame_needed = 0, uses_anonymous_args = 0
 812              	.LVL88:
 813 0000 08B5     		push	{r3, lr}
 814              	.LCFI18:
 815              		.cfi_def_cfa_offset 8
 816              		.cfi_offset 3, -8
 817              		.cfi_offset 14, -4
 608:rtthread/src/thread.c **** 
 818              		.loc 1 608 0
 819 0002 FFF7FEFF 		bl	rt_tick_from_millisecond
 820              	.LVL89:
 610:rtthread/src/thread.c **** }
 821              		.loc 1 610 0
 822 0006 FFF7FEFF 		bl	rt_thread_sleep
 823              	.LVL90:
 611:rtthread/src/thread.c **** 
 824              		.loc 1 611 0
 825 000a 08BD     		pop	{r3, pc}
 826              		.cfi_endproc
 827              	.LFE26:
 829              		.section	.text.rt_thread_delay_until,"ax",%progbits
 830              		.align	1
 831              		.global	rt_thread_delay_until
 832              		.syntax unified
 833              		.thumb
 834              		.thumb_func
 835              		.fpu softvfp
 837              	rt_thread_delay_until:
 838              	.LFB25:
 550:rtthread/src/thread.c ****     register rt_base_t level;
 839              		.loc 1 550 0
 840              		.cfi_startproc
 841              		@ args = 0, pretend = 0, frame = 0
 842              		@ frame_needed = 0, uses_anonymous_args = 0
 843              	.LVL91:
 844 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 845              	.LCFI19:
 846              		.cfi_def_cfa_offset 24
 847              		.cfi_offset 3, -24
 848              		.cfi_offset 4, -20
 849              		.cfi_offset 5, -16
 850              		.cfi_offset 6, -12
 851              		.cfi_offset 7, -8
 852              		.cfi_offset 14, -4
 853 0002 0546     		mov	r5, r0
 854 0004 0C46     		mov	r4, r1
 557:rtthread/src/thread.c ****     RT_ASSERT(thread != RT_NULL);
 855              		.loc 1 557 0
 856 0006 FFF7FEFF 		bl	rt_thread_self
 857              	.LVL92:
 858 000a 0646     		mov	r6, r0
 859              	.LVL93:
 562:rtthread/src/thread.c **** 
 860              		.loc 1 562 0
 861 000c FFF7FEFF 		bl	rt_hw_interrupt_disable
 862              	.LVL94:
ARM GAS  /tmp/ccTLI8H2.s 			page 33


 863 0010 0746     		mov	r7, r0
 864              	.LVL95:
 564:rtthread/src/thread.c ****     {
 865              		.loc 1 564 0
 866 0012 FFF7FEFF 		bl	rt_tick_get
 867              	.LVL96:
 868 0016 2B68     		ldr	r3, [r5]
 869 0018 C01A     		subs	r0, r0, r3
 870 001a A042     		cmp	r0, r4
 871 001c 1DD2     		bcs	.L56
 566:rtthread/src/thread.c **** 
 872              		.loc 1 566 0
 873 001e 1C44     		add	r4, r4, r3
 874              	.LVL97:
 875 0020 FFF7FEFF 		bl	rt_tick_get
 876              	.LVL98:
 877 0024 201A     		subs	r0, r4, r0
 878 0026 2860     		str	r0, [r5]
 569:rtthread/src/thread.c **** 
 879              		.loc 1 569 0
 880 0028 3046     		mov	r0, r6
 881 002a FFF7FEFF 		bl	rt_thread_suspend
 882              	.LVL99:
 572:rtthread/src/thread.c ****         rt_timer_start(&(thread->thread_timer));
 883              		.loc 1 572 0
 884 002e 06F14404 		add	r4, r6, #68
 885 0032 2A46     		mov	r2, r5
 886 0034 0021     		movs	r1, #0
 887 0036 2046     		mov	r0, r4
 888 0038 FFF7FEFF 		bl	rt_timer_control
 889              	.LVL100:
 573:rtthread/src/thread.c **** 
 890              		.loc 1 573 0
 891 003c 2046     		mov	r0, r4
 892 003e FFF7FEFF 		bl	rt_timer_start
 893              	.LVL101:
 576:rtthread/src/thread.c **** 
 894              		.loc 1 576 0
 895 0042 3846     		mov	r0, r7
 896 0044 FFF7FEFF 		bl	rt_hw_interrupt_enable
 897              	.LVL102:
 578:rtthread/src/thread.c **** 
 898              		.loc 1 578 0
 899 0048 FFF7FEFF 		bl	rt_schedule
 900              	.LVL103:
 581:rtthread/src/thread.c ****         {
 901              		.loc 1 581 0
 902 004c 336B     		ldr	r3, [r6, #48]
 903 004e 13F1020F 		cmn	r3, #2
 904 0052 05D1     		bne	.L57
 583:rtthread/src/thread.c ****         }
 905              		.loc 1 583 0
 906 0054 0023     		movs	r3, #0
 907 0056 3363     		str	r3, [r6, #48]
 908 0058 02E0     		b	.L57
 909              	.LVL104:
 910              	.L56:
ARM GAS  /tmp/ccTLI8H2.s 			page 34


 588:rtthread/src/thread.c ****     }
 911              		.loc 1 588 0
 912 005a 3846     		mov	r0, r7
 913 005c FFF7FEFF 		bl	rt_hw_interrupt_enable
 914              	.LVL105:
 915              	.L57:
 592:rtthread/src/thread.c **** 
 916              		.loc 1 592 0
 917 0060 FFF7FEFF 		bl	rt_tick_get
 918              	.LVL106:
 919 0064 2860     		str	r0, [r5]
 595:rtthread/src/thread.c **** 
 920              		.loc 1 595 0
 921 0066 0020     		movs	r0, #0
 922 0068 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 923              		.cfi_endproc
 924              	.LFE25:
 926              		.section	.text.rt_thread_resume,"ax",%progbits
 927              		.align	1
 928              		.global	rt_thread_resume
 929              		.syntax unified
 930              		.thumb
 931              		.thumb_func
 932              		.fpu softvfp
 934              	rt_thread_resume:
 935              	.LFB29:
 755:rtthread/src/thread.c ****     register rt_base_t temp;
 936              		.loc 1 755 0
 937              		.cfi_startproc
 938              		@ args = 0, pretend = 0, frame = 0
 939              		@ frame_needed = 0, uses_anonymous_args = 0
 940              	.LVL107:
 941 0000 38B5     		push	{r3, r4, r5, lr}
 942              	.LCFI20:
 943              		.cfi_def_cfa_offset 16
 944              		.cfi_offset 3, -16
 945              		.cfi_offset 4, -12
 946              		.cfi_offset 5, -8
 947              		.cfi_offset 14, -4
 764:rtthread/src/thread.c ****     {
 948              		.loc 1 764 0
 949 0002 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 950 0006 03F00F03 		and	r3, r3, #15
 951 000a 022B     		cmp	r3, #2
 952 000c 19D1     		bne	.L61
 953 000e 0446     		mov	r4, r0
 773:rtthread/src/thread.c **** 
 954              		.loc 1 773 0
 955 0010 FFF7FEFF 		bl	rt_hw_interrupt_disable
 956              	.LVL108:
 957 0014 0546     		mov	r5, r0
 958              	.LVL109:
 776:rtthread/src/thread.c **** 
 959              		.loc 1 776 0
 960 0016 04F11403 		add	r3, r4, #20
 961              	.LVL110:
 962              	.LBB28:
ARM GAS  /tmp/ccTLI8H2.s 			page 35


 963              	.LBB29:
  88:rtthread/include/rtservice.h ****     n->prev->next = n->next;
 964              		.loc 2 88 0
 965 001a 6269     		ldr	r2, [r4, #20]
 966 001c A169     		ldr	r1, [r4, #24]
 967 001e 5160     		str	r1, [r2, #4]
  89:rtthread/include/rtservice.h **** 
 968              		.loc 2 89 0
 969 0020 A269     		ldr	r2, [r4, #24]
 970 0022 6169     		ldr	r1, [r4, #20]
 971 0024 1160     		str	r1, [r2]
 972              		.loc 2 91 0
 973 0026 A361     		str	r3, [r4, #24]
 974 0028 6361     		str	r3, [r4, #20]
 975              	.LVL111:
 976              	.LBE29:
 977              	.LBE28:
 778:rtthread/src/thread.c **** 
 978              		.loc 1 778 0
 979 002a 04F14400 		add	r0, r4, #68
 980              	.LVL112:
 981 002e FFF7FEFF 		bl	rt_timer_stop
 982              	.LVL113:
 781:rtthread/src/thread.c **** 
 983              		.loc 1 781 0
 984 0032 2846     		mov	r0, r5
 985 0034 FFF7FEFF 		bl	rt_hw_interrupt_enable
 986              	.LVL114:
 784:rtthread/src/thread.c **** 
 987              		.loc 1 784 0
 988 0038 2046     		mov	r0, r4
 989 003a FFF7FEFF 		bl	rt_schedule_insert_thread
 990              	.LVL115:
 787:rtthread/src/thread.c **** }
 991              		.loc 1 787 0
 992 003e 0020     		movs	r0, #0
 993              	.LVL116:
 994              	.L59:
 788:rtthread/src/thread.c **** 
 995              		.loc 1 788 0
 996 0040 38BD     		pop	{r3, r4, r5, pc}
 997              	.LVL117:
 998              	.L61:
 769:rtthread/src/thread.c ****     }
 999              		.loc 1 769 0
 1000 0042 4FF0FF30 		mov	r0, #-1
 1001              	.LVL118:
 1002 0046 FBE7     		b	.L59
 1003              		.cfi_endproc
 1004              	.LFE29:
 1006              		.section	.text.rt_thread_startup,"ax",%progbits
 1007              		.align	1
 1008              		.global	rt_thread_startup
 1009              		.syntax unified
 1010              		.thumb
 1011              		.thumb_func
 1012              		.fpu softvfp
ARM GAS  /tmp/ccTLI8H2.s 			page 36


 1014              	rt_thread_startup:
 1015              	.LFB20:
 267:rtthread/src/thread.c ****     /* thread check */
 1016              		.loc 1 267 0
 1017              		.cfi_startproc
 1018              		@ args = 0, pretend = 0, frame = 0
 1019              		@ frame_needed = 0, uses_anonymous_args = 0
 1020              	.LVL119:
 1021 0000 08B5     		push	{r3, lr}
 1022              	.LCFI21:
 1023              		.cfi_def_cfa_offset 8
 1024              		.cfi_offset 3, -8
 1025              		.cfi_offset 14, -4
 274:rtthread/src/thread.c **** 
 1026              		.loc 1 274 0
 1027 0002 90F83610 		ldrb	r1, [r0, #54]	@ zero_extendqisi2
 1028 0006 80F83510 		strb	r1, [r0, #53]
 282:rtthread/src/thread.c **** #endif
 1029              		.loc 1 282 0
 1030 000a 0122     		movs	r2, #1
 1031 000c 8A40     		lsls	r2, r2, r1
 1032 000e 8263     		str	r2, [r0, #56]
 288:rtthread/src/thread.c ****     /* then resume it */
 1033              		.loc 1 288 0
 1034 0010 0222     		movs	r2, #2
 1035 0012 80F83420 		strb	r2, [r0, #52]
 290:rtthread/src/thread.c ****     if (rt_thread_self() != RT_NULL)
 1036              		.loc 1 290 0
 1037 0016 FFF7FEFF 		bl	rt_thread_resume
 1038              	.LVL120:
 291:rtthread/src/thread.c ****     {
 1039              		.loc 1 291 0
 1040 001a FFF7FEFF 		bl	rt_thread_self
 1041              	.LVL121:
 1042 001e 08B1     		cbz	r0, .L64
 294:rtthread/src/thread.c ****     }
 1043              		.loc 1 294 0
 1044 0020 FFF7FEFF 		bl	rt_schedule
 1045              	.LVL122:
 1046              	.L64:
 298:rtthread/src/thread.c **** 
 1047              		.loc 1 298 0
 1048 0024 0020     		movs	r0, #0
 1049 0026 08BD     		pop	{r3, pc}
 1050              		.cfi_endproc
 1051              	.LFE20:
 1053              		.section	.text.rt_thread_control,"ax",%progbits
 1054              		.align	1
 1055              		.global	rt_thread_control
 1056              		.syntax unified
 1057              		.thumb
 1058              		.thumb_func
 1059              		.fpu softvfp
 1061              	rt_thread_control:
 1062              	.LFB27:
 627:rtthread/src/thread.c ****     register rt_base_t temp;
 1063              		.loc 1 627 0
ARM GAS  /tmp/ccTLI8H2.s 			page 37


 1064              		.cfi_startproc
 1065              		@ args = 0, pretend = 0, frame = 0
 1066              		@ frame_needed = 0, uses_anonymous_args = 0
 1067              	.LVL123:
 1068 0000 70B5     		push	{r4, r5, r6, lr}
 1069              	.LCFI22:
 1070              		.cfi_def_cfa_offset 16
 1071              		.cfi_offset 4, -16
 1072              		.cfi_offset 5, -12
 1073              		.cfi_offset 6, -8
 1074              		.cfi_offset 14, -4
 1075 0002 0446     		mov	r4, r0
 634:rtthread/src/thread.c ****     {
 1076              		.loc 1 634 0
 1077 0004 0129     		cmp	r1, #1
 1078 0006 29D0     		beq	.L68
 1079 0008 1546     		mov	r5, r2
 1080 000a 0229     		cmp	r1, #2
 1081 000c 02D0     		beq	.L69
 1082 000e 11B3     		cbz	r1, .L77
 699:rtthread/src/thread.c **** }
 1083              		.loc 1 699 0
 1084 0010 0020     		movs	r0, #0
 1085              	.LVL124:
 1086 0012 12E0     		b	.L66
 1087              	.LVL125:
 1088              	.L69:
 638:rtthread/src/thread.c **** 
 1089              		.loc 1 638 0
 1090 0014 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1091              	.LVL126:
 1092 0018 0646     		mov	r6, r0
 1093              	.LVL127:
 641:rtthread/src/thread.c ****         {
 1094              		.loc 1 641 0
 1095 001a 94F83430 		ldrb	r3, [r4, #52]	@ zero_extendqisi2
 1096 001e 03F00F03 		and	r3, r3, #15
 1097 0022 012B     		cmp	r3, #1
 1098 0024 0AD0     		beq	.L78
 663:rtthread/src/thread.c **** 
 1099              		.loc 1 663 0
 1100 0026 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 1101 0028 84F83520 		strb	r2, [r4, #53]
 671:rtthread/src/thread.c **** #endif
 1102              		.loc 1 671 0
 1103 002c 0123     		movs	r3, #1
 1104 002e 9340     		lsls	r3, r3, r2
 1105 0030 A363     		str	r3, [r4, #56]
 1106              	.LVL128:
 1107              	.L72:
 676:rtthread/src/thread.c ****         break;
 1108              		.loc 1 676 0
 1109 0032 3046     		mov	r0, r6
 1110 0034 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1111              	.LVL129:
 699:rtthread/src/thread.c **** }
 1112              		.loc 1 699 0
ARM GAS  /tmp/ccTLI8H2.s 			page 38


 1113 0038 0020     		movs	r0, #0
 1114              	.LVL130:
 1115              	.L66:
 700:rtthread/src/thread.c **** 
 1116              		.loc 1 700 0
 1117 003a 70BD     		pop	{r4, r5, r6, pc}
 1118              	.LVL131:
 1119              	.L78:
 644:rtthread/src/thread.c **** 
 1120              		.loc 1 644 0
 1121 003c 2046     		mov	r0, r4
 1122              	.LVL132:
 1123 003e FFF7FEFF 		bl	rt_schedule_remove_thread
 1124              	.LVL133:
 647:rtthread/src/thread.c **** 
 1125              		.loc 1 647 0
 1126 0042 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 1127 0044 84F83520 		strb	r2, [r4, #53]
 655:rtthread/src/thread.c **** #endif
 1128              		.loc 1 655 0
 1129 0048 0123     		movs	r3, #1
 1130 004a 9340     		lsls	r3, r3, r2
 1131 004c A363     		str	r3, [r4, #56]
 659:rtthread/src/thread.c ****         }
 1132              		.loc 1 659 0
 1133 004e 2046     		mov	r0, r4
 1134 0050 FFF7FEFF 		bl	rt_schedule_insert_thread
 1135              	.LVL134:
 1136 0054 EDE7     		b	.L72
 1137              	.LVL135:
 1138              	.L77:
 680:rtthread/src/thread.c **** 
 1139              		.loc 1 680 0
 1140 0056 FFF7FEFF 		bl	rt_thread_startup
 1141              	.LVL136:
 1142 005a EEE7     		b	.L66
 1143              	.LVL137:
 1144              	.L68:
 684:rtthread/src/thread.c ****         {
 1145              		.loc 1 684 0
 1146 005c FFF7FEFF 		bl	rt_object_is_systemobject
 1147              	.LVL138:
 1148 0060 0128     		cmp	r0, #1
 1149 0062 01D0     		beq	.L79
 699:rtthread/src/thread.c **** }
 1150              		.loc 1 699 0
 1151 0064 0020     		movs	r0, #0
 1152 0066 E8E7     		b	.L66
 1153              	.L79:
 686:rtthread/src/thread.c ****         }
 1154              		.loc 1 686 0
 1155 0068 2046     		mov	r0, r4
 1156 006a FFF7FEFF 		bl	rt_thread_detach
 1157              	.LVL139:
 1158 006e E4E7     		b	.L66
 1159              		.cfi_endproc
 1160              	.LFE27:
ARM GAS  /tmp/ccTLI8H2.s 			page 39


 1162              		.section	.text.rt_thread_find,"ax",%progbits
 1163              		.align	1
 1164              		.global	rt_thread_find
 1165              		.syntax unified
 1166              		.thumb
 1167              		.thumb_func
 1168              		.fpu softvfp
 1170              	rt_thread_find:
 1171              	.LFB31:
 819:rtthread/src/thread.c **** 
 820:rtthread/src/thread.c **** /**
 821:rtthread/src/thread.c ****  * This function will find the specified thread.
 822:rtthread/src/thread.c ****  *
 823:rtthread/src/thread.c ****  * @param name the name of thread finding
 824:rtthread/src/thread.c ****  *
 825:rtthread/src/thread.c ****  * @return the found thread
 826:rtthread/src/thread.c ****  *
 827:rtthread/src/thread.c ****  * @note please don't invoke this function in interrupt status.
 828:rtthread/src/thread.c ****  */
 829:rtthread/src/thread.c **** rt_thread_t rt_thread_find(char *name)
 830:rtthread/src/thread.c **** {
 1172              		.loc 1 830 0
 1173              		.cfi_startproc
 1174              		@ args = 0, pretend = 0, frame = 0
 1175              		@ frame_needed = 0, uses_anonymous_args = 0
 1176              	.LVL140:
 1177 0000 08B5     		push	{r3, lr}
 1178              	.LCFI23:
 1179              		.cfi_def_cfa_offset 8
 1180              		.cfi_offset 3, -8
 1181              		.cfi_offset 14, -4
 831:rtthread/src/thread.c ****     return (rt_thread_t)rt_object_find(name, RT_Object_Class_Thread);
 1182              		.loc 1 831 0
 1183 0002 0121     		movs	r1, #1
 1184 0004 FFF7FEFF 		bl	rt_object_find
 1185              	.LVL141:
 832:rtthread/src/thread.c **** }
 1186              		.loc 1 832 0
 1187 0008 08BD     		pop	{r3, pc}
 1188              		.cfi_endproc
 1189              	.LFE31:
 1191              		.text
 1192              	.Letext0:
 1193              		.file 3 "rtthread/include/rtdef.h"
 1194              		.file 4 "rtthread/include/rtthread.h"
 1195              		.file 5 "rtthread/include/rthw.h"
ARM GAS  /tmp/ccTLI8H2.s 			page 40


DEFINED SYMBOLS
                            *ABS*:0000000000000000 thread.c
     /tmp/ccTLI8H2.s:16     .text._thread_cleanup_execute:0000000000000000 $t
     /tmp/ccTLI8H2.s:22     .text._thread_cleanup_execute:0000000000000000 _thread_cleanup_execute
     /tmp/ccTLI8H2.s:62     .text.rt_thread_exit:0000000000000000 $t
     /tmp/ccTLI8H2.s:69     .text.rt_thread_exit:0000000000000000 rt_thread_exit
     /tmp/ccTLI8H2.s:152    .text.rt_thread_exit:0000000000000054 $d
     /tmp/ccTLI8H2.s:158    .text._rt_thread_init:0000000000000000 $t
     /tmp/ccTLI8H2.s:164    .text._rt_thread_init:0000000000000000 _rt_thread_init
     /tmp/ccTLI8H2.s:265    .text._rt_thread_init:0000000000000070 $d
     /tmp/ccTLI8H2.s:278    .text.rt_thread_timeout:0000000000000000 rt_thread_timeout
     /tmp/ccTLI8H2.s:271    .text.rt_thread_timeout:0000000000000000 $t
     /tmp/ccTLI8H2.s:325    .text.rt_thread_init:0000000000000000 $t
     /tmp/ccTLI8H2.s:332    .text.rt_thread_init:0000000000000000 rt_thread_init
     /tmp/ccTLI8H2.s:386    .text.rt_thread_self:0000000000000000 $t
     /tmp/ccTLI8H2.s:393    .text.rt_thread_self:0000000000000000 rt_thread_self
     /tmp/ccTLI8H2.s:407    .text.rt_thread_self:0000000000000008 $d
     /tmp/ccTLI8H2.s:412    .text.rt_thread_detach:0000000000000000 $t
     /tmp/ccTLI8H2.s:419    .text.rt_thread_detach:0000000000000000 rt_thread_detach
     /tmp/ccTLI8H2.s:512    .text.rt_thread_detach:0000000000000060 $d
     /tmp/ccTLI8H2.s:517    .text.rt_thread_yield:0000000000000000 $t
     /tmp/ccTLI8H2.s:524    .text.rt_thread_yield:0000000000000000 rt_thread_yield
     /tmp/ccTLI8H2.s:611    .text.rt_thread_yield:0000000000000058 $d
     /tmp/ccTLI8H2.s:617    .text.rt_thread_suspend:0000000000000000 $t
     /tmp/ccTLI8H2.s:624    .text.rt_thread_suspend:0000000000000000 rt_thread_suspend
     /tmp/ccTLI8H2.s:683    .text.rt_thread_sleep:0000000000000000 $t
     /tmp/ccTLI8H2.s:690    .text.rt_thread_sleep:0000000000000000 rt_thread_sleep
     /tmp/ccTLI8H2.s:766    .text.rt_thread_sleep:000000000000004c $d
     /tmp/ccTLI8H2.s:771    .text.rt_thread_delay:0000000000000000 $t
     /tmp/ccTLI8H2.s:778    .text.rt_thread_delay:0000000000000000 rt_thread_delay
     /tmp/ccTLI8H2.s:799    .text.rt_thread_mdelay:0000000000000000 $t
     /tmp/ccTLI8H2.s:806    .text.rt_thread_mdelay:0000000000000000 rt_thread_mdelay
     /tmp/ccTLI8H2.s:830    .text.rt_thread_delay_until:0000000000000000 $t
     /tmp/ccTLI8H2.s:837    .text.rt_thread_delay_until:0000000000000000 rt_thread_delay_until
     /tmp/ccTLI8H2.s:927    .text.rt_thread_resume:0000000000000000 $t
     /tmp/ccTLI8H2.s:934    .text.rt_thread_resume:0000000000000000 rt_thread_resume
     /tmp/ccTLI8H2.s:1007   .text.rt_thread_startup:0000000000000000 $t
     /tmp/ccTLI8H2.s:1014   .text.rt_thread_startup:0000000000000000 rt_thread_startup
     /tmp/ccTLI8H2.s:1054   .text.rt_thread_control:0000000000000000 $t
     /tmp/ccTLI8H2.s:1061   .text.rt_thread_control:0000000000000000 rt_thread_control
     /tmp/ccTLI8H2.s:1163   .text.rt_thread_find:0000000000000000 $t
     /tmp/ccTLI8H2.s:1170   .text.rt_thread_find:0000000000000000 rt_thread_find

UNDEFINED SYMBOLS
rt_hw_interrupt_disable
rt_hw_interrupt_enable
rt_schedule_remove_thread
rt_timer_detach
rt_object_is_systemobject
rt_schedule
rt_object_detach
rt_current_thread
rt_thread_defunct
rt_memset
rt_hw_stack_init
rt_timer_init
rt_schedule_insert_thread
ARM GAS  /tmp/ccTLI8H2.s 			page 41


rt_object_init
rt_thread_priority_table
rt_timer_stop
rt_timer_control
rt_timer_start
rt_tick_from_millisecond
rt_tick_get
rt_object_find
