/*******************************************************************************
        => 开启I2C配置
*******************************************************************************/
// 像很多的其他RTOS一样，ChibiOS的HAL中的组件一般都是可裁剪的，需要我们去配置才能开启某些
// 组件功能。为了能够在我们的工程中使用I2C，我们需要修改工程目录下的cfg目录下的halconf.h文件，
// 搜索“I2C”字样，找到宏HAL_USE_I2C，然后修改其定义为TRUE即可，此时I2C就被加入到了工程中，
// 将会在hal层初始化的时候也对I2C设备层进行初始化。

// 由于STM32F4有多个I2C设备，所以需要配置使用哪些I2C，修改mcucfg.h文件，
// 找到STM32_I2C_USE_I2C1这个宏，修改值为TRUE，就可以开启I2C1这个设备




/*******************************************************************************
        => IO配置
*******************************************************************************/
// 既然是I2C接口，那必然需要用到IO口的配置，这里我们以STM32F407为例，根据手册，配置PB6 和
// PB7 分别作为SCL和SDA信号线：
// 按照我们在 《 ChibiOS如何建立自己的板级（board）配置 》 中提到的方法， 修改board.h文件，
// 这里由于原先的board.h文件中定义的I2C是PB6和PB9，所以我们需要将所有的PB9修改为普通IO模式
// （可以参考PB8，PB8配置就是典型的普通IO的配置方式），然后将PB7配置为I2C的SDA的外设复用模式，
// PB7详细的配置情况如下：



/*******************************************************************************
        => 建立I2C设备
*******************************************************************************/
// 硬件层配置完毕后我们需要建立hal层的I2C设备，我们需要一个I2C的建立函数，根据手册，该函数
// 名为 i2cStart， 原型如下：
        void i2cStart(I2CDriver *i2cp, const I2CConfig *config);
        // 可以看到，需要传入两个参数，一个是I2CDriver结构体指针，
        // 这里ChibiOS已经给我们准备好了，名字就叫做I2CD1，事实上，
        // 这个设备的建立是由于我们前面将STM32_I2C_USE_I2C1这个宏
        // 开启所产生的；第二个参数是一个I2C的配置信息，这个参数需
        // 要我们自己定义，比如定义代码如下：
        I2CConfig               i2c_cfg;
        i2c_cfg.op_mode         = OPMODE_I2C;           // i2c模式
        i2c_cfg.clock_speed     = 400000;               // 时钟速率为400KHz
        i2c_cfg.duty_cycle      = FAST_DUTY_CYCLE_2;    // 时钟占空比选择
        // 这部分的配置还是需要了解一些STM32F4的I2C特性，不过好在配
        // 置内容不多，所以依样画葫芦即可。然后我们调用Start就可以建立I2C：
        i2cStart(&I2CD1, &i2c_cfg);


        // I2C 看状态转换图
        // ____________________________________________________
        可以看到，i2cStart后，我们可以用i2cMasterTransmit来发送数据，
        发送完毕后自动返回到I2C_READY状态；也可以用i2cMasterReceive来
        接收数据，完成后同样会返回；一旦发送或者接收超时，I2C设备将被锁定，
        此时需要重新Start才能恢复
        
        
        // 这里我们调用Transmit函数，原型如下：
        #define i2cMasterTransmit(i2cp, addr, txbuf, txbytes, rxbuf, rxbytes)  \
                (i2cMasterTransmitTimeout(i2cp, addr, txbuf, txbytes, rxbuf, rxbytes, TIME_INFINITE))
        // 可以看到其实是一个对超时函数的封装，只是超时时间固定为无限等待
        // （或者说就是阻塞）， 通过参数的名称， 非常好理解每一项的用途，
        //      i2cp         就是i2c设备
        //      addr         就是从机地址
        //      txbuf        为要发送的数据
        //      txbytes      为发送数据字节数
        //      rxbuf        为接收数据区
        //      rxbytes      为要接收的字节数

        
        // 这里我以BQ25601这个设备为例
        // 其从机地址为0x6B，向其寄存器3写入数据0x33，则可以如下操作：
        uint8_t tx_buf[2] = { 0x03, 0x33 };
        i2cMasterTransmit(&I2CD1, 0x6B, tx_buf, 2, NULL, 0);
        // 即可完成写入动作，当然如果想要读取，也可以修改后面的 NULL为
        // 别的变量地址并修改rxbytes为读取数量

        
        
        
        
/*******************************************************************************
        => I2C
*******************************************************************************/
        // 关闭I2C
        // ____________________________________________________
        // 同样根据ChibiOS的I2C状态转换图，
        // 我们可以调用i2cStop来关闭设备，此时设备将进入低功耗状态
        
        
        
        // 关于多线程操作
        // ____________________________________________________
        // ChibiOS属于多任务系统，而I2C总线又属于一种共享总线，因此
        // 可能存在代码的多个模块同时访问I2C总线的情况，为此，ChibiOS
        // 的I2C设计了两个函数用于总线的申请和释放：
        void i2cAcquireBus(I2CDriver *i2cp);
        void i2cReleaseBus(I2CDriver *i2cp);
        // 相当于对I2C设备进行上锁和解锁，可以保证在多线程操作的时候能
        // 保证对I2C设备的完整命令的原子性操作避免出现错误。




