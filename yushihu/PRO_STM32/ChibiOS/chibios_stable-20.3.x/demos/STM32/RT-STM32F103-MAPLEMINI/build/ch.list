
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000239 	.word	0x08000239
 8000008:	0800023b 	.word	0x0800023b
 800000c:	0800023b 	.word	0x0800023b
 8000010:	0800023b 	.word	0x0800023b
 8000014:	0800023b 	.word	0x0800023b
 8000018:	0800023b 	.word	0x0800023b
 800001c:	0800023b 	.word	0x0800023b
 8000020:	0800023b 	.word	0x0800023b
 8000024:	0800023b 	.word	0x0800023b
 8000028:	0800023b 	.word	0x0800023b
 800002c:	08004e21 	.word	0x08004e21
 8000030:	0800023b 	.word	0x0800023b
 8000034:	0800023b 	.word	0x0800023b
 8000038:	0800023b 	.word	0x0800023b
 800003c:	0800023b 	.word	0x0800023b
 8000040:	0800023b 	.word	0x0800023b
 8000044:	0800023b 	.word	0x0800023b
 8000048:	0800023b 	.word	0x0800023b
 800004c:	0800023b 	.word	0x0800023b
 8000050:	0800023b 	.word	0x0800023b
 8000054:	0800023b 	.word	0x0800023b
 8000058:	0800023b 	.word	0x0800023b
 800005c:	0800023b 	.word	0x0800023b
 8000060:	0800023b 	.word	0x0800023b
 8000064:	0800023b 	.word	0x0800023b
 8000068:	0800023b 	.word	0x0800023b
 800006c:	0800023b 	.word	0x0800023b
 8000070:	0800023b 	.word	0x0800023b
 8000074:	0800023b 	.word	0x0800023b
 8000078:	0800023b 	.word	0x0800023b
 800007c:	0800023b 	.word	0x0800023b
 8000080:	0800023b 	.word	0x0800023b
 8000084:	0800023b 	.word	0x0800023b
 8000088:	0800023b 	.word	0x0800023b
 800008c:	0800023b 	.word	0x0800023b
 8000090:	0800a541 	.word	0x0800a541
 8000094:	0800023b 	.word	0x0800023b
 8000098:	0800023b 	.word	0x0800023b
 800009c:	0800023b 	.word	0x0800023b
 80000a0:	0800023b 	.word	0x0800023b
 80000a4:	0800023b 	.word	0x0800023b
 80000a8:	0800023b 	.word	0x0800023b
 80000ac:	0800023b 	.word	0x0800023b
 80000b0:	0800a861 	.word	0x0800a861
 80000b4:	0800023b 	.word	0x0800023b
 80000b8:	0800023b 	.word	0x0800023b
 80000bc:	0800023b 	.word	0x0800023b
 80000c0:	0800023b 	.word	0x0800023b
 80000c4:	0800023b 	.word	0x0800023b
 80000c8:	0800023b 	.word	0x0800023b
 80000cc:	0800023b 	.word	0x0800023b
 80000d0:	0800023b 	.word	0x0800023b
 80000d4:	0800023b 	.word	0x0800023b
 80000d8:	0800023b 	.word	0x0800023b
 80000dc:	0800023b 	.word	0x0800023b
 80000e0:	0800023b 	.word	0x0800023b
 80000e4:	0800023b 	.word	0x0800023b
 80000e8:	0800023b 	.word	0x0800023b
 80000ec:	0800023b 	.word	0x0800023b
 80000f0:	0800023b 	.word	0x0800023b
 80000f4:	0800023b 	.word	0x0800023b
 80000f8:	0800023b 	.word	0x0800023b
 80000fc:	0800023b 	.word	0x0800023b
 8000100:	0800023b 	.word	0x0800023b
 8000104:	0800023b 	.word	0x0800023b
 8000108:	0800023b 	.word	0x0800023b
 800010c:	0800023b 	.word	0x0800023b
 8000110:	0800023b 	.word	0x0800023b
 8000114:	0800023b 	.word	0x0800023b
 8000118:	0800023b 	.word	0x0800023b
 800011c:	0800023b 	.word	0x0800023b
 8000120:	0800023b 	.word	0x0800023b
 8000124:	0800023b 	.word	0x0800023b
 8000128:	0800023b 	.word	0x0800023b
 800012c:	0800023b 	.word	0x0800023b
 8000130:	0800023b 	.word	0x0800023b
 8000134:	0800023b 	.word	0x0800023b
 8000138:	0800023b 	.word	0x0800023b
 800013c:	0800023b 	.word	0x0800023b
 8000140:	0800023b 	.word	0x0800023b
 8000144:	0800023b 	.word	0x0800023b
 8000148:	0800023b 	.word	0x0800023b
 800014c:	0800023b 	.word	0x0800023b
 8000150:	0800023b 	.word	0x0800023b
 8000154:	0800023b 	.word	0x0800023b
 8000158:	0800023b 	.word	0x0800023b
 800015c:	0800023b 	.word	0x0800023b

Disassembly of section .text:

08000160 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000160:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000162:	4827      	ldr	r0, [pc, #156]	; (8000200 <endfiniloop+0x4>)
                msr     MSP, r0
 8000164:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000168:	4826      	ldr	r0, [pc, #152]	; (8000204 <endfiniloop+0x8>)
                msr     PSP, r0
 800016a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 800016e:	4826      	ldr	r0, [pc, #152]	; (8000208 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 8000170:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 8000174:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000178:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 800017a:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 800017c:	f380 8814 	msr	CONTROL, r0
                isb
 8000180:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000184:	f00a fc14 	bl	800a9b0 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000188:	f00a f99a 	bl	800a4c0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800018c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000190:	491e      	ldr	r1, [pc, #120]	; (800020c <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 8000192:	4a1b      	ldr	r2, [pc, #108]	; (8000200 <endfiniloop+0x4>)

08000194 <msloop>:
msloop:
                cmp     r1, r2
 8000194:	4291      	cmp	r1, r2
                itt     lo
 8000196:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000198:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 800019c:	e7fa      	bcc.n	8000194 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800019e:	491c      	ldr	r1, [pc, #112]	; (8000210 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 80001a0:	4a18      	ldr	r2, [pc, #96]	; (8000204 <endfiniloop+0x8>)

080001a2 <psloop>:
psloop:
                cmp     r1, r2
 80001a2:	4291      	cmp	r1, r2
                itt     lo
 80001a4:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001a6:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 80001aa:	e7fa      	bcc.n	80001a2 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 80001ac:	4919      	ldr	r1, [pc, #100]	; (8000214 <endfiniloop+0x18>)
                ldr     r2, =__data_base__
 80001ae:	4a1a      	ldr	r2, [pc, #104]	; (8000218 <endfiniloop+0x1c>)
                ldr     r3, =__data_end__
 80001b0:	4b1a      	ldr	r3, [pc, #104]	; (800021c <endfiniloop+0x20>)

080001b2 <dloop>:
dloop:
                cmp     r2, r3
 80001b2:	429a      	cmp	r2, r3
                ittt    lo
 80001b4:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 80001b6:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 80001ba:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 80001be:	e7f8      	bcc.n	80001b2 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 80001c0:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 80001c2:	4917      	ldr	r1, [pc, #92]	; (8000220 <endfiniloop+0x24>)
                ldr     r2, =__bss_end__
 80001c4:	4a17      	ldr	r2, [pc, #92]	; (8000224 <endfiniloop+0x28>)

080001c6 <bloop>:
bloop:
                cmp     r1, r2
 80001c6:	4291      	cmp	r1, r2
                itt     lo
 80001c8:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001ca:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 80001ce:	e7fa      	bcc.n	80001c6 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 80001d0:	f00a fba6 	bl	800a920 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 80001d4:	f00a fbe4 	bl	800a9a0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 80001d8:	4c13      	ldr	r4, [pc, #76]	; (8000228 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end__
 80001da:	4d14      	ldr	r5, [pc, #80]	; (800022c <endfiniloop+0x30>)

080001dc <initloop>:
initloop:
                cmp     r4, r5
 80001dc:	42ac      	cmp	r4, r5
                bge     endinitloop
 80001de:	da03      	bge.n	80001e8 <endinitloop>
                ldr     r1, [r4], #4
 80001e0:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80001e4:	4788      	blx	r1
                b       initloop
 80001e6:	e7f9      	b.n	80001dc <initloop>

080001e8 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80001e8:	f008 f922 	bl	8008430 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 80001ec:	4c10      	ldr	r4, [pc, #64]	; (8000230 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end__
 80001ee:	4d11      	ldr	r5, [pc, #68]	; (8000234 <endfiniloop+0x38>)

080001f0 <finiloop>:
finiloop:
                cmp     r4, r5
 80001f0:	42ac      	cmp	r4, r5
                bge     endfiniloop
 80001f2:	da03      	bge.n	80001fc <endfiniloop>
                ldr     r1, [r4], #4
 80001f4:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80001f8:	4788      	blx	r1
                b       finiloop
 80001fa:	e7f9      	b.n	80001f0 <finiloop>

080001fc <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80001fc:	f00a bbc8 	b.w	800a990 <__default_exit>
                ldr     r0, =__main_stack_end__
 8000200:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000204:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000208:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 800020c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000210:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000214:	0800d574 	.word	0x0800d574
                ldr     r2, =__data_base__
 8000218:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800021c:	20000ce8 	.word	0x20000ce8
                ldr     r1, =__bss_base__
 8000220:	20000ce8 	.word	0x20000ce8
                ldr     r2, =__bss_end__
 8000224:	20002490 	.word	0x20002490
                ldr     r4, =__init_array_base__
 8000228:	08000160 	.word	0x08000160
                ldr     r5, =__init_array_end__
 800022c:	08000160 	.word	0x08000160
                ldr     r4, =__fini_array_base__
 8000230:	08000160 	.word	0x08000160
                ldr     r5, =__fini_array_end__
 8000234:	08000160 	.word	0x08000160

08000238 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000238:	e792      	b.n	8000160 <_crt0_entry>

0800023a <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 800023a:	f000 f800 	bl	800023e <_unhandled_exception>

0800023e <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 800023e:	e7fe      	b.n	800023e <_unhandled_exception>

08000240 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000240:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000244:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000248:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 800024a:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800024c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000250 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000250:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000252:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 8000256:	4628      	mov	r0, r5
                blx     r4
 8000258:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 800025a:	2000      	movs	r0, #0
                bl      chThdExit
 800025c:	f004 fdf0 	bl	8004e40 <chThdExit>

08000260 <_zombies>:
_zombies:       b       _zombies
 8000260:	e7fe      	b.n	8000260 <_zombies>

08000262 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 8000262:	f004 fe25 	bl	8004eb0 <chSchDoReschedule>

08000266 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000266:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000268:	e7fe      	b.n	8000268 <_port_exit_from_isr+0x2>
	...

0800026c <memcmp>:
 800026c:	2a03      	cmp	r2, #3
 800026e:	b470      	push	{r4, r5, r6}
 8000270:	d914      	bls.n	800029c <memcmp+0x30>
 8000272:	ea40 0501 	orr.w	r5, r0, r1
 8000276:	07ad      	lsls	r5, r5, #30
 8000278:	4604      	mov	r4, r0
 800027a:	460b      	mov	r3, r1
 800027c:	d122      	bne.n	80002c4 <memcmp+0x58>
 800027e:	681d      	ldr	r5, [r3, #0]
 8000280:	6826      	ldr	r6, [r4, #0]
 8000282:	4619      	mov	r1, r3
 8000284:	42ae      	cmp	r6, r5
 8000286:	4620      	mov	r0, r4
 8000288:	f103 0304 	add.w	r3, r3, #4
 800028c:	f104 0404 	add.w	r4, r4, #4
 8000290:	d118      	bne.n	80002c4 <memcmp+0x58>
 8000292:	3a04      	subs	r2, #4
 8000294:	2a03      	cmp	r2, #3
 8000296:	4620      	mov	r0, r4
 8000298:	4619      	mov	r1, r3
 800029a:	d8f0      	bhi.n	800027e <memcmp+0x12>
 800029c:	1e54      	subs	r4, r2, #1
 800029e:	b172      	cbz	r2, 80002be <memcmp+0x52>
 80002a0:	7802      	ldrb	r2, [r0, #0]
 80002a2:	780b      	ldrb	r3, [r1, #0]
 80002a4:	429a      	cmp	r2, r3
 80002a6:	bf08      	it	eq
 80002a8:	1864      	addeq	r4, r4, r1
 80002aa:	d006      	beq.n	80002ba <memcmp+0x4e>
 80002ac:	e00c      	b.n	80002c8 <memcmp+0x5c>
 80002ae:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 80002b2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80002b6:	429a      	cmp	r2, r3
 80002b8:	d106      	bne.n	80002c8 <memcmp+0x5c>
 80002ba:	42a1      	cmp	r1, r4
 80002bc:	d1f7      	bne.n	80002ae <memcmp+0x42>
 80002be:	2000      	movs	r0, #0
 80002c0:	bc70      	pop	{r4, r5, r6}
 80002c2:	4770      	bx	lr
 80002c4:	1e54      	subs	r4, r2, #1
 80002c6:	e7eb      	b.n	80002a0 <memcmp+0x34>
 80002c8:	1ad0      	subs	r0, r2, r3
 80002ca:	bc70      	pop	{r4, r5, r6}
 80002cc:	4770      	bx	lr
 80002ce:	bf00      	nop

080002d0 <memcpy>:
 80002d0:	4684      	mov	ip, r0
 80002d2:	ea41 0300 	orr.w	r3, r1, r0
 80002d6:	f013 0303 	ands.w	r3, r3, #3
 80002da:	d149      	bne.n	8000370 <memcpy+0xa0>
 80002dc:	3a40      	subs	r2, #64	; 0x40
 80002de:	d323      	bcc.n	8000328 <memcpy+0x58>
 80002e0:	680b      	ldr	r3, [r1, #0]
 80002e2:	6003      	str	r3, [r0, #0]
 80002e4:	684b      	ldr	r3, [r1, #4]
 80002e6:	6043      	str	r3, [r0, #4]
 80002e8:	688b      	ldr	r3, [r1, #8]
 80002ea:	6083      	str	r3, [r0, #8]
 80002ec:	68cb      	ldr	r3, [r1, #12]
 80002ee:	60c3      	str	r3, [r0, #12]
 80002f0:	690b      	ldr	r3, [r1, #16]
 80002f2:	6103      	str	r3, [r0, #16]
 80002f4:	694b      	ldr	r3, [r1, #20]
 80002f6:	6143      	str	r3, [r0, #20]
 80002f8:	698b      	ldr	r3, [r1, #24]
 80002fa:	6183      	str	r3, [r0, #24]
 80002fc:	69cb      	ldr	r3, [r1, #28]
 80002fe:	61c3      	str	r3, [r0, #28]
 8000300:	6a0b      	ldr	r3, [r1, #32]
 8000302:	6203      	str	r3, [r0, #32]
 8000304:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8000306:	6243      	str	r3, [r0, #36]	; 0x24
 8000308:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 800030a:	6283      	str	r3, [r0, #40]	; 0x28
 800030c:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 800030e:	62c3      	str	r3, [r0, #44]	; 0x2c
 8000310:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8000312:	6303      	str	r3, [r0, #48]	; 0x30
 8000314:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8000316:	6343      	str	r3, [r0, #52]	; 0x34
 8000318:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 800031a:	6383      	str	r3, [r0, #56]	; 0x38
 800031c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 800031e:	63c3      	str	r3, [r0, #60]	; 0x3c
 8000320:	3040      	adds	r0, #64	; 0x40
 8000322:	3140      	adds	r1, #64	; 0x40
 8000324:	3a40      	subs	r2, #64	; 0x40
 8000326:	d2db      	bcs.n	80002e0 <memcpy+0x10>
 8000328:	3230      	adds	r2, #48	; 0x30
 800032a:	d30b      	bcc.n	8000344 <memcpy+0x74>
 800032c:	680b      	ldr	r3, [r1, #0]
 800032e:	6003      	str	r3, [r0, #0]
 8000330:	684b      	ldr	r3, [r1, #4]
 8000332:	6043      	str	r3, [r0, #4]
 8000334:	688b      	ldr	r3, [r1, #8]
 8000336:	6083      	str	r3, [r0, #8]
 8000338:	68cb      	ldr	r3, [r1, #12]
 800033a:	60c3      	str	r3, [r0, #12]
 800033c:	3010      	adds	r0, #16
 800033e:	3110      	adds	r1, #16
 8000340:	3a10      	subs	r2, #16
 8000342:	d2f3      	bcs.n	800032c <memcpy+0x5c>
 8000344:	320c      	adds	r2, #12
 8000346:	d305      	bcc.n	8000354 <memcpy+0x84>
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	3a04      	subs	r2, #4
 8000352:	d2f9      	bcs.n	8000348 <memcpy+0x78>
 8000354:	3204      	adds	r2, #4
 8000356:	d008      	beq.n	800036a <memcpy+0x9a>
 8000358:	07d2      	lsls	r2, r2, #31
 800035a:	bf1c      	itt	ne
 800035c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000360:	f800 3b01 	strbne.w	r3, [r0], #1
 8000364:	d301      	bcc.n	800036a <memcpy+0x9a>
 8000366:	880b      	ldrh	r3, [r1, #0]
 8000368:	8003      	strh	r3, [r0, #0]
 800036a:	4660      	mov	r0, ip
 800036c:	4770      	bx	lr
 800036e:	bf00      	nop
 8000370:	2a08      	cmp	r2, #8
 8000372:	d313      	bcc.n	800039c <memcpy+0xcc>
 8000374:	078b      	lsls	r3, r1, #30
 8000376:	d0b1      	beq.n	80002dc <memcpy+0xc>
 8000378:	f010 0303 	ands.w	r3, r0, #3
 800037c:	d0ae      	beq.n	80002dc <memcpy+0xc>
 800037e:	f1c3 0304 	rsb	r3, r3, #4
 8000382:	1ad2      	subs	r2, r2, r3
 8000384:	07db      	lsls	r3, r3, #31
 8000386:	bf1c      	itt	ne
 8000388:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800038c:	f800 3b01 	strbne.w	r3, [r0], #1
 8000390:	d3a4      	bcc.n	80002dc <memcpy+0xc>
 8000392:	f831 3b02 	ldrh.w	r3, [r1], #2
 8000396:	f820 3b02 	strh.w	r3, [r0], #2
 800039a:	e79f      	b.n	80002dc <memcpy+0xc>
 800039c:	3a04      	subs	r2, #4
 800039e:	d3d9      	bcc.n	8000354 <memcpy+0x84>
 80003a0:	3a01      	subs	r2, #1
 80003a2:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003a6:	f800 3b01 	strb.w	r3, [r0], #1
 80003aa:	d2f9      	bcs.n	80003a0 <memcpy+0xd0>
 80003ac:	780b      	ldrb	r3, [r1, #0]
 80003ae:	7003      	strb	r3, [r0, #0]
 80003b0:	784b      	ldrb	r3, [r1, #1]
 80003b2:	7043      	strb	r3, [r0, #1]
 80003b4:	788b      	ldrb	r3, [r1, #2]
 80003b6:	7083      	strb	r3, [r0, #2]
 80003b8:	4660      	mov	r0, ip
 80003ba:	4770      	bx	lr

080003bc <memset>:
 80003bc:	b4f0      	push	{r4, r5, r6, r7}
 80003be:	0786      	lsls	r6, r0, #30
 80003c0:	d043      	beq.n	800044a <memset+0x8e>
 80003c2:	1e54      	subs	r4, r2, #1
 80003c4:	2a00      	cmp	r2, #0
 80003c6:	d03e      	beq.n	8000446 <memset+0x8a>
 80003c8:	b2ca      	uxtb	r2, r1
 80003ca:	4603      	mov	r3, r0
 80003cc:	e002      	b.n	80003d4 <memset+0x18>
 80003ce:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
 80003d2:	d338      	bcc.n	8000446 <memset+0x8a>
 80003d4:	f803 2b01 	strb.w	r2, [r3], #1
 80003d8:	079d      	lsls	r5, r3, #30
 80003da:	d1f8      	bne.n	80003ce <memset+0x12>
 80003dc:	2c03      	cmp	r4, #3
 80003de:	d92b      	bls.n	8000438 <memset+0x7c>
 80003e0:	b2cd      	uxtb	r5, r1
 80003e2:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80003e6:	2c0f      	cmp	r4, #15
 80003e8:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80003ec:	d916      	bls.n	800041c <memset+0x60>
 80003ee:	f1a4 0710 	sub.w	r7, r4, #16
 80003f2:	093f      	lsrs	r7, r7, #4
 80003f4:	f103 0620 	add.w	r6, r3, #32
 80003f8:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 80003fc:	f103 0210 	add.w	r2, r3, #16
 8000400:	e942 5504 	strd	r5, r5, [r2, #-16]
 8000404:	e942 5502 	strd	r5, r5, [r2, #-8]
 8000408:	3210      	adds	r2, #16
 800040a:	42b2      	cmp	r2, r6
 800040c:	d1f8      	bne.n	8000400 <memset+0x44>
 800040e:	f004 040f 	and.w	r4, r4, #15
 8000412:	3701      	adds	r7, #1
 8000414:	2c03      	cmp	r4, #3
 8000416:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 800041a:	d90d      	bls.n	8000438 <memset+0x7c>
 800041c:	461e      	mov	r6, r3
 800041e:	4622      	mov	r2, r4
 8000420:	3a04      	subs	r2, #4
 8000422:	2a03      	cmp	r2, #3
 8000424:	f846 5b04 	str.w	r5, [r6], #4
 8000428:	d8fa      	bhi.n	8000420 <memset+0x64>
 800042a:	1f22      	subs	r2, r4, #4
 800042c:	f022 0203 	bic.w	r2, r2, #3
 8000430:	3204      	adds	r2, #4
 8000432:	4413      	add	r3, r2
 8000434:	f004 0403 	and.w	r4, r4, #3
 8000438:	b12c      	cbz	r4, 8000446 <memset+0x8a>
 800043a:	b2c9      	uxtb	r1, r1
 800043c:	441c      	add	r4, r3
 800043e:	f803 1b01 	strb.w	r1, [r3], #1
 8000442:	429c      	cmp	r4, r3
 8000444:	d1fb      	bne.n	800043e <memset+0x82>
 8000446:	bcf0      	pop	{r4, r5, r6, r7}
 8000448:	4770      	bx	lr
 800044a:	4614      	mov	r4, r2
 800044c:	4603      	mov	r3, r0
 800044e:	e7c5      	b.n	80003dc <memset+0x20>

08000450 <strchr>:
 8000450:	b2c9      	uxtb	r1, r1
 8000452:	f000 0303 	and.w	r3, r0, #3
 8000456:	2900      	cmp	r1, #0
 8000458:	d043      	beq.n	80004e2 <strchr+0x92>
 800045a:	b17b      	cbz	r3, 800047c <strchr+0x2c>
 800045c:	7803      	ldrb	r3, [r0, #0]
 800045e:	2b00      	cmp	r3, #0
 8000460:	d067      	beq.n	8000532 <strchr+0xe2>
 8000462:	4299      	cmp	r1, r3
 8000464:	d03c      	beq.n	80004e0 <strchr+0x90>
 8000466:	1c43      	adds	r3, r0, #1
 8000468:	e005      	b.n	8000476 <strchr+0x26>
 800046a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800046e:	2a00      	cmp	r2, #0
 8000470:	d05d      	beq.n	800052e <strchr+0xde>
 8000472:	428a      	cmp	r2, r1
 8000474:	d034      	beq.n	80004e0 <strchr+0x90>
 8000476:	079a      	lsls	r2, r3, #30
 8000478:	4618      	mov	r0, r3
 800047a:	d1f6      	bne.n	800046a <strchr+0x1a>
 800047c:	b470      	push	{r4, r5, r6}
 800047e:	6804      	ldr	r4, [r0, #0]
 8000480:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8000484:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8000488:	ea86 0504 	eor.w	r5, r6, r4
 800048c:	f1a5 3301 	sub.w	r3, r5, #16843009	; 0x1010101
 8000490:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 8000494:	ea23 0305 	bic.w	r3, r3, r5
 8000498:	ea22 0204 	bic.w	r2, r2, r4
 800049c:	4313      	orrs	r3, r2
 800049e:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80004a2:	d10f      	bne.n	80004c4 <strchr+0x74>
 80004a4:	f850 4f04 	ldr.w	r4, [r0, #4]!
 80004a8:	ea84 0506 	eor.w	r5, r4, r6
 80004ac:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
 80004b0:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
 80004b4:	ea22 0205 	bic.w	r2, r2, r5
 80004b8:	ea23 0304 	bic.w	r3, r3, r4
 80004bc:	4313      	orrs	r3, r2
 80004be:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80004c2:	d0ef      	beq.n	80004a4 <strchr+0x54>
 80004c4:	7803      	ldrb	r3, [r0, #0]
 80004c6:	b143      	cbz	r3, 80004da <strchr+0x8a>
 80004c8:	4299      	cmp	r1, r3
 80004ca:	d102      	bne.n	80004d2 <strchr+0x82>
 80004cc:	e006      	b.n	80004dc <strchr+0x8c>
 80004ce:	428b      	cmp	r3, r1
 80004d0:	d004      	beq.n	80004dc <strchr+0x8c>
 80004d2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80004d6:	2b00      	cmp	r3, #0
 80004d8:	d1f9      	bne.n	80004ce <strchr+0x7e>
 80004da:	4618      	mov	r0, r3
 80004dc:	bc70      	pop	{r4, r5, r6}
 80004de:	4770      	bx	lr
 80004e0:	4770      	bx	lr
 80004e2:	b15b      	cbz	r3, 80004fc <strchr+0xac>
 80004e4:	7803      	ldrb	r3, [r0, #0]
 80004e6:	2b00      	cmp	r3, #0
 80004e8:	d0fa      	beq.n	80004e0 <strchr+0x90>
 80004ea:	1c43      	adds	r3, r0, #1
 80004ec:	e003      	b.n	80004f6 <strchr+0xa6>
 80004ee:	7802      	ldrb	r2, [r0, #0]
 80004f0:	3301      	adds	r3, #1
 80004f2:	2a00      	cmp	r2, #0
 80004f4:	d0f4      	beq.n	80004e0 <strchr+0x90>
 80004f6:	0799      	lsls	r1, r3, #30
 80004f8:	4618      	mov	r0, r3
 80004fa:	d1f8      	bne.n	80004ee <strchr+0x9e>
 80004fc:	6802      	ldr	r2, [r0, #0]
 80004fe:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8000502:	ea23 0302 	bic.w	r3, r3, r2
 8000506:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800050a:	d108      	bne.n	800051e <strchr+0xce>
 800050c:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8000510:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8000514:	ea23 0302 	bic.w	r3, r3, r2
 8000518:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800051c:	d0f6      	beq.n	800050c <strchr+0xbc>
 800051e:	7803      	ldrb	r3, [r0, #0]
 8000520:	2b00      	cmp	r3, #0
 8000522:	d0dd      	beq.n	80004e0 <strchr+0x90>
 8000524:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8000528:	2b00      	cmp	r3, #0
 800052a:	d1fb      	bne.n	8000524 <strchr+0xd4>
 800052c:	4770      	bx	lr
 800052e:	4610      	mov	r0, r2
 8000530:	4770      	bx	lr
 8000532:	4618      	mov	r0, r3
 8000534:	4770      	bx	lr
 8000536:	bf00      	nop

08000538 <strcmp>:
 8000538:	ea80 0c01 	eor.w	ip, r0, r1
 800053c:	f01c 0f03 	tst.w	ip, #3
 8000540:	d137      	bne.n	80005b2 <strcmp+0x7a>
 8000542:	f010 0c03 	ands.w	ip, r0, #3
 8000546:	f020 0003 	bic.w	r0, r0, #3
 800054a:	f021 0103 	bic.w	r1, r1, #3
 800054e:	f850 2b04 	ldr.w	r2, [r0], #4
 8000552:	bf08      	it	eq
 8000554:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000558:	d00e      	beq.n	8000578 <strcmp+0x40>
 800055a:	f08c 0c03 	eor.w	ip, ip, #3
 800055e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8000562:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8000566:	fa23 fc0c 	lsr.w	ip, r3, ip
 800056a:	f851 3b04 	ldr.w	r3, [r1], #4
 800056e:	ea42 020c 	orr.w	r2, r2, ip
 8000572:	ea43 030c 	orr.w	r3, r3, ip
 8000576:	bf00      	nop
 8000578:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 800057c:	429a      	cmp	r2, r3
 800057e:	bf01      	itttt	eq
 8000580:	ea2c 0c02 	biceq.w	ip, ip, r2
 8000584:	f01c 3f80 	tsteq.w	ip, #2155905152	; 0x80808080
 8000588:	f850 2b04 	ldreq.w	r2, [r0], #4
 800058c:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000590:	d0f2      	beq.n	8000578 <strcmp+0x40>
 8000592:	ea4f 6002 	mov.w	r0, r2, lsl #24
 8000596:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800059a:	2801      	cmp	r0, #1
 800059c:	bf28      	it	cs
 800059e:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 80005a2:	bf08      	it	eq
 80005a4:	0a1b      	lsreq	r3, r3, #8
 80005a6:	d0f4      	beq.n	8000592 <strcmp+0x5a>
 80005a8:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80005ac:	0e00      	lsrs	r0, r0, #24
 80005ae:	1ac0      	subs	r0, r0, r3
 80005b0:	4770      	bx	lr
 80005b2:	f010 0f03 	tst.w	r0, #3
 80005b6:	d00a      	beq.n	80005ce <strcmp+0x96>
 80005b8:	f810 2b01 	ldrb.w	r2, [r0], #1
 80005bc:	f811 3b01 	ldrb.w	r3, [r1], #1
 80005c0:	2a01      	cmp	r2, #1
 80005c2:	bf28      	it	cs
 80005c4:	429a      	cmpcs	r2, r3
 80005c6:	d0f4      	beq.n	80005b2 <strcmp+0x7a>
 80005c8:	eba2 0003 	sub.w	r0, r2, r3
 80005cc:	4770      	bx	lr
 80005ce:	f84d 5d04 	str.w	r5, [sp, #-4]!
 80005d2:	f850 2b04 	ldr.w	r2, [r0], #4
 80005d6:	f001 0503 	and.w	r5, r1, #3
 80005da:	f021 0103 	bic.w	r1, r1, #3
 80005de:	f851 3b04 	ldr.w	r3, [r1], #4
 80005e2:	2d02      	cmp	r5, #2
 80005e4:	d026      	beq.n	8000634 <strcmp+0xfc>
 80005e6:	d84d      	bhi.n	8000684 <strcmp+0x14c>
 80005e8:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
 80005ec:	ebb5 2f13 	cmp.w	r5, r3, lsr #8
 80005f0:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 80005f4:	ea2c 0c02 	bic.w	ip, ip, r2
 80005f8:	d10d      	bne.n	8000616 <strcmp+0xde>
 80005fa:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 80005fe:	bf08      	it	eq
 8000600:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000604:	d10a      	bne.n	800061c <strcmp+0xe4>
 8000606:	ea85 0502 	eor.w	r5, r5, r2
 800060a:	ebb5 6f03 	cmp.w	r5, r3, lsl #24
 800060e:	d10c      	bne.n	800062a <strcmp+0xf2>
 8000610:	f850 2b04 	ldr.w	r2, [r0], #4
 8000614:	e7e8      	b.n	80005e8 <strcmp+0xb0>
 8000616:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800061a:	e05b      	b.n	80006d4 <strcmp+0x19c>
 800061c:	f03c 4c7f 	bics.w	ip, ip, #4278190080	; 0xff000000
 8000620:	d154      	bne.n	80006cc <strcmp+0x194>
 8000622:	780b      	ldrb	r3, [r1, #0]
 8000624:	ea4f 6512 	mov.w	r5, r2, lsr #24
 8000628:	e054      	b.n	80006d4 <strcmp+0x19c>
 800062a:	ea4f 6512 	mov.w	r5, r2, lsr #24
 800062e:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000632:	e04f      	b.n	80006d4 <strcmp+0x19c>
 8000634:	ea4f 4502 	mov.w	r5, r2, lsl #16
 8000638:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 800063c:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8000640:	ea2c 0c02 	bic.w	ip, ip, r2
 8000644:	ebb5 4f13 	cmp.w	r5, r3, lsr #16
 8000648:	d118      	bne.n	800067c <strcmp+0x144>
 800064a:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 800064e:	bf08      	it	eq
 8000650:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000654:	d107      	bne.n	8000666 <strcmp+0x12e>
 8000656:	ea85 0502 	eor.w	r5, r5, r2
 800065a:	ebb5 4f03 	cmp.w	r5, r3, lsl #16
 800065e:	d109      	bne.n	8000674 <strcmp+0x13c>
 8000660:	f850 2b04 	ldr.w	r2, [r0], #4
 8000664:	e7e6      	b.n	8000634 <strcmp+0xfc>
 8000666:	ea5f 4c0c 	movs.w	ip, ip, lsl #16
 800066a:	d12f      	bne.n	80006cc <strcmp+0x194>
 800066c:	880b      	ldrh	r3, [r1, #0]
 800066e:	ea4f 4512 	mov.w	r5, r2, lsr #16
 8000672:	e02f      	b.n	80006d4 <strcmp+0x19c>
 8000674:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8000678:	ea4f 4512 	mov.w	r5, r2, lsr #16
 800067c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8000680:	e028      	b.n	80006d4 <strcmp+0x19c>
 8000682:	bf00      	nop
 8000684:	f002 05ff 	and.w	r5, r2, #255	; 0xff
 8000688:	ebb5 6f13 	cmp.w	r5, r3, lsr #24
 800068c:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8000690:	ea2c 0c02 	bic.w	ip, ip, r2
 8000694:	d10d      	bne.n	80006b2 <strcmp+0x17a>
 8000696:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 800069a:	bf08      	it	eq
 800069c:	f851 3b04 	ldreq.w	r3, [r1], #4
 80006a0:	d10a      	bne.n	80006b8 <strcmp+0x180>
 80006a2:	ea85 0502 	eor.w	r5, r5, r2
 80006a6:	ebb5 2f03 	cmp.w	r5, r3, lsl #8
 80006aa:	d10a      	bne.n	80006c2 <strcmp+0x18a>
 80006ac:	f850 2b04 	ldr.w	r2, [r0], #4
 80006b0:	e7e8      	b.n	8000684 <strcmp+0x14c>
 80006b2:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80006b6:	e00d      	b.n	80006d4 <strcmp+0x19c>
 80006b8:	f012 0fff 	tst.w	r2, #255	; 0xff
 80006bc:	d006      	beq.n	80006cc <strcmp+0x194>
 80006be:	f851 3b04 	ldr.w	r3, [r1], #4
 80006c2:	ea4f 2512 	mov.w	r5, r2, lsr #8
 80006c6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80006ca:	e003      	b.n	80006d4 <strcmp+0x19c>
 80006cc:	f04f 0000 	mov.w	r0, #0
 80006d0:	bc20      	pop	{r5}
 80006d2:	4770      	bx	lr
 80006d4:	f005 02ff 	and.w	r2, r5, #255	; 0xff
 80006d8:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80006dc:	2801      	cmp	r0, #1
 80006de:	bf28      	it	cs
 80006e0:	4290      	cmpcs	r0, r2
 80006e2:	bf04      	itt	eq
 80006e4:	0a2d      	lsreq	r5, r5, #8
 80006e6:	0a1b      	lsreq	r3, r3, #8
 80006e8:	d0f4      	beq.n	80006d4 <strcmp+0x19c>
 80006ea:	eba2 0000 	sub.w	r0, r2, r0
 80006ee:	bc20      	pop	{r5}
 80006f0:	4770      	bx	lr
 80006f2:	bf00      	nop

080006f4 <strncmp>:
 80006f4:	2a00      	cmp	r2, #0
 80006f6:	d03f      	beq.n	8000778 <strncmp+0x84>
 80006f8:	ea40 0301 	orr.w	r3, r0, r1
 80006fc:	f013 0303 	ands.w	r3, r3, #3
 8000700:	b4f0      	push	{r4, r5, r6, r7}
 8000702:	d125      	bne.n	8000750 <strncmp+0x5c>
 8000704:	2a03      	cmp	r2, #3
 8000706:	d923      	bls.n	8000750 <strncmp+0x5c>
 8000708:	6804      	ldr	r4, [r0, #0]
 800070a:	680d      	ldr	r5, [r1, #0]
 800070c:	42ac      	cmp	r4, r5
 800070e:	d11f      	bne.n	8000750 <strncmp+0x5c>
 8000710:	3a04      	subs	r2, #4
 8000712:	d033      	beq.n	800077c <strncmp+0x88>
 8000714:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8000718:	ea25 0404 	bic.w	r4, r5, r4
 800071c:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8000720:	d12f      	bne.n	8000782 <strncmp+0x8e>
 8000722:	1d07      	adds	r7, r0, #4
 8000724:	1d0d      	adds	r5, r1, #4
 8000726:	e00d      	b.n	8000744 <strncmp+0x50>
 8000728:	f857 3b04 	ldr.w	r3, [r7], #4
 800072c:	680e      	ldr	r6, [r1, #0]
 800072e:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 8000732:	42b3      	cmp	r3, r6
 8000734:	ea24 0403 	bic.w	r4, r4, r3
 8000738:	d10a      	bne.n	8000750 <strncmp+0x5c>
 800073a:	3a04      	subs	r2, #4
 800073c:	d01e      	beq.n	800077c <strncmp+0x88>
 800073e:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8000742:	d11b      	bne.n	800077c <strncmp+0x88>
 8000744:	2a03      	cmp	r2, #3
 8000746:	4629      	mov	r1, r5
 8000748:	4638      	mov	r0, r7
 800074a:	f105 0504 	add.w	r5, r5, #4
 800074e:	d8eb      	bhi.n	8000728 <strncmp+0x34>
 8000750:	7803      	ldrb	r3, [r0, #0]
 8000752:	780c      	ldrb	r4, [r1, #0]
 8000754:	3a01      	subs	r2, #1
 8000756:	429c      	cmp	r4, r3
 8000758:	d10b      	bne.n	8000772 <strncmp+0x7e>
 800075a:	b17a      	cbz	r2, 800077c <strncmp+0x88>
 800075c:	b914      	cbnz	r4, 8000764 <strncmp+0x70>
 800075e:	e00d      	b.n	800077c <strncmp+0x88>
 8000760:	b162      	cbz	r2, 800077c <strncmp+0x88>
 8000762:	b173      	cbz	r3, 8000782 <strncmp+0x8e>
 8000764:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8000768:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800076c:	3a01      	subs	r2, #1
 800076e:	42a3      	cmp	r3, r4
 8000770:	d0f6      	beq.n	8000760 <strncmp+0x6c>
 8000772:	1b18      	subs	r0, r3, r4
 8000774:	bcf0      	pop	{r4, r5, r6, r7}
 8000776:	4770      	bx	lr
 8000778:	4610      	mov	r0, r2
 800077a:	4770      	bx	lr
 800077c:	2000      	movs	r0, #0
 800077e:	bcf0      	pop	{r4, r5, r6, r7}
 8000780:	4770      	bx	lr
 8000782:	4618      	mov	r0, r3
 8000784:	e7f6      	b.n	8000774 <strncmp+0x80>
 8000786:	bf00      	nop

08000788 <strncpy>:
 8000788:	ea40 0301 	orr.w	r3, r0, r1
 800078c:	079b      	lsls	r3, r3, #30
 800078e:	b470      	push	{r4, r5, r6}
 8000790:	d12a      	bne.n	80007e8 <strncpy+0x60>
 8000792:	2a03      	cmp	r2, #3
 8000794:	d928      	bls.n	80007e8 <strncpy+0x60>
 8000796:	460c      	mov	r4, r1
 8000798:	4603      	mov	r3, r0
 800079a:	4621      	mov	r1, r4
 800079c:	f854 6b04 	ldr.w	r6, [r4], #4
 80007a0:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
 80007a4:	ea25 0506 	bic.w	r5, r5, r6
 80007a8:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 80007ac:	d106      	bne.n	80007bc <strncpy+0x34>
 80007ae:	3a04      	subs	r2, #4
 80007b0:	2a03      	cmp	r2, #3
 80007b2:	f843 6b04 	str.w	r6, [r3], #4
 80007b6:	4621      	mov	r1, r4
 80007b8:	d8ef      	bhi.n	800079a <strncpy+0x12>
 80007ba:	b19a      	cbz	r2, 80007e4 <strncpy+0x5c>
 80007bc:	780c      	ldrb	r4, [r1, #0]
 80007be:	3a01      	subs	r2, #1
 80007c0:	701c      	strb	r4, [r3, #0]
 80007c2:	3301      	adds	r3, #1
 80007c4:	b13c      	cbz	r4, 80007d6 <strncpy+0x4e>
 80007c6:	b16a      	cbz	r2, 80007e4 <strncpy+0x5c>
 80007c8:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80007cc:	3a01      	subs	r2, #1
 80007ce:	f803 4b01 	strb.w	r4, [r3], #1
 80007d2:	2c00      	cmp	r4, #0
 80007d4:	d1f7      	bne.n	80007c6 <strncpy+0x3e>
 80007d6:	b12a      	cbz	r2, 80007e4 <strncpy+0x5c>
 80007d8:	2100      	movs	r1, #0
 80007da:	441a      	add	r2, r3
 80007dc:	f803 1b01 	strb.w	r1, [r3], #1
 80007e0:	4293      	cmp	r3, r2
 80007e2:	d1fb      	bne.n	80007dc <strncpy+0x54>
 80007e4:	bc70      	pop	{r4, r5, r6}
 80007e6:	4770      	bx	lr
 80007e8:	4603      	mov	r3, r0
 80007ea:	e7e6      	b.n	80007ba <strncpy+0x32>

080007ec <strpbrk>:
 80007ec:	b430      	push	{r4, r5}
 80007ee:	7804      	ldrb	r4, [r0, #0]
 80007f0:	b1dc      	cbz	r4, 800082a <strpbrk+0x3e>
 80007f2:	780d      	ldrb	r5, [r1, #0]
 80007f4:	b19d      	cbz	r5, 800081e <strpbrk+0x32>
 80007f6:	42ac      	cmp	r4, r5
 80007f8:	d00f      	beq.n	800081a <strpbrk+0x2e>
 80007fa:	460a      	mov	r2, r1
 80007fc:	e001      	b.n	8000802 <strpbrk+0x16>
 80007fe:	429c      	cmp	r4, r3
 8000800:	d00b      	beq.n	800081a <strpbrk+0x2e>
 8000802:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8000806:	2b00      	cmp	r3, #0
 8000808:	d1f9      	bne.n	80007fe <strpbrk+0x12>
 800080a:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800080e:	2c00      	cmp	r4, #0
 8000810:	d1f0      	bne.n	80007f4 <strpbrk+0x8>
 8000812:	7813      	ldrb	r3, [r2, #0]
 8000814:	2b00      	cmp	r3, #0
 8000816:	bf08      	it	eq
 8000818:	2000      	moveq	r0, #0
 800081a:	bc30      	pop	{r4, r5}
 800081c:	4770      	bx	lr
 800081e:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8000822:	460a      	mov	r2, r1
 8000824:	2c00      	cmp	r4, #0
 8000826:	d1e5      	bne.n	80007f4 <strpbrk+0x8>
 8000828:	e7f3      	b.n	8000812 <strpbrk+0x26>
 800082a:	4620      	mov	r0, r4
 800082c:	e7f5      	b.n	800081a <strpbrk+0x2e>
 800082e:	bf00      	nop

08000830 <strspn>:
 8000830:	b470      	push	{r4, r5, r6}
 8000832:	7804      	ldrb	r4, [r0, #0]
 8000834:	b1a4      	cbz	r4, 8000860 <strspn+0x30>
 8000836:	4606      	mov	r6, r0
 8000838:	780d      	ldrb	r5, [r1, #0]
 800083a:	b14d      	cbz	r5, 8000850 <strspn+0x20>
 800083c:	42a5      	cmp	r5, r4
 800083e:	d00a      	beq.n	8000856 <strspn+0x26>
 8000840:	460a      	mov	r2, r1
 8000842:	e001      	b.n	8000848 <strspn+0x18>
 8000844:	42a3      	cmp	r3, r4
 8000846:	d006      	beq.n	8000856 <strspn+0x26>
 8000848:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800084c:	2b00      	cmp	r3, #0
 800084e:	d1f9      	bne.n	8000844 <strspn+0x14>
 8000850:	1b80      	subs	r0, r0, r6
 8000852:	bc70      	pop	{r4, r5, r6}
 8000854:	4770      	bx	lr
 8000856:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800085a:	2c00      	cmp	r4, #0
 800085c:	d1ed      	bne.n	800083a <strspn+0xa>
 800085e:	e7f7      	b.n	8000850 <strspn+0x20>
 8000860:	4620      	mov	r0, r4
 8000862:	e7f6      	b.n	8000852 <strspn+0x22>
	...

08000870 <chMtxTryLock.constprop.61>:
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000870:	2320      	movs	r3, #32
 8000872:	f383 8811 	msr	BASEPRI, r3
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 8000876:	4b09      	ldr	r3, [pc, #36]	; (800089c <chMtxTryLock.constprop.61+0x2c>)
 8000878:	689a      	ldr	r2, [r3, #8]
 800087a:	b122      	cbz	r2, 8000886 <chMtxTryLock.constprop.61+0x16>
    if (mp->owner == currp) {
      mp->cnt++;
      return true;
    }
#endif
    return false;
 800087c:	2000      	movs	r0, #0
 800087e:	2300      	movs	r3, #0
 8000880:	f383 8811 	msr	BASEPRI, r3
}
 8000884:	4770      	bx	lr

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8000886:	4a06      	ldr	r2, [pc, #24]	; (80008a0 <chMtxTryLock.constprop.61+0x30>)
  mp->next = currp->mtxlist;
  currp->mtxlist = mp;
 8000888:	2001      	movs	r0, #1
  mp->owner = currp;
 800088a:	6992      	ldr	r2, [r2, #24]
  mp->next = currp->mtxlist;
 800088c:	6b91      	ldr	r1, [r2, #56]	; 0x38
  currp->mtxlist = mp;
 800088e:	6393      	str	r3, [r2, #56]	; 0x38
  mp->next = currp->mtxlist;
 8000890:	e9c3 2102 	strd	r2, r1, [r3, #8]
 8000894:	2300      	movs	r3, #0
 8000896:	f383 8811 	msr	BASEPRI, r3
}
 800089a:	4770      	bx	lr
 800089c:	20000c38 	.word	0x20000c38
 80008a0:	20001254 	.word	0x20001254
	...

080008b0 <chEvtGetAndClearEvents.constprop.51>:
 80008b0:	2320      	movs	r3, #32
 80008b2:	f383 8811 	msr	BASEPRI, r3
 */
eventmask_t chEvtGetAndClearEventsI(eventmask_t events) {
  eventmask_t m;

  m = currp->epending & events;
  currp->epending &= ~events;
 80008b6:	2300      	movs	r3, #0
  m = currp->epending & events;
 80008b8:	4a03      	ldr	r2, [pc, #12]	; (80008c8 <chEvtGetAndClearEvents.constprop.51+0x18>)
 80008ba:	6992      	ldr	r2, [r2, #24]
 80008bc:	6b50      	ldr	r0, [r2, #52]	; 0x34
  currp->epending &= ~events;
 80008be:	6353      	str	r3, [r2, #52]	; 0x34
 80008c0:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  m = chEvtGetAndClearEventsI(events);
  chSysUnlock();

  return m;
}
 80008c4:	4770      	bx	lr
 80008c6:	bf00      	nop
 80008c8:	20001254 	.word	0x20001254
 80008cc:	00000000 	.word	0x00000000

080008d0 <_test_assert_time_window.constprop.3>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80008d0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80008d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
                (systime_t)((systime_t)end - (systime_t)start));
 80008d6:	1a09      	subs	r1, r1, r0
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 80008d8:	1a1b      	subs	r3, r3, r0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 80008da:	b289      	uxth	r1, r1
 80008dc:	b29b      	uxth	r3, r3
 80008de:	428b      	cmp	r3, r1
 80008e0:	d30a      	bcc.n	80008f8 <_test_assert_time_window.constprop.3+0x28>
  test_local_fail      = true;
 80008e2:	2001      	movs	r0, #1
  clear_tokens();

  return false;
}

bool _test_assert_time_window(systime_t start,
 80008e4:	b410      	push	{r4}
  test_global_fail     = true;
 80008e6:	4905      	ldr	r1, [pc, #20]	; (80008fc <_test_assert_time_window.constprop.3+0x2c>)
  test_local_fail      = true;
 80008e8:	4c05      	ldr	r4, [pc, #20]	; (8000900 <_test_assert_time_window.constprop.3+0x30>)
  test_failure_message = msg;
 80008ea:	4b06      	ldr	r3, [pc, #24]	; (8000904 <_test_assert_time_window.constprop.3+0x34>)
 80008ec:	4a06      	ldr	r2, [pc, #24]	; (8000908 <_test_assert_time_window.constprop.3+0x38>)
  test_local_fail      = true;
 80008ee:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 80008f0:	7008      	strb	r0, [r1, #0]
  test_failure_message = msg;
 80008f2:	601a      	str	r2, [r3, #0]
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
 80008f4:	bc10      	pop	{r4}
 80008f6:	4770      	bx	lr
  return false;
 80008f8:	2000      	movs	r0, #0
}
 80008fa:	4770      	bx	lr
 80008fc:	20001cf0 	.word	0x20001cf0
 8000900:	20001d90 	.word	0x20001d90
 8000904:	20001cec 	.word	0x20001cec
 8000908:	0800a9bc 	.word	0x0800a9bc
 800090c:	00000000 	.word	0x00000000

08000910 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8000910:	b430      	push	{r4, r5}
 8000912:	2320      	movs	r3, #32
 8000914:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000918:	4b0b      	ldr	r3, [pc, #44]	; (8000948 <chCoreAllocFromTop+0x38>)
 800091a:	4249      	negs	r1, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 800091c:	e9d3 4500 	ldrd	r4, r5, [r3]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000920:	1a28      	subs	r0, r5, r0
 8000922:	4008      	ands	r0, r1
  prev = p - offset;
 8000924:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000926:	42a2      	cmp	r2, r4
 8000928:	d307      	bcc.n	800093a <chCoreAllocFromTop+0x2a>
 800092a:	4295      	cmp	r5, r2
 800092c:	d305      	bcc.n	800093a <chCoreAllocFromTop+0x2a>
  ch_memcore.topmem = prev;
 800092e:	605a      	str	r2, [r3, #4]
 8000930:	2300      	movs	r3, #0
 8000932:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 8000936:	bc30      	pop	{r4, r5}
 8000938:	4770      	bx	lr
    return NULL;
 800093a:	2000      	movs	r0, #0
 800093c:	2300      	movs	r3, #0
 800093e:	f383 8811 	msr	BASEPRI, r3
}
 8000942:	bc30      	pop	{r4, r5}
 8000944:	4770      	bx	lr
 8000946:	bf00      	nop
 8000948:	200013f0 	.word	0x200013f0
 800094c:	00000000 	.word	0x00000000

08000950 <oslib_test_008_001_setup>:
  /*lint -save -e9033 [10.8] Required cast operations.*/
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
  /*lint restore*/

  /* Initializing the heap header.*/
  heapp->provider = NULL;
 8000950:	2000      	movs	r0, #0
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 8000952:	4b0b      	ldr	r3, [pc, #44]	; (8000980 <oslib_test_008_001_setup+0x30>)
  heapp->provider = NULL;
 8000954:	4a0b      	ldr	r2, [pc, #44]	; (8000984 <oslib_test_008_001_setup+0x34>)
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 8000956:	1dd9      	adds	r1, r3, #7
 8000958:	f021 0107 	bic.w	r1, r1, #7
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
 800095c:	1acb      	subs	r3, r1, r3
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 800095e:	f1c3 0378 	rsb	r3, r3, #120	; 0x78
 * - [8.1.10] Testing final conditions. The heap geometry must be the
 *   same than the one registered at beginning.
 * .
 */

static void oslib_test_008_001_setup(void) {
 8000962:	b410      	push	{r4}
 8000964:	08db      	lsrs	r3, r3, #3
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000966:	f102 040c 	add.w	r4, r2, #12
 800096a:	604b      	str	r3, [r1, #4]
  H_NEXT(&heapp->header) = hp;
 800096c:	6051      	str	r1, [r2, #4]
  H_NEXT(hp) = NULL;
 800096e:	6008      	str	r0, [r1, #0]
  tqp->prev = (thread_t *)tqp;
 8000970:	e9c2 4403 	strd	r4, r4, [r2, #12]
  heapp->provider = NULL;
 8000974:	6010      	str	r0, [r2, #0]
  H_PAGES(&heapp->header) = 0;
 8000976:	6090      	str	r0, [r2, #8]
  mp->owner = NULL;
 8000978:	6150      	str	r0, [r2, #20]
  chHeapObjectInit(&test_heap, test_heap_buffer, sizeof(test_heap_buffer));
}
 800097a:	bc10      	pop	{r4}
 800097c:	4770      	bx	lr
 800097e:	bf00      	nop
 8000980:	20001d10 	.word	0x20001d10
 8000984:	20001cf4 	.word	0x20001cf4
	...

08000990 <oslib_test_007_003_setup>:
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8000990:	2200      	movs	r2, #0
  mp->object_size = size;
 8000992:	2104      	movs	r1, #4
  mp->next = NULL;
 8000994:	4b04      	ldr	r3, [pc, #16]	; (80009a8 <oslib_test_007_003_setup+0x18>)
 8000996:	60da      	str	r2, [r3, #12]
  mp->align = align;
  mp->provider = provider;
 8000998:	619a      	str	r2, [r3, #24]
 800099a:	e9c3 3300 	strd	r3, r3, [r3]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 800099e:	609a      	str	r2, [r3, #8]
  mp->align = align;
 80009a0:	e9c3 1104 	strd	r1, r1, [r3, #16]
 * .
 */

static void oslib_test_007_003_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}
 80009a4:	4770      	bx	lr
 80009a6:	bf00      	nop
 80009a8:	20000c14 	.word	0x20000c14
 80009ac:	00000000 	.word	0x00000000

080009b0 <oslib_test_007_002_setup>:
 80009b0:	f7ff bfee 	b.w	8000990 <oslib_test_007_003_setup>
	...

080009c0 <null_provider>:
}
 80009c0:	2000      	movs	r0, #0
 80009c2:	4770      	bx	lr
	...

080009d0 <oslib_test_007_001_setup>:
  mp->next = NULL;
 80009d0:	2100      	movs	r1, #0
  mp->object_size = size;
 80009d2:	2204      	movs	r2, #4
  mp->next = NULL;
 80009d4:	4b02      	ldr	r3, [pc, #8]	; (80009e0 <oslib_test_007_001_setup+0x10>)
 80009d6:	6019      	str	r1, [r3, #0]
  mp->provider = provider;
 80009d8:	60d9      	str	r1, [r3, #12]
  mp->align = align;
 80009da:	e9c3 2201 	strd	r2, r2, [r3, #4]
}
 80009de:	4770      	bx	lr
 80009e0:	20000c80 	.word	0x20000c80
	...

080009f0 <__ch_delegate_fn0>:
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn0(va_list *argsp) {
  delegate_fn0_t fn0 = (delegate_fn0_t)va_arg(*argsp, delegate_fn0_t);
 80009f0:	6803      	ldr	r3, [r0, #0]
 80009f2:	1d1a      	adds	r2, r3, #4
 80009f4:	6002      	str	r2, [r0, #0]
  return fn0();
 80009f6:	681b      	ldr	r3, [r3, #0]
 80009f8:	4718      	bx	r3
 80009fa:	bf00      	nop
 80009fc:	0000      	movs	r0, r0
	...

08000a00 <__ch_delegate_fn1>:
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn1(va_list *argsp) {
  delegate_fn1_t fn1 = (delegate_fn1_t)va_arg(*argsp, delegate_fn1_t);
 8000a00:	6801      	ldr	r1, [r0, #0]
msg_t __ch_delegate_fn1(va_list *argsp) {
 8000a02:	4603      	mov	r3, r0
  delegate_fn1_t fn1 = (delegate_fn1_t)va_arg(*argsp, delegate_fn1_t);
 8000a04:	460a      	mov	r2, r1
 8000a06:	1d08      	adds	r0, r1, #4
msg_t __ch_delegate_fn1(va_list *argsp) {
 8000a08:	b410      	push	{r4}
  delegate_fn1_t fn1 = (delegate_fn1_t)va_arg(*argsp, delegate_fn1_t);
 8000a0a:	6018      	str	r0, [r3, #0]
 8000a0c:	f852 4b08 	ldr.w	r4, [r2], #8
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
  return fn1(p1);
 8000a10:	6848      	ldr	r0, [r1, #4]
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
 8000a12:	601a      	str	r2, [r3, #0]
  return fn1(p1);
 8000a14:	4623      	mov	r3, r4
}
 8000a16:	bc10      	pop	{r4}
  return fn1(p1);
 8000a18:	4718      	bx	r3
 8000a1a:	bf00      	nop
 8000a1c:	0000      	movs	r0, r0
	...

08000a20 <__ch_delegate_fn2>:
 * @brief   Veneer for functions with two parameters.
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn2(va_list *argsp) {
 8000a20:	4602      	mov	r2, r0
  delegate_fn2_t fn2 = (delegate_fn2_t)va_arg(*argsp, delegate_fn2_t);
 8000a22:	6803      	ldr	r3, [r0, #0]
msg_t __ch_delegate_fn2(va_list *argsp) {
 8000a24:	b410      	push	{r4}
  delegate_fn2_t fn2 = (delegate_fn2_t)va_arg(*argsp, delegate_fn2_t);
 8000a26:	1d19      	adds	r1, r3, #4
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
 8000a28:	6858      	ldr	r0, [r3, #4]
  delegate_fn2_t fn2 = (delegate_fn2_t)va_arg(*argsp, delegate_fn2_t);
 8000a2a:	6011      	str	r1, [r2, #0]
 8000a2c:	681c      	ldr	r4, [r3, #0]
  msg_t p2 = (msg_t)va_arg(*argsp, msg_t);
 8000a2e:	f103 010c 	add.w	r1, r3, #12
 8000a32:	6011      	str	r1, [r2, #0]
  return fn2(p1, p2);
 8000a34:	6899      	ldr	r1, [r3, #8]
 8000a36:	4623      	mov	r3, r4
}
 8000a38:	bc10      	pop	{r4}
  return fn2(p1, p2);
 8000a3a:	4718      	bx	r3
 8000a3c:	0000      	movs	r0, r0
	...

08000a40 <__ch_delegate_fn3>:
 * @brief   Veneer for functions with three parameters.
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn3(va_list *argsp) {
 8000a40:	4602      	mov	r2, r0
  delegate_fn3_t fn3 = (delegate_fn3_t)va_arg(*argsp, delegate_fn3_t);
 8000a42:	6803      	ldr	r3, [r0, #0]
msg_t __ch_delegate_fn3(va_list *argsp) {
 8000a44:	b430      	push	{r4, r5}
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
  msg_t p2 = (msg_t)va_arg(*argsp, msg_t);
 8000a46:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
  delegate_fn3_t fn3 = (delegate_fn3_t)va_arg(*argsp, delegate_fn3_t);
 8000a4a:	1d1c      	adds	r4, r3, #4
 8000a4c:	6014      	str	r4, [r2, #0]
 8000a4e:	681c      	ldr	r4, [r3, #0]
  msg_t p3 = (msg_t)va_arg(*argsp, msg_t);
 8000a50:	f103 0510 	add.w	r5, r3, #16
 8000a54:	6015      	str	r5, [r2, #0]
  return fn3(p1, p2, p3);
 8000a56:	68da      	ldr	r2, [r3, #12]
 8000a58:	4623      	mov	r3, r4
}
 8000a5a:	bc30      	pop	{r4, r5}
  return fn3(p1, p2, p3);
 8000a5c:	4718      	bx	r3
 8000a5e:	bf00      	nop

08000a60 <__ch_delegate_fn4>:
 * @brief   Veneer for functions with four parameters.
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn4(va_list *argsp) {
 8000a60:	b470      	push	{r4, r5, r6}
 8000a62:	4604      	mov	r4, r0
  delegate_fn4_t fn4 = (delegate_fn4_t)va_arg(*argsp, delegate_fn4_t);
 8000a64:	6803      	ldr	r3, [r0, #0]
 8000a66:	1d1d      	adds	r5, r3, #4
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
  msg_t p2 = (msg_t)va_arg(*argsp, msg_t);
 8000a68:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
  msg_t p3 = (msg_t)va_arg(*argsp, msg_t);
 8000a6c:	68da      	ldr	r2, [r3, #12]
  delegate_fn4_t fn4 = (delegate_fn4_t)va_arg(*argsp, delegate_fn4_t);
 8000a6e:	6025      	str	r5, [r4, #0]
 8000a70:	681d      	ldr	r5, [r3, #0]
  msg_t p4 = (msg_t)va_arg(*argsp, msg_t);
 8000a72:	f103 0614 	add.w	r6, r3, #20
 8000a76:	6026      	str	r6, [r4, #0]
  return fn4(p1, p2, p3, p4);
 8000a78:	46ac      	mov	ip, r5
}
 8000a7a:	bc70      	pop	{r4, r5, r6}
  return fn4(p1, p2, p3, p4);
 8000a7c:	691b      	ldr	r3, [r3, #16]
 8000a7e:	4760      	bx	ip

08000a80 <oslib_test_003_002_setup>:

  pp->buffer = buf;
  pp->rdptr  = buf;
  pp->wrptr  = buf;
  pp->top    = &buf[n];
  pp->cnt    = (size_t)0;
 8000a80:	2200      	movs	r2, #0
 * - [3.2.1] Reading while pipe is empty.
 * - [3.2.2] Writing a string larger than pipe buffer.
 * .
 */

static void oslib_test_003_002_setup(void) {
 8000a82:	b430      	push	{r4, r5}
  pp->buffer = buf;
 8000a84:	4b0e      	ldr	r3, [pc, #56]	; (8000ac0 <oslib_test_003_002_setup+0x40>)
 8000a86:	490f      	ldr	r1, [pc, #60]	; (8000ac4 <oslib_test_003_002_setup+0x44>)
  tqp->next = (thread_t *)tqp;
 8000a88:	f103 0420 	add.w	r4, r3, #32
  pp->top    = &buf[n];
 8000a8c:	f101 0508 	add.w	r5, r1, #8
 8000a90:	f103 0030 	add.w	r0, r3, #48	; 0x30
  pp->buffer = buf;
 8000a94:	6019      	str	r1, [r3, #0]
  pp->wrptr  = buf;
 8000a96:	e9c3 1102 	strd	r1, r1, [r3, #8]
 8000a9a:	f103 0140 	add.w	r1, r3, #64	; 0x40
  pp->top    = &buf[n];
 8000a9e:	605d      	str	r5, [r3, #4]
  tqp->prev = (thread_t *)tqp;
 8000aa0:	e9c3 4408 	strd	r4, r4, [r3, #32]
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE / 2);
}
 8000aa4:	bc30      	pop	{r4, r5}
 8000aa6:	e9c3 000c 	strd	r0, r0, [r3, #48]	; 0x30
 8000aaa:	e9c3 1110 	strd	r1, r1, [r3, #64]	; 0x40
  pp->cnt    = (size_t)0;
 8000aae:	611a      	str	r2, [r3, #16]
  pp->reset  = false;
 8000ab0:	751a      	strb	r2, [r3, #20]
  pp->wtr    = NULL;
  pp->rtr    = NULL;
 8000ab2:	e9c3 2206 	strd	r2, r2, [r3, #24]
 8000ab6:	629a      	str	r2, [r3, #40]	; 0x28
 8000ab8:	639a      	str	r2, [r3, #56]	; 0x38
 8000aba:	649a      	str	r2, [r3, #72]	; 0x48
 8000abc:	4770      	bx	lr
 8000abe:	bf00      	nop
 8000ac0:	20000c98 	.word	0x20000c98
 8000ac4:	20001200 	.word	0x20001200
	...

08000ad0 <oslib_test_003_001_setup>:
  pp->cnt    = (size_t)0;
 8000ad0:	2200      	movs	r2, #0
static void oslib_test_003_001_setup(void) {
 8000ad2:	b430      	push	{r4, r5}
  pp->buffer = buf;
 8000ad4:	4b0e      	ldr	r3, [pc, #56]	; (8000b10 <oslib_test_003_001_setup+0x40>)
 8000ad6:	490f      	ldr	r1, [pc, #60]	; (8000b14 <oslib_test_003_001_setup+0x44>)
  tqp->next = (thread_t *)tqp;
 8000ad8:	f103 0420 	add.w	r4, r3, #32
  pp->top    = &buf[n];
 8000adc:	f101 0510 	add.w	r5, r1, #16
 8000ae0:	f103 0030 	add.w	r0, r3, #48	; 0x30
  pp->buffer = buf;
 8000ae4:	6019      	str	r1, [r3, #0]
  pp->wrptr  = buf;
 8000ae6:	e9c3 1102 	strd	r1, r1, [r3, #8]
 8000aea:	f103 0140 	add.w	r1, r3, #64	; 0x40
  pp->top    = &buf[n];
 8000aee:	605d      	str	r5, [r3, #4]
  tqp->prev = (thread_t *)tqp;
 8000af0:	e9c3 4408 	strd	r4, r4, [r3, #32]
}
 8000af4:	bc30      	pop	{r4, r5}
 8000af6:	e9c3 000c 	strd	r0, r0, [r3, #48]	; 0x30
 8000afa:	e9c3 1110 	strd	r1, r1, [r3, #64]	; 0x40
  pp->cnt    = (size_t)0;
 8000afe:	611a      	str	r2, [r3, #16]
  pp->reset  = false;
 8000b00:	751a      	strb	r2, [r3, #20]
  pp->rtr    = NULL;
 8000b02:	e9c3 2206 	strd	r2, r2, [r3, #24]
 8000b06:	629a      	str	r2, [r3, #40]	; 0x28
 8000b08:	639a      	str	r2, [r3, #56]	; 0x38
 8000b0a:	649a      	str	r2, [r3, #72]	; 0x48
 8000b0c:	4770      	bx	lr
 8000b0e:	bf00      	nop
 8000b10:	20000c98 	.word	0x20000c98
 8000b14:	20001200 	.word	0x20001200
	...

08000b20 <oslib_test_002_003_setup>:

  mbp->buffer = buf;
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
  mbp->cnt    = (size_t)0;
 8000b20:	2100      	movs	r1, #0
 *   active state.
 * - [2.3.4] Testing chMBFetchTimeout() and chMBFetchI() timeout.
 * .
 */

static void oslib_test_002_003_setup(void) {
 8000b22:	b430      	push	{r4, r5}
  mbp->buffer = buf;
 8000b24:	4b09      	ldr	r3, [pc, #36]	; (8000b4c <oslib_test_002_003_setup+0x2c>)
 8000b26:	4a0a      	ldr	r2, [pc, #40]	; (8000b50 <oslib_test_002_003_setup+0x30>)
  tqp->next = (thread_t *)tqp;
 8000b28:	f103 0418 	add.w	r4, r3, #24
  mbp->top    = &buf[n];
 8000b2c:	f102 0510 	add.w	r5, r2, #16
 8000b30:	f103 0020 	add.w	r0, r3, #32
 8000b34:	605d      	str	r5, [r3, #4]
  tqp->prev = (thread_t *)tqp;
 8000b36:	e9c3 4406 	strd	r4, r4, [r3, #24]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8000b3a:	bc30      	pop	{r4, r5}
  mbp->buffer = buf;
 8000b3c:	601a      	str	r2, [r3, #0]
  mbp->wrptr  = buf;
 8000b3e:	e9c3 2202 	strd	r2, r2, [r3, #8]
 8000b42:	e9c3 0008 	strd	r0, r0, [r3, #32]
  mbp->cnt    = (size_t)0;
 8000b46:	6119      	str	r1, [r3, #16]
  mbp->reset  = false;
 8000b48:	7519      	strb	r1, [r3, #20]
 8000b4a:	4770      	bx	lr
 8000b4c:	20000c58 	.word	0x20000c58
 8000b50:	20001520 	.word	0x20001520
	...

08000b60 <oslib_test_002_002_setup>:
 8000b60:	f7ff bfde 	b.w	8000b20 <oslib_test_002_003_setup>
	...

08000b70 <oslib_test_002_001_setup>:
 8000b70:	f7ff bfd6 	b.w	8000b20 <oslib_test_002_003_setup>
	...

08000b80 <rt_test_011_011_setup>:
 8000b80:	2200      	movs	r2, #0
  tqp->next = (thread_t *)tqp;
 8000b82:	4b02      	ldr	r3, [pc, #8]	; (8000b8c <rt_test_011_011_setup+0xc>)
 8000b84:	609a      	str	r2, [r3, #8]
  tqp->prev = (thread_t *)tqp;
 8000b86:	e9c3 3300 	strd	r3, r3, [r3]
 * .
 */

static void rt_test_011_011_setup(void) {
  chMtxObjectInit(&mtx1);
}
 8000b8a:	4770      	bx	lr
 8000b8c:	20001550 	.word	0x20001550

08000b90 <rt_test_011_010_setup>:
 8000b90:	2201      	movs	r2, #1
  tqp->next = (thread_t *)tqp;
 8000b92:	4b02      	ldr	r3, [pc, #8]	; (8000b9c <rt_test_011_010_setup+0xc>)
 8000b94:	609a      	str	r2, [r3, #8]
  tqp->prev = (thread_t *)tqp;
 8000b96:	e9c3 3300 	strd	r3, r3, [r3]
}
 8000b9a:	4770      	bx	lr
 8000b9c:	2000166c 	.word	0x2000166c

08000ba0 <tmo>:
static void tmo(void *param) {(void)param;}
 8000ba0:	4770      	bx	lr
 8000ba2:	bf00      	nop
	...

08000bb0 <rt_test_011_007_setup>:
 8000bb0:	2200      	movs	r2, #0
  tqp->next = (thread_t *)tqp;
 8000bb2:	4b02      	ldr	r3, [pc, #8]	; (8000bbc <rt_test_011_007_setup+0xc>)
 8000bb4:	609a      	str	r2, [r3, #8]
  tqp->prev = (thread_t *)tqp;
 8000bb6:	e9c3 3300 	strd	r3, r3, [r3]
}
 8000bba:	4770      	bx	lr
 8000bbc:	2000166c 	.word	0x2000166c

08000bc0 <rt_test_010_002_setup>:
  mp->next = NULL;
 8000bc0:	2200      	movs	r2, #0
  mp->object_size = size;
 8000bc2:	f44f 70a4 	mov.w	r0, #328	; 0x148
  mp->align = align;
 8000bc6:	2104      	movs	r1, #4
  mp->next = NULL;
 8000bc8:	4b02      	ldr	r3, [pc, #8]	; (8000bd4 <rt_test_010_002_setup+0x14>)
 8000bca:	601a      	str	r2, [r3, #0]
  mp->provider = provider;
 8000bcc:	60da      	str	r2, [r3, #12]
  mp->align = align;
 8000bce:	e9c3 0101 	strd	r0, r1, [r3, #4]
 * .
 */

static void rt_test_010_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
 8000bd2:	4770      	bx	lr
 8000bd4:	20001530 	.word	0x20001530
	...

08000be0 <rt_test_010_001_setup>:
  heapp->provider = NULL;
 8000be0:	2000      	movs	r0, #0
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 8000be2:	4b0b      	ldr	r3, [pc, #44]	; (8000c10 <rt_test_010_001_setup+0x30>)
  heapp->provider = NULL;
 8000be4:	4a0b      	ldr	r2, [pc, #44]	; (8000c14 <rt_test_010_001_setup+0x34>)
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 8000be6:	1dd9      	adds	r1, r3, #7
 8000be8:	f021 0107 	bic.w	r1, r1, #7
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
 8000bec:	1acb      	subs	r3, r1, r3
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8000bee:	f5c3 63cc 	rsb	r3, r3, #1632	; 0x660
static void rt_test_010_001_setup(void) {
 8000bf2:	b410      	push	{r4}
 8000bf4:	08db      	lsrs	r3, r3, #3
  tqp->next = (thread_t *)tqp;
 8000bf6:	f102 040c 	add.w	r4, r2, #12
 8000bfa:	604b      	str	r3, [r1, #4]
  H_NEXT(&heapp->header) = hp;
 8000bfc:	6051      	str	r1, [r2, #4]
  H_NEXT(hp) = NULL;
 8000bfe:	6008      	str	r0, [r1, #0]
  tqp->prev = (thread_t *)tqp;
 8000c00:	e9c2 4403 	strd	r4, r4, [r2, #12]
  heapp->provider = NULL;
 8000c04:	6010      	str	r0, [r2, #0]
  H_PAGES(&heapp->header) = 0;
 8000c06:	6090      	str	r0, [r2, #8]
 8000c08:	6150      	str	r0, [r2, #20]
}
 8000c0a:	bc10      	pop	{r4}
 8000c0c:	4770      	bx	lr
 8000c0e:	bf00      	nop
 8000c10:	20001680 	.word	0x20001680
 8000c14:	200014a0 	.word	0x200014a0
	...

08000c20 <rt_test_009_007_setup>:
 *   has been emptied.
 * - [9.7.4] Unregistering from the Event Sources.
 * .
 */

static void rt_test_009_007_setup(void) {
 8000c20:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8000c22:	f7ff fe45 	bl	80008b0 <chEvtGetAndClearEvents.constprop.51>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8000c26:	4a02      	ldr	r2, [pc, #8]	; (8000c30 <rt_test_009_007_setup+0x10>)
 8000c28:	4b02      	ldr	r3, [pc, #8]	; (8000c34 <rt_test_009_007_setup+0x14>)
 8000c2a:	6012      	str	r2, [r2, #0]
 8000c2c:	601b      	str	r3, [r3, #0]
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}
 8000c2e:	bd08      	pop	{r3, pc}
 8000c30:	20000c0c 	.word	0x20000c0c
 8000c34:	20000c10 	.word	0x20000c10
	...

08000c40 <rt_test_009_006_setup>:
  chEvtGetAndClearEvents(ALL_EVENTS);
 8000c40:	f7ff be36 	b.w	80008b0 <chEvtGetAndClearEvents.constprop.51>
	...

08000c50 <rt_test_009_005_setup>:
 8000c50:	f7ff bff6 	b.w	8000c40 <rt_test_009_006_setup>
	...

08000c60 <rt_test_009_004_setup>:
 8000c60:	f7ff bfee 	b.w	8000c40 <rt_test_009_006_setup>
	...

08000c70 <rt_test_009_003_setup>:
 8000c70:	f7ff bfe6 	b.w	8000c40 <rt_test_009_006_setup>
	...

08000c80 <rt_test_009_002_setup>:
 8000c80:	f7ff bfde 	b.w	8000c40 <rt_test_009_006_setup>
	...

08000c90 <rt_test_007_009_setup>:
 8000c90:	2000      	movs	r0, #0
  tqp->next = (thread_t *)tqp;
 8000c92:	4a06      	ldr	r2, [pc, #24]	; (8000cac <rt_test_007_009_setup+0x1c>)
 8000c94:	4b06      	ldr	r3, [pc, #24]	; (8000cb0 <rt_test_007_009_setup+0x20>)
 8000c96:	4907      	ldr	r1, [pc, #28]	; (8000cb4 <rt_test_007_009_setup+0x24>)
 8000c98:	6090      	str	r0, [r2, #8]
  tqp->prev = (thread_t *)tqp;
 8000c9a:	e9c2 2200 	strd	r2, r2, [r2]
 8000c9e:	6098      	str	r0, [r3, #8]
 8000ca0:	e9c3 3300 	strd	r3, r3, [r3]
 8000ca4:	e9c1 1100 	strd	r1, r1, [r1]

static void rt_test_007_009_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 8000ca8:	4770      	bx	lr
 8000caa:	bf00      	nop
 8000cac:	20000c38 	.word	0x20000c38
 8000cb0:	20000c48 	.word	0x20000c48
 8000cb4:	20000c04 	.word	0x20000c04
	...

08000cc0 <rt_test_007_008_setup>:
 8000cc0:	2100      	movs	r1, #0
  tqp->next = (thread_t *)tqp;
 8000cc2:	4b04      	ldr	r3, [pc, #16]	; (8000cd4 <rt_test_007_008_setup+0x14>)
 8000cc4:	4a04      	ldr	r2, [pc, #16]	; (8000cd8 <rt_test_007_008_setup+0x18>)
 8000cc6:	6099      	str	r1, [r3, #8]
  tqp->prev = (thread_t *)tqp;
 8000cc8:	e9c3 3300 	strd	r3, r3, [r3]
 8000ccc:	e9c2 2200 	strd	r2, r2, [r2]
}
 8000cd0:	4770      	bx	lr
 8000cd2:	bf00      	nop
 8000cd4:	20000c38 	.word	0x20000c38
 8000cd8:	20000c04 	.word	0x20000c04
 8000cdc:	00000000 	.word	0x00000000

08000ce0 <rt_test_007_007_setup>:
 8000ce0:	f7ff bfee 	b.w	8000cc0 <rt_test_007_008_setup>
	...

08000cf0 <rt_test_007_005_setup>:
 8000cf0:	2200      	movs	r2, #0
  tqp->next = (thread_t *)tqp;
 8000cf2:	4b02      	ldr	r3, [pc, #8]	; (8000cfc <rt_test_007_005_setup+0xc>)
 8000cf4:	609a      	str	r2, [r3, #8]
  tqp->prev = (thread_t *)tqp;
 8000cf6:	e9c3 3300 	strd	r3, r3, [r3]
}
 8000cfa:	4770      	bx	lr
 8000cfc:	20000c38 	.word	0x20000c38

08000d00 <rt_test_007_004_setup>:
 8000d00:	2100      	movs	r1, #0
  tqp->next = (thread_t *)tqp;
 8000d02:	4a04      	ldr	r2, [pc, #16]	; (8000d14 <rt_test_007_004_setup+0x14>)
 8000d04:	4b04      	ldr	r3, [pc, #16]	; (8000d18 <rt_test_007_004_setup+0x18>)
 8000d06:	6091      	str	r1, [r2, #8]
  tqp->prev = (thread_t *)tqp;
 8000d08:	e9c2 2200 	strd	r2, r2, [r2]
 8000d0c:	6099      	str	r1, [r3, #8]
 8000d0e:	e9c3 3300 	strd	r3, r3, [r3]
}
 8000d12:	4770      	bx	lr
 8000d14:	20000c38 	.word	0x20000c38
 8000d18:	20000c48 	.word	0x20000c48
 8000d1c:	00000000 	.word	0x00000000

08000d20 <rt_test_007_001_setup>:
 8000d20:	f7ff bfe6 	b.w	8000cf0 <rt_test_007_005_setup>
	...

08000d30 <rt_test_006_005_setup>:
 8000d30:	2200      	movs	r2, #0
  tqp->next = (thread_t *)tqp;
 8000d32:	4b02      	ldr	r3, [pc, #8]	; (8000d3c <rt_test_006_005_setup+0xc>)
 8000d34:	609a      	str	r2, [r3, #8]
  tqp->prev = (thread_t *)tqp;
 8000d36:	e9c3 3300 	strd	r3, r3, [r3]
 * .
 */

static void rt_test_006_005_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 8000d3a:	4770      	bx	lr
 8000d3c:	20001660 	.word	0x20001660

08000d40 <rt_test_006_004_setup>:
 8000d40:	f7ff bff6 	b.w	8000d30 <rt_test_006_005_setup>
	...

08000d50 <rt_test_006_003_setup>:
 8000d50:	f7ff bfee 	b.w	8000d30 <rt_test_006_005_setup>
	...

08000d60 <rt_test_006_002_setup>:
 8000d60:	f7ff bfe6 	b.w	8000d30 <rt_test_006_005_setup>
	...

08000d70 <rt_test_006_001_setup>:
 8000d70:	2201      	movs	r2, #1
  tqp->next = (thread_t *)tqp;
 8000d72:	4b02      	ldr	r3, [pc, #8]	; (8000d7c <rt_test_006_001_setup+0xc>)
 8000d74:	609a      	str	r2, [r3, #8]
  tqp->prev = (thread_t *)tqp;
 8000d76:	e9c3 3300 	strd	r3, r3, [r3]
}
 8000d7a:	4770      	bx	lr
 8000d7c:	20001660 	.word	0x20001660

08000d80 <rt_test_005_001_setup>:
 *   the state of the reference are tested.
 * .
 */

static void rt_test_005_001_setup(void) {
  tr1 = NULL;
 8000d80:	2200      	movs	r2, #0
 8000d82:	4b01      	ldr	r3, [pc, #4]	; (8000d88 <rt_test_005_001_setup+0x8>)
 8000d84:	601a      	str	r2, [r3, #0]
}
 8000d86:	4770      	bx	lr
 8000d88:	20001dc0 	.word	0x20001dc0
 8000d8c:	00000000 	.word	0x00000000

08000d90 <_test_assert>:
  if (!condition)
 8000d90:	b948      	cbnz	r0, 8000da6 <_test_assert+0x16>
  test_local_fail      = true;
 8000d92:	2001      	movs	r0, #1
bool _test_assert(bool condition, const char *msg) {
 8000d94:	b410      	push	{r4}
  test_global_fail     = true;
 8000d96:	4a05      	ldr	r2, [pc, #20]	; (8000dac <_test_assert+0x1c>)
  test_local_fail      = true;
 8000d98:	4c05      	ldr	r4, [pc, #20]	; (8000db0 <_test_assert+0x20>)
  test_failure_message = msg;
 8000d9a:	4b06      	ldr	r3, [pc, #24]	; (8000db4 <_test_assert+0x24>)
  test_local_fail      = true;
 8000d9c:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 8000d9e:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 8000da0:	6019      	str	r1, [r3, #0]
}
 8000da2:	bc10      	pop	{r4}
 8000da4:	4770      	bx	lr
  return false;
 8000da6:	2000      	movs	r0, #0
}
 8000da8:	4770      	bx	lr
 8000daa:	bf00      	nop
 8000dac:	20001cf0 	.word	0x20001cf0
 8000db0:	20001d90 	.word	0x20001d90
 8000db4:	20001cec 	.word	0x20001cec
	...

08000dc0 <rt_test_003_002_execute>:
    test_assert(b == false, "in range");
  }
  test_end_step(2);

  /* [3.2.3] Checking boundaries for start > end.*/
  test_set_step(3);
 8000dc0:	2203      	movs	r2, #3
 8000dc2:	4b01      	ldr	r3, [pc, #4]	; (8000dc8 <rt_test_003_002_execute+0x8>)
 8000dc4:	601a      	str	r2, [r3, #0]
    test_assert(b == true, "not in range");
    b = chTimeIsInRangeX((systime_t)10, (systime_t)100, (systime_t)10);
    test_assert(b == false, "in range");
  }
  test_end_step(3);
}
 8000dc6:	4770      	bx	lr
 8000dc8:	20001d94 	.word	0x20001d94
 8000dcc:	00000000 	.word	0x00000000

08000dd0 <rt_test_003_001_execute>:
 8000dd0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  test_set_step(1);
 8000dd4:	2001      	movs	r0, #1
 8000dd6:	4619      	mov	r1, r3
 8000dd8:	4a04      	ldr	r2, [pc, #16]	; (8000dec <rt_test_003_001_execute+0x1c>)
 8000dda:	6010      	str	r0, [r2, #0]
 8000ddc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000dde:	b292      	uxth	r2, r2
 8000de0:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    while (time == chVTGetSystemTimeX()) {
 8000de2:	b29b      	uxth	r3, r3
 8000de4:	429a      	cmp	r2, r3
 8000de6:	d0fb      	beq.n	8000de0 <rt_test_003_001_execute+0x10>
}
 8000de8:	4770      	bx	lr
 8000dea:	bf00      	nop
 8000dec:	20001d94 	.word	0x20001d94

08000df0 <rt_test_002_003_execute>:

static void rt_test_002_003_execute(void) {

  /* [2.3.1] Testing chSysSuspend(), chSysDisable() and
     chSysEnable().*/
  test_set_step(1);
 8000df0:	2101      	movs	r1, #1
 8000df2:	4a07      	ldr	r2, [pc, #28]	; (8000e10 <rt_test_002_003_execute+0x20>)
 8000df4:	2320      	movs	r3, #32
 8000df6:	6011      	str	r1, [r2, #0]
 8000df8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8000dfc:	b662      	cpsie	i
  __ASM volatile ("cpsid i" : : : "memory");
 8000dfe:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000e00:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8000e04:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000e06:	2300      	movs	r3, #0
 8000e08:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8000e0c:	b662      	cpsie	i
    chSysDisable();
    chSysSuspend();
    chSysEnable();
  }
  test_end_step(1);
}
 8000e0e:	4770      	bx	lr
 8000e10:	20001d94 	.word	0x20001d94
	...

08000e20 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8000e20:	b430      	push	{r4, r5}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000e22:	2520      	movs	r5, #32
 8000e24:	2400      	movs	r4, #0
 8000e26:	4b0a      	ldr	r3, [pc, #40]	; (8000e50 <test_terminate_threads+0x30>)
 8000e28:	f103 0014 	add.w	r0, r3, #20
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8000e2c:	f853 2b04 	ldr.w	r2, [r3], #4
 8000e30:	b14a      	cbz	r2, 8000e46 <test_terminate_threads+0x26>
 8000e32:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->flags |= CH_FLAG_TERMINATE;
 8000e36:	f892 1021 	ldrb.w	r1, [r2, #33]	; 0x21
 8000e3a:	f041 0104 	orr.w	r1, r1, #4
 8000e3e:	f882 1021 	strb.w	r1, [r2, #33]	; 0x21
 8000e42:	f384 8811 	msr	BASEPRI, r4
  for (i = 0; i < MAX_THREADS; i++)
 8000e46:	4283      	cmp	r3, r0
 8000e48:	d1f0      	bne.n	8000e2c <test_terminate_threads+0xc>
      chThdTerminate(threads[i]);
}
 8000e4a:	bc30      	pop	{r4, r5}
 8000e4c:	4770      	bx	lr
 8000e4e:	bf00      	nop
 8000e50:	20001dac 	.word	0x20001dac
	...

08000e60 <test_printn.part.0>:

  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
 8000e60:	b320      	cbz	r0, 8000eac <test_printn.part.0+0x4c>
void test_printn(uint32_t n) {
 8000e62:	b570      	push	{r4, r5, r6, lr}
 8000e64:	b084      	sub	sp, #16
    p = buf;
 8000e66:	466d      	mov	r5, sp
      *p++ = (n % 10) + '0', n /= 10;
 8000e68:	4e11      	ldr	r6, [pc, #68]	; (8000eb0 <test_printn.part.0+0x50>)
    p = buf;
 8000e6a:	462c      	mov	r4, r5
 8000e6c:	e000      	b.n	8000e70 <test_printn.part.0+0x10>
    while (n)
 8000e6e:	4614      	mov	r4, r2
      *p++ = (n % 10) + '0', n /= 10;
 8000e70:	4622      	mov	r2, r4
 8000e72:	fba6 1300 	umull	r1, r3, r6, r0
 8000e76:	08db      	lsrs	r3, r3, #3
 8000e78:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8000e7c:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 8000e80:	f100 0130 	add.w	r1, r0, #48	; 0x30
 8000e84:	b2c9      	uxtb	r1, r1
 8000e86:	f802 1b01 	strb.w	r1, [r2], #1
    while (n)
 8000e8a:	4618      	mov	r0, r3
 8000e8c:	2b00      	cmp	r3, #0
 8000e8e:	d1ee      	bne.n	8000e6e <test_printn.part.0+0xe>
    while (p > buf)
 8000e90:	42aa      	cmp	r2, r5
 8000e92:	d909      	bls.n	8000ea8 <test_printn.part.0+0x48>
 8000e94:	4e07      	ldr	r6, [pc, #28]	; (8000eb4 <test_printn.part.0+0x54>)
 8000e96:	e001      	b.n	8000e9c <test_printn.part.0+0x3c>
 8000e98:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      streamPut(test_chp, *--p);
 8000e9c:	6830      	ldr	r0, [r6, #0]
 8000e9e:	6803      	ldr	r3, [r0, #0]
 8000ea0:	68db      	ldr	r3, [r3, #12]
 8000ea2:	4798      	blx	r3
    while (p > buf)
 8000ea4:	42a5      	cmp	r5, r4
 8000ea6:	d1f7      	bne.n	8000e98 <test_printn.part.0+0x38>
  }
}
 8000ea8:	b004      	add	sp, #16
 8000eaa:	bd70      	pop	{r4, r5, r6, pc}
 8000eac:	4770      	bx	lr
 8000eae:	bf00      	nop
 8000eb0:	cccccccd 	.word	0xcccccccd
 8000eb4:	20001ce8 	.word	0x20001ce8
	...

08000ec0 <test_printn>:
  if (!n)
 8000ec0:	b928      	cbnz	r0, 8000ece <test_printn+0xe>
    streamPut(test_chp, '0');
 8000ec2:	4b04      	ldr	r3, [pc, #16]	; (8000ed4 <test_printn+0x14>)
 8000ec4:	2130      	movs	r1, #48	; 0x30
 8000ec6:	6818      	ldr	r0, [r3, #0]
 8000ec8:	6803      	ldr	r3, [r0, #0]
 8000eca:	68db      	ldr	r3, [r3, #12]
 8000ecc:	4718      	bx	r3
 8000ece:	f7ff bfc7 	b.w	8000e60 <test_printn.part.0>
 8000ed2:	bf00      	nop
 8000ed4:	20001ce8 	.word	0x20001ce8
	...

08000ee0 <test_emit_token>:
 8000ee0:	2320      	movs	r3, #32
 8000ee2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void test_emit_token(char token) {

  osalSysLock();
  if (test_tokp < &test_tokens_buffer[TEST_CFG_MAX_TOKENS])
 8000ee6:	4a06      	ldr	r2, [pc, #24]	; (8000f00 <test_emit_token+0x20>)
 8000ee8:	4906      	ldr	r1, [pc, #24]	; (8000f04 <test_emit_token+0x24>)
 8000eea:	6813      	ldr	r3, [r2, #0]
 8000eec:	428b      	cmp	r3, r1
 8000eee:	d202      	bcs.n	8000ef6 <test_emit_token+0x16>
    *test_tokp++ = token;
 8000ef0:	1c59      	adds	r1, r3, #1
 8000ef2:	7018      	strb	r0, [r3, #0]
 8000ef4:	6011      	str	r1, [r2, #0]
 8000ef6:	2300      	movs	r3, #0
 8000ef8:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 8000efc:	4770      	bx	lr
 8000efe:	bf00      	nop
 8000f00:	20001da8 	.word	0x20001da8
 8000f04:	20001da8 	.word	0x20001da8
	...

08000f10 <obj_write>:
  return false;
}

static bool obj_write(objects_cache_t *ocp,
                      oc_object_t *objp,
                      bool async) {
 8000f10:	b508      	push	{r3, lr}
  (void)ocp;
  (void)async;

  test_emit_token('A' + objp->obj_key);
 8000f12:	6948      	ldr	r0, [r1, #20]
 8000f14:	3041      	adds	r0, #65	; 0x41
 8000f16:	b2c0      	uxtb	r0, r0
 8000f18:	f7ff ffe2 	bl	8000ee0 <test_emit_token>

  return false;
}
 8000f1c:	2000      	movs	r0, #0
 8000f1e:	bd08      	pop	{r3, pc}

08000f20 <dis_func0>:
 * Shared code.
 ****************************************************************************/

static bool exit_flag;

static int dis_func0(void) {
 8000f20:	b508      	push	{r3, lr}

  test_emit_token('0');
 8000f22:	2030      	movs	r0, #48	; 0x30
 8000f24:	f7ff ffdc 	bl	8000ee0 <test_emit_token>

  return (msg_t)0x55AA;
}
 8000f28:	f245 50aa 	movw	r0, #21930	; 0x55aa
 8000f2c:	bd08      	pop	{r3, pc}
 8000f2e:	bf00      	nop

08000f30 <dis_func1>:

static msg_t dis_func1(msg_t a) {
 8000f30:	b510      	push	{r4, lr}
 8000f32:	4604      	mov	r4, r0

  test_emit_token((char)a);
 8000f34:	b2c0      	uxtb	r0, r0
 8000f36:	f7ff ffd3 	bl	8000ee0 <test_emit_token>

  return (msg_t)a;
}
 8000f3a:	4620      	mov	r0, r4
 8000f3c:	bd10      	pop	{r4, pc}
 8000f3e:	bf00      	nop

08000f40 <dis_func2>:

static msg_t dis_func2(msg_t a, msg_t b) {
 8000f40:	b538      	push	{r3, r4, r5, lr}
 8000f42:	460d      	mov	r5, r1
 8000f44:	4604      	mov	r4, r0

  test_emit_token((char)a);
 8000f46:	b2c0      	uxtb	r0, r0
 8000f48:	f7ff ffca 	bl	8000ee0 <test_emit_token>
  test_emit_token((char)b);
 8000f4c:	b2e8      	uxtb	r0, r5
 8000f4e:	f7ff ffc7 	bl	8000ee0 <test_emit_token>

  return (msg_t)a;
}
 8000f52:	4620      	mov	r0, r4
 8000f54:	bd38      	pop	{r3, r4, r5, pc}
 8000f56:	bf00      	nop
	...

08000f60 <dis_func3>:

static msg_t dis_func3(msg_t a, msg_t b, msg_t c) {
 8000f60:	b570      	push	{r4, r5, r6, lr}
 8000f62:	460e      	mov	r6, r1
 8000f64:	4615      	mov	r5, r2
 8000f66:	4604      	mov	r4, r0

  test_emit_token((char)a);
 8000f68:	b2c0      	uxtb	r0, r0
 8000f6a:	f7ff ffb9 	bl	8000ee0 <test_emit_token>
  test_emit_token((char)b);
 8000f6e:	b2f0      	uxtb	r0, r6
 8000f70:	f7ff ffb6 	bl	8000ee0 <test_emit_token>
  test_emit_token((char)c);
 8000f74:	b2e8      	uxtb	r0, r5
 8000f76:	f7ff ffb3 	bl	8000ee0 <test_emit_token>

  return (msg_t)a;
}
 8000f7a:	4620      	mov	r0, r4
 8000f7c:	bd70      	pop	{r4, r5, r6, pc}
 8000f7e:	bf00      	nop

08000f80 <dis_func4>:

static msg_t dis_func4(msg_t a, msg_t b, msg_t c, msg_t d) {
 8000f80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000f82:	460f      	mov	r7, r1
 8000f84:	4616      	mov	r6, r2
 8000f86:	461d      	mov	r5, r3
 8000f88:	4604      	mov	r4, r0

  test_emit_token((char)a);
 8000f8a:	b2c0      	uxtb	r0, r0
 8000f8c:	f7ff ffa8 	bl	8000ee0 <test_emit_token>
  test_emit_token((char)b);
 8000f90:	b2f8      	uxtb	r0, r7
 8000f92:	f7ff ffa5 	bl	8000ee0 <test_emit_token>
  test_emit_token((char)c);
 8000f96:	b2f0      	uxtb	r0, r6
 8000f98:	f7ff ffa2 	bl	8000ee0 <test_emit_token>
  test_emit_token((char)d);
 8000f9c:	b2e8      	uxtb	r0, r5
 8000f9e:	f7ff ff9f 	bl	8000ee0 <test_emit_token>

  return (msg_t)a;
}
 8000fa2:	4620      	mov	r0, r4
 8000fa4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000fa6:	bf00      	nop
	...

08000fb0 <dis_func_end>:

static int dis_func_end(void) {
 8000fb0:	b508      	push	{r3, lr}

  test_emit_token('Z');
 8000fb2:	205a      	movs	r0, #90	; 0x5a
 8000fb4:	f7ff ff94 	bl	8000ee0 <test_emit_token>
  exit_flag = true;
 8000fb8:	2201      	movs	r2, #1
 8000fba:	4b02      	ldr	r3, [pc, #8]	; (8000fc4 <dis_func_end+0x14>)

  return (msg_t)0xAA55;
}
 8000fbc:	f64a 2055 	movw	r0, #43605	; 0xaa55
  exit_flag = true;
 8000fc0:	701a      	strb	r2, [r3, #0]
}
 8000fc2:	bd08      	pop	{r3, pc}
 8000fc4:	2000145c 	.word	0x2000145c
	...

08000fd0 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8000fd0:	2043      	movs	r0, #67	; 0x43
 8000fd2:	f7ff bf85 	b.w	8000ee0 <test_emit_token>
 8000fd6:	bf00      	nop
	...

08000fe0 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8000fe0:	2042      	movs	r0, #66	; 0x42
 8000fe2:	f7ff bf7d 	b.w	8000ee0 <test_emit_token>
 8000fe6:	bf00      	nop
	...

08000ff0 <h1>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8000ff0:	2041      	movs	r0, #65	; 0x41
 8000ff2:	f7ff bf75 	b.w	8000ee0 <test_emit_token>
 8000ff6:	bf00      	nop
	...

08001000 <thread>:
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 8001000:	7800      	ldrb	r0, [r0, #0]
 8001002:	f7ff bf6d 	b.w	8000ee0 <test_emit_token>
 8001006:	bf00      	nop
	...

08001010 <dyn_thread1>:
 8001010:	f7ff bff6 	b.w	8001000 <thread>
	...

08001020 <test_println>:
void test_println(const char *msgp) {
 8001020:	b570      	push	{r4, r5, r6, lr}
  while (*msgp)
 8001022:	7801      	ldrb	r1, [r0, #0]
 8001024:	b189      	cbz	r1, 800104a <test_println+0x2a>
 8001026:	4604      	mov	r4, r0
 8001028:	4d09      	ldr	r5, [pc, #36]	; (8001050 <test_println+0x30>)
    streamPut(test_chp, *msgp++);
 800102a:	6828      	ldr	r0, [r5, #0]
 800102c:	6803      	ldr	r3, [r0, #0]
 800102e:	68db      	ldr	r3, [r3, #12]
 8001030:	4798      	blx	r3
  while (*msgp)
 8001032:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8001036:	2900      	cmp	r1, #0
 8001038:	d1f7      	bne.n	800102a <test_println+0xa>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 800103a:	6828      	ldr	r0, [r5, #0]
 800103c:	2202      	movs	r2, #2
}
 800103e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8001042:	6803      	ldr	r3, [r0, #0]
 8001044:	4903      	ldr	r1, [pc, #12]	; (8001054 <test_println+0x34>)
 8001046:	685b      	ldr	r3, [r3, #4]
 8001048:	4718      	bx	r3
 800104a:	4d01      	ldr	r5, [pc, #4]	; (8001050 <test_println+0x30>)
 800104c:	e7f5      	b.n	800103a <test_println+0x1a>
 800104e:	bf00      	nop
 8001050:	20001ce8 	.word	0x20001ce8
 8001054:	0800ac8c 	.word	0x0800ac8c
	...

08001060 <test_print>:
  while (*msgp)
 8001060:	7801      	ldrb	r1, [r0, #0]
 8001062:	b159      	cbz	r1, 800107c <test_print+0x1c>
void test_print(const char *msgp) {
 8001064:	b538      	push	{r3, r4, r5, lr}
 8001066:	4604      	mov	r4, r0
 8001068:	4d05      	ldr	r5, [pc, #20]	; (8001080 <test_print+0x20>)
    streamPut(test_chp, *msgp++);
 800106a:	6828      	ldr	r0, [r5, #0]
 800106c:	6803      	ldr	r3, [r0, #0]
 800106e:	68db      	ldr	r3, [r3, #12]
 8001070:	4798      	blx	r3
  while (*msgp)
 8001072:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8001076:	2900      	cmp	r1, #0
 8001078:	d1f7      	bne.n	800106a <test_print+0xa>
}
 800107a:	bd38      	pop	{r3, r4, r5, pc}
 800107c:	4770      	bx	lr
 800107e:	bf00      	nop
 8001080:	20001ce8 	.word	0x20001ce8
	...

08001090 <_test_assert_sequence>:
bool _test_assert_sequence(char *expected, const char *msg) {
 8001090:	b4f0      	push	{r4, r5, r6, r7}
  while (cp < test_tokp) {
 8001092:	4e0d      	ldr	r6, [pc, #52]	; (80010c8 <_test_assert_sequence+0x38>)
  char *cp = test_tokens_buffer;
 8001094:	4f0d      	ldr	r7, [pc, #52]	; (80010cc <_test_assert_sequence+0x3c>)
 8001096:	1e42      	subs	r2, r0, #1
  while (cp < test_tokp) {
 8001098:	6835      	ldr	r5, [r6, #0]
  char *cp = test_tokens_buffer;
 800109a:	463b      	mov	r3, r7
 800109c:	e003      	b.n	80010a6 <_test_assert_sequence+0x16>
    if (*cp++ != *expected++)
 800109e:	f813 4b01 	ldrb.w	r4, [r3], #1
 80010a2:	4284      	cmp	r4, r0
 80010a4:	d107      	bne.n	80010b6 <_test_assert_sequence+0x26>
  while (cp < test_tokp) {
 80010a6:	429d      	cmp	r5, r3
 80010a8:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 80010ac:	d8f7      	bhi.n	800109e <_test_assert_sequence+0xe>
  if (*expected)
 80010ae:	b910      	cbnz	r0, 80010b6 <_test_assert_sequence+0x26>
  test_tokp = test_tokens_buffer;
 80010b0:	6037      	str	r7, [r6, #0]
}
 80010b2:	bcf0      	pop	{r4, r5, r6, r7}
 80010b4:	4770      	bx	lr
  test_local_fail      = true;
 80010b6:	2001      	movs	r0, #1
 80010b8:	4c05      	ldr	r4, [pc, #20]	; (80010d0 <_test_assert_sequence+0x40>)
  test_global_fail     = true;
 80010ba:	4a06      	ldr	r2, [pc, #24]	; (80010d4 <_test_assert_sequence+0x44>)
  test_failure_message = msg;
 80010bc:	4b06      	ldr	r3, [pc, #24]	; (80010d8 <_test_assert_sequence+0x48>)
  test_local_fail      = true;
 80010be:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 80010c0:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 80010c2:	6019      	str	r1, [r3, #0]
}
 80010c4:	bcf0      	pop	{r4, r5, r6, r7}
 80010c6:	4770      	bx	lr
 80010c8:	20001da8 	.word	0x20001da8
 80010cc:	20001d98 	.word	0x20001d98
 80010d0:	20001d90 	.word	0x20001d90
 80010d4:	20001cf0 	.word	0x20001cf0
 80010d8:	20001cec 	.word	0x20001cec
 80010dc:	00000000 	.word	0x00000000

080010e0 <rt_test_009_002_execute>:
static void rt_test_009_002_execute(void) {
 80010e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 80010e2:	2301      	movs	r3, #1
 80010e4:	2507      	movs	r5, #7

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 80010e6:	461e      	mov	r6, r3
  eid = (eventid_t)0;
 80010e8:	2400      	movs	r4, #0
 80010ea:	4a0d      	ldr	r2, [pc, #52]	; (8001120 <rt_test_009_002_execute+0x40>)
 80010ec:	4f0d      	ldr	r7, [pc, #52]	; (8001124 <rt_test_009_002_execute+0x44>)
 80010ee:	6013      	str	r3, [r2, #0]
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 80010f0:	fa25 f304 	lsr.w	r3, r5, r4
 80010f4:	07db      	lsls	r3, r3, #31
      events &= ~EVENT_MASK(eid);
 80010f6:	fa06 f204 	lsl.w	r2, r6, r4
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 80010fa:	d50e      	bpl.n	800111a <rt_test_009_002_execute+0x3a>
      handlers[eid](eid);
 80010fc:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
 8001100:	4620      	mov	r0, r4
      events &= ~EVENT_MASK(eid);
 8001102:	ea25 0502 	bic.w	r5, r5, r2
    }
    eid++;
 8001106:	3401      	adds	r4, #1
      handlers[eid](eid);
 8001108:	4798      	blx	r3
  while (events != (eventmask_t)0) {
 800110a:	2d00      	cmp	r5, #0
 800110c:	d1f0      	bne.n	80010f0 <rt_test_009_002_execute+0x10>
}
 800110e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABC", "invalid sequence");
 8001112:	4905      	ldr	r1, [pc, #20]	; (8001128 <rt_test_009_002_execute+0x48>)
 8001114:	4805      	ldr	r0, [pc, #20]	; (800112c <rt_test_009_002_execute+0x4c>)
 8001116:	f7ff bfbb 	b.w	8001090 <_test_assert_sequence>
    eid++;
 800111a:	3401      	adds	r4, #1
 800111c:	e7e8      	b.n	80010f0 <rt_test_009_002_execute+0x10>
 800111e:	bf00      	nop
 8001120:	20001d94 	.word	0x20001d94
 8001124:	0800ad0c 	.word	0x0800ad0c
 8001128:	0800c260 	.word	0x0800c260
 800112c:	0800c274 	.word	0x0800c274

08001130 <print_line>:
static void print_line(void) {
 8001130:	b570      	push	{r4, r5, r6, lr}
 8001132:	244c      	movs	r4, #76	; 0x4c
 8001134:	4d07      	ldr	r5, [pc, #28]	; (8001154 <print_line+0x24>)
    streamPut(test_chp, '-');
 8001136:	6828      	ldr	r0, [r5, #0]
 8001138:	212d      	movs	r1, #45	; 0x2d
 800113a:	6803      	ldr	r3, [r0, #0]
 800113c:	68db      	ldr	r3, [r3, #12]
 800113e:	4798      	blx	r3
  for (i = 0; i < 76; i++)
 8001140:	3c01      	subs	r4, #1
 8001142:	d1f8      	bne.n	8001136 <print_line+0x6>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8001144:	6828      	ldr	r0, [r5, #0]
 8001146:	2202      	movs	r2, #2
}
 8001148:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 800114c:	6803      	ldr	r3, [r0, #0]
 800114e:	4902      	ldr	r1, [pc, #8]	; (8001158 <print_line+0x28>)
 8001150:	685b      	ldr	r3, [r3, #4]
 8001152:	4718      	bx	r3
 8001154:	20001ce8 	.word	0x20001ce8
 8001158:	0800ac8c 	.word	0x0800ac8c
 800115c:	00000000 	.word	0x00000000

08001160 <get_descriptor>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8001160:	2902      	cmp	r1, #2
 8001162:	d006      	beq.n	8001172 <get_descriptor+0x12>
 8001164:	2903      	cmp	r1, #3
 8001166:	d006      	beq.n	8001176 <get_descriptor+0x16>
 8001168:	2901      	cmp	r1, #1
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
 800116a:	4806      	ldr	r0, [pc, #24]	; (8001184 <get_descriptor+0x24>)
 800116c:	bf18      	it	ne
 800116e:	2000      	movne	r0, #0
 8001170:	4770      	bx	lr
    return &vcom_configuration_descriptor;
 8001172:	4805      	ldr	r0, [pc, #20]	; (8001188 <get_descriptor+0x28>)
 8001174:	4770      	bx	lr
    if (dindex < 4)
 8001176:	2a03      	cmp	r2, #3
      return &vcom_strings[dindex];
 8001178:	bf9a      	itte	ls
 800117a:	4804      	ldrls	r0, [pc, #16]	; (800118c <get_descriptor+0x2c>)
 800117c:	eb00 00c2 	addls.w	r0, r0, r2, lsl #3
  return NULL;
 8001180:	2000      	movhi	r0, #0
}
 8001182:	4770      	bx	lr
 8001184:	0800d48c 	.word	0x0800d48c
 8001188:	0800d440 	.word	0x0800d440
 800118c:	0800d514 	.word	0x0800d514

08001190 <_port_irq_epilogue>:
 8001190:	2320      	movs	r3, #32
 8001192:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001196:	4b0d      	ldr	r3, [pc, #52]	; (80011cc <_port_irq_epilogue+0x3c>)
 8001198:	685b      	ldr	r3, [r3, #4]
 800119a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800119e:	d102      	bne.n	80011a6 <_port_irq_epilogue+0x16>
 80011a0:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 80011a4:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80011a6:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
 80011aa:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
 80011ae:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
 80011b0:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80011b2:	f383 8809 	msr	PSP, r3
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80011b6:	4a06      	ldr	r2, [pc, #24]	; (80011d0 <_port_irq_epilogue+0x40>)
 80011b8:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 80011ba:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
 80011bc:	6889      	ldr	r1, [r1, #8]
 80011be:	6892      	ldr	r2, [r2, #8]
 80011c0:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
 80011c2:	bf8c      	ite	hi
 80011c4:	4a03      	ldrhi	r2, [pc, #12]	; (80011d4 <_port_irq_epilogue+0x44>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
 80011c6:	4a04      	ldrls	r2, [pc, #16]	; (80011d8 <_port_irq_epilogue+0x48>)
 80011c8:	619a      	str	r2, [r3, #24]
 80011ca:	4770      	bx	lr
 80011cc:	e000ed00 	.word	0xe000ed00
 80011d0:	20001254 	.word	0x20001254
 80011d4:	08000263 	.word	0x08000263
 80011d8:	08000266 	.word	0x08000266
 80011dc:	00000000 	.word	0x00000000

080011e0 <chCoreAllocAlignedI>:
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80011e0:	4b08      	ldr	r3, [pc, #32]	; (8001204 <chCoreAllocAlignedI+0x24>)
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80011e2:	b410      	push	{r4}
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80011e4:	e9d3 4200 	ldrd	r4, r2, [r3]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80011e8:	4249      	negs	r1, r1
 80011ea:	1a10      	subs	r0, r2, r0
 80011ec:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80011ee:	42a0      	cmp	r0, r4
 80011f0:	d304      	bcc.n	80011fc <chCoreAllocAlignedI+0x1c>
 80011f2:	4282      	cmp	r2, r0
 80011f4:	d302      	bcc.n	80011fc <chCoreAllocAlignedI+0x1c>
  ch_memcore.topmem = prev;
 80011f6:	6058      	str	r0, [r3, #4]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 80011f8:	bc10      	pop	{r4}
 80011fa:	4770      	bx	lr
    return NULL;
 80011fc:	2000      	movs	r0, #0
 80011fe:	bc10      	pop	{r4}
 8001200:	4770      	bx	lr
 8001202:	bf00      	nop
 8001204:	200013f0 	.word	0x200013f0
	...

08001210 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8001210:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001212:	2220      	movs	r2, #32
 8001214:	4603      	mov	r3, r0
 8001216:	f382 8811 	msr	BASEPRI, r2
  objp = mp->next;
 800121a:	6800      	ldr	r0, [r0, #0]
  if (objp != NULL) {
 800121c:	b128      	cbz	r0, 800122a <chPoolAlloc+0x1a>
    mp->next = mp->next->next;
 800121e:	6802      	ldr	r2, [r0, #0]
 8001220:	601a      	str	r2, [r3, #0]
 8001222:	2300      	movs	r3, #0
 8001224:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8001228:	bd08      	pop	{r3, pc}
  else if (mp->provider != NULL) {
 800122a:	68da      	ldr	r2, [r3, #12]
 800122c:	2a00      	cmp	r2, #0
 800122e:	d0f8      	beq.n	8001222 <chPoolAlloc+0x12>
    objp = mp->provider(mp->object_size, mp->align);
 8001230:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
 8001234:	4790      	blx	r2
 8001236:	2300      	movs	r3, #0
 8001238:	f383 8811 	msr	BASEPRI, r3
}
 800123c:	bd08      	pop	{r3, pc}
 800123e:	bf00      	nop

08001240 <oslib_test_007_001_execute>:
  test_set_step(1);
 8001240:	2101      	movs	r1, #1
static void oslib_test_007_001_execute(void) {
 8001242:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8001246:	2204      	movs	r2, #4
 8001248:	2520      	movs	r5, #32
 800124a:	2000      	movs	r0, #0
 800124c:	4e38      	ldr	r6, [pc, #224]	; (8001330 <oslib_test_007_001_execute+0xf0>)
 800124e:	4b39      	ldr	r3, [pc, #228]	; (8001334 <oslib_test_007_001_execute+0xf4>)
 8001250:	4c39      	ldr	r4, [pc, #228]	; (8001338 <oslib_test_007_001_execute+0xf8>)
 8001252:	6031      	str	r1, [r6, #0]
 8001254:	f385 8811 	msr	BASEPRI, r5
  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 8001258:	6821      	ldr	r1, [r4, #0]
  mp->next = php;
 800125a:	6023      	str	r3, [r4, #0]
  php->next = mp->next;
 800125c:	6019      	str	r1, [r3, #0]
 800125e:	f380 8811 	msr	BASEPRI, r0
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8001262:	6861      	ldr	r1, [r4, #4]
  while (n != 0U) {
 8001264:	3a01      	subs	r2, #1
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8001266:	440b      	add	r3, r1
  while (n != 0U) {
 8001268:	d1f4      	bne.n	8001254 <oslib_test_007_001_execute+0x14>
  test_set_step(2);
 800126a:	2302      	movs	r3, #2
 800126c:	2504      	movs	r5, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 800126e:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 8001338 <oslib_test_007_001_execute+0xf8>
 8001272:	4f32      	ldr	r7, [pc, #200]	; (800133c <oslib_test_007_001_execute+0xfc>)
  test_set_step(2);
 8001274:	6033      	str	r3, [r6, #0]
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8001276:	4640      	mov	r0, r8
 8001278:	f7ff ffca 	bl	8001210 <chPoolAlloc>
 800127c:	3000      	adds	r0, #0
 800127e:	bf18      	it	ne
 8001280:	2001      	movne	r0, #1
 8001282:	4639      	mov	r1, r7
 8001284:	f7ff fd84 	bl	8000d90 <_test_assert>
 8001288:	2800      	cmp	r0, #0
 800128a:	d13b      	bne.n	8001304 <oslib_test_007_001_execute+0xc4>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800128c:	3d01      	subs	r5, #1
 800128e:	d1f2      	bne.n	8001276 <oslib_test_007_001_execute+0x36>
  test_set_step(3);
 8001290:	2303      	movs	r3, #3
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8001292:	4829      	ldr	r0, [pc, #164]	; (8001338 <oslib_test_007_001_execute+0xf8>)
  test_set_step(3);
 8001294:	6033      	str	r3, [r6, #0]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8001296:	f7ff ffbb 	bl	8001210 <chPoolAlloc>
 800129a:	fab0 f080 	clz	r0, r0
 800129e:	4928      	ldr	r1, [pc, #160]	; (8001340 <oslib_test_007_001_execute+0x100>)
 80012a0:	0940      	lsrs	r0, r0, #5
 80012a2:	f7ff fd75 	bl	8000d90 <_test_assert>
 80012a6:	bb68      	cbnz	r0, 8001304 <oslib_test_007_001_execute+0xc4>
  test_set_step(4);
 80012a8:	2204      	movs	r2, #4
 80012aa:	2720      	movs	r7, #32
 80012ac:	4b21      	ldr	r3, [pc, #132]	; (8001334 <oslib_test_007_001_execute+0xf4>)
 80012ae:	6032      	str	r2, [r6, #0]
 80012b0:	f103 0010 	add.w	r0, r3, #16
 80012b4:	f387 8811 	msr	BASEPRI, r7
  php->next = mp->next;
 80012b8:	6822      	ldr	r2, [r4, #0]
  mp->next = php;
 80012ba:	6023      	str	r3, [r4, #0]
  php->next = mp->next;
 80012bc:	f843 2b04 	str.w	r2, [r3], #4
 80012c0:	f385 8811 	msr	BASEPRI, r5
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80012c4:	4298      	cmp	r0, r3
 80012c6:	d1f5      	bne.n	80012b4 <oslib_test_007_001_execute+0x74>
  test_set_step(5);
 80012c8:	2305      	movs	r3, #5
 80012ca:	2504      	movs	r5, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 80012cc:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8001338 <oslib_test_007_001_execute+0xf8>
 80012d0:	4f1a      	ldr	r7, [pc, #104]	; (800133c <oslib_test_007_001_execute+0xfc>)
  test_set_step(5);
 80012d2:	6033      	str	r3, [r6, #0]
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 80012d4:	4640      	mov	r0, r8
 80012d6:	f7ff ff9b 	bl	8001210 <chPoolAlloc>
 80012da:	3000      	adds	r0, #0
 80012dc:	bf18      	it	ne
 80012de:	2001      	movne	r0, #1
 80012e0:	4639      	mov	r1, r7
 80012e2:	f7ff fd55 	bl	8000d90 <_test_assert>
 80012e6:	b968      	cbnz	r0, 8001304 <oslib_test_007_001_execute+0xc4>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80012e8:	3d01      	subs	r5, #1
 80012ea:	d1f3      	bne.n	80012d4 <oslib_test_007_001_execute+0x94>
  test_set_step(6);
 80012ec:	2306      	movs	r3, #6
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80012ee:	4812      	ldr	r0, [pc, #72]	; (8001338 <oslib_test_007_001_execute+0xf8>)
  test_set_step(6);
 80012f0:	6033      	str	r3, [r6, #0]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80012f2:	f7ff ff8d 	bl	8001210 <chPoolAlloc>
 80012f6:	fab0 f080 	clz	r0, r0
 80012fa:	4911      	ldr	r1, [pc, #68]	; (8001340 <oslib_test_007_001_execute+0x100>)
 80012fc:	0940      	lsrs	r0, r0, #5
 80012fe:	f7ff fd47 	bl	8000d90 <_test_assert>
 8001302:	b108      	cbz	r0, 8001308 <oslib_test_007_001_execute+0xc8>
}
 8001304:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(7);
 8001308:	2107      	movs	r1, #7
  mp->object_size = size;
 800130a:	2304      	movs	r3, #4
  mp->provider = provider;
 800130c:	4a0d      	ldr	r2, [pc, #52]	; (8001344 <oslib_test_007_001_execute+0x104>)
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 800130e:	480a      	ldr	r0, [pc, #40]	; (8001338 <oslib_test_007_001_execute+0xf8>)
  test_set_step(7);
 8001310:	6031      	str	r1, [r6, #0]
  mp->next = NULL;
 8001312:	6025      	str	r5, [r4, #0]
  mp->align = align;
 8001314:	e9c4 3301 	strd	r3, r3, [r4, #4]
  mp->provider = provider;
 8001318:	60e2      	str	r2, [r4, #12]
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 800131a:	f7ff ff79 	bl	8001210 <chPoolAlloc>
}
 800131e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8001322:	fab0 f080 	clz	r0, r0
 8001326:	4908      	ldr	r1, [pc, #32]	; (8001348 <oslib_test_007_001_execute+0x108>)
 8001328:	0940      	lsrs	r0, r0, #5
 800132a:	f7ff bd31 	b.w	8000d90 <_test_assert>
 800132e:	bf00      	nop
 8001330:	20001d94 	.word	0x20001d94
 8001334:	20001650 	.word	0x20001650
 8001338:	20000c80 	.word	0x20000c80
 800133c:	0800b3a4 	.word	0x0800b3a4
 8001340:	0800b3b0 	.word	0x0800b3b0
 8001344:	080009c1 	.word	0x080009c1
 8001348:	0800b3c0 	.word	0x0800b3c0
 800134c:	00000000 	.word	0x00000000

08001350 <chEvtAddEvents>:
 8001350:	2320      	movs	r3, #32
 8001352:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline eventmask_t chEvtAddEventsI(eventmask_t events) {

  return currp->epending |= events;
 8001356:	4b04      	ldr	r3, [pc, #16]	; (8001368 <chEvtAddEvents+0x18>)
 8001358:	2200      	movs	r2, #0
 800135a:	699b      	ldr	r3, [r3, #24]
 800135c:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800135e:	4308      	orrs	r0, r1
 8001360:	6358      	str	r0, [r3, #52]	; 0x34
 8001362:	f382 8811 	msr	BASEPRI, r2
}
 8001366:	4770      	bx	lr
 8001368:	20001254 	.word	0x20001254
 800136c:	00000000 	.word	0x00000000

08001370 <chEvtUnregister>:
 8001370:	2320      	movs	r3, #32
 8001372:	f383 8811 	msr	BASEPRI, r3
  p = (event_listener_t *)esp;
 8001376:	4602      	mov	r2, r0
 8001378:	e002      	b.n	8001380 <chEvtUnregister+0x10>
    if (p->next == elp) {
 800137a:	428b      	cmp	r3, r1
 800137c:	d007      	beq.n	800138e <chEvtUnregister+0x1e>
 800137e:	461a      	mov	r2, r3
  while (p->next != (event_listener_t *)esp) {
 8001380:	6813      	ldr	r3, [r2, #0]
 8001382:	4283      	cmp	r3, r0
 8001384:	d1f9      	bne.n	800137a <chEvtUnregister+0xa>
 8001386:	2300      	movs	r3, #0
 8001388:	f383 8811 	msr	BASEPRI, r3
}
 800138c:	4770      	bx	lr
      p->next = elp->next;
 800138e:	680b      	ldr	r3, [r1, #0]
 8001390:	6013      	str	r3, [r2, #0]
 8001392:	2300      	movs	r3, #0
 8001394:	f383 8811 	msr	BASEPRI, r3
}
 8001398:	4770      	bx	lr
 800139a:	bf00      	nop
 800139c:	0000      	movs	r0, r0
	...

080013a0 <rt_test_009_001_execute>:
  test_set_step(2);
 80013a0:	2002      	movs	r0, #2
static void rt_test_009_001_execute(void) {
 80013a2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  test_set_step(2);
 80013a6:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 8001494 <rt_test_009_001_execute+0xf4>
  esp->next = (event_listener_t *)esp;
 80013aa:	4c36      	ldr	r4, [pc, #216]	; (8001484 <rt_test_009_001_execute+0xe4>)
static void rt_test_009_001_execute(void) {
 80013ac:	b08c      	sub	sp, #48	; 0x30
  test_set_step(2);
 80013ae:	f8c9 0000 	str.w	r0, [r9]
 80013b2:	6024      	str	r4, [r4, #0]
 80013b4:	2620      	movs	r6, #32
 80013b6:	f386 8811 	msr	BASEPRI, r6
  elp->events   = events;
 80013ba:	2301      	movs	r3, #1
  elp->flags    = (eventflags_t)0;
 80013bc:	2500      	movs	r5, #0
  elp->wflags   = wflags;
 80013be:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  elp->listener = currp;
 80013c2:	4a31      	ldr	r2, [pc, #196]	; (8001488 <rt_test_009_001_execute+0xe8>)
  elp->events   = events;
 80013c4:	9309      	str	r3, [sp, #36]	; 0x24
  elp->next     = esp->next;
 80013c6:	6823      	ldr	r3, [r4, #0]
 80013c8:	af0c      	add	r7, sp, #48	; 0x30
 80013ca:	9301      	str	r3, [sp, #4]
  elp->listener = currp;
 80013cc:	6993      	ldr	r3, [r2, #24]
  elp->wflags   = wflags;
 80013ce:	e9cd 510a 	strd	r5, r1, [sp, #40]	; 0x28
  elp->listener = currp;
 80013d2:	9308      	str	r3, [sp, #32]
  elp->next     = esp->next;
 80013d4:	9b01      	ldr	r3, [sp, #4]
 80013d6:	f847 3d14 	str.w	r3, [r7, #-20]!
  esp->next     = elp;
 80013da:	6027      	str	r7, [r4, #0]
 80013dc:	f385 8811 	msr	BASEPRI, r5
 80013e0:	f386 8811 	msr	BASEPRI, r6
  elp->next     = esp->next;
 80013e4:	6823      	ldr	r3, [r4, #0]
 80013e6:	f10d 0830 	add.w	r8, sp, #48	; 0x30
  elp->listener = currp;
 80013ea:	6992      	ldr	r2, [r2, #24]
  elp->next     = esp->next;
 80013ec:	f848 3d28 	str.w	r3, [r8, #-40]!
  elp->listener = currp;
 80013f0:	9203      	str	r2, [sp, #12]
  elp->flags    = (eventflags_t)0;
 80013f2:	e9cd 0504 	strd	r0, r5, [sp, #16]
  elp->wflags   = wflags;
 80013f6:	9106      	str	r1, [sp, #24]
  esp->next     = elp;
 80013f8:	f8c4 8000 	str.w	r8, [r4]
 80013fc:	f385 8811 	msr	BASEPRI, r5
 8001400:	f386 8811 	msr	BASEPRI, r6
  return (bool)(esp != (event_source_t *)esp->next);
 8001404:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8001406:	4921      	ldr	r1, [pc, #132]	; (800148c <rt_test_009_001_execute+0xec>)
 8001408:	1b00      	subs	r0, r0, r4
 800140a:	bf18      	it	ne
 800140c:	2001      	movne	r0, #1
 800140e:	f7ff fcbf 	bl	8000d90 <_test_assert>
 8001412:	b120      	cbz	r0, 800141e <rt_test_009_001_execute+0x7e>
 8001414:	f385 8811 	msr	BASEPRI, r5
}
 8001418:	b00c      	add	sp, #48	; 0x30
 800141a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800141e:	4682      	mov	sl, r0
 8001420:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 8001424:	2303      	movs	r3, #3
    chEvtUnregister(&es1, &el1);
 8001426:	4639      	mov	r1, r7
 8001428:	4620      	mov	r0, r4
  test_set_step(3);
 800142a:	f8c9 3000 	str.w	r3, [r9]
    chEvtUnregister(&es1, &el1);
 800142e:	f7ff ff9f 	bl	8001370 <chEvtUnregister>
 8001432:	f386 8811 	msr	BASEPRI, r6
 8001436:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8001438:	4914      	ldr	r1, [pc, #80]	; (800148c <rt_test_009_001_execute+0xec>)
 800143a:	1b00      	subs	r0, r0, r4
 800143c:	bf18      	it	ne
 800143e:	2001      	movne	r0, #1
 8001440:	f7ff fca6 	bl	8000d90 <_test_assert>
 8001444:	4605      	mov	r5, r0
 8001446:	b120      	cbz	r0, 8001452 <rt_test_009_001_execute+0xb2>
 8001448:	f38a 8811 	msr	BASEPRI, sl
}
 800144c:	b00c      	add	sp, #48	; 0x30
 800144e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001452:	f380 8811 	msr	BASEPRI, r0
  test_set_step(4);
 8001456:	2304      	movs	r3, #4
    chEvtUnregister(&es1, &el2);
 8001458:	4641      	mov	r1, r8
 800145a:	4620      	mov	r0, r4
  test_set_step(4);
 800145c:	f8c9 3000 	str.w	r3, [r9]
    chEvtUnregister(&es1, &el2);
 8001460:	f7ff ff86 	bl	8001370 <chEvtUnregister>
 8001464:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 8001468:	6820      	ldr	r0, [r4, #0]
 800146a:	4909      	ldr	r1, [pc, #36]	; (8001490 <rt_test_009_001_execute+0xf0>)
 800146c:	1b00      	subs	r0, r0, r4
 800146e:	fab0 f080 	clz	r0, r0
 8001472:	0940      	lsrs	r0, r0, #5
 8001474:	f7ff fc8c 	bl	8000d90 <_test_assert>
 8001478:	2800      	cmp	r0, #0
 800147a:	d1cb      	bne.n	8001414 <rt_test_009_001_execute+0x74>
 800147c:	f380 8811 	msr	BASEPRI, r0
 8001480:	e7ca      	b.n	8001418 <rt_test_009_001_execute+0x78>
 8001482:	bf00      	nop
 8001484:	20000c0c 	.word	0x20000c0c
 8001488:	20001254 	.word	0x20001254
 800148c:	0800c234 	.word	0x0800c234
 8001490:	0800c240 	.word	0x0800c240
 8001494:	20001d94 	.word	0x20001d94
	...

080014a0 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80014a0:	4b0f      	ldr	r3, [pc, #60]	; (80014e0 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80014a2:	4a10      	ldr	r2, [pc, #64]	; (80014e4 <chTMStopMeasurementX+0x44>)
 80014a4:	685b      	ldr	r3, [r3, #4]
  tmp->last = (now - tmp->last) - offset;
 80014a6:	6881      	ldr	r1, [r0, #8]
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80014a8:	6f52      	ldr	r2, [r2, #116]	; 0x74
  tmp->last = (now - tmp->last) - offset;
 80014aa:	1a5b      	subs	r3, r3, r1
 80014ac:	1a9b      	subs	r3, r3, r2
  tmp->n++;
 80014ae:	68c2      	ldr	r2, [r0, #12]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80014b0:	e92d 0830 	stmdb	sp!, {r4, r5, fp}
  tmp->cumulative += (rttime_t)tmp->last;
 80014b4:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 80014b8:	6841      	ldr	r1, [r0, #4]
  tmp->n++;
 80014ba:	3201      	adds	r2, #1
  tmp->cumulative += (rttime_t)tmp->last;
 80014bc:	eb14 0b03 	adds.w	fp, r4, r3
  tmp->last = (now - tmp->last) - offset;
 80014c0:	e9c0 3202 	strd	r3, r2, [r0, #8]
  if (tmp->last < tmp->best) {
 80014c4:	6802      	ldr	r2, [r0, #0]
  tmp->cumulative += (rttime_t)tmp->last;
 80014c6:	f145 0c00 	adc.w	ip, r5, #0
  if (tmp->last > tmp->worst) {
 80014ca:	428b      	cmp	r3, r1
    tmp->worst = tmp->last;
 80014cc:	bf88      	it	hi
 80014ce:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 80014d0:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 80014d2:	e9c0 bc04 	strd	fp, ip, [r0, #16]
}
 80014d6:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
    tmp->best = tmp->last;
 80014da:	bf38      	it	cc
 80014dc:	6003      	strcc	r3, [r0, #0]
}
 80014de:	4770      	bx	lr
 80014e0:	e0001000 	.word	0xe0001000
 80014e4:	20001254 	.word	0x20001254
	...

080014f0 <chTMStartMeasurementX>:
 80014f0:	4b01      	ldr	r3, [pc, #4]	; (80014f8 <chTMStartMeasurementX+0x8>)
 80014f2:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 80014f4:	6083      	str	r3, [r0, #8]
}
 80014f6:	4770      	bx	lr
 80014f8:	e0001000 	.word	0xe0001000
 80014fc:	00000000 	.word	0x00000000

08001500 <chThdCreateSuspendedI>:
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8001500:	b4f0      	push	{r4, r5, r6, r7}
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001502:	2100      	movs	r1, #0
  tp->state     = CH_STATE_WTSTART;
 8001504:	2702      	movs	r7, #2
  tp->refs      = (trefs_t)1;
 8001506:	2501      	movs	r5, #1
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8001508:	6883      	ldr	r3, [r0, #8]
  tp->wabase = tdp->wbase;
 800150a:	6846      	ldr	r6, [r0, #4]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800150c:	6904      	ldr	r4, [r0, #16]
  REG_INSERT(tp);
 800150e:	4a19      	ldr	r2, [pc, #100]	; (8001574 <chThdCreateSuspendedI+0x74>)
  tp->wabase = tdp->wbase;
 8001510:	f843 6c2c 	str.w	r6, [r3, #-44]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001514:	f843 4c6c 	str.w	r4, [r3, #-108]
  return _thread_init(tp, tdp->name, tdp->prio);
 8001518:	6806      	ldr	r6, [r0, #0]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800151a:	6944      	ldr	r4, [r0, #20]
  return _thread_init(tp, tdp->name, tdp->prio);
 800151c:	68c0      	ldr	r0, [r0, #12]
  tp->refs      = (trefs_t)1;
 800151e:	f803 5c26 	strb.w	r5, [r3, #-38]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001522:	f803 1c27 	strb.w	r1, [r3, #-39]
  tp->state     = CH_STATE_WTSTART;
 8001526:	f803 7c28 	strb.w	r7, [r3, #-40]
  REG_INSERT(tp);
 800152a:	f843 2c38 	str.w	r2, [r3, #-56]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800152e:	4d12      	ldr	r5, [pc, #72]	; (8001578 <chThdCreateSuspendedI+0x78>)
 8001530:	f843 4c68 	str.w	r4, [r3, #-104]
  tp->prio      = prio;
 8001534:	f843 0c40 	str.w	r0, [r3, #-64]
  REG_INSERT(tp);
 8001538:	6954      	ldr	r4, [r2, #20]
  tp->realprio  = prio;
 800153a:	f843 0c0c 	str.w	r0, [r3, #-12]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800153e:	f1a3 006c 	sub.w	r0, r3, #108	; 0x6c
 8001542:	f843 0c3c 	str.w	r0, [r3, #-60]
 8001546:	f843 5c4c 	str.w	r5, [r3, #-76]
  tp = (thread_t *)((uint8_t *)tdp->wend -
 800154a:	f1a3 0048 	sub.w	r0, r3, #72	; 0x48
  tp->epending  = (eventmask_t)0;
 800154e:	e943 1105 	strd	r1, r1, [r3, #-20]
  list_init(&tp->waiting);
 8001552:	f1a3 0520 	sub.w	r5, r3, #32
  queue_init(&tp->msgqueue);
 8001556:	f1a3 011c 	sub.w	r1, r3, #28
  tp->name      = name;
 800155a:	f843 6c30 	str.w	r6, [r3, #-48]
  REG_INSERT(tp);
 800155e:	f843 4c34 	str.w	r4, [r3, #-52]
 8001562:	6120      	str	r0, [r4, #16]
 8001564:	6150      	str	r0, [r2, #20]
  tqp->next = (thread_t *)tqp;
 8001566:	e943 5108 	strd	r5, r1, [r3, #-32]
}
 800156a:	bcf0      	pop	{r4, r5, r6, r7}
  tqp->prev = (thread_t *)tqp;
 800156c:	f843 1c18 	str.w	r1, [r3, #-24]
 8001570:	4770      	bx	lr
 8001572:	bf00      	nop
 8001574:	20001254 	.word	0x20001254
 8001578:	08000251 	.word	0x08000251
 800157c:	00000000 	.word	0x00000000

08001580 <wakeup>:
 8001580:	2320      	movs	r3, #32
 8001582:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
 8001586:	f890 3020 	ldrb.w	r3, [r0, #32]
 800158a:	2b07      	cmp	r3, #7
 800158c:	d80e      	bhi.n	80015ac <wakeup+0x2c>
 800158e:	e8df f003 	tbb	[pc, r3]
 8001592:	0d28      	.short	0x0d28
 8001594:	0408240d 	.word	0x0408240d
 8001598:	080d      	.short	0x080d
    chSemFastSignalI(tp->u.wtsemp);
 800159a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 800159c:	6893      	ldr	r3, [r2, #8]
 800159e:	3301      	adds	r3, #1
 80015a0:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80015a2:	e9d0 2300 	ldrd	r2, r3, [r0]
 80015a6:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80015a8:	6802      	ldr	r2, [r0, #0]
 80015aa:	6053      	str	r3, [r2, #4]
static void wakeup(void *p) {
 80015ac:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
 80015ae:	2200      	movs	r2, #0
  tp->u.rdymsg = MSG_TIMEOUT;
 80015b0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  } while (cp->prio >= tp->prio);
 80015b4:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 80015b6:	4b0d      	ldr	r3, [pc, #52]	; (80015ec <wakeup+0x6c>)
  tp->u.rdymsg = MSG_TIMEOUT;
 80015b8:	6244      	str	r4, [r0, #36]	; 0x24
  tp->state = CH_STATE_READY;
 80015ba:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 80015be:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80015c0:	689a      	ldr	r2, [r3, #8]
 80015c2:	428a      	cmp	r2, r1
 80015c4:	d2fb      	bcs.n	80015be <wakeup+0x3e>
  tp->queue.prev             = cp->queue.prev;
 80015c6:	685a      	ldr	r2, [r3, #4]
 80015c8:	2100      	movs	r1, #0
 80015ca:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 80015ce:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80015d0:	6058      	str	r0, [r3, #4]
 80015d2:	f381 8811 	msr	BASEPRI, r1
}
 80015d6:	bc10      	pop	{r4}
 80015d8:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 80015da:	2200      	movs	r2, #0
 80015dc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80015de:	601a      	str	r2, [r3, #0]
 80015e0:	e7e4      	b.n	80015ac <wakeup+0x2c>
 80015e2:	2300      	movs	r3, #0
 80015e4:	f383 8811 	msr	BASEPRI, r3
 80015e8:	4770      	bx	lr
 80015ea:	bf00      	nop
 80015ec:	20001254 	.word	0x20001254

080015f0 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
 80015f0:	4601      	mov	r1, r0
  tp->state = CH_STATE_READY;
 80015f2:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 80015f4:	4b07      	ldr	r3, [pc, #28]	; (8001614 <chSchReadyI+0x24>)
  } while (cp->prio >= tp->prio);
 80015f6:	6880      	ldr	r0, [r0, #8]
  tp->state = CH_STATE_READY;
 80015f8:	f881 2020 	strb.w	r2, [r1, #32]
    cp = cp->queue.next;
 80015fc:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80015fe:	689a      	ldr	r2, [r3, #8]
 8001600:	4282      	cmp	r2, r0
 8001602:	d2fb      	bcs.n	80015fc <chSchReadyI+0xc>
  tp->queue.prev             = cp->queue.prev;
 8001604:	685a      	ldr	r2, [r3, #4]
}
 8001606:	4608      	mov	r0, r1
  tp->queue.prev             = cp->queue.prev;
 8001608:	e9c1 3200 	strd	r3, r2, [r1]
  tp->queue.prev->queue.next = tp;
 800160c:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 800160e:	6059      	str	r1, [r3, #4]
}
 8001610:	4770      	bx	lr
 8001612:	bf00      	nop
 8001614:	20001254 	.word	0x20001254
	...

08001620 <chThdDequeueAllI.constprop.97>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001620:	b538      	push	{r3, r4, r5, lr}
  return (bool)(tqp->next != (const thread_t *)tqp);
 8001622:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
 8001624:	4298      	cmp	r0, r3
 8001626:	d00c      	beq.n	8001642 <chThdDequeueAllI.constprop.97+0x22>
 8001628:	4604      	mov	r4, r0

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 800162a:	f06f 0501 	mvn.w	r5, #1
  tqp->next             = tp->queue.next;
 800162e:	681a      	ldr	r2, [r3, #0]
  (void) chSchReadyI(tp);
 8001630:	4618      	mov	r0, r3
 8001632:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001634:	6054      	str	r4, [r2, #4]
  tp->u.rdymsg = msg;
 8001636:	625d      	str	r5, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8001638:	f7ff ffda 	bl	80015f0 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 800163c:	6823      	ldr	r3, [r4, #0]
 800163e:	42a3      	cmp	r3, r4
 8001640:	d1f5      	bne.n	800162e <chThdDequeueAllI.constprop.97+0xe>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8001642:	bd38      	pop	{r3, r4, r5, pc}
	...

08001650 <chThdDequeueNextI.constprop.95>:
 8001650:	6802      	ldr	r2, [r0, #0]
  if (queue_notempty(tqp)) {
 8001652:	4290      	cmp	r0, r2
 8001654:	d00a      	beq.n	800166c <chThdDequeueNextI.constprop.95+0x1c>
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001656:	b410      	push	{r4}
 8001658:	4603      	mov	r3, r0
  tp->u.rdymsg = msg;
 800165a:	2400      	movs	r4, #0
  tqp->next             = tp->queue.next;
 800165c:	6811      	ldr	r1, [r2, #0]
  (void) chSchReadyI(tp);
 800165e:	4610      	mov	r0, r2
 8001660:	6019      	str	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001662:	604b      	str	r3, [r1, #4]
  tp->u.rdymsg = msg;
 8001664:	6254      	str	r4, [r2, #36]	; 0x24
}
 8001666:	bc10      	pop	{r4}
  (void) chSchReadyI(tp);
 8001668:	f7ff bfc2 	b.w	80015f0 <chSchReadyI>
 800166c:	4770      	bx	lr
 800166e:	bf00      	nop

08001670 <chMBPostI.constprop.37>:

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8001670:	4b0f      	ldr	r3, [pc, #60]	; (80016b0 <chMBPostI.constprop.37+0x40>)
 8001672:	7d1a      	ldrb	r2, [r3, #20]
 8001674:	b9aa      	cbnz	r2, 80016a2 <chMBPostI.constprop.37+0x32>
 */
static inline size_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8001676:	691a      	ldr	r2, [r3, #16]
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8001678:	b570      	push	{r4, r5, r6, lr}
 800167a:	e9d3 6100 	ldrd	r6, r1, [r3]
  return (size_t)(mbp->top - mbp->buffer);
 800167e:	1b8c      	subs	r4, r1, r6
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8001680:	ebb2 0fa4 	cmp.w	r2, r4, asr #2
 8001684:	d010      	beq.n	80016a8 <chMBPostI.constprop.37+0x38>
    *mbp->wrptr++ = msg;
 8001686:	689d      	ldr	r5, [r3, #8]
    if (mbp->wrptr >= mbp->top) {
      mbp->wrptr = mbp->buffer;
    }
    mbp->cnt++;
 8001688:	3201      	adds	r2, #1
    *mbp->wrptr++ = msg;
 800168a:	1d2c      	adds	r4, r5, #4
 800168c:	609c      	str	r4, [r3, #8]
    if (mbp->wrptr >= mbp->top) {
 800168e:	42a1      	cmp	r1, r4
    *mbp->wrptr++ = msg;
 8001690:	6028      	str	r0, [r5, #0]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001692:	4808      	ldr	r0, [pc, #32]	; (80016b4 <chMBPostI.constprop.37+0x44>)
      mbp->wrptr = mbp->buffer;
 8001694:	bf98      	it	ls
 8001696:	609e      	strls	r6, [r3, #8]
    mbp->cnt++;
 8001698:	611a      	str	r2, [r3, #16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 800169a:	f7ff ffd9 	bl	8001650 <chThdDequeueNextI.constprop.95>

    return MSG_OK;
 800169e:	2000      	movs	r0, #0
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
}
 80016a0:	bd70      	pop	{r4, r5, r6, pc}
    return MSG_RESET;
 80016a2:	f06f 0001 	mvn.w	r0, #1
}
 80016a6:	4770      	bx	lr
  return MSG_TIMEOUT;
 80016a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80016ac:	bd70      	pop	{r4, r5, r6, pc}
 80016ae:	bf00      	nop
 80016b0:	20000c58 	.word	0x20000c58
 80016b4:	20000c78 	.word	0x20000c78
	...

080016c0 <chMBPostAheadI.constprop.34>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 80016c0:	b538      	push	{r3, r4, r5, lr}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 80016c2:	4b0f      	ldr	r3, [pc, #60]	; (8001700 <chMBPostAheadI.constprop.34+0x40>)
 80016c4:	7d1a      	ldrb	r2, [r3, #20]
 80016c6:	b9a2      	cbnz	r2, 80016f2 <chMBPostAheadI.constprop.34+0x32>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80016c8:	e9d3 4500 	ldrd	r4, r5, [r3]
 80016cc:	6919      	ldr	r1, [r3, #16]
  return (size_t)(mbp->top - mbp->buffer);
 80016ce:	1b2a      	subs	r2, r5, r4
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 80016d0:	ebb1 0fa2 	cmp.w	r1, r2, asr #2
 80016d4:	d010      	beq.n	80016f8 <chMBPostAheadI.constprop.34+0x38>
    if (--mbp->rdptr < mbp->buffer) {
 80016d6:	68da      	ldr	r2, [r3, #12]
      mbp->rdptr = mbp->top - 1;
    }
    *mbp->rdptr = msg;
    mbp->cnt++;
 80016d8:	3101      	adds	r1, #1
    if (--mbp->rdptr < mbp->buffer) {
 80016da:	3a04      	subs	r2, #4
 80016dc:	4294      	cmp	r4, r2
      mbp->rdptr = mbp->top - 1;
 80016de:	bf88      	it	hi
 80016e0:	1f2a      	subhi	r2, r5, #4
 80016e2:	60da      	str	r2, [r3, #12]
    *mbp->rdptr = msg;
 80016e4:	6010      	str	r0, [r2, #0]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 80016e6:	4807      	ldr	r0, [pc, #28]	; (8001704 <chMBPostAheadI.constprop.34+0x44>)
    mbp->cnt++;
 80016e8:	6119      	str	r1, [r3, #16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 80016ea:	f7ff ffb1 	bl	8001650 <chThdDequeueNextI.constprop.95>

    return MSG_OK;
 80016ee:	2000      	movs	r0, #0
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
}
 80016f0:	bd38      	pop	{r3, r4, r5, pc}
    return MSG_RESET;
 80016f2:	f06f 0001 	mvn.w	r0, #1
}
 80016f6:	bd38      	pop	{r3, r4, r5, pc}
  return MSG_TIMEOUT;
 80016f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80016fc:	bd38      	pop	{r3, r4, r5, pc}
 80016fe:	bf00      	nop
 8001700:	20000c58 	.word	0x20000c58
 8001704:	20000c78 	.word	0x20000c78
	...

08001710 <chMBFetchI.constprop.33>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8001710:	b538      	push	{r3, r4, r5, lr}

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8001712:	4b0f      	ldr	r3, [pc, #60]	; (8001750 <chMBFetchI.constprop.33+0x40>)
 8001714:	7d1a      	ldrb	r2, [r3, #20]
 8001716:	b9a2      	cbnz	r2, 8001742 <chMBFetchI.constprop.33+0x32>
    return MSG_RESET;
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8001718:	691a      	ldr	r2, [r3, #16]
 800171a:	b1aa      	cbz	r2, 8001748 <chMBFetchI.constprop.33+0x38>
    *msgp = *mbp->rdptr++;
 800171c:	68dc      	ldr	r4, [r3, #12]
    if (mbp->rdptr >= mbp->top) {
 800171e:	685d      	ldr	r5, [r3, #4]
    *msgp = *mbp->rdptr++;
 8001720:	1d21      	adds	r1, r4, #4
    if (mbp->rdptr >= mbp->top) {
 8001722:	42a9      	cmp	r1, r5
    *msgp = *mbp->rdptr++;
 8001724:	6824      	ldr	r4, [r4, #0]
 8001726:	60d9      	str	r1, [r3, #12]
      mbp->rdptr = mbp->buffer;
 8001728:	bf28      	it	cs
 800172a:	6819      	ldrcs	r1, [r3, #0]
    *msgp = *mbp->rdptr++;
 800172c:	6004      	str	r4, [r0, #0]
    }
    mbp->cnt--;
 800172e:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8001732:	4808      	ldr	r0, [pc, #32]	; (8001754 <chMBFetchI.constprop.33+0x44>)
      mbp->rdptr = mbp->buffer;
 8001734:	bf28      	it	cs
 8001736:	60d9      	strcs	r1, [r3, #12]
    mbp->cnt--;
 8001738:	611a      	str	r2, [r3, #16]
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 800173a:	f7ff ff89 	bl	8001650 <chThdDequeueNextI.constprop.95>

    return MSG_OK;
 800173e:	2000      	movs	r0, #0
  }

  /* No message, immediate timeout.*/
  return MSG_TIMEOUT;
}
 8001740:	bd38      	pop	{r3, r4, r5, pc}
    return MSG_RESET;
 8001742:	f06f 0001 	mvn.w	r0, #1
}
 8001746:	bd38      	pop	{r3, r4, r5, pc}
  return MSG_TIMEOUT;
 8001748:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 800174c:	bd38      	pop	{r3, r4, r5, pc}
 800174e:	bf00      	nop
 8001750:	20000c58 	.word	0x20000c58
 8001754:	20000c70 	.word	0x20000c70
	...

08001760 <chCondSignalI.constprop.58>:
  return (bool)(tqp->next != (const thread_t *)tqp);
 8001760:	4b07      	ldr	r3, [pc, #28]	; (8001780 <chCondSignalI.constprop.58+0x20>)
 8001762:	681a      	ldr	r2, [r3, #0]
void chCondSignalI(condition_variable_t *cp) {

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
 8001764:	429a      	cmp	r2, r3
 8001766:	d009      	beq.n	800177c <chCondSignalI.constprop.58+0x1c>
void chCondSignalI(condition_variable_t *cp) {
 8001768:	b410      	push	{r4}
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
 800176a:	2400      	movs	r4, #0
  tqp->next             = tp->queue.next;
 800176c:	6811      	ldr	r1, [r2, #0]
    (void) chSchReadyI(tp);
 800176e:	4610      	mov	r0, r2
  tqp->next->queue.prev = (thread_t *)tqp;
 8001770:	604b      	str	r3, [r1, #4]
  tqp->next             = tp->queue.next;
 8001772:	6019      	str	r1, [r3, #0]
    tp->u.rdymsg = MSG_OK;
 8001774:	6254      	str	r4, [r2, #36]	; 0x24
  }
}
 8001776:	bc10      	pop	{r4}
    (void) chSchReadyI(tp);
 8001778:	f7ff bf3a 	b.w	80015f0 <chSchReadyI>
 800177c:	4770      	bx	lr
 800177e:	bf00      	nop
 8001780:	20000c04 	.word	0x20000c04
	...

08001790 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8001790:	4603      	mov	r3, r0
  tp->epending |= events;
 8001792:	6b42      	ldr	r2, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 8001794:	f890 0020 	ldrb.w	r0, [r0, #32]
  tp->epending |= events;
 8001798:	4311      	orrs	r1, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
 800179a:	280a      	cmp	r0, #10
  tp->epending |= events;
 800179c:	6359      	str	r1, [r3, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 800179e:	d00a      	beq.n	80017b6 <chEvtSignalI+0x26>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80017a0:	280b      	cmp	r0, #11
 80017a2:	d000      	beq.n	80017a6 <chEvtSignalI+0x16>
}
 80017a4:	4770      	bx	lr
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80017a6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 80017a8:	438a      	bics	r2, r1
 80017aa:	d1fb      	bne.n	80017a4 <chEvtSignalI+0x14>
    tp->u.rdymsg = MSG_OK;
 80017ac:	2200      	movs	r2, #0
    (void) chSchReadyI(tp);
 80017ae:	4618      	mov	r0, r3
    tp->u.rdymsg = MSG_OK;
 80017b0:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 80017b2:	f7ff bf1d 	b.w	80015f0 <chSchReadyI>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80017b6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 80017b8:	4211      	tst	r1, r2
 80017ba:	d1f7      	bne.n	80017ac <chEvtSignalI+0x1c>
 80017bc:	4770      	bx	lr
 80017be:	bf00      	nop

080017c0 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80017c0:	b570      	push	{r4, r5, r6, lr}
  elp = esp->next;
 80017c2:	6804      	ldr	r4, [r0, #0]
  while (elp != (event_listener_t *)esp) {
 80017c4:	42a0      	cmp	r0, r4
 80017c6:	d00f      	beq.n	80017e8 <chEvtBroadcastFlagsI+0x28>
 80017c8:	4606      	mov	r6, r0
 80017ca:	460d      	mov	r5, r1
    elp->flags |= flags;
 80017cc:	68e3      	ldr	r3, [r4, #12]
 80017ce:	432b      	orrs	r3, r5
 80017d0:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 80017d2:	b115      	cbz	r5, 80017da <chEvtBroadcastFlagsI+0x1a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 80017d4:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 80017d6:	421d      	tst	r5, r3
 80017d8:	d003      	beq.n	80017e2 <chEvtBroadcastFlagsI+0x22>
      chEvtSignalI(elp->listener, elp->events);
 80017da:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 80017de:	f7ff ffd7 	bl	8001790 <chEvtSignalI>
    elp = elp->next;
 80017e2:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80017e4:	42a6      	cmp	r6, r4
 80017e6:	d1f1      	bne.n	80017cc <chEvtBroadcastFlagsI+0xc>
}
 80017e8:	bd70      	pop	{r4, r5, r6, pc}
 80017ea:	bf00      	nop
 80017ec:	0000      	movs	r0, r0
	...

080017f0 <chMtxUnlockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  thread_t *ctp = currp;
 80017f0:	4a12      	ldr	r2, [pc, #72]	; (800183c <chMtxUnlockS+0x4c>)
void chMtxUnlockS(mutex_t *mp) {
 80017f2:	b430      	push	{r4, r5}
  return (bool)(tqp->next != (const thread_t *)tqp);
 80017f4:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80017f6:	68c3      	ldr	r3, [r0, #12]
  thread_t *ctp = currp;
 80017f8:	6995      	ldr	r5, [r2, #24]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80017fa:	4284      	cmp	r4, r0
    ctp->mtxlist = mp->next;
 80017fc:	63ab      	str	r3, [r5, #56]	; 0x38
    if (chMtxQueueNotEmptyS(mp)) {
 80017fe:	d018      	beq.n	8001832 <chMtxUnlockS+0x42>
 8001800:	4601      	mov	r1, r0
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8001802:	6be8      	ldr	r0, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8001804:	b14b      	cbz	r3, 800181a <chMtxUnlockS+0x2a>
 8001806:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8001808:	4293      	cmp	r3, r2
 800180a:	d003      	beq.n	8001814 <chMtxUnlockS+0x24>
 800180c:	6892      	ldr	r2, [r2, #8]
 800180e:	4290      	cmp	r0, r2
 8001810:	bf38      	it	cc
 8001812:	4610      	movcc	r0, r2
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8001814:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 8001816:	2b00      	cmp	r3, #0
 8001818:	d1f5      	bne.n	8001806 <chMtxUnlockS+0x16>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 800181a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  tqp->next             = tp->queue.next;
 800181c:	6823      	ldr	r3, [r4, #0]
      ctp->prio = newprio;
 800181e:	60a8      	str	r0, [r5, #8]
 8001820:	600b      	str	r3, [r1, #0]
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
 8001822:	4620      	mov	r0, r4
  tqp->next->queue.prev = (thread_t *)tqp;
 8001824:	6059      	str	r1, [r3, #4]
      mp->next = tp->mtxlist;
 8001826:	e9c1 4202 	strd	r4, r2, [r1, #8]
      tp->mtxlist = mp;
 800182a:	63a1      	str	r1, [r4, #56]	; 0x38
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800182c:	bc30      	pop	{r4, r5}
      (void) chSchReadyI(tp);
 800182e:	f7ff bedf 	b.w	80015f0 <chSchReadyI>
      mp->owner = NULL;
 8001832:	2300      	movs	r3, #0
 8001834:	60a3      	str	r3, [r4, #8]
}
 8001836:	bc30      	pop	{r4, r5}
 8001838:	4770      	bx	lr
 800183a:	bf00      	nop
 800183c:	20001254 	.word	0x20001254

08001840 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8001840:	6883      	ldr	r3, [r0, #8]
 8001842:	3301      	adds	r3, #1
 8001844:	2b00      	cmp	r3, #0
 8001846:	6083      	str	r3, [r0, #8]
 8001848:	dd00      	ble.n	800184c <chSemSignalI+0xc>
 800184a:	4770      	bx	lr
void chSemSignalI(semaphore_t *sp) {
 800184c:	b410      	push	{r4}
 800184e:	4602      	mov	r2, r0
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 8001850:	2400      	movs	r4, #0
  thread_t *tp = tqp->next;
 8001852:	6803      	ldr	r3, [r0, #0]
  tqp->next             = tp->queue.next;
 8001854:	6819      	ldr	r1, [r3, #0]
    (void) chSchReadyI(tp);
 8001856:	4618      	mov	r0, r3
 8001858:	6011      	str	r1, [r2, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800185a:	604a      	str	r2, [r1, #4]
    tp->u.rdymsg = MSG_OK;
 800185c:	625c      	str	r4, [r3, #36]	; 0x24
  }
}
 800185e:	bc10      	pop	{r4}
    (void) chSchReadyI(tp);
 8001860:	f7ff bec6 	b.w	80015f0 <chSchReadyI>
	...

08001870 <chCacheReleaseObjectI>:
 * @param[in] objp      pointer to the @p oc_object_t structure
 *
 * @iclass
 */
void chCacheReleaseObjectI(objects_cache_t *ocp,
                           oc_object_t *objp) {
 8001870:	e9d1 2308 	ldrd	r2, r3, [r1, #32]
  chDbgAssert(chSemGetCounterI(&objp->obj_sem) <= (cnt_t)0,
              "semaphore counter greater than 0");

  /* If some thread is waiting for this specific buffer then it is
     handed directly without going through the LRU.*/
  if (chSemGetCounterI(&objp->obj_sem) < (cnt_t)0) {
 8001874:	2a00      	cmp	r2, #0
 8001876:	db2e      	blt.n	80018d6 <chCacheReleaseObjectI+0x66>
                           oc_object_t *objp) {
 8001878:	b570      	push	{r4, r5, r6, lr}
    return;
  }

  /* If the object specifies OC_FLAG_NOTSYNC then it must be invalidated
     and removed from the hash table.*/
  if ((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U) {
 800187a:	071d      	lsls	r5, r3, #28
 800187c:	f100 0214 	add.w	r2, r0, #20
 8001880:	d413      	bmi.n	80018aa <chCacheReleaseObjectI+0x3a>
    objp->obj_key   = 0U;
    objp->obj_flags = OC_FLAG_INLRU;
  }
  else {
    /* LRU insertion point depends on the OC_FLAG_FORGET flag.*/
    if ((objp->obj_flags & OC_FLAG_FORGET) == 0U) {
 8001882:	069c      	lsls	r4, r3, #26
 8001884:	d421      	bmi.n	80018ca <chCacheReleaseObjectI+0x5a>
      /* Placing it on head.*/
      LRU_INSERT_HEAD(ocp, objp);
 8001886:	69c4      	ldr	r4, [r0, #28]
 8001888:	e9c1 4202 	strd	r4, r2, [r1, #8]
 800188c:	60e1      	str	r1, [r4, #12]
 800188e:	61c1      	str	r1, [r0, #28]
    }
    else {
      /* Low priority data, placing it on tail.*/
      LRU_INSERT_TAIL(ocp, objp);
    }
    objp->obj_flags &= OC_FLAG_INHASH | OC_FLAG_LAZYWRITE;
 8001890:	f003 0312 	and.w	r3, r3, #18
    objp->obj_flags |= OC_FLAG_INLRU;
 8001894:	f043 0301 	orr.w	r3, r3, #1
 8001898:	624b      	str	r3, [r1, #36]	; 0x24
 800189a:	460c      	mov	r4, r1
  }

  /* Increasing the LRU counter semaphore.*/
  chSemSignalI(&ocp->lru_sem);
 800189c:	3030      	adds	r0, #48	; 0x30
 800189e:	f7ff ffcf 	bl	8001840 <chSemSignalI>
 80018a2:	6a23      	ldr	r3, [r4, #32]
 80018a4:	3301      	adds	r3, #1
 80018a6:	6223      	str	r3, [r4, #32]

  /* Releasing the object, we know there are no threads waiting so
     using the "fast" signal variant.*/
  chSemFastSignalI(&objp->obj_sem);
}
 80018a8:	bd70      	pop	{r4, r5, r6, pc}
    objp->obj_group = 0U;
 80018aa:	2300      	movs	r3, #0
    HASH_REMOVE(objp);
 80018ac:	e9d1 6400 	ldrd	r6, r4, [r1]
    objp->obj_flags = OC_FLAG_INLRU;
 80018b0:	2501      	movs	r5, #1
    HASH_REMOVE(objp);
 80018b2:	6026      	str	r6, [r4, #0]
 80018b4:	680e      	ldr	r6, [r1, #0]
 80018b6:	6074      	str	r4, [r6, #4]
    LRU_INSERT_TAIL(ocp, objp);
 80018b8:	6a04      	ldr	r4, [r0, #32]
 80018ba:	e9c1 2402 	strd	r2, r4, [r1, #8]
 80018be:	60a1      	str	r1, [r4, #8]
 80018c0:	6201      	str	r1, [r0, #32]
    objp->obj_key   = 0U;
 80018c2:	e9c1 3304 	strd	r3, r3, [r1, #16]
    objp->obj_flags = OC_FLAG_INLRU;
 80018c6:	624d      	str	r5, [r1, #36]	; 0x24
 80018c8:	e7e7      	b.n	800189a <chCacheReleaseObjectI+0x2a>
      LRU_INSERT_TAIL(ocp, objp);
 80018ca:	6a04      	ldr	r4, [r0, #32]
 80018cc:	e9c1 2402 	strd	r2, r4, [r1, #8]
 80018d0:	60a1      	str	r1, [r4, #8]
 80018d2:	6201      	str	r1, [r0, #32]
 80018d4:	e7dc      	b.n	8001890 <chCacheReleaseObjectI+0x20>
    objp->obj_flags &= OC_FLAG_INHASH | OC_FLAG_NOTSYNC | OC_FLAG_LAZYWRITE;
 80018d6:	f003 031a 	and.w	r3, r3, #26
 80018da:	624b      	str	r3, [r1, #36]	; 0x24
    chSemSignalI(&objp->obj_sem);
 80018dc:	f101 0018 	add.w	r0, r1, #24
 80018e0:	f7ff bfae 	b.w	8001840 <chSemSignalI>
	...

080018f0 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80018f0:	4b1f      	ldr	r3, [pc, #124]	; (8001970 <chVTDoResetI+0x80>)
void chVTDoResetI(virtual_timer_t *vtp) {
 80018f2:	b430      	push	{r4, r5}
  if (ch.vtlist.next != vtp) {
 80018f4:	69da      	ldr	r2, [r3, #28]
 80018f6:	4282      	cmp	r2, r0
 80018f8:	d00f      	beq.n	800191a <chVTDoResetI+0x2a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 80018fa:	e9d0 2100 	ldrd	r2, r1, [r0]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;
 80018fe:	2400      	movs	r4, #0
    vtp->prev->next = vtp->next;
 8001900:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8001902:	6802      	ldr	r2, [r0, #0]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001904:	331c      	adds	r3, #28
 8001906:	429a      	cmp	r2, r3
    vtp->next->prev = vtp->prev;
 8001908:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 800190a:	60c4      	str	r4, [r0, #12]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800190c:	d003      	beq.n	8001916 <chVTDoResetI+0x26>
      vtp->next->delta += vtp->delta;
 800190e:	6881      	ldr	r1, [r0, #8]
 8001910:	6893      	ldr	r3, [r2, #8]
 8001912:	440b      	add	r3, r1
 8001914:	6093      	str	r3, [r2, #8]
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001916:	bc30      	pop	{r4, r5}
 8001918:	4770      	bx	lr
  ch.vtlist.next = vtp->next;
 800191a:	4618      	mov	r0, r3
  vtp->func = NULL;
 800191c:	2400      	movs	r4, #0
  ch.vtlist.next = vtp->next;
 800191e:	6811      	ldr	r1, [r2, #0]
 8001920:	f840 1f1c 	str.w	r1, [r0, #28]!
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001924:	4281      	cmp	r1, r0
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8001926:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 8001928:	60d4      	str	r4, [r2, #12]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800192a:	d01a      	beq.n	8001962 <chVTDoResetI+0x72>
 800192c:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  ch.vtlist.next->delta += vtp->delta;
 8001930:	6895      	ldr	r5, [r2, #8]
 8001932:	688a      	ldr	r2, [r1, #8]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8001934:	8d18      	ldrh	r0, [r3, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8001936:	1953      	adds	r3, r2, r5
 8001938:	608b      	str	r3, [r1, #8]
 800193a:	6a62      	ldr	r2, [r4, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 800193c:	1a12      	subs	r2, r2, r0
 800193e:	b292      	uxth	r2, r2
  if (nowdelta >= ch.vtlist.next->delta) {
 8001940:	4293      	cmp	r3, r2
 8001942:	d9e8      	bls.n	8001916 <chVTDoResetI+0x26>
  delta = ch.vtlist.next->delta - nowdelta;
 8001944:	1a99      	subs	r1, r3, r2
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001946:	2901      	cmp	r1, #1
 8001948:	d90f      	bls.n	800196a <chVTDoResetI+0x7a>
 800194a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800194e:	4293      	cmp	r3, r2
 8001950:	bf28      	it	cs
 8001952:	4613      	movcs	r3, r2
}
 8001954:	bc30      	pop	{r4, r5}
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8001956:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 800195a:	4403      	add	r3, r0
 800195c:	b29b      	uxth	r3, r3
 800195e:	6353      	str	r3, [r2, #52]	; 0x34
 8001960:	4770      	bx	lr
  STM32_ST_TIM->DIER = 0U;
 8001962:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001966:	60dc      	str	r4, [r3, #12]
 8001968:	e7d5      	b.n	8001916 <chVTDoResetI+0x26>
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800196a:	1c93      	adds	r3, r2, #2
 800196c:	e7f2      	b.n	8001954 <chVTDoResetI+0x64>
 800196e:	bf00      	nop
 8001970:	20001254 	.word	0x20001254
	...

08001980 <chVTDoSetI>:
                vtfunc_t vtfunc, void *par) {
 8001980:	b470      	push	{r4, r5, r6}
  return (systime_t)STM32_ST_TIM->CNT;
 8001982:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8001986:	4d2e      	ldr	r5, [pc, #184]	; (8001a40 <chVTDoSetI+0xc0>)
 8001988:	6a64      	ldr	r4, [r4, #36]	; 0x24
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 800198a:	2901      	cmp	r1, #1
  vtp->func = vtfunc;
 800198c:	e9c0 2303 	strd	r2, r3, [r0, #12]
 8001990:	b2a3      	uxth	r3, r4
 8001992:	69ea      	ldr	r2, [r5, #28]
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001994:	d92e      	bls.n	80019f4 <chVTDoSetI+0x74>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001996:	f105 041c 	add.w	r4, r5, #28
 800199a:	42a2      	cmp	r2, r4
 800199c:	d038      	beq.n	8001a10 <chVTDoSetI+0x90>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 800199e:	8d2e      	ldrh	r6, [r5, #40]	; 0x28
 80019a0:	6894      	ldr	r4, [r2, #8]
  return (sysinterval_t)((systime_t)(end - start));
 80019a2:	1b9b      	subs	r3, r3, r6
 80019a4:	b29b      	uxth	r3, r3
 80019a6:	1859      	adds	r1, r3, r1
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80019a8:	d317      	bcc.n	80019da <chVTDoSetI+0x5a>
      p = p->next;
 80019aa:	6812      	ldr	r2, [r2, #0]
      delta -= p->delta;
 80019ac:	1b09      	subs	r1, r1, r4
 80019ae:	6894      	ldr	r4, [r2, #8]
  while (p->delta < delta) {
 80019b0:	42a1      	cmp	r1, r4
 80019b2:	d904      	bls.n	80019be <chVTDoSetI+0x3e>
    p = p->next;
 80019b4:	6812      	ldr	r2, [r2, #0]
    delta -= p->delta;
 80019b6:	1b09      	subs	r1, r1, r4
  while (p->delta < delta) {
 80019b8:	6894      	ldr	r4, [r2, #8]
 80019ba:	428c      	cmp	r4, r1
 80019bc:	d3fa      	bcc.n	80019b4 <chVTDoSetI+0x34>
  ch.vtlist.delta = (sysinterval_t)-1;
 80019be:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  vtp->prev = vtp->next->prev;
 80019c2:	6853      	ldr	r3, [r2, #4]
 80019c4:	e9c0 2300 	strd	r2, r3, [r0]
  vtp->prev->next = vtp;
 80019c8:	6018      	str	r0, [r3, #0]
  p->prev = vtp;
 80019ca:	6050      	str	r0, [r2, #4]
  vtp->delta = delta;
 80019cc:	6081      	str	r1, [r0, #8]
  p->delta -= delta;
 80019ce:	6893      	ldr	r3, [r2, #8]
 80019d0:	1a59      	subs	r1, r3, r1
 80019d2:	6091      	str	r1, [r2, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 80019d4:	626c      	str	r4, [r5, #36]	; 0x24
}
 80019d6:	bc70      	pop	{r4, r5, r6}
 80019d8:	4770      	bx	lr
    else if (delta < p->delta) {
 80019da:	42a1      	cmp	r1, r4
 80019dc:	d2e8      	bcs.n	80019b0 <chVTDoSetI+0x30>
  return systime + (systime_t)interval;
 80019de:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80019e2:	4299      	cmp	r1, r3
 80019e4:	bf94      	ite	ls
 80019e6:	1876      	addls	r6, r6, r1
 80019e8:	18f6      	addhi	r6, r6, r3
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80019ea:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80019ee:	b2b6      	uxth	r6, r6
 80019f0:	635e      	str	r6, [r3, #52]	; 0x34
 80019f2:	e7dd      	b.n	80019b0 <chVTDoSetI+0x30>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80019f4:	f105 011c 	add.w	r1, r5, #28
 80019f8:	428a      	cmp	r2, r1
      vtp->delta = delay;
 80019fa:	f04f 0102 	mov.w	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80019fe:	d1ce      	bne.n	800199e <chVTDoSetI+0x1e>
      ch.vtlist.lasttime = now;
 8001a00:	852b      	strh	r3, [r5, #40]	; 0x28
      ch.vtlist.prev = vtp;
 8001a02:	e9c5 0007 	strd	r0, r0, [r5, #28]
      vtp->delta = delay;
 8001a06:	460c      	mov	r4, r1
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8001a08:	e9c0 2200 	strd	r2, r2, [r0]
      vtp->delta = delay;
 8001a0c:	6081      	str	r1, [r0, #8]
 8001a0e:	e00b      	b.n	8001a28 <chVTDoSetI+0xa8>
 8001a10:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8001a14:	428c      	cmp	r4, r1
 8001a16:	bf28      	it	cs
 8001a18:	460c      	movcs	r4, r1
      ch.vtlist.lasttime = now;
 8001a1a:	852b      	strh	r3, [r5, #40]	; 0x28
      ch.vtlist.prev = vtp;
 8001a1c:	e9c5 0007 	strd	r0, r0, [r5, #28]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8001a20:	e9c0 2200 	strd	r2, r2, [r0]
 8001a24:	b2a4      	uxth	r4, r4
      vtp->delta = delay;
 8001a26:	6081      	str	r1, [r0, #8]
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8001a28:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 8001a2c:	2000      	movs	r0, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001a2e:	2102      	movs	r1, #2
 8001a30:	4423      	add	r3, r4
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8001a32:	b29b      	uxth	r3, r3
 8001a34:	6353      	str	r3, [r2, #52]	; 0x34
}
 8001a36:	bc70      	pop	{r4, r5, r6}
  STM32_ST_TIM->SR     = 0;
 8001a38:	6110      	str	r0, [r2, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001a3a:	60d1      	str	r1, [r2, #12]
 8001a3c:	4770      	bx	lr
 8001a3e:	bf00      	nop
 8001a40:	20001254 	.word	0x20001254
	...

08001a50 <chSysGetStatusAndLockX.part.1>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001a50:	f3ef 8305 	mrs	r3, IPSR
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001a54:	2320      	movs	r3, #32
 8001a56:	f383 8811 	msr	BASEPRI, r3
    else {
      chSysLock();
    }
  }
  return sts;
}
 8001a5a:	4770      	bx	lr
 8001a5c:	0000      	movs	r0, r0
	...

08001a60 <chSysIntegrityCheckI>:
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8001a60:	07c2      	lsls	r2, r0, #31
bool chSysIntegrityCheckI(unsigned testmask) {
 8001a62:	b410      	push	{r4}
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8001a64:	d510      	bpl.n	8001a88 <chSysIntegrityCheckI+0x28>
    tp = ch.rlist.queue.next;
 8001a66:	4b26      	ldr	r3, [pc, #152]	; (8001b00 <chSysIntegrityCheckI+0xa0>)
 8001a68:	e9d3 1400 	ldrd	r1, r4, [r3]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001a6c:	4299      	cmp	r1, r3
 8001a6e:	d03b      	beq.n	8001ae8 <chSysIntegrityCheckI+0x88>
    n = (cnt_t)0;
 8001a70:	2200      	movs	r2, #0
      tp = tp->queue.next;
 8001a72:	6809      	ldr	r1, [r1, #0]
      n++;
 8001a74:	3201      	adds	r2, #1
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001a76:	4299      	cmp	r1, r3
 8001a78:	d1fb      	bne.n	8001a72 <chSysIntegrityCheckI+0x12>
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001a7a:	428c      	cmp	r4, r1
 8001a7c:	d031      	beq.n	8001ae2 <chSysIntegrityCheckI+0x82>
      tp = tp->queue.prev;
 8001a7e:	6864      	ldr	r4, [r4, #4]
      n--;
 8001a80:	3a01      	subs	r2, #1
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001a82:	429c      	cmp	r4, r3
 8001a84:	d1fb      	bne.n	8001a7e <chSysIntegrityCheckI+0x1e>
    if (n != (cnt_t)0) {
 8001a86:	bb62      	cbnz	r2, 8001ae2 <chSysIntegrityCheckI+0x82>
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 8001a88:	0783      	lsls	r3, r0, #30
 8001a8a:	d512      	bpl.n	8001ab2 <chSysIntegrityCheckI+0x52>
    vtp = ch.vtlist.next;
 8001a8c:	4b1c      	ldr	r3, [pc, #112]	; (8001b00 <chSysIntegrityCheckI+0xa0>)
 8001a8e:	69da      	ldr	r2, [r3, #28]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001a90:	f103 041c 	add.w	r4, r3, #28
 8001a94:	42a2      	cmp	r2, r4
 8001a96:	6a19      	ldr	r1, [r3, #32]
 8001a98:	d02a      	beq.n	8001af0 <chSysIntegrityCheckI+0x90>
    n = (cnt_t)0;
 8001a9a:	2300      	movs	r3, #0
      vtp = vtp->next;
 8001a9c:	6812      	ldr	r2, [r2, #0]
      n++;
 8001a9e:	3301      	adds	r3, #1
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001aa0:	42a2      	cmp	r2, r4
 8001aa2:	d1fb      	bne.n	8001a9c <chSysIntegrityCheckI+0x3c>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001aa4:	4291      	cmp	r1, r2
 8001aa6:	d01c      	beq.n	8001ae2 <chSysIntegrityCheckI+0x82>
      vtp = vtp->prev;
 8001aa8:	6849      	ldr	r1, [r1, #4]
      n--;
 8001aaa:	3b01      	subs	r3, #1
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001aac:	42a1      	cmp	r1, r4
 8001aae:	d1fb      	bne.n	8001aa8 <chSysIntegrityCheckI+0x48>
    if (n != (cnt_t)0) {
 8001ab0:	b9bb      	cbnz	r3, 8001ae2 <chSysIntegrityCheckI+0x82>
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 8001ab2:	f010 0004 	ands.w	r0, r0, #4
 8001ab6:	d012      	beq.n	8001ade <chSysIntegrityCheckI+0x7e>
    tp = ch.rlist.newer;
 8001ab8:	4b11      	ldr	r3, [pc, #68]	; (8001b00 <chSysIntegrityCheckI+0xa0>)
    n = (cnt_t)0;
 8001aba:	2000      	movs	r0, #0
 8001abc:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
    while (tp != (thread_t *)&ch.rlist) {
 8001ac0:	429a      	cmp	r2, r3
 8001ac2:	d019      	beq.n	8001af8 <chSysIntegrityCheckI+0x98>
      tp = tp->newer;
 8001ac4:	6912      	ldr	r2, [r2, #16]
      n++;
 8001ac6:	3001      	adds	r0, #1
    while (tp != (thread_t *)&ch.rlist) {
 8001ac8:	429a      	cmp	r2, r3
 8001aca:	d1fb      	bne.n	8001ac4 <chSysIntegrityCheckI+0x64>
    while (tp != (thread_t *)&ch.rlist) {
 8001acc:	4291      	cmp	r1, r2
 8001ace:	d008      	beq.n	8001ae2 <chSysIntegrityCheckI+0x82>
      tp = tp->older;
 8001ad0:	6949      	ldr	r1, [r1, #20]
      n--;
 8001ad2:	3801      	subs	r0, #1
    while (tp != (thread_t *)&ch.rlist) {
 8001ad4:	4299      	cmp	r1, r3
 8001ad6:	d1fb      	bne.n	8001ad0 <chSysIntegrityCheckI+0x70>
    if (n != (cnt_t)0) {
 8001ad8:	3000      	adds	r0, #0
 8001ada:	bf18      	it	ne
 8001adc:	2001      	movne	r0, #1
}
 8001ade:	bc10      	pop	{r4}
 8001ae0:	4770      	bx	lr
      return true;
 8001ae2:	2001      	movs	r0, #1
}
 8001ae4:	bc10      	pop	{r4}
 8001ae6:	4770      	bx	lr
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001ae8:	429c      	cmp	r4, r3
 8001aea:	d0cd      	beq.n	8001a88 <chSysIntegrityCheckI+0x28>
    n = (cnt_t)0;
 8001aec:	2200      	movs	r2, #0
 8001aee:	e7c6      	b.n	8001a7e <chSysIntegrityCheckI+0x1e>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001af0:	42a1      	cmp	r1, r4
 8001af2:	d0de      	beq.n	8001ab2 <chSysIntegrityCheckI+0x52>
    n = (cnt_t)0;
 8001af4:	2300      	movs	r3, #0
 8001af6:	e7d7      	b.n	8001aa8 <chSysIntegrityCheckI+0x48>
    while (tp != (thread_t *)&ch.rlist) {
 8001af8:	4291      	cmp	r1, r2
 8001afa:	d1e9      	bne.n	8001ad0 <chSysIntegrityCheckI+0x70>
 8001afc:	e7ef      	b.n	8001ade <chSysIntegrityCheckI+0x7e>
 8001afe:	bf00      	nop
 8001b00:	20001254 	.word	0x20001254
	...

08001b10 <rt_test_002_001_execute>:
  test_set_step(1);
 8001b10:	2001      	movs	r0, #1
static void rt_test_002_001_execute(void) {
 8001b12:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 8001b14:	4d23      	ldr	r5, [pc, #140]	; (8001ba4 <rt_test_002_001_execute+0x94>)
 8001b16:	2420      	movs	r4, #32
 8001b18:	6028      	str	r0, [r5, #0]
 8001b1a:	f384 8811 	msr	BASEPRI, r4
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8001b1e:	f7ff ff9f 	bl	8001a60 <chSysIntegrityCheckI>
 8001b22:	2300      	movs	r3, #0
 8001b24:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "ready list check failed");
 8001b28:	f080 0001 	eor.w	r0, r0, #1
 8001b2c:	b2c0      	uxtb	r0, r0
 8001b2e:	491e      	ldr	r1, [pc, #120]	; (8001ba8 <rt_test_002_001_execute+0x98>)
 8001b30:	f7ff f92e 	bl	8000d90 <_test_assert>
 8001b34:	b100      	cbz	r0, 8001b38 <rt_test_002_001_execute+0x28>
}
 8001b36:	bd70      	pop	{r4, r5, r6, pc}
 8001b38:	4606      	mov	r6, r0
  test_set_step(2);
 8001b3a:	2002      	movs	r0, #2
 8001b3c:	6028      	str	r0, [r5, #0]
 8001b3e:	f384 8811 	msr	BASEPRI, r4
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8001b42:	f7ff ff8d 	bl	8001a60 <chSysIntegrityCheckI>
 8001b46:	f386 8811 	msr	BASEPRI, r6
    test_assert(result == false, "virtual timers list check failed");
 8001b4a:	f080 0001 	eor.w	r0, r0, #1
 8001b4e:	b2c0      	uxtb	r0, r0
 8001b50:	4916      	ldr	r1, [pc, #88]	; (8001bac <rt_test_002_001_execute+0x9c>)
 8001b52:	f7ff f91d 	bl	8000d90 <_test_assert>
 8001b56:	4606      	mov	r6, r0
 8001b58:	2800      	cmp	r0, #0
 8001b5a:	d1ec      	bne.n	8001b36 <rt_test_002_001_execute+0x26>
  test_set_step(3);
 8001b5c:	2303      	movs	r3, #3
 8001b5e:	602b      	str	r3, [r5, #0]
 8001b60:	f384 8811 	msr	BASEPRI, r4
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8001b64:	2004      	movs	r0, #4
 8001b66:	f7ff ff7b 	bl	8001a60 <chSysIntegrityCheckI>
 8001b6a:	f386 8811 	msr	BASEPRI, r6
    test_assert(result == false, "registry list check failed");
 8001b6e:	f080 0001 	eor.w	r0, r0, #1
 8001b72:	b2c0      	uxtb	r0, r0
 8001b74:	490e      	ldr	r1, [pc, #56]	; (8001bb0 <rt_test_002_001_execute+0xa0>)
 8001b76:	f7ff f90b 	bl	8000d90 <_test_assert>
 8001b7a:	4606      	mov	r6, r0
 8001b7c:	2800      	cmp	r0, #0
 8001b7e:	d1da      	bne.n	8001b36 <rt_test_002_001_execute+0x26>
  test_set_step(4);
 8001b80:	2304      	movs	r3, #4
 8001b82:	602b      	str	r3, [r5, #0]
 8001b84:	f384 8811 	msr	BASEPRI, r4
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8001b88:	2008      	movs	r0, #8
 8001b8a:	f7ff ff69 	bl	8001a60 <chSysIntegrityCheckI>
 8001b8e:	f386 8811 	msr	BASEPRI, r6
}
 8001b92:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert(result == false, "port layer check failed");
 8001b96:	f080 0001 	eor.w	r0, r0, #1
 8001b9a:	b2c0      	uxtb	r0, r0
 8001b9c:	4905      	ldr	r1, [pc, #20]	; (8001bb4 <rt_test_002_001_execute+0xa4>)
 8001b9e:	f7ff b8f7 	b.w	8000d90 <_test_assert>
 8001ba2:	bf00      	nop
 8001ba4:	20001d94 	.word	0x20001d94
 8001ba8:	0800bebc 	.word	0x0800bebc
 8001bac:	0800bed4 	.word	0x0800bed4
 8001bb0:	0800bef8 	.word	0x0800bef8
 8001bb4:	0800bf14 	.word	0x0800bf14
	...

08001bc0 <_idle_thread>:
static void _idle_thread(void *p) {
 8001bc0:	e7fe      	b.n	8001bc0 <_idle_thread>
 8001bc2:	bf00      	nop
	...

08001bd0 <usb_lld_start_in>:
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8001bd0:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8001bd4:	68c3      	ldr	r3, [r0, #12]
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8001bd6:	b430      	push	{r4, r5}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8001bd8:	695a      	ldr	r2, [r3, #20]

  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
 8001bda:	8a18      	ldrh	r0, [r3, #16]
  n = isp->txsize;
 8001bdc:	6813      	ldr	r3, [r2, #0]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8001bde:	4c1a      	ldr	r4, [pc, #104]	; (8001c48 <usb_lld_start_in+0x78>)
 8001be0:	4298      	cmp	r0, r3
 8001be2:	bf28      	it	cs
 8001be4:	4618      	movcs	r0, r3
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
 8001be6:	60d0      	str	r0, [r2, #12]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8001be8:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8001bea:	010d      	lsls	r5, r1, #4
 8001bec:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001bf0:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
  usb_packet_write_from_buffer(ep, isp->txbuf, n);
 8001bf4:	6894      	ldr	r4, [r2, #8]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8001bf6:	58ea      	ldr	r2, [r5, r3]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8001bf8:	442b      	add	r3, r5
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 8001bfa:	6058      	str	r0, [r3, #4]
  while (i > 0) {
 8001bfc:	b188      	cbz	r0, 8001c22 <usb_lld_start_in+0x52>
 8001bfe:	f102 5200 	add.w	r2, r2, #536870912	; 0x20000000
 8001c02:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 8001c06:	0052      	lsls	r2, r2, #1
 8001c08:	3801      	subs	r0, #1
 8001c0a:	0840      	lsrs	r0, r0, #1
 8001c0c:	1d13      	adds	r3, r2, #4
 8001c0e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8001c12:	e000      	b.n	8001c16 <usb_lld_start_in+0x46>
 8001c14:	3304      	adds	r3, #4
    w |= *buf++ << 8;
 8001c16:	f834 5b02 	ldrh.w	r5, [r4], #2
  while (i > 0) {
 8001c1a:	4298      	cmp	r0, r3
    *pmap++ = (stm32_usb_pma_t)w;
 8001c1c:	6015      	str	r5, [r2, #0]
 8001c1e:	461a      	mov	r2, r3
  while (i > 0) {
 8001c20:	d1f8      	bne.n	8001c14 <usb_lld_start_in+0x44>

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
}
 8001c22:	bc30      	pop	{r4, r5}
 8001c24:	0089      	lsls	r1, r1, #2
 8001c26:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8001c2a:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8001c2e:	680b      	ldr	r3, [r1, #0]
 8001c30:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8001c34:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001c38:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8001c3c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001c40:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001c44:	600b      	str	r3, [r1, #0]
}
 8001c46:	4770      	bx	lr
 8001c48:	40005c00 	.word	0x40005c00
 8001c4c:	00000000 	.word	0x00000000

08001c50 <usb_lld_start_out>:
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8001c50:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8001c54:	68c0      	ldr	r0, [r0, #12]
 8001c56:	6982      	ldr	r2, [r0, #24]
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
 8001c58:	6813      	ldr	r3, [r2, #0]
 8001c5a:	b1bb      	cbz	r3, 8001c8c <usb_lld_start_out+0x3c>
    osp->rxpkts = (uint16_t)((osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8001c5c:	8a40      	ldrh	r0, [r0, #18]
 8001c5e:	4403      	add	r3, r0
 8001c60:	3b01      	subs	r3, #1
 8001c62:	fbb3 f3f0 	udiv	r3, r3, r0
 8001c66:	8193      	strh	r3, [r2, #12]
 8001c68:	0089      	lsls	r1, r1, #2
 8001c6a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8001c6e:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 8001c72:	680b      	ldr	r3, [r1, #0]
 8001c74:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8001c78:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001c7c:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8001c80:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001c84:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001c88:	600b      	str	r3, [r1, #0]
}
 8001c8a:	4770      	bx	lr
    osp->rxpkts = 1;
 8001c8c:	2301      	movs	r3, #1
 8001c8e:	8193      	strh	r3, [r2, #12]
 8001c90:	e7ea      	b.n	8001c68 <usb_lld_start_out+0x18>
 8001c92:	bf00      	nop
	...

08001ca0 <usb_lld_init_endpoint>:
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8001ca0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8001ca4:	b4f0      	push	{r4, r5, r6, r7}
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8001ca6:	68de      	ldr	r6, [r3, #12]
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8001ca8:	6833      	ldr	r3, [r6, #0]
 8001caa:	f013 0303 	ands.w	r3, r3, #3
 8001cae:	d05c      	beq.n	8001d6a <usb_lld_init_endpoint+0xca>
 8001cb0:	2b02      	cmp	r3, #2
 8001cb2:	d966      	bls.n	8001d82 <usb_lld_init_endpoint+0xe2>
 8001cb4:	2b03      	cmp	r3, #3
 8001cb6:	d158      	bne.n	8001d6a <usb_lld_init_endpoint+0xca>
    epr = EPR_EP_TYPE_INTERRUPT;
 8001cb8:	f44f 63c0 	mov.w	r3, #1536	; 0x600
  dp = USB_GET_DESCRIPTOR(ep);
 8001cbc:	4a32      	ldr	r2, [pc, #200]	; (8001d88 <usb_lld_init_endpoint+0xe8>)
  if (epcp->in_state != NULL) {
 8001cbe:	6974      	ldr	r4, [r6, #20]
  dp = USB_GET_DESCRIPTOR(ep);
 8001cc0:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8001cc2:	010f      	lsls	r7, r1, #4
 8001cc4:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8001cc8:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
 8001ccc:	18bd      	adds	r5, r7, r2
  if (epcp->in_state != NULL) {
 8001cce:	b184      	cbz	r4, 8001cf2 <usb_lld_init_endpoint+0x52>
    dp->TXCOUNT0 = 0;
 8001cd0:	f04f 0c00 	mov.w	ip, #0
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8001cd4:	8a34      	ldrh	r4, [r6, #16]
    dp->TXCOUNT0 = 0;
 8001cd6:	f8c5 c004 	str.w	ip, [r5, #4]
  next = usbp->pmnext;
 8001cda:	f8d0 c084 	ldr.w	ip, [r0, #132]	; 0x84
  usbp->pmnext += (size + 1) & ~1;
 8001cde:	3401      	adds	r4, #1
 8001ce0:	f024 0401 	bic.w	r4, r4, #1
 8001ce4:	4464      	add	r4, ip
 8001ce6:	f8c0 4084 	str.w	r4, [r0, #132]	; 0x84
    epr |= EPR_STAT_TX_NAK;
 8001cea:	f043 0320 	orr.w	r3, r3, #32
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8001cee:	f847 c002 	str.w	ip, [r7, r2]
  if (epcp->out_state != NULL) {
 8001cf2:	69b2      	ldr	r2, [r6, #24]
 8001cf4:	b1c2      	cbz	r2, 8001d28 <usb_lld_init_endpoint+0x88>
    if (epcp->out_maxsize > 62)
 8001cf6:	8a74      	ldrh	r4, [r6, #18]
 8001cf8:	2c3e      	cmp	r4, #62	; 0x3e
 8001cfa:	f104 32ff 	add.w	r2, r4, #4294967295	; 0xffffffff
 8001cfe:	d937      	bls.n	8001d70 <usb_lld_init_endpoint+0xd0>
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 8001d00:	f042 021f 	orr.w	r2, r2, #31
 8001d04:	3201      	adds	r2, #1
 8001d06:	4e21      	ldr	r6, [pc, #132]	; (8001d8c <usb_lld_init_endpoint+0xec>)
 8001d08:	1152      	asrs	r2, r2, #5
 8001d0a:	ea46 2282 	orr.w	r2, r6, r2, lsl #10
 8001d0e:	b292      	uxth	r2, r2
    dp->RXCOUNT0 = nblocks;
 8001d10:	60ea      	str	r2, [r5, #12]
  next = usbp->pmnext;
 8001d12:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
  usbp->pmnext += (size + 1) & ~1;
 8001d16:	3401      	adds	r4, #1
 8001d18:	f024 0401 	bic.w	r4, r4, #1
 8001d1c:	4414      	add	r4, r2
 8001d1e:	f8c0 4084 	str.w	r4, [r0, #132]	; 0x84
    epr |= EPR_STAT_RX_NAK;
 8001d22:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 8001d26:	60aa      	str	r2, [r5, #8]
 8001d28:	008a      	lsls	r2, r1, #2
 8001d2a:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8001d2e:	f502 42b8 	add.w	r2, r2, #23552	; 0x5c00
  if (STM32_USB->EPR[ep] & EPR_DTOG_RX) {
 8001d32:	6810      	ldr	r0, [r2, #0]
 8001d34:	0444      	lsls	r4, r0, #17
  if (STM32_USB->EPR[ep] & EPR_DTOG_TX) {
 8001d36:	6810      	ldr	r0, [r2, #0]
    epr |= EPR_DTOG_RX;
 8001d38:	bf48      	it	mi
 8001d3a:	f443 4380 	orrmi.w	r3, r3, #16384	; 0x4000
  if (STM32_USB->EPR[ep] & EPR_DTOG_TX) {
 8001d3e:	0640      	lsls	r0, r0, #25
  EPR_SET(ep, epr | ep);
 8001d40:	f248 0080 	movw	r0, #32896	; 0x8080
  EPR_TOGGLE(ep, epr);
 8001d44:	f647 0470 	movw	r4, #30832	; 0x7870
    epr |= EPR_DTOG_TX;
 8001d48:	bf48      	it	mi
 8001d4a:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
  EPR_SET(ep, epr | ep);
 8001d4e:	4319      	orrs	r1, r3
 8001d50:	f421 4178 	bic.w	r1, r1, #63488	; 0xf800
 8001d54:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8001d58:	4301      	orrs	r1, r0
 8001d5a:	6011      	str	r1, [r2, #0]
  EPR_TOGGLE(ep, epr);
 8001d5c:	6811      	ldr	r1, [r2, #0]
 8001d5e:	4023      	ands	r3, r4
 8001d60:	404b      	eors	r3, r1
 8001d62:	4303      	orrs	r3, r0
 8001d64:	6013      	str	r3, [r2, #0]
}
 8001d66:	bcf0      	pop	{r4, r5, r6, r7}
 8001d68:	4770      	bx	lr
    epr = EPR_EP_TYPE_CONTROL;
 8001d6a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001d6e:	e7a5      	b.n	8001cbc <usb_lld_init_endpoint+0x1c>
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
 8001d70:	f042 0201 	orr.w	r2, r2, #1
 8001d74:	3201      	adds	r2, #1
 8001d76:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 8001d7a:	0252      	lsls	r2, r2, #9
 8001d7c:	f402 427c 	and.w	r2, r2, #64512	; 0xfc00
 8001d80:	e7c6      	b.n	8001d10 <usb_lld_init_endpoint+0x70>
    epr = EPR_EP_TYPE_BULK;
 8001d82:	2300      	movs	r3, #0
 8001d84:	e79a      	b.n	8001cbc <usb_lld_init_endpoint+0x1c>
 8001d86:	bf00      	nop
 8001d88:	40005c00 	.word	0x40005c00
 8001d8c:	ffff8000 	.word	0xffff8000

08001d90 <usb_lld_reset>:
  STM32_USB->BTABLE = BTABLE_ADDR;
 8001d90:	2100      	movs	r1, #0
  if (usbp->config->sof_cb != NULL)
 8001d92:	6843      	ldr	r3, [r0, #4]
void usb_lld_reset(USBDriver *usbp) {
 8001d94:	b4f0      	push	{r4, r5, r6, r7}
  if (usbp->config->sof_cb != NULL)
 8001d96:	68db      	ldr	r3, [r3, #12]
  STM32_USB->DADDR  = DADDR_EF;
 8001d98:	2780      	movs	r7, #128	; 0x80
  if (usbp->config->sof_cb != NULL)
 8001d9a:	428b      	cmp	r3, r1
    cntr |= CNTR_SOFM;
 8001d9c:	bf0c      	ite	eq
 8001d9e:	f44f 461c 	moveq.w	r6, #39936	; 0x9c00
 8001da2:	f44f 461e 	movne.w	r6, #40448	; 0x9e00
  usbp->pmnext = 64;
 8001da6:	2540      	movs	r5, #64	; 0x40
  STM32_USB->BTABLE = BTABLE_ADDR;
 8001da8:	4b05      	ldr	r3, [pc, #20]	; (8001dc0 <usb_lld_reset+0x30>)
  usbp->epc[0] = &ep0config;
 8001daa:	4c06      	ldr	r4, [pc, #24]	; (8001dc4 <usb_lld_reset+0x34>)
  STM32_USB->BTABLE = BTABLE_ADDR;
 8001dac:	6519      	str	r1, [r3, #80]	; 0x50
  STM32_USB->ISTR   = 0;
 8001dae:	6459      	str	r1, [r3, #68]	; 0x44
  STM32_USB->DADDR  = DADDR_EF;
 8001db0:	64df      	str	r7, [r3, #76]	; 0x4c
  STM32_USB->CNTR = cntr;
 8001db2:	641e      	str	r6, [r3, #64]	; 0x40
  usbp->pmnext = 64;
 8001db4:	f8c0 5084 	str.w	r5, [r0, #132]	; 0x84
  usbp->epc[0] = &ep0config;
 8001db8:	60c4      	str	r4, [r0, #12]
}
 8001dba:	bcf0      	pop	{r4, r5, r6, r7}
  usb_lld_init_endpoint(usbp, 0);
 8001dbc:	f7ff bf70 	b.w	8001ca0 <usb_lld_init_endpoint>
 8001dc0:	40005c00 	.word	0x40005c00
 8001dc4:	0800aca0 	.word	0x0800aca0
	...

08001dd0 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
 8001dd0:	f890 2064 	ldrb.w	r2, [r0, #100]	; 0x64
 8001dd4:	2a15      	cmp	r2, #21
 8001dd6:	d815      	bhi.n	8001e04 <_usb_ep0out+0x34>
 8001dd8:	2301      	movs	r3, #1
 8001dda:	f640 6141 	movw	r1, #3649	; 0xe41
 8001dde:	4093      	lsls	r3, r2
 8001de0:	420b      	tst	r3, r1
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8001de2:	b570      	push	{r4, r5, r6, lr}
 8001de4:	4604      	mov	r4, r0
 8001de6:	d125      	bne.n	8001e34 <_usb_ep0out+0x64>
 8001de8:	f413 1580 	ands.w	r5, r3, #1048576	; 0x100000
 8001dec:	d00b      	beq.n	8001e06 <_usb_ep0out+0x36>
    return;
  case USB_EP0_OUT_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8001dee:	68c3      	ldr	r3, [r0, #12]
 8001df0:	699b      	ldr	r3, [r3, #24]
 8001df2:	685b      	ldr	r3, [r3, #4]
 8001df4:	b92b      	cbnz	r3, 8001e02 <_usb_ep0out+0x32>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 8001df6:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8001df8:	b103      	cbz	r3, 8001dfc <_usb_ep0out+0x2c>
      usbp->ep0endcb(usbp);
 8001dfa:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 8001dfc:	2300      	movs	r3, #0
 8001dfe:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8001e02:	bd70      	pop	{r4, r5, r6, pc}
 8001e04:	4770      	bx	lr
 8001e06:	029b      	lsls	r3, r3, #10
 8001e08:	d5fb      	bpl.n	8001e02 <_usb_ep0out+0x32>
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8001e0a:	220b      	movs	r2, #11
 8001e0c:	2320      	movs	r3, #32
 8001e0e:	f880 2064 	strb.w	r2, [r0, #100]	; 0x64
 8001e12:	f383 8811 	msr	BASEPRI, r3
  isp = usbp->epc[ep]->in_state;
 8001e16:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001e18:	8902      	ldrh	r2, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 8001e1a:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001e1c:	f042 0201 	orr.w	r2, r2, #1
 8001e20:	8102      	strh	r2, [r0, #8]
  usb_lld_start_in(usbp, ep);
 8001e22:	4629      	mov	r1, r5
  isp->txbuf  = buf;
 8001e24:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 8001e26:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8001e2a:	f7ff fed1 	bl	8001bd0 <usb_lld_start_in>
 8001e2e:	f385 8811 	msr	BASEPRI, r5
}
 8001e32:	bd70      	pop	{r4, r5, r6, pc}
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8001e34:	f248 0680 	movw	r6, #32896	; 0x8080
 8001e38:	490d      	ldr	r1, [pc, #52]	; (8001e70 <_usb_ep0out+0xa0>)
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001e3a:	6843      	ldr	r3, [r0, #4]
 8001e3c:	680a      	ldr	r2, [r1, #0]
 8001e3e:	681d      	ldr	r5, [r3, #0]
 8001e40:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 8001e44:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001e48:	f082 0210 	eor.w	r2, r2, #16
 8001e4c:	4332      	orrs	r2, r6
 8001e4e:	600a      	str	r2, [r1, #0]
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8001e50:	680b      	ldr	r3, [r1, #0]
 8001e52:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8001e56:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001e5a:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8001e5e:	4333      	orrs	r3, r6
 8001e60:	600b      	str	r3, [r1, #0]
 8001e62:	b10d      	cbz	r5, 8001e68 <_usb_ep0out+0x98>
 8001e64:	2106      	movs	r1, #6
 8001e66:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8001e68:	2306      	movs	r3, #6
 8001e6a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
}
 8001e6e:	bd70      	pop	{r4, r5, r6, pc}
 8001e70:	40005c00 	.word	0x40005c00
	...

08001e80 <_usb_ep0in>:
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001e80:	b538      	push	{r3, r4, r5, lr}
  switch (usbp->ep0state) {
 8001e82:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001e86:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8001e88:	2b15      	cmp	r3, #21
 8001e8a:	d82a      	bhi.n	8001ee2 <_usb_ep0in+0x62>
 8001e8c:	e8df f003 	tbb	[pc, r3]
 8001e90:	2929290b 	.word	0x2929290b
 8001e94:	290b2929 	.word	0x290b2929
 8001e98:	513a2a29 	.word	0x513a2a29
 8001e9c:	29292929 	.word	0x29292929
 8001ea0:	29292929 	.word	0x29292929
 8001ea4:	0b0b      	.short	0x0b0b
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8001ea6:	f248 0080 	movw	r0, #32896	; 0x8080
 8001eaa:	4930      	ldr	r1, [pc, #192]	; (8001f6c <_usb_ep0in+0xec>)
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001eac:	6863      	ldr	r3, [r4, #4]
 8001eae:	680a      	ldr	r2, [r1, #0]
 8001eb0:	681d      	ldr	r5, [r3, #0]
 8001eb2:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 8001eb6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001eba:	f082 0210 	eor.w	r2, r2, #16
 8001ebe:	4302      	orrs	r2, r0
 8001ec0:	600a      	str	r2, [r1, #0]
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8001ec2:	680b      	ldr	r3, [r1, #0]
 8001ec4:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8001ec8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001ecc:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8001ed0:	4303      	orrs	r3, r0
 8001ed2:	600b      	str	r3, [r1, #0]
 8001ed4:	b115      	cbz	r5, 8001edc <_usb_ep0in+0x5c>
 8001ed6:	2106      	movs	r1, #6
 8001ed8:	4620      	mov	r0, r4
 8001eda:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8001edc:	2306      	movs	r3, #6
 8001ede:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
}
 8001ee2:	bd38      	pop	{r3, r4, r5, pc}
  hw |= (uint16_t)*p << 8U;
 8001ee4:	f890 107b 	ldrb.w	r1, [r0, #123]	; 0x7b
 8001ee8:	f890 307a 	ldrb.w	r3, [r0, #122]	; 0x7a
    if ((usbp->ep0n < max) &&
 8001eec:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
    max = (size_t)get_hword(&usbp->setup[6]);
 8001eee:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    if ((usbp->ep0n < max) &&
 8001ef2:	429a      	cmp	r2, r3
 8001ef4:	d206      	bcs.n	8001f04 <_usb_ep0in+0x84>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8001ef6:	68c3      	ldr	r3, [r0, #12]
 8001ef8:	8a1b      	ldrh	r3, [r3, #16]
 8001efa:	fbb2 f5f3 	udiv	r5, r2, r3
 8001efe:	fb03 2515 	mls	r5, r3, r5, r2
    if ((usbp->ep0n < max) &&
 8001f02:	b1ed      	cbz	r5, 8001f40 <_usb_ep0in+0xc0>
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8001f04:	2214      	movs	r2, #20
 8001f06:	2320      	movs	r3, #32
 8001f08:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
 8001f0c:	f383 8811 	msr	BASEPRI, r3
  osp->rxbuf  = buf;
 8001f10:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
 8001f12:	68e3      	ldr	r3, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001f14:	8962      	ldrh	r2, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 8001f16:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001f18:	f042 0201 	orr.w	r2, r2, #1
 8001f1c:	8162      	strh	r2, [r4, #10]
  usb_lld_start_out(usbp, ep);
 8001f1e:	4620      	mov	r0, r4
  osp->rxbuf  = buf;
 8001f20:	609d      	str	r5, [r3, #8]
  osp->rxcnt  = 0;
 8001f22:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_out(usbp, ep);
 8001f26:	4629      	mov	r1, r5
 8001f28:	f7ff fe92 	bl	8001c50 <usb_lld_start_out>
 8001f2c:	f385 8811 	msr	BASEPRI, r5
}
 8001f30:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
 8001f32:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8001f34:	b103      	cbz	r3, 8001f38 <_usb_ep0in+0xb8>
      usbp->ep0endcb(usbp);
 8001f36:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 8001f38:	2300      	movs	r3, #0
 8001f3a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
}
 8001f3e:	bd38      	pop	{r3, r4, r5, pc}
 8001f40:	2320      	movs	r3, #32
 8001f42:	f383 8811 	msr	BASEPRI, r3
  isp = usbp->epc[ep]->in_state;
 8001f46:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001f48:	8902      	ldrh	r2, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 8001f4a:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001f4c:	f042 0201 	orr.w	r2, r2, #1
 8001f50:	8102      	strh	r2, [r0, #8]
  usb_lld_start_in(usbp, ep);
 8001f52:	4629      	mov	r1, r5
  isp->txbuf  = buf;
 8001f54:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 8001f56:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8001f5a:	f7ff fe39 	bl	8001bd0 <usb_lld_start_in>
 8001f5e:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 8001f62:	230a      	movs	r3, #10
 8001f64:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
}
 8001f68:	bd38      	pop	{r3, r4, r5, pc}
 8001f6a:	bf00      	nop
 8001f6c:	40005c00 	.word	0x40005c00

08001f70 <_usb_ep0setup>:
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8001f70:	b570      	push	{r4, r5, r6, lr}
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8001f72:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8001f76:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8001f78:	b113      	cbz	r3, 8001f80 <_usb_ep0setup+0x10>
    usbp->ep0state = USB_EP0_STP_WAITING;
 8001f7a:	2300      	movs	r3, #0
 8001f7c:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
  udp = USB_GET_DESCRIPTOR(ep);
 8001f80:	4bbd      	ldr	r3, [pc, #756]	; (8002278 <_usb_ep0setup+0x308>)
  usbReadSetup(usbp, ep, usbp->setup);
 8001f82:	f104 0274 	add.w	r2, r4, #116	; 0x74
 8001f86:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001f88:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001f8c:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 8001f90:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  pmap = USB_ADDR2PTR(udp->RXADDR0);
 8001f94:	689b      	ldr	r3, [r3, #8]
 8001f96:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8001f9a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8001f9e:	005b      	lsls	r3, r3, #1
 8001fa0:	f103 0010 	add.w	r0, r3, #16
    *(uint16_t *)buf = (uint16_t)*pmap++;
 8001fa4:	6819      	ldr	r1, [r3, #0]
 8001fa6:	3304      	adds	r3, #4
  for (n = 0; n < 4; n++) {
 8001fa8:	4283      	cmp	r3, r0
    *(uint16_t *)buf = (uint16_t)*pmap++;
 8001faa:	f822 1b02 	strh.w	r1, [r2], #2
  for (n = 0; n < 4; n++) {
 8001fae:	d1f9      	bne.n	8001fa4 <_usb_ep0setup+0x34>
  if ((usbp->config->requests_hook_cb == NULL) ||
 8001fb0:	6863      	ldr	r3, [r4, #4]
 8001fb2:	689b      	ldr	r3, [r3, #8]
 8001fb4:	b363      	cbz	r3, 8002010 <_usb_ep0setup+0xa0>
      !(usbp->config->requests_hook_cb(usbp))) {
 8001fb6:	4620      	mov	r0, r4
 8001fb8:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 8001fba:	b348      	cbz	r0, 8002010 <_usb_ep0setup+0xa0>
 8001fbc:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8001fbe:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
  hw |= (uint16_t)*p << 8U;
 8001fc2:	f894 007b 	ldrb.w	r0, [r4, #123]	; 0x7b
 8001fc6:	f894 107a 	ldrb.w	r1, [r4, #122]	; 0x7a
  max = (size_t)get_hword(&usbp->setup[6]);
 8001fca:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
  if (usbp->ep0n > max) {
 8001fce:	4291      	cmp	r1, r2
 8001fd0:	bf2c      	ite	cs
 8001fd2:	4611      	movcs	r1, r2
    usbp->ep0n = max;
 8001fd4:	66e1      	strcc	r1, [r4, #108]	; 0x6c
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001fd6:	061a      	lsls	r2, r3, #24
 8001fd8:	f100 80a3 	bmi.w	8002122 <_usb_ep0setup+0x1b2>
    if (usbp->ep0n != 0U) {
 8001fdc:	2900      	cmp	r1, #0
 8001fde:	d073      	beq.n	80020c8 <_usb_ep0setup+0x158>
      usbp->ep0state = USB_EP0_OUT_RX;
 8001fe0:	2215      	movs	r2, #21
 8001fe2:	2320      	movs	r3, #32
 8001fe4:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
 8001fe8:	f383 8811 	msr	BASEPRI, r3
  osp->rxcnt  = 0;
 8001fec:	2500      	movs	r5, #0
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 8001fee:	e9d4 611a 	ldrd	r6, r1, [r4, #104]	; 0x68
  osp = usbp->epc[ep]->out_state;
 8001ff2:	68e3      	ldr	r3, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001ff4:	8962      	ldrh	r2, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 8001ff6:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001ff8:	f042 0201 	orr.w	r2, r2, #1
 8001ffc:	8162      	strh	r2, [r4, #10]
  usb_lld_start_out(usbp, ep);
 8001ffe:	4620      	mov	r0, r4
  osp->rxcnt  = 0;
 8002000:	e883 0062 	stmia.w	r3, {r1, r5, r6}
  usb_lld_start_out(usbp, ep);
 8002004:	4629      	mov	r1, r5
 8002006:	f7ff fe23 	bl	8001c50 <usb_lld_start_out>
 800200a:	f385 8811 	msr	BASEPRI, r5
}
 800200e:	bd70      	pop	{r4, r5, r6, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8002010:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8002014:	f013 0560 	ands.w	r5, r3, #96	; 0x60
 8002018:	4618      	mov	r0, r3
 800201a:	d01e      	beq.n	800205a <_usb_ep0setup+0xea>
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 800201c:	f248 0080 	movw	r0, #32896	; 0x8080
 8002020:	4995      	ldr	r1, [pc, #596]	; (8002278 <_usb_ep0setup+0x308>)
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8002022:	6863      	ldr	r3, [r4, #4]
 8002024:	680a      	ldr	r2, [r1, #0]
 8002026:	681d      	ldr	r5, [r3, #0]
 8002028:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 800202c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002030:	f082 0210 	eor.w	r2, r2, #16
 8002034:	4302      	orrs	r2, r0
 8002036:	600a      	str	r2, [r1, #0]
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8002038:	680b      	ldr	r3, [r1, #0]
 800203a:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 800203e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002042:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8002046:	4303      	orrs	r3, r0
 8002048:	600b      	str	r3, [r1, #0]
 800204a:	b115      	cbz	r5, 8002052 <_usb_ep0setup+0xe2>
 800204c:	2106      	movs	r1, #6
 800204e:	4620      	mov	r0, r4
 8002050:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
 8002052:	2306      	movs	r3, #6
 8002054:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
}
 8002058:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800205a:	f240 3102 	movw	r1, #770	; 0x302
           ((uint32_t)usbp->setup[1] << 8U))) {
 800205e:	f894 6075 	ldrb.w	r6, [r4, #117]	; 0x75
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002062:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 8002066:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800206a:	428a      	cmp	r2, r1
 800206c:	f000 8122 	beq.w	80022b4 <_usb_ep0setup+0x344>
 8002070:	d841      	bhi.n	80020f6 <_usb_ep0setup+0x186>
 8002072:	2a02      	cmp	r2, #2
 8002074:	f000 8106 	beq.w	8002284 <_usb_ep0setup+0x314>
 8002078:	f240 80c3 	bls.w	8002202 <_usb_ep0setup+0x292>
 800207c:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
 8002080:	f000 80c8 	beq.w	8002214 <_usb_ep0setup+0x2a4>
 8002084:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8002088:	f000 8093 	beq.w	80021b2 <_usb_ep0setup+0x242>
 800208c:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8002090:	d1c4      	bne.n	800201c <_usb_ep0setup+0xac>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8002092:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8002096:	2b01      	cmp	r3, #1
 8002098:	d1c0      	bne.n	800201c <_usb_ep0setup+0xac>
      usbp->status &= ~2U;
 800209a:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800209e:	66a5      	str	r5, [r4, #104]	; 0x68
      usbp->status &= ~2U;
 80020a0:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80020a4:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
      usbp->status &= ~2U;
 80020a8:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
 80020ac:	e00a      	b.n	80020c4 <_usb_ep0setup+0x154>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80020ae:	f5b2 6fc0 	cmp.w	r2, #1536	; 0x600
 80020b2:	f080 808d 	bcs.w	80021d0 <_usb_ep0setup+0x260>
 80020b6:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 80020ba:	d1af      	bne.n	800201c <_usb_ep0setup+0xac>
    usbSetupTransfer(usbp, NULL, 0, set_address);
 80020bc:	4b6f      	ldr	r3, [pc, #444]	; (800227c <_usb_ep0setup+0x30c>)
 80020be:	e9c4 551a 	strd	r5, r5, [r4, #104]	; 0x68
 80020c2:	6723      	str	r3, [r4, #112]	; 0x70
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80020c4:	0603      	lsls	r3, r0, #24
 80020c6:	d445      	bmi.n	8002154 <_usb_ep0setup+0x1e4>
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 80020c8:	220b      	movs	r2, #11
 80020ca:	2320      	movs	r3, #32
 80020cc:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
 80020d0:	f383 8811 	msr	BASEPRI, r3
  isp->txbuf  = buf;
 80020d4:	2500      	movs	r5, #0
  isp = usbp->epc[ep]->in_state;
 80020d6:	68e3      	ldr	r3, [r4, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80020d8:	8922      	ldrh	r2, [r4, #8]
  isp = usbp->epc[ep]->in_state;
 80020da:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80020dc:	f042 0201 	orr.w	r2, r2, #1
 80020e0:	8122      	strh	r2, [r4, #8]
  usb_lld_start_in(usbp, ep);
 80020e2:	4620      	mov	r0, r4
  isp->txbuf  = buf;
 80020e4:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 80020e6:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 80020ea:	4629      	mov	r1, r5
 80020ec:	f7ff fd70 	bl	8001bd0 <usb_lld_start_in>
 80020f0:	f385 8811 	msr	BASEPRI, r5
}
 80020f4:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80020f6:	f240 6101 	movw	r1, #1537	; 0x601
 80020fa:	428a      	cmp	r2, r1
 80020fc:	d9d7      	bls.n	80020ae <_usb_ep0setup+0x13e>
 80020fe:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
 8002102:	d03e      	beq.n	8002182 <_usb_ep0setup+0x212>
 8002104:	f640 4102 	movw	r1, #3074	; 0xc02
 8002108:	428a      	cmp	r2, r1
 800210a:	f000 80ae 	beq.w	800226a <_usb_ep0setup+0x2fa>
 800210e:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 8002112:	d183      	bne.n	800201c <_usb_ep0setup+0xac>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8002114:	2201      	movs	r2, #1
 8002116:	f104 017f 	add.w	r1, r4, #127	; 0x7f
 800211a:	e9c4 251b 	strd	r2, r5, [r4, #108]	; 0x6c
 800211e:	66a1      	str	r1, [r4, #104]	; 0x68
 8002120:	e74f      	b.n	8001fc2 <_usb_ep0setup+0x52>
    if (usbp->ep0n != 0U) {
 8002122:	b1b9      	cbz	r1, 8002154 <_usb_ep0setup+0x1e4>
      usbp->ep0state = USB_EP0_IN_TX;
 8002124:	2209      	movs	r2, #9
 8002126:	2320      	movs	r3, #32
 8002128:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
 800212c:	f383 8811 	msr	BASEPRI, r3
  isp->txcnt  = 0;
 8002130:	2500      	movs	r5, #0
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8002132:	e9d4 611a 	ldrd	r6, r1, [r4, #104]	; 0x68
  isp = usbp->epc[ep]->in_state;
 8002136:	68e3      	ldr	r3, [r4, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8002138:	8922      	ldrh	r2, [r4, #8]
  isp = usbp->epc[ep]->in_state;
 800213a:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800213c:	f042 0201 	orr.w	r2, r2, #1
 8002140:	8122      	strh	r2, [r4, #8]
  usb_lld_start_in(usbp, ep);
 8002142:	4620      	mov	r0, r4
  isp->txcnt  = 0;
 8002144:	e883 0062 	stmia.w	r3, {r1, r5, r6}
  usb_lld_start_in(usbp, ep);
 8002148:	4629      	mov	r1, r5
 800214a:	f7ff fd41 	bl	8001bd0 <usb_lld_start_in>
 800214e:	f385 8811 	msr	BASEPRI, r5
}
 8002152:	bd70      	pop	{r4, r5, r6, pc}
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8002154:	2214      	movs	r2, #20
 8002156:	2320      	movs	r3, #32
 8002158:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
 800215c:	f383 8811 	msr	BASEPRI, r3
  osp->rxbuf  = buf;
 8002160:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
 8002162:	68e3      	ldr	r3, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8002164:	8962      	ldrh	r2, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 8002166:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8002168:	f042 0201 	orr.w	r2, r2, #1
 800216c:	8162      	strh	r2, [r4, #10]
  usb_lld_start_out(usbp, ep);
 800216e:	4620      	mov	r0, r4
  osp->rxbuf  = buf;
 8002170:	609d      	str	r5, [r3, #8]
  osp->rxcnt  = 0;
 8002172:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_out(usbp, ep);
 8002176:	4629      	mov	r1, r5
 8002178:	f7ff fd6a 	bl	8001c50 <usb_lld_start_out>
 800217c:	f385 8811 	msr	BASEPRI, r5
}
 8002180:	bd70      	pop	{r4, r5, r6, pc}
      if (usbp->state == USB_ACTIVE) {
 8002182:	7823      	ldrb	r3, [r4, #0]
 8002184:	2b04      	cmp	r3, #4
 8002186:	f000 80c1 	beq.w	800230c <_usb_ep0setup+0x39c>
      if (usbp->setup[2] != 0U) {
 800218a:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 800218e:	b14b      	cbz	r3, 80021a4 <_usb_ep0setup+0x234>
        usbp->state = USB_ACTIVE;
 8002190:	2104      	movs	r1, #4
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8002192:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
 8002194:	f884 307f 	strb.w	r3, [r4, #127]	; 0x7f
        usbp->state = USB_ACTIVE;
 8002198:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800219a:	6813      	ldr	r3, [r2, #0]
 800219c:	b113      	cbz	r3, 80021a4 <_usb_ep0setup+0x234>
 800219e:	2102      	movs	r1, #2
 80021a0:	4620      	mov	r0, r4
 80021a2:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80021a4:	2300      	movs	r3, #0
 80021a6:	f894 0074 	ldrb.w	r0, [r4, #116]	; 0x74
 80021aa:	e9c4 331a 	strd	r3, r3, [r4, #104]	; 0x68
 80021ae:	6723      	str	r3, [r4, #112]	; 0x70
 80021b0:	e788      	b.n	80020c4 <_usb_ep0setup+0x154>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80021b2:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 80021b6:	2b01      	cmp	r3, #1
 80021b8:	f47f af30 	bne.w	800201c <_usb_ep0setup+0xac>
      usbp->status |= 2U;
 80021bc:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80021c0:	66a5      	str	r5, [r4, #104]	; 0x68
      usbp->status |= 2U;
 80021c2:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80021c6:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
      usbp->status |= 2U;
 80021ca:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
 80021ce:	e779      	b.n	80020c4 <_usb_ep0setup+0x154>
  hw |= (uint16_t)*p << 8U;
 80021d0:	f894 1079 	ldrb.w	r1, [r4, #121]	; 0x79
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80021d4:	6862      	ldr	r2, [r4, #4]
  hw |= (uint16_t)*p << 8U;
 80021d6:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80021da:	6856      	ldr	r6, [r2, #4]
 80021dc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80021e0:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 80021e4:	f894 1077 	ldrb.w	r1, [r4, #119]	; 0x77
 80021e8:	4620      	mov	r0, r4
 80021ea:	47b0      	blx	r6
    if (dp == NULL) {
 80021ec:	2800      	cmp	r0, #0
 80021ee:	f43f af15 	beq.w	800201c <_usb_ep0setup+0xac>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 80021f2:	e9d0 2300 	ldrd	r2, r3, [r0]
 80021f6:	6725      	str	r5, [r4, #112]	; 0x70
 80021f8:	e9c4 321a 	strd	r3, r2, [r4, #104]	; 0x68
 80021fc:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8002200:	e6df      	b.n	8001fc2 <_usb_ep0setup+0x52>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002202:	bb7a      	cbnz	r2, 8002264 <_usb_ep0setup+0x2f4>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8002204:	2102      	movs	r1, #2
 8002206:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 800220a:	e9c4 121b 	strd	r1, r2, [r4, #108]	; 0x6c
 800220e:	66a0      	str	r0, [r4, #104]	; 0x68
 8002210:	460a      	mov	r2, r1
 8002212:	e6d6      	b.n	8001fc2 <_usb_ep0setup+0x52>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8002214:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8002218:	2b00      	cmp	r3, #0
 800221a:	f47f aeff 	bne.w	800201c <_usb_ep0setup+0xac>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800221e:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 8002222:	f012 030f 	ands.w	r3, r2, #15
 8002226:	d018      	beq.n	800225a <_usb_ep0setup+0x2ea>
 8002228:	009b      	lsls	r3, r3, #2
 800222a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800222e:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8002232:	f012 0f80 	tst.w	r2, #128	; 0x80

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 8002236:	681a      	ldr	r2, [r3, #0]
 8002238:	f040 8099 	bne.w	800236e <_usb_ep0setup+0x3fe>
  if ((STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) != EPR_STAT_RX_VALID)
 800223c:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8002240:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 8002244:	d009      	beq.n	800225a <_usb_ep0setup+0x2ea>
    EPR_SET_STAT_TX(ep, EPR_STAT_RX_NAK);
 8002246:	681a      	ldr	r2, [r3, #0]
 8002248:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 800224c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002250:	f442 4220 	orr.w	r2, r2, #40960	; 0xa000
 8002254:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002258:	601a      	str	r2, [r3, #0]
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800225a:	2300      	movs	r3, #0
 800225c:	e9c4 331a 	strd	r3, r3, [r4, #104]	; 0x68
 8002260:	6723      	str	r3, [r4, #112]	; 0x70
 8002262:	e72f      	b.n	80020c4 <_usb_ep0setup+0x154>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002264:	2a01      	cmp	r2, #1
 8002266:	f47f aed9 	bne.w	800201c <_usb_ep0setup+0xac>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 800226a:	2202      	movs	r2, #2
 800226c:	2000      	movs	r0, #0
 800226e:	4904      	ldr	r1, [pc, #16]	; (8002280 <_usb_ep0setup+0x310>)
 8002270:	e9c4 201b 	strd	r2, r0, [r4, #108]	; 0x6c
 8002274:	66a1      	str	r1, [r4, #104]	; 0x68
 8002276:	e6a4      	b.n	8001fc2 <_usb_ep0setup+0x52>
 8002278:	40005c00 	.word	0x40005c00
 800227c:	080023f1 	.word	0x080023f1
 8002280:	0800d570 	.word	0x0800d570
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8002284:	f894 1078 	ldrb.w	r1, [r4, #120]	; 0x78
 8002288:	f001 000f 	and.w	r0, r1, #15
 800228c:	f011 0f80 	tst.w	r1, #128	; 0x80
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 8002290:	4946      	ldr	r1, [pc, #280]	; (80023ac <_usb_ep0setup+0x43c>)
 8002292:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 8002296:	d12c      	bne.n	80022f2 <_usb_ep0setup+0x382>
  switch (STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) {
 8002298:	f411 5140 	ands.w	r1, r1, #12288	; 0x3000
 800229c:	f43f aebe 	beq.w	800201c <_usb_ep0setup+0xac>
 80022a0:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 80022a4:	d12b      	bne.n	80022fe <_usb_ep0setup+0x38e>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 80022a6:	2502      	movs	r5, #2
 80022a8:	2000      	movs	r0, #0
 80022aa:	4941      	ldr	r1, [pc, #260]	; (80023b0 <_usb_ep0setup+0x440>)
 80022ac:	e9c4 501b 	strd	r5, r0, [r4, #108]	; 0x6c
 80022b0:	66a1      	str	r1, [r4, #104]	; 0x68
 80022b2:	e686      	b.n	8001fc2 <_usb_ep0setup+0x52>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80022b4:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 80022b8:	2b00      	cmp	r3, #0
 80022ba:	f47f aeaf 	bne.w	800201c <_usb_ep0setup+0xac>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80022be:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 80022c2:	f012 030f 	ands.w	r3, r2, #15
 80022c6:	d0c8      	beq.n	800225a <_usb_ep0setup+0x2ea>
 80022c8:	009b      	lsls	r3, r3, #2
 80022ca:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80022ce:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80022d2:	f012 0f80 	tst.w	r2, #128	; 0x80
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 80022d6:	681a      	ldr	r2, [r3, #0]
 80022d8:	d15b      	bne.n	8002392 <_usb_ep0setup+0x422>
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 80022da:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 80022de:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 80022e2:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
 80022e6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80022ea:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80022ee:	601a      	str	r2, [r3, #0]
 80022f0:	e7b3      	b.n	800225a <_usb_ep0setup+0x2ea>
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 80022f2:	f011 0130 	ands.w	r1, r1, #48	; 0x30
 80022f6:	f43f ae91 	beq.w	800201c <_usb_ep0setup+0xac>
 80022fa:	2910      	cmp	r1, #16
 80022fc:	d0d3      	beq.n	80022a6 <_usb_ep0setup+0x336>
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 80022fe:	2502      	movs	r5, #2
 8002300:	2000      	movs	r0, #0
 8002302:	492c      	ldr	r1, [pc, #176]	; (80023b4 <_usb_ep0setup+0x444>)
 8002304:	e9c4 501b 	strd	r5, r0, [r4, #108]	; 0x6c
 8002308:	66a1      	str	r1, [r4, #104]	; 0x68
 800230a:	e65a      	b.n	8001fc2 <_usb_ep0setup+0x52>
 800230c:	2320      	movs	r3, #32
 800230e:	f383 8811 	msr	BASEPRI, r3
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8002312:	2201      	movs	r2, #1
  usbp->pmnext = 64;
 8002314:	2640      	movs	r6, #64	; 0x40
    EPR_TOGGLE(i, 0);
 8002316:	f248 0080 	movw	r0, #32896	; 0x8080
  usbp->transmitting &= 1U;
 800231a:	8921      	ldrh	r1, [r4, #8]
  usbp->receiving    &= 1U;
 800231c:	8963      	ldrh	r3, [r4, #10]
    usbp->epc[i] = NULL;
 800231e:	e9c4 5504 	strd	r5, r5, [r4, #16]
 8002322:	e9c4 5506 	strd	r5, r5, [r4, #24]
 8002326:	e9c4 5508 	strd	r5, r5, [r4, #32]
  usbp->transmitting &= 1U;
 800232a:	4011      	ands	r1, r2
  usbp->receiving    &= 1U;
 800232c:	4013      	ands	r3, r2
    usbp->epc[i] = NULL;
 800232e:	62a5      	str	r5, [r4, #40]	; 0x28
  usbp->transmitting &= 1U;
 8002330:	8121      	strh	r1, [r4, #8]
  usbp->receiving    &= 1U;
 8002332:	8163      	strh	r3, [r4, #10]
  usbp->pmnext = 64;
 8002334:	f8c4 6084 	str.w	r6, [r4, #132]	; 0x84
 8002338:	0093      	lsls	r3, r2, #2
 800233a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800233e:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
    EPR_TOGGLE(i, 0);
 8002342:	6819      	ldr	r1, [r3, #0]
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8002344:	3201      	adds	r2, #1
    EPR_TOGGLE(i, 0);
 8002346:	4301      	orrs	r1, r0
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8002348:	2a08      	cmp	r2, #8
    EPR_TOGGLE(i, 0);
 800234a:	6019      	str	r1, [r3, #0]
    EPR_SET(i, 0);
 800234c:	6018      	str	r0, [r3, #0]
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 800234e:	d1f3      	bne.n	8002338 <_usb_ep0setup+0x3c8>
 8002350:	2300      	movs	r3, #0
 8002352:	f383 8811 	msr	BASEPRI, r3
        usbp->state = USB_SELECTED;
 8002356:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8002358:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = 0U;
 800235a:	f884 307f 	strb.w	r3, [r4, #127]	; 0x7f
        usbp->state = USB_SELECTED;
 800235e:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8002360:	6813      	ldr	r3, [r2, #0]
 8002362:	2b00      	cmp	r3, #0
 8002364:	f43f af11 	beq.w	800218a <_usb_ep0setup+0x21a>
 8002368:	4620      	mov	r0, r4
 800236a:	4798      	blx	r3
 800236c:	e70d      	b.n	800218a <_usb_ep0setup+0x21a>
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 800236e:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8002372:	2a30      	cmp	r2, #48	; 0x30
 8002374:	f43f af71 	beq.w	800225a <_usb_ep0setup+0x2ea>
    EPR_SET_STAT_TX(ep, EPR_STAT_TX_NAK);
 8002378:	681a      	ldr	r2, [r3, #0]
 800237a:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 800237e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002382:	f082 0220 	eor.w	r2, r2, #32
 8002386:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800238a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800238e:	601a      	str	r2, [r3, #0]
 8002390:	e763      	b.n	800225a <_usb_ep0setup+0x2ea>
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8002392:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 8002396:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800239a:	f082 0210 	eor.w	r2, r2, #16
 800239e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80023a2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80023a6:	601a      	str	r2, [r3, #0]
 80023a8:	e757      	b.n	800225a <_usb_ep0setup+0x2ea>
 80023aa:	bf00      	nop
 80023ac:	40005c00 	.word	0x40005c00
 80023b0:	0800ad18 	.word	0x0800ad18
 80023b4:	0800a9d0 	.word	0x0800a9d0
	...

080023c0 <usbStartTransmitI>:
                       const uint8_t *buf, size_t n) {
 80023c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80023c2:	2401      	movs	r4, #1
  isp->txcnt  = 0;
 80023c4:	2700      	movs	r7, #0
  isp = usbp->epc[ep]->in_state;
 80023c6:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 80023ca:	f8dc e00c 	ldr.w	lr, [ip, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80023ce:	f8b0 c008 	ldrh.w	ip, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 80023d2:	f8de 5014 	ldr.w	r5, [lr, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80023d6:	408c      	lsls	r4, r1
 80023d8:	ea44 040c 	orr.w	r4, r4, ip
 80023dc:	8104      	strh	r4, [r0, #8]
  isp->txbuf  = buf;
 80023de:	60aa      	str	r2, [r5, #8]
  isp->txcnt  = 0;
 80023e0:	e9c5 3700 	strd	r3, r7, [r5]
}
 80023e4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  usb_lld_start_in(usbp, ep);
 80023e8:	f7ff bbf2 	b.w	8001bd0 <usb_lld_start_in>
 80023ec:	0000      	movs	r0, r0
	...

080023f0 <set_address>:
  usbp->address = usbp->setup[2];
 80023f0:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80023f4:	6842      	ldr	r2, [r0, #4]
  usbp->address = usbp->setup[2];
 80023f6:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
  STM32_USB->DADDR = (uint32_t)(usbp->address) | DADDR_EF;
 80023fa:	4906      	ldr	r1, [pc, #24]	; (8002414 <set_address+0x24>)
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80023fc:	6812      	ldr	r2, [r2, #0]
 80023fe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
static void set_address(USBDriver *usbp) {
 8002402:	b510      	push	{r4, lr}
 8002404:	4604      	mov	r4, r0
 8002406:	64cb      	str	r3, [r1, #76]	; 0x4c
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8002408:	b10a      	cbz	r2, 800240e <set_address+0x1e>
 800240a:	2101      	movs	r1, #1
 800240c:	4790      	blx	r2
  usbp->state = USB_SELECTED;
 800240e:	2303      	movs	r3, #3
 8002410:	7023      	strb	r3, [r4, #0]
}
 8002412:	bd10      	pop	{r4, pc}
 8002414:	40005c00 	.word	0x40005c00
	...

08002420 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 8002420:	4770      	bx	lr
 8002422:	bf00      	nop
	...

08002430 <sduRequestsHook>:
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8002430:	f890 3074 	ldrb.w	r3, [r0, #116]	; 0x74
bool sduRequestsHook(USBDriver *usbp) {
 8002434:	4602      	mov	r2, r0
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8002436:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800243a:	2b20      	cmp	r3, #32
 800243c:	d001      	beq.n	8002442 <sduRequestsHook+0x12>
      return false;
 800243e:	2000      	movs	r0, #0
}
 8002440:	4770      	bx	lr
    switch (usbp->setup[1]) {
 8002442:	f890 3075 	ldrb.w	r3, [r0, #117]	; 0x75
 8002446:	2b20      	cmp	r3, #32
 8002448:	d3f9      	bcc.n	800243e <sduRequestsHook+0xe>
 800244a:	2b21      	cmp	r3, #33	; 0x21
 800244c:	d807      	bhi.n	800245e <sduRequestsHook+0x2e>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800244e:	2007      	movs	r0, #7
 8002450:	2100      	movs	r1, #0
 8002452:	4b07      	ldr	r3, [pc, #28]	; (8002470 <sduRequestsHook+0x40>)
 8002454:	e9c2 011b 	strd	r0, r1, [r2, #108]	; 0x6c
 8002458:	6693      	str	r3, [r2, #104]	; 0x68
      return true;
 800245a:	2001      	movs	r0, #1
 800245c:	4770      	bx	lr
    switch (usbp->setup[1]) {
 800245e:	2b22      	cmp	r3, #34	; 0x22
 8002460:	d1ed      	bne.n	800243e <sduRequestsHook+0xe>
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002462:	2300      	movs	r3, #0
      return true;
 8002464:	2001      	movs	r0, #1
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002466:	e9c2 331a 	strd	r3, r3, [r2, #104]	; 0x68
 800246a:	6713      	str	r3, [r2, #112]	; 0x70
 800246c:	4770      	bx	lr
 800246e:	bf00      	nop
 8002470:	20000c30 	.word	0x20000c30
	...

08002480 <_ctl>:
}
 8002480:	2000      	movs	r0, #0
 8002482:	4770      	bx	lr
	...

08002490 <sdu_start_receive>:
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8002490:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8002492:	f8d0 148c 	ldr.w	r1, [r0, #1164]	; 0x48c
 8002496:	680a      	ldr	r2, [r1, #0]
 8002498:	7813      	ldrb	r3, [r2, #0]
 800249a:	2b04      	cmp	r3, #4
 800249c:	d001      	beq.n	80024a2 <sdu_start_receive+0x12>
    return true;
 800249e:	2001      	movs	r0, #1
}
 80024a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80024a2:	7a03      	ldrb	r3, [r0, #8]
 80024a4:	2b02      	cmp	r3, #2
 80024a6:	d1fa      	bne.n	800249e <sdu_start_receive+0xe>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80024a8:	2301      	movs	r3, #1
 80024aa:	790c      	ldrb	r4, [r1, #4]
 80024ac:	8955      	ldrh	r5, [r2, #10]
 80024ae:	fa03 f404 	lsl.w	r4, r3, r4
 80024b2:	4225      	tst	r5, r4
 80024b4:	d1f3      	bne.n	800249e <sdu_start_receive+0xe>
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  if (ibqIsFullI(ibqp)) {
 80024b6:	e9d0 4607 	ldrd	r4, r6, [r0, #28]
 80024ba:	42b4      	cmp	r4, r6
 80024bc:	d015      	beq.n	80024ea <sdu_start_receive+0x5a>
  if (buf == NULL) {
 80024be:	1d23      	adds	r3, r4, #4
 80024c0:	d0ed      	beq.n	800249e <sdu_start_receive+0xe>
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80024c2:	2001      	movs	r0, #1
  osp->rxcnt  = 0;
 80024c4:	2400      	movs	r4, #0
  osp->rxsize = n;
 80024c6:	f44f 7780 	mov.w	r7, #256	; 0x100
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 80024ca:	7949      	ldrb	r1, [r1, #5]
  osp = usbp->epc[ep]->out_state;
 80024cc:	eb02 0681 	add.w	r6, r2, r1, lsl #2
 80024d0:	68f6      	ldr	r6, [r6, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80024d2:	4088      	lsls	r0, r1
  osp = usbp->epc[ep]->out_state;
 80024d4:	69b6      	ldr	r6, [r6, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80024d6:	4305      	orrs	r5, r0
 80024d8:	8155      	strh	r5, [r2, #10]
  usb_lld_start_out(usbp, ep);
 80024da:	4610      	mov	r0, r2
  osp->rxbuf  = buf;
 80024dc:	60b3      	str	r3, [r6, #8]
  osp->rxcnt  = 0;
 80024de:	e9c6 7400 	strd	r7, r4, [r6]
  usb_lld_start_out(usbp, ep);
 80024e2:	f7ff fbb5 	bl	8001c50 <usb_lld_start_out>
  return false;
 80024e6:	4620      	mov	r0, r4
}
 80024e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80024ea:	6980      	ldr	r0, [r0, #24]
 80024ec:	2800      	cmp	r0, #0
 80024ee:	d1d6      	bne.n	800249e <sdu_start_receive+0xe>
 80024f0:	e7e5      	b.n	80024be <sdu_start_receive+0x2e>
 80024f2:	bf00      	nop
	...

08002500 <ibnotify>:
  (void) sdu_start_receive(sdup);
 8002500:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8002502:	f7ff bfc5 	b.w	8002490 <sdu_start_receive>
 8002506:	bf00      	nop
	...

08002510 <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8002510:	3111      	adds	r1, #17
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8002512:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8002514:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 8002518:	b194      	cbz	r4, 8002540 <sduDataReceived+0x30>
 800251a:	2320      	movs	r3, #32
 800251c:	f383 8811 	msr	BASEPRI, r3
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8002520:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8002524:	6813      	ldr	r3, [r2, #0]
 8002526:	7952      	ldrb	r2, [r2, #5]
 8002528:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800252c:	68db      	ldr	r3, [r3, #12]
 800252e:	699b      	ldr	r3, [r3, #24]
 8002530:	685d      	ldr	r5, [r3, #4]
  if (size > (size_t)0) {
 8002532:	b935      	cbnz	r5, 8002542 <sduDataReceived+0x32>
  (void) sdu_start_receive(sdup);
 8002534:	4620      	mov	r0, r4
 8002536:	f7ff ffab 	bl	8002490 <sdu_start_receive>
 800253a:	2300      	movs	r3, #0
 800253c:	f383 8811 	msr	BASEPRI, r3
}
 8002540:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8002542:	2104      	movs	r1, #4
 8002544:	1860      	adds	r0, r4, r1
 8002546:	f7ff f93b 	bl	80017c0 <chEvtBroadcastFlagsI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 800254a:	69e3      	ldr	r3, [r4, #28]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
  if (ibqp->bwrptr >= ibqp->btop) {
 800254c:	6a61      	ldr	r1, [r4, #36]	; 0x24
  *((size_t *)ibqp->bwrptr) = size;
 800254e:	601d      	str	r5, [r3, #0]
  ibqp->bwrptr += ibqp->bsize;
 8002550:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  ibqp->bcounter++;
 8002552:	69a2      	ldr	r2, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
 8002554:	4403      	add	r3, r0
  if (ibqp->bwrptr >= ibqp->btop) {
 8002556:	428b      	cmp	r3, r1
  ibqp->bwrptr += ibqp->bsize;
 8002558:	61e3      	str	r3, [r4, #28]
    ibqp->bwrptr = ibqp->buffers;
 800255a:	bf28      	it	cs
 800255c:	6b23      	ldrcs	r3, [r4, #48]	; 0x30
  ibqp->bcounter++;
 800255e:	f102 0201 	add.w	r2, r2, #1
    ibqp->bwrptr = ibqp->buffers;
 8002562:	bf28      	it	cs
 8002564:	61e3      	strcs	r3, [r4, #28]
  ibqp->bcounter++;
 8002566:	61a2      	str	r2, [r4, #24]
    ibqPostFullBufferI(&sdup->ibqueue, size);
 8002568:	f104 000c 	add.w	r0, r4, #12
  chThdDequeueNextI(tqp, msg);
 800256c:	f7ff f870 	bl	8001650 <chThdDequeueNextI.constprop.95>
  (void) sdu_start_receive(sdup);
 8002570:	4620      	mov	r0, r4
 8002572:	f7ff ff8d 	bl	8002490 <sdu_start_receive>
 8002576:	2300      	movs	r3, #0
 8002578:	f383 8811 	msr	BASEPRI, r3
 800257c:	e7e0      	b.n	8002540 <sduDataReceived+0x30>
 800257e:	bf00      	nop

08002580 <obqGetFullBufferI>:
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 8002580:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
 8002584:	429a      	cmp	r2, r3
 8002586:	d004      	beq.n	8002592 <obqGetFullBufferI+0x12>
    return NULL;
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 8002588:	4618      	mov	r0, r3
 800258a:	f850 3b04 	ldr.w	r3, [r0], #4
 800258e:	600b      	str	r3, [r1, #0]

  return obqp->brdptr + sizeof (size_t);
}
 8002590:	4770      	bx	lr
  if (obqIsEmptyI(obqp)) {
 8002592:	68c2      	ldr	r2, [r0, #12]
 8002594:	2a00      	cmp	r2, #0
 8002596:	d0f7      	beq.n	8002588 <obqGetFullBufferI+0x8>
    return NULL;
 8002598:	2000      	movs	r0, #0
 800259a:	4770      	bx	lr
 800259c:	0000      	movs	r0, r0
	...

080025a0 <obnotify>:
static void obnotify(io_buffers_queue_t *bqp) {
 80025a0:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 80025a2:	6b44      	ldr	r4, [r0, #52]	; 0x34
static void obnotify(io_buffers_queue_t *bqp) {
 80025a4:	b082      	sub	sp, #8
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80025a6:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 80025aa:	6813      	ldr	r3, [r2, #0]
 80025ac:	7819      	ldrb	r1, [r3, #0]
 80025ae:	2904      	cmp	r1, #4
 80025b0:	d001      	beq.n	80025b6 <obnotify+0x16>
}
 80025b2:	b002      	add	sp, #8
 80025b4:	bd10      	pop	{r4, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80025b6:	7a21      	ldrb	r1, [r4, #8]
 80025b8:	2902      	cmp	r1, #2
 80025ba:	d1fa      	bne.n	80025b2 <obnotify+0x12>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80025bc:	2101      	movs	r1, #1
 80025be:	7910      	ldrb	r0, [r2, #4]
 80025c0:	891a      	ldrh	r2, [r3, #8]
 80025c2:	fa01 f300 	lsl.w	r3, r1, r0
 80025c6:	4213      	tst	r3, r2
 80025c8:	d1f3      	bne.n	80025b2 <obnotify+0x12>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80025ca:	a901      	add	r1, sp, #4
 80025cc:	f104 0044 	add.w	r0, r4, #68	; 0x44
 80025d0:	f7ff ffd6 	bl	8002580 <obqGetFullBufferI>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80025d4:	f8d4 348c 	ldr.w	r3, [r4, #1164]	; 0x48c
 80025d8:	4602      	mov	r2, r0
 80025da:	7919      	ldrb	r1, [r3, #4]
 80025dc:	6818      	ldr	r0, [r3, #0]
 80025de:	9b01      	ldr	r3, [sp, #4]
 80025e0:	f7ff feee 	bl	80023c0 <usbStartTransmitI>
 80025e4:	e7e5      	b.n	80025b2 <obnotify+0x12>
 80025e6:	bf00      	nop
	...

080025f0 <sof_handler>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 80025f0:	b510      	push	{r4, lr}
 80025f2:	2320      	movs	r3, #32
 80025f4:	b082      	sub	sp, #8
 80025f6:	f383 8811 	msr	BASEPRI, r3
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80025fa:	4c1f      	ldr	r4, [pc, #124]	; (8002678 <sof_handler+0x88>)
 80025fc:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8002600:	6813      	ldr	r3, [r2, #0]
 8002602:	7819      	ldrb	r1, [r3, #0]
 8002604:	2904      	cmp	r1, #4
 8002606:	d004      	beq.n	8002612 <sof_handler+0x22>
 8002608:	2300      	movs	r3, #0
 800260a:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
  osalSysUnlockFromISR();
}
 800260e:	b002      	add	sp, #8
 8002610:	bd10      	pop	{r4, pc}
 8002612:	7a21      	ldrb	r1, [r4, #8]
 8002614:	2902      	cmp	r1, #2
 8002616:	d1f7      	bne.n	8002608 <sof_handler+0x18>
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8002618:	2101      	movs	r1, #1
 800261a:	7910      	ldrb	r0, [r2, #4]
 800261c:	891a      	ldrh	r2, [r3, #8]
 800261e:	fa01 f300 	lsl.w	r3, r1, r0
 8002622:	4213      	tst	r3, r2
 8002624:	d1f0      	bne.n	8002608 <sof_handler+0x18>

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8002626:	e9d4 3215 	ldrd	r3, r2, [r4, #84]	; 0x54
 800262a:	4293      	cmp	r3, r2
 800262c:	d1ec      	bne.n	8002608 <sof_handler+0x18>
 800262e:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8002630:	2a00      	cmp	r2, #0
 8002632:	d0e9      	beq.n	8002608 <sof_handler+0x18>
 8002634:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8002636:	2a00      	cmp	r2, #0
 8002638:	d0e6      	beq.n	8002608 <sof_handler+0x18>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 800263a:	3a04      	subs	r2, #4

    if (size > 0U) {
 800263c:	1ad2      	subs	r2, r2, r3
 800263e:	d0e3      	beq.n	8002608 <sof_handler+0x18>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 8002640:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
      if (obqp->bwrptr >= obqp->btop) {
 8002642:	e9d4 1017 	ldrd	r1, r0, [r4, #92]	; 0x5c
      obqp->bwrptr += obqp->bsize;
 8002646:	4403      	add	r3, r0
      if (obqp->bwrptr >= obqp->btop) {
 8002648:	428b      	cmp	r3, r1
      obqp->bwrptr += obqp->bsize;
 800264a:	6563      	str	r3, [r4, #84]	; 0x54
        obqp->bwrptr = obqp->buffers;
 800264c:	bf28      	it	cs
 800264e:	6ea3      	ldrcs	r3, [r4, #104]	; 0x68
      obqp->bcounter--;
 8002650:	6d22      	ldr	r2, [r4, #80]	; 0x50
        obqp->bwrptr = obqp->buffers;
 8002652:	bf28      	it	cs
 8002654:	6563      	strcs	r3, [r4, #84]	; 0x54
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 8002656:	2300      	movs	r3, #0
      obqp->bcounter--;
 8002658:	3a01      	subs	r2, #1
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800265a:	a901      	add	r1, sp, #4
 800265c:	4807      	ldr	r0, [pc, #28]	; (800267c <sof_handler+0x8c>)
 800265e:	6522      	str	r2, [r4, #80]	; 0x50
      obqp->ptr = NULL;
 8002660:	66e3      	str	r3, [r4, #108]	; 0x6c
 8002662:	f7ff ff8d 	bl	8002580 <obqGetFullBufferI>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8002666:	f8d4 348c 	ldr.w	r3, [r4, #1164]	; 0x48c
 800266a:	4602      	mov	r2, r0
 800266c:	7919      	ldrb	r1, [r3, #4]
 800266e:	6818      	ldr	r0, [r3, #0]
 8002670:	9b01      	ldr	r3, [sp, #4]
 8002672:	f7ff fea5 	bl	80023c0 <usbStartTransmitI>
 8002676:	e7c7      	b.n	8002608 <sof_handler+0x18>
 8002678:	20000ce8 	.word	0x20000ce8
 800267c:	20000d2c 	.word	0x20000d2c

08002680 <sduDataTransmitted>:
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8002680:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8002684:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8002688:	6a9c      	ldr	r4, [r3, #40]	; 0x28
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800268a:	b082      	sub	sp, #8
  if (sdup == NULL) {
 800268c:	b1f4      	cbz	r4, 80026cc <sduDataTransmitted+0x4c>
 800268e:	460e      	mov	r6, r1
 8002690:	4605      	mov	r5, r0
 8002692:	2320      	movs	r3, #32
 8002694:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 8002698:	2108      	movs	r1, #8
 800269a:	1d20      	adds	r0, r4, #4
 800269c:	eb05 0786 	add.w	r7, r5, r6, lsl #2
 80026a0:	f7ff f88e 	bl	80017c0 <chEvtBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 80026a4:	68fb      	ldr	r3, [r7, #12]
 80026a6:	f104 0844 	add.w	r8, r4, #68	; 0x44
 80026aa:	695b      	ldr	r3, [r3, #20]
 80026ac:	681b      	ldr	r3, [r3, #0]
 80026ae:	bb03      	cbnz	r3, 80026f2 <sduDataTransmitted+0x72>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80026b0:	4640      	mov	r0, r8
 80026b2:	a901      	add	r1, sp, #4
 80026b4:	f7ff ff64 	bl	8002580 <obqGetFullBufferI>
  if (buf != NULL) {
 80026b8:	b158      	cbz	r0, 80026d2 <sduDataTransmitted+0x52>
    usbStartTransmitI(usbp, ep, buf, n);
 80026ba:	4602      	mov	r2, r0
 80026bc:	4631      	mov	r1, r6
 80026be:	4628      	mov	r0, r5
 80026c0:	9b01      	ldr	r3, [sp, #4]
 80026c2:	f7ff fe7d 	bl	80023c0 <usbStartTransmitI>
 80026c6:	2300      	movs	r3, #0
 80026c8:	f383 8811 	msr	BASEPRI, r3
}
 80026cc:	b002      	add	sp, #8
 80026ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80026d2:	68fb      	ldr	r3, [r7, #12]
 80026d4:	695a      	ldr	r2, [r3, #20]
 80026d6:	6812      	ldr	r2, [r2, #0]
 80026d8:	2a00      	cmp	r2, #0
 80026da:	d0f4      	beq.n	80026c6 <sduDataTransmitted+0x46>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 80026dc:	8a1b      	ldrh	r3, [r3, #16]
 80026de:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80026e0:	4013      	ands	r3, r2
 80026e2:	d1f0      	bne.n	80026c6 <sduDataTransmitted+0x46>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 80026e4:	4631      	mov	r1, r6
 80026e6:	f105 0274 	add.w	r2, r5, #116	; 0x74
 80026ea:	4628      	mov	r0, r5
 80026ec:	f7ff fe68 	bl	80023c0 <usbStartTransmitI>
 80026f0:	e7e9      	b.n	80026c6 <sduDataTransmitted+0x46>
  obqp->brdptr += obqp->bsize;
 80026f2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80026f4:	6e21      	ldr	r1, [r4, #96]	; 0x60
  obqp->bcounter++;
 80026f6:	6d22      	ldr	r2, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
 80026f8:	440b      	add	r3, r1
  if (obqp->brdptr >= obqp->btop) {
 80026fa:	6de1      	ldr	r1, [r4, #92]	; 0x5c
  obqp->brdptr += obqp->bsize;
 80026fc:	65a3      	str	r3, [r4, #88]	; 0x58
  if (obqp->brdptr >= obqp->btop) {
 80026fe:	428b      	cmp	r3, r1
    obqp->brdptr = obqp->buffers;
 8002700:	bf28      	it	cs
 8002702:	6ea3      	ldrcs	r3, [r4, #104]	; 0x68
  obqp->bcounter++;
 8002704:	f102 0201 	add.w	r2, r2, #1
    obqp->brdptr = obqp->buffers;
 8002708:	bf28      	it	cs
 800270a:	65a3      	strcs	r3, [r4, #88]	; 0x58
  chThdDequeueNextI(tqp, msg);
 800270c:	4640      	mov	r0, r8
  obqp->bcounter++;
 800270e:	6522      	str	r2, [r4, #80]	; 0x50
 8002710:	f7fe ff9e 	bl	8001650 <chThdDequeueNextI.constprop.95>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8002714:	4640      	mov	r0, r8
 8002716:	a901      	add	r1, sp, #4
 8002718:	f7ff ff32 	bl	8002580 <obqGetFullBufferI>
  if (buf != NULL) {
 800271c:	2800      	cmp	r0, #0
 800271e:	d1cc      	bne.n	80026ba <sduDataTransmitted+0x3a>
 8002720:	e7d7      	b.n	80026d2 <sduDataTransmitted+0x52>
 8002722:	bf00      	nop
	...

08002730 <oslib_test_001_003_execute>:
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void oslib_test_001_003_execute(void) {
 8002730:	b538      	push	{r3, r4, r5, lr}

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
 8002732:	2501      	movs	r5, #1
 8002734:	4b4a      	ldr	r3, [pc, #296]	; (8002860 <oslib_test_001_003_execute+0x130>)
  {
    test_print("--- CH_CFG_USE_MAILBOXES:               ");
    test_printn(CH_CFG_USE_MAILBOXES);
    test_println("");
 8002736:	4c4b      	ldr	r4, [pc, #300]	; (8002864 <oslib_test_001_003_execute+0x134>)
    test_print("--- CH_CFG_USE_MAILBOXES:               ");
 8002738:	484b      	ldr	r0, [pc, #300]	; (8002868 <oslib_test_001_003_execute+0x138>)
  test_set_step(1);
 800273a:	601d      	str	r5, [r3, #0]
    test_print("--- CH_CFG_USE_MAILBOXES:               ");
 800273c:	f7fe fc90 	bl	8001060 <test_print>
 8002740:	4628      	mov	r0, r5
 8002742:	f7fe fb8d 	bl	8000e60 <test_printn.part.0>
    test_println("");
 8002746:	4620      	mov	r0, r4
 8002748:	f7fe fc6a 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_MEMCORE:                 ");
 800274c:	4847      	ldr	r0, [pc, #284]	; (800286c <oslib_test_001_003_execute+0x13c>)
 800274e:	f7fe fc87 	bl	8001060 <test_print>
 8002752:	4628      	mov	r0, r5
 8002754:	f7fe fb84 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_MEMCORE);
    test_println("");
 8002758:	4620      	mov	r0, r4
 800275a:	f7fe fc61 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_HEAP:                    ");
 800275e:	4844      	ldr	r0, [pc, #272]	; (8002870 <oslib_test_001_003_execute+0x140>)
 8002760:	f7fe fc7e 	bl	8001060 <test_print>
 8002764:	4628      	mov	r0, r5
 8002766:	f7fe fb7b 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_HEAP);
    test_println("");
 800276a:	4620      	mov	r0, r4
 800276c:	f7fe fc58 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_MEMPOOLS:                ");
 8002770:	4840      	ldr	r0, [pc, #256]	; (8002874 <oslib_test_001_003_execute+0x144>)
 8002772:	f7fe fc75 	bl	8001060 <test_print>
 8002776:	4628      	mov	r0, r5
 8002778:	f7fe fb72 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_MEMPOOLS);
    test_println("");
 800277c:	4620      	mov	r0, r4
 800277e:	f7fe fc4f 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_OBJ_FIFOS:               ");
 8002782:	483d      	ldr	r0, [pc, #244]	; (8002878 <oslib_test_001_003_execute+0x148>)
 8002784:	f7fe fc6c 	bl	8001060 <test_print>
 8002788:	4628      	mov	r0, r5
 800278a:	f7fe fb69 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_OBJ_FIFOS);
    test_println("");
 800278e:	4620      	mov	r0, r4
 8002790:	f7fe fc46 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_PIPES:                   ");
 8002794:	4839      	ldr	r0, [pc, #228]	; (800287c <oslib_test_001_003_execute+0x14c>)
 8002796:	f7fe fc63 	bl	8001060 <test_print>
 800279a:	4628      	mov	r0, r5
 800279c:	f7fe fb60 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_PIPES);
    test_println("");
 80027a0:	4620      	mov	r0, r4
 80027a2:	f7fe fc3d 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_OBJ_CACHES:              ");
 80027a6:	4836      	ldr	r0, [pc, #216]	; (8002880 <oslib_test_001_003_execute+0x150>)
 80027a8:	f7fe fc5a 	bl	8001060 <test_print>
 80027ac:	4628      	mov	r0, r5
 80027ae:	f7fe fb57 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_OBJ_CACHES);
    test_println("");
 80027b2:	4620      	mov	r0, r4
 80027b4:	f7fe fc34 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_DELEGATES:               ");
 80027b8:	4832      	ldr	r0, [pc, #200]	; (8002884 <oslib_test_001_003_execute+0x154>)
 80027ba:	f7fe fc51 	bl	8001060 <test_print>
 80027be:	4628      	mov	r0, r5
 80027c0:	f7fe fb4e 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_DELEGATES);
    test_println("");
 80027c4:	4620      	mov	r0, r4
 80027c6:	f7fe fc2b 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_FACTORY:                 ");
 80027ca:	482f      	ldr	r0, [pc, #188]	; (8002888 <oslib_test_001_003_execute+0x158>)
 80027cc:	f7fe fc48 	bl	8001060 <test_print>
 80027d0:	4628      	mov	r0, r5
 80027d2:	f7fe fb45 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_FACTORY);
    test_println("");
 80027d6:	4620      	mov	r0, r4
 80027d8:	f7fe fc22 	bl	8001020 <test_println>
    test_print("--- CH_CFG_FACTORY_MAX_NAMES_LENGTH:    ");
 80027dc:	482b      	ldr	r0, [pc, #172]	; (800288c <oslib_test_001_003_execute+0x15c>)
 80027de:	f7fe fc3f 	bl	8001060 <test_print>
 80027e2:	2008      	movs	r0, #8
 80027e4:	f7fe fb3c 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_MAX_NAMES_LENGTH);
    test_println("");
 80027e8:	4620      	mov	r0, r4
 80027ea:	f7fe fc19 	bl	8001020 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJECTS_REGISTRY:    ");
 80027ee:	4828      	ldr	r0, [pc, #160]	; (8002890 <oslib_test_001_003_execute+0x160>)
 80027f0:	f7fe fc36 	bl	8001060 <test_print>
 80027f4:	4628      	mov	r0, r5
 80027f6:	f7fe fb33 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_OBJECTS_REGISTRY);
    test_println("");
 80027fa:	4620      	mov	r0, r4
 80027fc:	f7fe fc10 	bl	8001020 <test_println>
    test_print("--- CH_CFG_FACTORY_GENERIC_BUFFERS:     ");
 8002800:	4824      	ldr	r0, [pc, #144]	; (8002894 <oslib_test_001_003_execute+0x164>)
 8002802:	f7fe fc2d 	bl	8001060 <test_print>
 8002806:	4628      	mov	r0, r5
 8002808:	f7fe fb2a 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_GENERIC_BUFFERS);
    test_println("");
 800280c:	4620      	mov	r0, r4
 800280e:	f7fe fc07 	bl	8001020 <test_println>
    test_print("--- CH_CFG_FACTORY_SEMAPHORES:          ");
 8002812:	4821      	ldr	r0, [pc, #132]	; (8002898 <oslib_test_001_003_execute+0x168>)
 8002814:	f7fe fc24 	bl	8001060 <test_print>
 8002818:	4628      	mov	r0, r5
 800281a:	f7fe fb21 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_SEMAPHORES);
    test_println("");
 800281e:	4620      	mov	r0, r4
 8002820:	f7fe fbfe 	bl	8001020 <test_println>
    test_print("--- CH_CFG_FACTORY_MAILBOXES:           ");
 8002824:	481d      	ldr	r0, [pc, #116]	; (800289c <oslib_test_001_003_execute+0x16c>)
 8002826:	f7fe fc1b 	bl	8001060 <test_print>
 800282a:	4628      	mov	r0, r5
 800282c:	f7fe fb18 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_MAILBOXES);
    test_println("");
 8002830:	4620      	mov	r0, r4
 8002832:	f7fe fbf5 	bl	8001020 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJ_FIFOS:           ");
 8002836:	481a      	ldr	r0, [pc, #104]	; (80028a0 <oslib_test_001_003_execute+0x170>)
 8002838:	f7fe fc12 	bl	8001060 <test_print>
 800283c:	4628      	mov	r0, r5
 800283e:	f7fe fb0f 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_OBJ_FIFOS);
    test_println("");
 8002842:	4620      	mov	r0, r4
 8002844:	f7fe fbec 	bl	8001020 <test_println>
    test_print("--- CH_CFG_FACTORY_PIPES:               ");
 8002848:	4816      	ldr	r0, [pc, #88]	; (80028a4 <oslib_test_001_003_execute+0x174>)
 800284a:	f7fe fc09 	bl	8001060 <test_print>
 800284e:	4628      	mov	r0, r5
 8002850:	f7fe fb06 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_PIPES);
    test_println("");
 8002854:	4620      	mov	r0, r4
  }
  test_end_step(1);
}
 8002856:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println("");
 800285a:	f7fe bbe1 	b.w	8001020 <test_println>
 800285e:	bf00      	nop
 8002860:	20001d94 	.word	0x20001d94
 8002864:	0800c7f4 	.word	0x0800c7f4
 8002868:	0800ae7c 	.word	0x0800ae7c
 800286c:	0800aea8 	.word	0x0800aea8
 8002870:	0800aed4 	.word	0x0800aed4
 8002874:	0800af00 	.word	0x0800af00
 8002878:	0800af2c 	.word	0x0800af2c
 800287c:	0800af58 	.word	0x0800af58
 8002880:	0800af84 	.word	0x0800af84
 8002884:	0800afb0 	.word	0x0800afb0
 8002888:	0800afdc 	.word	0x0800afdc
 800288c:	0800b008 	.word	0x0800b008
 8002890:	0800b034 	.word	0x0800b034
 8002894:	0800b060 	.word	0x0800b060
 8002898:	0800b08c 	.word	0x0800b08c
 800289c:	0800b0b8 	.word	0x0800b0b8
 80028a0:	0800b0e4 	.word	0x0800b0e4
 80028a4:	0800b110 	.word	0x0800b110
	...

080028b0 <oslib_test_001_002_execute>:
static void oslib_test_001_002_execute(void) {
 80028b0:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 80028b2:	2501      	movs	r5, #1
 80028b4:	4b18      	ldr	r3, [pc, #96]	; (8002918 <oslib_test_001_002_execute+0x68>)
    test_println("--- Product:                            ChibiOS/LIB");
 80028b6:	4819      	ldr	r0, [pc, #100]	; (800291c <oslib_test_001_002_execute+0x6c>)
  test_set_step(1);
 80028b8:	601d      	str	r5, [r3, #0]
    test_println("");
 80028ba:	4c19      	ldr	r4, [pc, #100]	; (8002920 <oslib_test_001_002_execute+0x70>)
    test_println("--- Product:                            ChibiOS/LIB");
 80028bc:	f7fe fbb0 	bl	8001020 <test_println>
    test_print("--- Stable Flag:                        ");
 80028c0:	4818      	ldr	r0, [pc, #96]	; (8002924 <oslib_test_001_002_execute+0x74>)
 80028c2:	f7fe fbcd 	bl	8001060 <test_print>
 80028c6:	4628      	mov	r0, r5
 80028c8:	f7fe faca 	bl	8000e60 <test_printn.part.0>
    test_println("");
 80028cc:	4620      	mov	r0, r4
 80028ce:	f7fe fba7 	bl	8001020 <test_println>
    test_print("--- Version String:                     ");
 80028d2:	4815      	ldr	r0, [pc, #84]	; (8002928 <oslib_test_001_002_execute+0x78>)
 80028d4:	f7fe fbc4 	bl	8001060 <test_print>
    test_println(CH_OSLIB_VERSION);
 80028d8:	4814      	ldr	r0, [pc, #80]	; (800292c <oslib_test_001_002_execute+0x7c>)
 80028da:	f7fe fba1 	bl	8001020 <test_println>
    test_print("--- Major Number:                       ");
 80028de:	4814      	ldr	r0, [pc, #80]	; (8002930 <oslib_test_001_002_execute+0x80>)
 80028e0:	f7fe fbbe 	bl	8001060 <test_print>
 80028e4:	4628      	mov	r0, r5
 80028e6:	f7fe fabb 	bl	8000e60 <test_printn.part.0>
    test_println("");
 80028ea:	4620      	mov	r0, r4
 80028ec:	f7fe fb98 	bl	8001020 <test_println>
    test_print("--- Minor Number:                       ");
 80028f0:	4810      	ldr	r0, [pc, #64]	; (8002934 <oslib_test_001_002_execute+0x84>)
 80028f2:	f7fe fbb5 	bl	8001060 <test_print>
 80028f6:	2002      	movs	r0, #2
 80028f8:	f7fe fab2 	bl	8000e60 <test_printn.part.0>
    test_println("");
 80028fc:	4620      	mov	r0, r4
 80028fe:	f7fe fb8f 	bl	8001020 <test_println>
    test_print("--- Patch Number:                       ");
 8002902:	480d      	ldr	r0, [pc, #52]	; (8002938 <oslib_test_001_002_execute+0x88>)
 8002904:	f7fe fbac 	bl	8001060 <test_print>
    test_printn(CH_OSLIB_PATCH);
 8002908:	2000      	movs	r0, #0
 800290a:	f7fe fad9 	bl	8000ec0 <test_printn>
    test_println("");
 800290e:	4620      	mov	r0, r4
}
 8002910:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println("");
 8002914:	f7fe bb84 	b.w	8001020 <test_println>
 8002918:	20001d94 	.word	0x20001d94
 800291c:	0800ad54 	.word	0x0800ad54
 8002920:	0800c7f4 	.word	0x0800c7f4
 8002924:	0800ad88 	.word	0x0800ad88
 8002928:	0800adb4 	.word	0x0800adb4
 800292c:	0800ade0 	.word	0x0800ade0
 8002930:	0800ade8 	.word	0x0800ade8
 8002934:	0800ae14 	.word	0x0800ae14
 8002938:	0800ae40 	.word	0x0800ae40
 800293c:	00000000 	.word	0x00000000

08002940 <rt_test_011_012_execute>:
 */

static void rt_test_011_012_execute(void) {

  /* [11.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8002940:	2301      	movs	r3, #1
static void rt_test_011_012_execute(void) {
 8002942:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 8002944:	4d32      	ldr	r5, [pc, #200]	; (8002a10 <rt_test_011_012_execute+0xd0>)
  {
    test_print("--- System: ");
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
 8002946:	4c33      	ldr	r4, [pc, #204]	; (8002a14 <rt_test_011_012_execute+0xd4>)
    test_print("--- System: ");
 8002948:	4833      	ldr	r0, [pc, #204]	; (8002a18 <rt_test_011_012_execute+0xd8>)
  test_set_step(1);
 800294a:	602b      	str	r3, [r5, #0]
    test_print("--- System: ");
 800294c:	f7fe fb88 	bl	8001060 <test_print>
 8002950:	2078      	movs	r0, #120	; 0x78
 8002952:	f7fe fa85 	bl	8000e60 <test_printn.part.0>
    test_println(" bytes");
 8002956:	4620      	mov	r0, r4
 8002958:	f7fe fb62 	bl	8001020 <test_println>
  }
  test_end_step(1);

  /* [11.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 800295c:	2302      	movs	r3, #2
  {
    test_print("--- Thread: ");
 800295e:	482f      	ldr	r0, [pc, #188]	; (8002a1c <rt_test_011_012_execute+0xdc>)
  test_set_step(2);
 8002960:	602b      	str	r3, [r5, #0]
    test_print("--- Thread: ");
 8002962:	f7fe fb7d 	bl	8001060 <test_print>
 8002966:	2044      	movs	r0, #68	; 0x44
 8002968:	f7fe fa7a 	bl	8000e60 <test_printn.part.0>
    test_printn(sizeof(thread_t));
    test_println(" bytes");
 800296c:	4620      	mov	r0, r4
 800296e:	f7fe fb57 	bl	8001020 <test_println>
  }
  test_end_step(2);

  /* [11.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8002972:	2303      	movs	r3, #3
    test_println(" bytes");
  }
  test_end_step(3);

  /* [11.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 8002974:	2604      	movs	r6, #4
    test_print("--- Timer : ");
 8002976:	482a      	ldr	r0, [pc, #168]	; (8002a20 <rt_test_011_012_execute+0xe0>)
  test_set_step(3);
 8002978:	602b      	str	r3, [r5, #0]
    test_print("--- Timer : ");
 800297a:	f7fe fb71 	bl	8001060 <test_print>
 800297e:	2014      	movs	r0, #20
 8002980:	f7fe fa6e 	bl	8000e60 <test_printn.part.0>
    test_println(" bytes");
 8002984:	4620      	mov	r0, r4
 8002986:	f7fe fb4b 	bl	8001020 <test_println>
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 800298a:	4826      	ldr	r0, [pc, #152]	; (8002a24 <rt_test_011_012_execute+0xe4>)
  test_set_step(4);
 800298c:	602e      	str	r6, [r5, #0]
    test_print("--- Semaph: ");
 800298e:	f7fe fb67 	bl	8001060 <test_print>
 8002992:	200c      	movs	r0, #12
 8002994:	f7fe fa64 	bl	8000e60 <test_printn.part.0>
    test_printn(sizeof(semaphore_t));
    test_println(" bytes");
 8002998:	4620      	mov	r0, r4
 800299a:	f7fe fb41 	bl	8001020 <test_println>
#endif
  }
  test_end_step(4);

  /* [11.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 800299e:	2305      	movs	r3, #5
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 80029a0:	4821      	ldr	r0, [pc, #132]	; (8002a28 <rt_test_011_012_execute+0xe8>)
  test_set_step(5);
 80029a2:	602b      	str	r3, [r5, #0]
    test_print("--- Mutex : ");
 80029a4:	f7fe fb5c 	bl	8001060 <test_print>
 80029a8:	2010      	movs	r0, #16
 80029aa:	f7fe fa59 	bl	8000e60 <test_printn.part.0>
    test_printn(sizeof(mutex_t));
    test_println(" bytes");
 80029ae:	4620      	mov	r0, r4
 80029b0:	f7fe fb36 	bl	8001020 <test_println>
#endif
  }
  test_end_step(5);

  /* [11.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 80029b4:	2306      	movs	r3, #6
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 80029b6:	481d      	ldr	r0, [pc, #116]	; (8002a2c <rt_test_011_012_execute+0xec>)
  test_set_step(6);
 80029b8:	602b      	str	r3, [r5, #0]
    test_print("--- CondV.: ");
 80029ba:	f7fe fb51 	bl	8001060 <test_print>
 80029be:	2008      	movs	r0, #8
 80029c0:	f7fe fa4e 	bl	8000e60 <test_printn.part.0>
    test_printn(sizeof(condition_variable_t));
    test_println(" bytes");
 80029c4:	4620      	mov	r0, r4
 80029c6:	f7fe fb2b 	bl	8001020 <test_println>
#endif
  }
  test_end_step(6);

  /* [11.12.7] The size of an event source is printed.*/
  test_set_step(7);
 80029ca:	2307      	movs	r3, #7
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 80029cc:	4818      	ldr	r0, [pc, #96]	; (8002a30 <rt_test_011_012_execute+0xf0>)
  test_set_step(7);
 80029ce:	602b      	str	r3, [r5, #0]
    test_print("--- EventS: ");
 80029d0:	f7fe fb46 	bl	8001060 <test_print>
 80029d4:	4630      	mov	r0, r6
 80029d6:	f7fe fa43 	bl	8000e60 <test_printn.part.0>
    test_printn(sizeof(event_source_t));
    test_println(" bytes");
 80029da:	4620      	mov	r0, r4
 80029dc:	f7fe fb20 	bl	8001020 <test_println>
#endif
  }
  test_end_step(7);

  /* [11.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 80029e0:	2308      	movs	r3, #8
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 80029e2:	4814      	ldr	r0, [pc, #80]	; (8002a34 <rt_test_011_012_execute+0xf4>)
  test_set_step(8);
 80029e4:	602b      	str	r3, [r5, #0]
    test_print("--- EventL: ");
 80029e6:	f7fe fb3b 	bl	8001060 <test_print>
 80029ea:	2014      	movs	r0, #20
 80029ec:	f7fe fa38 	bl	8000e60 <test_printn.part.0>
    test_printn(sizeof(event_listener_t));
    test_println(" bytes");
 80029f0:	4620      	mov	r0, r4
 80029f2:	f7fe fb15 	bl	8001020 <test_println>
#endif
  }
  test_end_step(8);

  /* [11.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 80029f6:	2309      	movs	r3, #9
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 80029f8:	480f      	ldr	r0, [pc, #60]	; (8002a38 <rt_test_011_012_execute+0xf8>)
  test_set_step(9);
 80029fa:	602b      	str	r3, [r5, #0]
    test_print("--- MailB.: ");
 80029fc:	f7fe fb30 	bl	8001060 <test_print>
 8002a00:	2028      	movs	r0, #40	; 0x28
 8002a02:	f7fe fa2d 	bl	8000e60 <test_printn.part.0>
    test_printn(sizeof(mailbox_t));
    test_println(" bytes");
 8002a06:	4620      	mov	r0, r4
#endif
  }
  test_end_step(9);
}
 8002a08:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_println(" bytes");
 8002a0c:	f7fe bb08 	b.w	8001020 <test_println>
 8002a10:	20001d94 	.word	0x20001d94
 8002a14:	0800c578 	.word	0x0800c578
 8002a18:	0800c568 	.word	0x0800c568
 8002a1c:	0800c580 	.word	0x0800c580
 8002a20:	0800c590 	.word	0x0800c590
 8002a24:	0800c5a0 	.word	0x0800c5a0
 8002a28:	0800c5b0 	.word	0x0800c5b0
 8002a2c:	0800c5c0 	.word	0x0800c5c0
 8002a30:	0800c5d0 	.word	0x0800c5d0
 8002a34:	0800c5e0 	.word	0x0800c5e0
 8002a38:	0800c5f0 	.word	0x0800c5f0
 8002a3c:	00000000 	.word	0x00000000

08002a40 <rt_test_001_003_execute>:
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void rt_test_001_003_execute(void) {
 8002a40:	b538      	push	{r3, r4, r5, lr}

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
 8002a42:	2501      	movs	r5, #1
 8002a44:	4b92      	ldr	r3, [pc, #584]	; (8002c90 <rt_test_001_003_execute+0x250>)
  {
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
    test_printn(CH_CFG_ST_RESOLUTION);
    test_println("");
 8002a46:	4c93      	ldr	r4, [pc, #588]	; (8002c94 <rt_test_001_003_execute+0x254>)
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
 8002a48:	4893      	ldr	r0, [pc, #588]	; (8002c98 <rt_test_001_003_execute+0x258>)
  test_set_step(1);
 8002a4a:	601d      	str	r5, [r3, #0]
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
 8002a4c:	f7fe fb08 	bl	8001060 <test_print>
 8002a50:	2010      	movs	r0, #16
 8002a52:	f7fe fa05 	bl	8000e60 <test_printn.part.0>
    test_println("");
 8002a56:	4620      	mov	r0, r4
 8002a58:	f7fe fae2 	bl	8001020 <test_println>
    test_print("--- CH_CFG_ST_FREQUENCY:                ");
 8002a5c:	488f      	ldr	r0, [pc, #572]	; (8002c9c <rt_test_001_003_execute+0x25c>)
 8002a5e:	f7fe faff 	bl	8001060 <test_print>
 8002a62:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8002a66:	f7fe f9fb 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_ST_FREQUENCY);
    test_println("");
 8002a6a:	4620      	mov	r0, r4
 8002a6c:	f7fe fad8 	bl	8001020 <test_println>
    test_print("--- CH_CFG_INTERVALS_SIZE:              ");
 8002a70:	488b      	ldr	r0, [pc, #556]	; (8002ca0 <rt_test_001_003_execute+0x260>)
 8002a72:	f7fe faf5 	bl	8001060 <test_print>
 8002a76:	2020      	movs	r0, #32
 8002a78:	f7fe f9f2 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_INTERVALS_SIZE);
    test_println("");
 8002a7c:	4620      	mov	r0, r4
 8002a7e:	f7fe facf 	bl	8001020 <test_println>
    test_print("--- CH_CFG_TIME_TYPES_SIZE:             ");
 8002a82:	4888      	ldr	r0, [pc, #544]	; (8002ca4 <rt_test_001_003_execute+0x264>)
 8002a84:	f7fe faec 	bl	8001060 <test_print>
 8002a88:	2020      	movs	r0, #32
 8002a8a:	f7fe f9e9 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_TIME_TYPES_SIZE);
    test_println("");
 8002a8e:	4620      	mov	r0, r4
 8002a90:	f7fe fac6 	bl	8001020 <test_println>
    test_print("--- CH_CFG_ST_TIMEDELTA:                ");
 8002a94:	4884      	ldr	r0, [pc, #528]	; (8002ca8 <rt_test_001_003_execute+0x268>)
 8002a96:	f7fe fae3 	bl	8001060 <test_print>
 8002a9a:	2002      	movs	r0, #2
 8002a9c:	f7fe f9e0 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_ST_TIMEDELTA);
    test_println("");
 8002aa0:	4620      	mov	r0, r4
 8002aa2:	f7fe fabd 	bl	8001020 <test_println>
    test_print("--- CH_CFG_TIME_QUANTUM:                ");
 8002aa6:	4881      	ldr	r0, [pc, #516]	; (8002cac <rt_test_001_003_execute+0x26c>)
 8002aa8:	f7fe fada 	bl	8001060 <test_print>
    test_printn(CH_CFG_TIME_QUANTUM);
 8002aac:	2000      	movs	r0, #0
 8002aae:	f7fe fa07 	bl	8000ec0 <test_printn>
    test_println("");
 8002ab2:	4620      	mov	r0, r4
 8002ab4:	f7fe fab4 	bl	8001020 <test_println>
    test_print("--- CH_CFG_MEMCORE_SIZE:                ");
 8002ab8:	487d      	ldr	r0, [pc, #500]	; (8002cb0 <rt_test_001_003_execute+0x270>)
 8002aba:	f7fe fad1 	bl	8001060 <test_print>
    test_printn(CH_CFG_MEMCORE_SIZE);
 8002abe:	2000      	movs	r0, #0
 8002ac0:	f7fe f9fe 	bl	8000ec0 <test_printn>
    test_println("");
 8002ac4:	4620      	mov	r0, r4
 8002ac6:	f7fe faab 	bl	8001020 <test_println>
    test_print("--- CH_CFG_NO_IDLE_THREAD:              ");
 8002aca:	487a      	ldr	r0, [pc, #488]	; (8002cb4 <rt_test_001_003_execute+0x274>)
 8002acc:	f7fe fac8 	bl	8001060 <test_print>
    test_printn(CH_CFG_NO_IDLE_THREAD);
 8002ad0:	2000      	movs	r0, #0
 8002ad2:	f7fe f9f5 	bl	8000ec0 <test_printn>
    test_println("");
 8002ad6:	4620      	mov	r0, r4
 8002ad8:	f7fe faa2 	bl	8001020 <test_println>
    test_print("--- CH_CFG_OPTIMIZE_SPEED:              ");
 8002adc:	4876      	ldr	r0, [pc, #472]	; (8002cb8 <rt_test_001_003_execute+0x278>)
 8002ade:	f7fe fabf 	bl	8001060 <test_print>
 8002ae2:	4628      	mov	r0, r5
 8002ae4:	f7fe f9bc 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_OPTIMIZE_SPEED);
    test_println("");
 8002ae8:	4620      	mov	r0, r4
 8002aea:	f7fe fa99 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_TM:                      ");
 8002aee:	4873      	ldr	r0, [pc, #460]	; (8002cbc <rt_test_001_003_execute+0x27c>)
 8002af0:	f7fe fab6 	bl	8001060 <test_print>
 8002af4:	4628      	mov	r0, r5
 8002af6:	f7fe f9b3 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_TM);
    test_println("");
 8002afa:	4620      	mov	r0, r4
 8002afc:	f7fe fa90 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_REGISTRY:                ");
 8002b00:	486f      	ldr	r0, [pc, #444]	; (8002cc0 <rt_test_001_003_execute+0x280>)
 8002b02:	f7fe faad 	bl	8001060 <test_print>
 8002b06:	4628      	mov	r0, r5
 8002b08:	f7fe f9aa 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_REGISTRY);
    test_println("");
 8002b0c:	4620      	mov	r0, r4
 8002b0e:	f7fe fa87 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_WAITEXIT:                ");
 8002b12:	486c      	ldr	r0, [pc, #432]	; (8002cc4 <rt_test_001_003_execute+0x284>)
 8002b14:	f7fe faa4 	bl	8001060 <test_print>
 8002b18:	4628      	mov	r0, r5
 8002b1a:	f7fe f9a1 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_WAITEXIT);
    test_println("");
 8002b1e:	4620      	mov	r0, r4
 8002b20:	f7fe fa7e 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES:              ");
 8002b24:	4868      	ldr	r0, [pc, #416]	; (8002cc8 <rt_test_001_003_execute+0x288>)
 8002b26:	f7fe fa9b 	bl	8001060 <test_print>
 8002b2a:	4628      	mov	r0, r5
 8002b2c:	f7fe f998 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_SEMAPHORES);
    test_println("");
 8002b30:	4620      	mov	r0, r4
 8002b32:	f7fe fa75 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES_PRIORITY:     ");
 8002b36:	4865      	ldr	r0, [pc, #404]	; (8002ccc <rt_test_001_003_execute+0x28c>)
 8002b38:	f7fe fa92 	bl	8001060 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES_PRIORITY);
 8002b3c:	2000      	movs	r0, #0
 8002b3e:	f7fe f9bf 	bl	8000ec0 <test_printn>
    test_println("");
 8002b42:	4620      	mov	r0, r4
 8002b44:	f7fe fa6c 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES:                 ");
 8002b48:	4861      	ldr	r0, [pc, #388]	; (8002cd0 <rt_test_001_003_execute+0x290>)
 8002b4a:	f7fe fa89 	bl	8001060 <test_print>
 8002b4e:	4628      	mov	r0, r5
 8002b50:	f7fe f986 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_MUTEXES);
    test_println("");
 8002b54:	4620      	mov	r0, r4
 8002b56:	f7fe fa63 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES_RECURSIVE:       ");
 8002b5a:	485e      	ldr	r0, [pc, #376]	; (8002cd4 <rt_test_001_003_execute+0x294>)
 8002b5c:	f7fe fa80 	bl	8001060 <test_print>
    test_printn(CH_CFG_USE_MUTEXES_RECURSIVE);
 8002b60:	2000      	movs	r0, #0
 8002b62:	f7fe f9ad 	bl	8000ec0 <test_printn>
    test_println("");   
 8002b66:	4620      	mov	r0, r4
 8002b68:	f7fe fa5a 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS:                ");
 8002b6c:	485a      	ldr	r0, [pc, #360]	; (8002cd8 <rt_test_001_003_execute+0x298>)
 8002b6e:	f7fe fa77 	bl	8001060 <test_print>
 8002b72:	4628      	mov	r0, r5
 8002b74:	f7fe f974 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_CONDVARS);
    test_println("");
 8002b78:	4620      	mov	r0, r4
 8002b7a:	f7fe fa51 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS_TIMEOUT:        ");
 8002b7e:	4857      	ldr	r0, [pc, #348]	; (8002cdc <rt_test_001_003_execute+0x29c>)
 8002b80:	f7fe fa6e 	bl	8001060 <test_print>
 8002b84:	4628      	mov	r0, r5
 8002b86:	f7fe f96b 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_CONDVARS_TIMEOUT);
    test_println("");
 8002b8a:	4620      	mov	r0, r4
 8002b8c:	f7fe fa48 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_EVENTS:                  ");
 8002b90:	4853      	ldr	r0, [pc, #332]	; (8002ce0 <rt_test_001_003_execute+0x2a0>)
 8002b92:	f7fe fa65 	bl	8001060 <test_print>
 8002b96:	4628      	mov	r0, r5
 8002b98:	f7fe f962 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_EVENTS);
    test_println("");
 8002b9c:	4620      	mov	r0, r4
 8002b9e:	f7fe fa3f 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_EVENTS_TIMEOUT:          ");
 8002ba2:	4850      	ldr	r0, [pc, #320]	; (8002ce4 <rt_test_001_003_execute+0x2a4>)
 8002ba4:	f7fe fa5c 	bl	8001060 <test_print>
 8002ba8:	4628      	mov	r0, r5
 8002baa:	f7fe f959 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_EVENTS_TIMEOUT);
    test_println("");
 8002bae:	4620      	mov	r0, r4
 8002bb0:	f7fe fa36 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES:                ");
 8002bb4:	484c      	ldr	r0, [pc, #304]	; (8002ce8 <rt_test_001_003_execute+0x2a8>)
 8002bb6:	f7fe fa53 	bl	8001060 <test_print>
 8002bba:	4628      	mov	r0, r5
 8002bbc:	f7fe f950 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_MESSAGES);
    test_println("");
 8002bc0:	4620      	mov	r0, r4
 8002bc2:	f7fe fa2d 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES_PRIORITY:       ");
 8002bc6:	4849      	ldr	r0, [pc, #292]	; (8002cec <rt_test_001_003_execute+0x2ac>)
 8002bc8:	f7fe fa4a 	bl	8001060 <test_print>
    test_printn(CH_CFG_USE_MESSAGES_PRIORITY);
 8002bcc:	2000      	movs	r0, #0
 8002bce:	f7fe f977 	bl	8000ec0 <test_printn>
    test_println("");
 8002bd2:	4620      	mov	r0, r4
 8002bd4:	f7fe fa24 	bl	8001020 <test_println>
    test_print("--- CH_CFG_USE_DYNAMIC:                 ");
 8002bd8:	4845      	ldr	r0, [pc, #276]	; (8002cf0 <rt_test_001_003_execute+0x2b0>)
 8002bda:	f7fe fa41 	bl	8001060 <test_print>
 8002bde:	4628      	mov	r0, r5
 8002be0:	f7fe f93e 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_CFG_USE_DYNAMIC);
    test_println("");
 8002be4:	4620      	mov	r0, r4
 8002be6:	f7fe fa1b 	bl	8001020 <test_println>
    test_print("--- CH_DBG_STATISTICS:                  ");
 8002bea:	4842      	ldr	r0, [pc, #264]	; (8002cf4 <rt_test_001_003_execute+0x2b4>)
 8002bec:	f7fe fa38 	bl	8001060 <test_print>
    test_printn(CH_DBG_STATISTICS);
 8002bf0:	2000      	movs	r0, #0
 8002bf2:	f7fe f965 	bl	8000ec0 <test_printn>
    test_println("");
 8002bf6:	4620      	mov	r0, r4
 8002bf8:	f7fe fa12 	bl	8001020 <test_println>
    test_print("--- CH_DBG_SYSTEM_STATE_CHECK:          ");
 8002bfc:	483e      	ldr	r0, [pc, #248]	; (8002cf8 <rt_test_001_003_execute+0x2b8>)
 8002bfe:	f7fe fa2f 	bl	8001060 <test_print>
    test_printn(CH_DBG_SYSTEM_STATE_CHECK);
 8002c02:	2000      	movs	r0, #0
 8002c04:	f7fe f95c 	bl	8000ec0 <test_printn>
    test_println("");
 8002c08:	4620      	mov	r0, r4
 8002c0a:	f7fe fa09 	bl	8001020 <test_println>
    test_print("--- CH_DBG_ENABLE_CHECKS:               ");
 8002c0e:	483b      	ldr	r0, [pc, #236]	; (8002cfc <rt_test_001_003_execute+0x2bc>)
 8002c10:	f7fe fa26 	bl	8001060 <test_print>
    test_printn(CH_DBG_ENABLE_CHECKS);
 8002c14:	2000      	movs	r0, #0
 8002c16:	f7fe f953 	bl	8000ec0 <test_printn>
    test_println("");
 8002c1a:	4620      	mov	r0, r4
 8002c1c:	f7fe fa00 	bl	8001020 <test_println>
    test_print("--- CH_DBG_ENABLE_ASSERTS:              ");
 8002c20:	4837      	ldr	r0, [pc, #220]	; (8002d00 <rt_test_001_003_execute+0x2c0>)
 8002c22:	f7fe fa1d 	bl	8001060 <test_print>
    test_printn(CH_DBG_ENABLE_ASSERTS);
 8002c26:	2000      	movs	r0, #0
 8002c28:	f7fe f94a 	bl	8000ec0 <test_printn>
    test_println("");
 8002c2c:	4620      	mov	r0, r4
 8002c2e:	f7fe f9f7 	bl	8001020 <test_println>
    test_print("--- CH_DBG_TRACE_MASK:                  ");
 8002c32:	4834      	ldr	r0, [pc, #208]	; (8002d04 <rt_test_001_003_execute+0x2c4>)
 8002c34:	f7fe fa14 	bl	8001060 <test_print>
 8002c38:	20ff      	movs	r0, #255	; 0xff
 8002c3a:	f7fe f911 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_DBG_TRACE_MASK);
    test_println("");
 8002c3e:	4620      	mov	r0, r4
 8002c40:	f7fe f9ee 	bl	8001020 <test_println>
    test_print("--- CH_DBG_TRACE_BUFFER_SIZE:           ");
 8002c44:	4830      	ldr	r0, [pc, #192]	; (8002d08 <rt_test_001_003_execute+0x2c8>)
 8002c46:	f7fe fa0b 	bl	8001060 <test_print>
 8002c4a:	2080      	movs	r0, #128	; 0x80
 8002c4c:	f7fe f908 	bl	8000e60 <test_printn.part.0>
    test_printn(CH_DBG_TRACE_BUFFER_SIZE);
    test_println("");
 8002c50:	4620      	mov	r0, r4
 8002c52:	f7fe f9e5 	bl	8001020 <test_println>
    test_print("--- CH_DBG_ENABLE_STACK_CHECK:          ");
 8002c56:	482d      	ldr	r0, [pc, #180]	; (8002d0c <rt_test_001_003_execute+0x2cc>)
 8002c58:	f7fe fa02 	bl	8001060 <test_print>
    test_printn(CH_DBG_ENABLE_STACK_CHECK);
 8002c5c:	2000      	movs	r0, #0
 8002c5e:	f7fe f92f 	bl	8000ec0 <test_printn>
    test_println("");
 8002c62:	4620      	mov	r0, r4
 8002c64:	f7fe f9dc 	bl	8001020 <test_println>
    test_print("--- CH_DBG_FILL_THREADS:                ");
 8002c68:	4829      	ldr	r0, [pc, #164]	; (8002d10 <rt_test_001_003_execute+0x2d0>)
 8002c6a:	f7fe f9f9 	bl	8001060 <test_print>
    test_printn(CH_DBG_FILL_THREADS);
 8002c6e:	2000      	movs	r0, #0
 8002c70:	f7fe f926 	bl	8000ec0 <test_printn>
    test_println("");
 8002c74:	4620      	mov	r0, r4
 8002c76:	f7fe f9d3 	bl	8001020 <test_println>
    test_print("--- CH_DBG_THREADS_PROFILING:           ");
 8002c7a:	4826      	ldr	r0, [pc, #152]	; (8002d14 <rt_test_001_003_execute+0x2d4>)
 8002c7c:	f7fe f9f0 	bl	8001060 <test_print>
    test_printn(CH_DBG_THREADS_PROFILING);
 8002c80:	2000      	movs	r0, #0
 8002c82:	f7fe f91d 	bl	8000ec0 <test_printn>
    test_println("");
 8002c86:	4620      	mov	r0, r4
  }
  test_end_step(1);
}
 8002c88:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println("");
 8002c8c:	f7fe b9c8 	b.w	8001020 <test_println>
 8002c90:	20001d94 	.word	0x20001d94
 8002c94:	0800c7f4 	.word	0x0800c7f4
 8002c98:	0800b92c 	.word	0x0800b92c
 8002c9c:	0800b958 	.word	0x0800b958
 8002ca0:	0800b984 	.word	0x0800b984
 8002ca4:	0800b9b0 	.word	0x0800b9b0
 8002ca8:	0800b9dc 	.word	0x0800b9dc
 8002cac:	0800ba08 	.word	0x0800ba08
 8002cb0:	0800ba34 	.word	0x0800ba34
 8002cb4:	0800ba60 	.word	0x0800ba60
 8002cb8:	0800ba8c 	.word	0x0800ba8c
 8002cbc:	0800bab8 	.word	0x0800bab8
 8002cc0:	0800bae4 	.word	0x0800bae4
 8002cc4:	0800bb10 	.word	0x0800bb10
 8002cc8:	0800bb3c 	.word	0x0800bb3c
 8002ccc:	0800bb68 	.word	0x0800bb68
 8002cd0:	0800bb94 	.word	0x0800bb94
 8002cd4:	0800bbc0 	.word	0x0800bbc0
 8002cd8:	0800bbec 	.word	0x0800bbec
 8002cdc:	0800bc18 	.word	0x0800bc18
 8002ce0:	0800bc44 	.word	0x0800bc44
 8002ce4:	0800bc70 	.word	0x0800bc70
 8002ce8:	0800bc9c 	.word	0x0800bc9c
 8002cec:	0800bcc8 	.word	0x0800bcc8
 8002cf0:	0800bcf4 	.word	0x0800bcf4
 8002cf4:	0800bd20 	.word	0x0800bd20
 8002cf8:	0800bd4c 	.word	0x0800bd4c
 8002cfc:	0800bd78 	.word	0x0800bd78
 8002d00:	0800bda4 	.word	0x0800bda4
 8002d04:	0800bdd0 	.word	0x0800bdd0
 8002d08:	0800bdfc 	.word	0x0800bdfc
 8002d0c:	0800be28 	.word	0x0800be28
 8002d10:	0800be54 	.word	0x0800be54
 8002d14:	0800be80 	.word	0x0800be80
	...

08002d20 <rt_test_001_002_execute>:
static void rt_test_001_002_execute(void) {
 8002d20:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 8002d22:	2501      	movs	r5, #1
 8002d24:	4b18      	ldr	r3, [pc, #96]	; (8002d88 <rt_test_001_002_execute+0x68>)
    test_println("--- Product:                            ChibiOS/RT");
 8002d26:	4819      	ldr	r0, [pc, #100]	; (8002d8c <rt_test_001_002_execute+0x6c>)
  test_set_step(1);
 8002d28:	601d      	str	r5, [r3, #0]
    test_println("");
 8002d2a:	4c19      	ldr	r4, [pc, #100]	; (8002d90 <rt_test_001_002_execute+0x70>)
    test_println("--- Product:                            ChibiOS/RT");
 8002d2c:	f7fe f978 	bl	8001020 <test_println>
    test_print("--- Stable Flag:                        ");
 8002d30:	4818      	ldr	r0, [pc, #96]	; (8002d94 <rt_test_001_002_execute+0x74>)
 8002d32:	f7fe f995 	bl	8001060 <test_print>
 8002d36:	4628      	mov	r0, r5
 8002d38:	f7fe f892 	bl	8000e60 <test_printn.part.0>
    test_println("");
 8002d3c:	4620      	mov	r0, r4
 8002d3e:	f7fe f96f 	bl	8001020 <test_println>
    test_print("--- Version String:                     ");
 8002d42:	4815      	ldr	r0, [pc, #84]	; (8002d98 <rt_test_001_002_execute+0x78>)
 8002d44:	f7fe f98c 	bl	8001060 <test_print>
    test_println(CH_KERNEL_VERSION);
 8002d48:	4814      	ldr	r0, [pc, #80]	; (8002d9c <rt_test_001_002_execute+0x7c>)
 8002d4a:	f7fe f969 	bl	8001020 <test_println>
    test_print("--- Major Number:                       ");
 8002d4e:	4814      	ldr	r0, [pc, #80]	; (8002da0 <rt_test_001_002_execute+0x80>)
 8002d50:	f7fe f986 	bl	8001060 <test_print>
 8002d54:	2006      	movs	r0, #6
 8002d56:	f7fe f883 	bl	8000e60 <test_printn.part.0>
    test_println("");
 8002d5a:	4620      	mov	r0, r4
 8002d5c:	f7fe f960 	bl	8001020 <test_println>
    test_print("--- Minor Number:                       ");
 8002d60:	4810      	ldr	r0, [pc, #64]	; (8002da4 <rt_test_001_002_execute+0x84>)
 8002d62:	f7fe f97d 	bl	8001060 <test_print>
 8002d66:	4628      	mov	r0, r5
 8002d68:	f7fe f87a 	bl	8000e60 <test_printn.part.0>
    test_println("");
 8002d6c:	4620      	mov	r0, r4
 8002d6e:	f7fe f957 	bl	8001020 <test_println>
    test_print("--- Patch Number:                       ");
 8002d72:	480d      	ldr	r0, [pc, #52]	; (8002da8 <rt_test_001_002_execute+0x88>)
 8002d74:	f7fe f974 	bl	8001060 <test_print>
 8002d78:	4628      	mov	r0, r5
 8002d7a:	f7fe f871 	bl	8000e60 <test_printn.part.0>
    test_println("");
 8002d7e:	4620      	mov	r0, r4
}
 8002d80:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println("");
 8002d84:	f7fe b94c 	b.w	8001020 <test_println>
 8002d88:	20001d94 	.word	0x20001d94
 8002d8c:	0800b8e0 	.word	0x0800b8e0
 8002d90:	0800c7f4 	.word	0x0800c7f4
 8002d94:	0800ad88 	.word	0x0800ad88
 8002d98:	0800adb4 	.word	0x0800adb4
 8002d9c:	0800b914 	.word	0x0800b914
 8002da0:	0800ade8 	.word	0x0800ade8
 8002da4:	0800ae14 	.word	0x0800ae14
 8002da8:	0800ae40 	.word	0x0800ae40
 8002dac:	00000000 	.word	0x00000000

08002db0 <rt_test_001_001_execute>:
  test_set_step(1);
 8002db0:	2201      	movs	r2, #1
 8002db2:	4b1c      	ldr	r3, [pc, #112]	; (8002e24 <rt_test_001_001_execute+0x74>)
static void rt_test_001_001_execute(void) {
 8002db4:	b510      	push	{r4, lr}
    test_print("--- Architecture:                       ");
 8002db6:	481c      	ldr	r0, [pc, #112]	; (8002e28 <rt_test_001_001_execute+0x78>)
  test_set_step(1);
 8002db8:	601a      	str	r2, [r3, #0]
    test_print("--- Architecture:                       ");
 8002dba:	f7fe f951 	bl	8001060 <test_print>
    test_println(PORT_ARCHITECTURE_NAME);
 8002dbe:	481b      	ldr	r0, [pc, #108]	; (8002e2c <rt_test_001_001_execute+0x7c>)
 8002dc0:	f7fe f92e 	bl	8001020 <test_println>
    test_print("--- Core Variant:                       ");
 8002dc4:	481a      	ldr	r0, [pc, #104]	; (8002e30 <rt_test_001_001_execute+0x80>)
 8002dc6:	f7fe f94b 	bl	8001060 <test_print>
    test_println(PORT_CORE_VARIANT_NAME);
 8002dca:	481a      	ldr	r0, [pc, #104]	; (8002e34 <rt_test_001_001_execute+0x84>)
 8002dcc:	f7fe f928 	bl	8001020 <test_println>
    test_print("--- Compiler:                           ");
 8002dd0:	4819      	ldr	r0, [pc, #100]	; (8002e38 <rt_test_001_001_execute+0x88>)
 8002dd2:	f7fe f945 	bl	8001060 <test_print>
    test_println(PORT_COMPILER_NAME);
 8002dd6:	4819      	ldr	r0, [pc, #100]	; (8002e3c <rt_test_001_001_execute+0x8c>)
 8002dd8:	f7fe f922 	bl	8001020 <test_println>
    test_print("--- Port Info:                          ");
 8002ddc:	4818      	ldr	r0, [pc, #96]	; (8002e40 <rt_test_001_001_execute+0x90>)
 8002dde:	f7fe f93f 	bl	8001060 <test_print>
    test_println(PORT_INFO);
 8002de2:	4818      	ldr	r0, [pc, #96]	; (8002e44 <rt_test_001_001_execute+0x94>)
    test_println("");
 8002de4:	4c18      	ldr	r4, [pc, #96]	; (8002e48 <rt_test_001_001_execute+0x98>)
    test_println(PORT_INFO);
 8002de6:	f7fe f91b 	bl	8001020 <test_println>
    test_print("--- Natural alignment:                  ");
 8002dea:	4818      	ldr	r0, [pc, #96]	; (8002e4c <rt_test_001_001_execute+0x9c>)
 8002dec:	f7fe f938 	bl	8001060 <test_print>
 8002df0:	2004      	movs	r0, #4
 8002df2:	f7fe f835 	bl	8000e60 <test_printn.part.0>
    test_println("");
 8002df6:	4620      	mov	r0, r4
 8002df8:	f7fe f912 	bl	8001020 <test_println>
    test_print("--- Stack alignment:                    ");
 8002dfc:	4814      	ldr	r0, [pc, #80]	; (8002e50 <rt_test_001_001_execute+0xa0>)
 8002dfe:	f7fe f92f 	bl	8001060 <test_print>
 8002e02:	2008      	movs	r0, #8
 8002e04:	f7fe f82c 	bl	8000e60 <test_printn.part.0>
    test_println("");
 8002e08:	4620      	mov	r0, r4
 8002e0a:	f7fe f909 	bl	8001020 <test_println>
    test_print("--- Working area alignment:             ");
 8002e0e:	4811      	ldr	r0, [pc, #68]	; (8002e54 <rt_test_001_001_execute+0xa4>)
 8002e10:	f7fe f926 	bl	8001060 <test_print>
 8002e14:	2008      	movs	r0, #8
 8002e16:	f7fe f823 	bl	8000e60 <test_printn.part.0>
    test_println("");
 8002e1a:	4620      	mov	r0, r4
}
 8002e1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    test_println("");
 8002e20:	f7fe b8fe 	b.w	8001020 <test_println>
 8002e24:	20001d94 	.word	0x20001d94
 8002e28:	0800b728 	.word	0x0800b728
 8002e2c:	0800b754 	.word	0x0800b754
 8002e30:	0800b75c 	.word	0x0800b75c
 8002e34:	0800b788 	.word	0x0800b788
 8002e38:	0800b794 	.word	0x0800b794
 8002e3c:	0800b7c0 	.word	0x0800b7c0
 8002e40:	0800b808 	.word	0x0800b808
 8002e44:	0800b834 	.word	0x0800b834
 8002e48:	0800c7f4 	.word	0x0800c7f4
 8002e4c:	0800b84c 	.word	0x0800b84c
 8002e50:	0800b878 	.word	0x0800b878
 8002e54:	0800b8a4 	.word	0x0800b8a4
	...

08002e60 <oslib_test_001_001_execute>:
 8002e60:	f7ff bfa6 	b.w	8002db0 <rt_test_001_001_execute>
	...

08002e70 <usbInitEndpointI>:
  if (epcp->in_state != NULL) {
 8002e70:	6953      	ldr	r3, [r2, #20]
                      const USBEndpointConfig *epcp) {
 8002e72:	b410      	push	{r4}
  usbp->epc[ep] = epcp;
 8002e74:	eb00 0481 	add.w	r4, r0, r1, lsl #2
 8002e78:	60e2      	str	r2, [r4, #12]
  if (epcp->in_state != NULL) {
 8002e7a:	b123      	cbz	r3, 8002e86 <usbInitEndpointI+0x16>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8002e7c:	2400      	movs	r4, #0
 8002e7e:	601c      	str	r4, [r3, #0]
 8002e80:	605c      	str	r4, [r3, #4]
 8002e82:	609c      	str	r4, [r3, #8]
 8002e84:	60dc      	str	r4, [r3, #12]
  if (epcp->out_state != NULL) {
 8002e86:	6993      	ldr	r3, [r2, #24]
 8002e88:	b123      	cbz	r3, 8002e94 <usbInitEndpointI+0x24>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8002e8a:	2200      	movs	r2, #0
 8002e8c:	601a      	str	r2, [r3, #0]
 8002e8e:	605a      	str	r2, [r3, #4]
 8002e90:	609a      	str	r2, [r3, #8]
 8002e92:	60da      	str	r2, [r3, #12]
}
 8002e94:	bc10      	pop	{r4}
  usb_lld_init_endpoint(usbp, ep);
 8002e96:	f7fe bf03 	b.w	8001ca0 <usb_lld_init_endpoint>
 8002e9a:	bf00      	nop
 8002e9c:	0000      	movs	r0, r0
	...

08002ea0 <usb_event>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8002ea0:	b570      	push	{r4, r5, r6, lr}
  switch (event) {
 8002ea2:	2905      	cmp	r1, #5
 8002ea4:	d81e      	bhi.n	8002ee4 <usb_event+0x44>
 8002ea6:	e8df f001 	tbb	[pc, r1]
 8002eaa:	1d03      	.short	0x1d03
 8002eac:	4f03031e 	.word	0x4f03031e
 8002eb0:	2320      	movs	r3, #32
 8002eb2:	f383 8811 	msr	BASEPRI, r3
  if (bqIsSuspendedX(&sdup->ibqueue) && bqIsSuspendedX(&sdup->obqueue)) {
 8002eb6:	4c2c      	ldr	r4, [pc, #176]	; (8002f68 <usb_event+0xc8>)
 8002eb8:	7d23      	ldrb	r3, [r4, #20]
 8002eba:	b113      	cbz	r3, 8002ec2 <usb_event+0x22>
 8002ebc:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
 8002ec0:	b96b      	cbnz	r3, 8002ede <usb_event+0x3e>
  bqSuspendI(&sdup->ibqueue);
 8002ec2:	2501      	movs	r5, #1
  chEvtBroadcastFlagsI(esp, flags);
 8002ec4:	2102      	movs	r1, #2
 8002ec6:	4829      	ldr	r0, [pc, #164]	; (8002f6c <usb_event+0xcc>)
 8002ec8:	f7fe fc7a 	bl	80017c0 <chEvtBroadcastFlagsI>
  chThdDequeueAllI(tqp, msg);
 8002ecc:	4828      	ldr	r0, [pc, #160]	; (8002f70 <usb_event+0xd0>)
 8002ece:	7525      	strb	r5, [r4, #20]
 8002ed0:	f7fe fba6 	bl	8001620 <chThdDequeueAllI.constprop.97>
 8002ed4:	4827      	ldr	r0, [pc, #156]	; (8002f74 <usb_event+0xd4>)
  bqSuspendI(&sdup->obqueue);
 8002ed6:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8002eda:	f7fe fba1 	bl	8001620 <chThdDequeueAllI.constprop.97>
 8002ede:	2300      	movs	r3, #0
 8002ee0:	f383 8811 	msr	BASEPRI, r3
}
 8002ee4:	bd70      	pop	{r4, r5, r6, pc}
 8002ee6:	4606      	mov	r6, r0
 8002ee8:	2320      	movs	r3, #32
 8002eea:	f383 8811 	msr	BASEPRI, r3
  ibqp->bcounter  = 0;
 8002eee:	2500      	movs	r5, #0
 8002ef0:	4c1d      	ldr	r4, [pc, #116]	; (8002f68 <usb_event+0xc8>)
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8002ef2:	4a21      	ldr	r2, [pc, #132]	; (8002f78 <usb_event+0xd8>)
 8002ef4:	2101      	movs	r1, #1
 8002ef6:	f7ff ffbb 	bl	8002e70 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 8002efa:	2102      	movs	r1, #2
 8002efc:	4630      	mov	r0, r6
 8002efe:	4a1f      	ldr	r2, [pc, #124]	; (8002f7c <usb_event+0xdc>)
 8002f00:	f7ff ffb6 	bl	8002e70 <usbInitEndpointI>
  ibqp->brdptr    = ibqp->buffers;
 8002f04:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002f06:	f104 000c 	add.w	r0, r4, #12
  ibqp->bwrptr    = ibqp->buffers;
 8002f0a:	e9c4 3307 	strd	r3, r3, [r4, #28]
  ibqp->bcounter  = 0;
 8002f0e:	61a5      	str	r5, [r4, #24]
  ibqp->top       = NULL;
 8002f10:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8002f14:	f7fe fb84 	bl	8001620 <chThdDequeueAllI.constprop.97>
  obqp->brdptr    = obqp->buffers;
 8002f18:	e9d4 2319 	ldrd	r2, r3, [r4, #100]	; 0x64
 8002f1c:	f104 0044 	add.w	r0, r4, #68	; 0x44
  obqp->bcounter  = bqSizeX(obqp);
 8002f20:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->bwrptr    = obqp->buffers;
 8002f22:	e9c4 3315 	strd	r3, r3, [r4, #84]	; 0x54
  bqResumeX(&sdup->ibqueue);
 8002f26:	7525      	strb	r5, [r4, #20]
  obqp->top       = NULL;
 8002f28:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
 8002f2c:	f7fe fb78 	bl	8001620 <chThdDequeueAllI.constprop.97>
  chEvtBroadcastFlagsI(esp, flags);
 8002f30:	1d20      	adds	r0, r4, #4
 8002f32:	2101      	movs	r1, #1
  bqResumeX(&sdup->obqueue);
 8002f34:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8002f38:	f7fe fc42 	bl	80017c0 <chEvtBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
 8002f3c:	4620      	mov	r0, r4
 8002f3e:	f7ff faa7 	bl	8002490 <sdu_start_receive>
 8002f42:	f385 8811 	msr	BASEPRI, r5
}
 8002f46:	bd70      	pop	{r4, r5, r6, pc}
 8002f48:	2320      	movs	r3, #32
 8002f4a:	f383 8811 	msr	BASEPRI, r3
 8002f4e:	4c06      	ldr	r4, [pc, #24]	; (8002f68 <usb_event+0xc8>)
 8002f50:	2101      	movs	r1, #1
 8002f52:	1d20      	adds	r0, r4, #4
 8002f54:	f7fe fc34 	bl	80017c0 <chEvtBroadcastFlagsI>
  bqResumeX(&sdup->ibqueue);
 8002f58:	2300      	movs	r3, #0
 8002f5a:	7523      	strb	r3, [r4, #20]
  bqResumeX(&sdup->obqueue);
 8002f5c:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8002f60:	f383 8811 	msr	BASEPRI, r3
 8002f64:	bd70      	pop	{r4, r5, r6, pc}
 8002f66:	bf00      	nop
 8002f68:	20000ce8 	.word	0x20000ce8
 8002f6c:	20000cec 	.word	0x20000cec
 8002f70:	20000cf4 	.word	0x20000cf4
 8002f74:	20000d2c 	.word	0x20000d2c
 8002f78:	0800acc4 	.word	0x0800acc4
 8002f7c:	0800ace8 	.word	0x0800ace8

08002f80 <parse_arguments>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *parse_arguments(char *str, char **saveptr) {
 8002f80:	b538      	push	{r3, r4, r5, lr}
 8002f82:	460d      	mov	r5, r1
  char *p;

  if (str != NULL)
 8002f84:	b1e8      	cbz	r0, 8002fc2 <parse_arguments+0x42>
 8002f86:	4604      	mov	r4, r0
    *saveptr = str;
 8002f88:	6028      	str	r0, [r5, #0]
  if (!p) {
    return NULL;
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");
 8002f8a:	4911      	ldr	r1, [pc, #68]	; (8002fd0 <parse_arguments+0x50>)
 8002f8c:	4620      	mov	r0, r4
 8002f8e:	f7fd fc4f 	bl	8000830 <strspn>

  if (*p == '"') {
 8002f92:	5c21      	ldrb	r1, [r4, r0]
  p += strspn(p, " \t");
 8002f94:	4404      	add	r4, r0
  if (*p == '"') {
 8002f96:	2922      	cmp	r1, #34	; 0x22
 8002f98:	d00d      	beq.n	8002fb6 <parse_arguments+0x36>
    p++;
    *saveptr = strpbrk(p, "\"");
  }
  else {
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
 8002f9a:	490d      	ldr	r1, [pc, #52]	; (8002fd0 <parse_arguments+0x50>)
 8002f9c:	4620      	mov	r0, r4
 8002f9e:	f7fd fc25 	bl	80007ec <strpbrk>
 8002fa2:	6028      	str	r0, [r5, #0]
  }

  /* Replacing the delimiter with a zero.*/
  if (*saveptr != NULL) {
 8002fa4:	b118      	cbz	r0, 8002fae <parse_arguments+0x2e>
    *(*saveptr)++ = '\0';
 8002fa6:	2300      	movs	r3, #0
 8002fa8:	1c42      	adds	r2, r0, #1
 8002faa:	602a      	str	r2, [r5, #0]
 8002fac:	7003      	strb	r3, [r0, #0]
  }

  return *p != '\0' ? p : NULL;
 8002fae:	7823      	ldrb	r3, [r4, #0]
 8002fb0:	b153      	cbz	r3, 8002fc8 <parse_arguments+0x48>
}
 8002fb2:	4620      	mov	r0, r4
 8002fb4:	bd38      	pop	{r3, r4, r5, pc}
    p++;
 8002fb6:	3401      	adds	r4, #1
    *saveptr = strpbrk(p, "\"");
 8002fb8:	4620      	mov	r0, r4
 8002fba:	f7fd fa49 	bl	8000450 <strchr>
 8002fbe:	6028      	str	r0, [r5, #0]
 8002fc0:	e7f0      	b.n	8002fa4 <parse_arguments+0x24>
  p = *saveptr;
 8002fc2:	680c      	ldr	r4, [r1, #0]
  if (!p) {
 8002fc4:	2c00      	cmp	r4, #0
 8002fc6:	d1e0      	bne.n	8002f8a <parse_arguments+0xa>
  return *p != '\0' ? p : NULL;
 8002fc8:	2400      	movs	r4, #0
}
 8002fca:	4620      	mov	r0, r4
 8002fcc:	bd38      	pop	{r3, r4, r5, pc}
 8002fce:	bf00      	nop
 8002fd0:	0800b680 	.word	0x0800b680
	...

08002fe0 <chprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8002fe0:	b40e      	push	{r1, r2, r3}
 8002fe2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002fe6:	b086      	sub	sp, #24
 8002fe8:	ab0f      	add	r3, sp, #60	; 0x3c
 8002fea:	f853 4b04 	ldr.w	r4, [r3], #4
 8002fee:	4605      	mov	r5, r0
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8002ff0:	9302      	str	r3, [sp, #8]
 8002ff2:	469b      	mov	fp, r3
  int n = 0;
 8002ff4:	2700      	movs	r7, #0
 8002ff6:	e005      	b.n	8003004 <chprintf+0x24>
      streamPut(chp, (uint8_t)c);
 8002ff8:	682b      	ldr	r3, [r5, #0]
 8002ffa:	4628      	mov	r0, r5
 8002ffc:	68db      	ldr	r3, [r3, #12]
      n++;
 8002ffe:	3701      	adds	r7, #1
    c = *fmt++;
 8003000:	4614      	mov	r4, r2
      streamPut(chp, (uint8_t)c);
 8003002:	4798      	blx	r3
    c = *fmt++;
 8003004:	7821      	ldrb	r1, [r4, #0]
 8003006:	1c62      	adds	r2, r4, #1
    if (c == 0) {
 8003008:	2900      	cmp	r1, #0
 800300a:	d07f      	beq.n	800310c <chprintf+0x12c>
    if (c != '%') {
 800300c:	2925      	cmp	r1, #37	; 0x25
 800300e:	d1f3      	bne.n	8002ff8 <chprintf+0x18>
    if (*fmt == '-') {
 8003010:	7863      	ldrb	r3, [r4, #1]
 8003012:	2b2d      	cmp	r3, #45	; 0x2d
 8003014:	bf03      	ittte	eq
 8003016:	78a3      	ldrbeq	r3, [r4, #2]
      fmt++;
 8003018:	1ca2      	addeq	r2, r4, #2
      left_align = true;
 800301a:	2101      	moveq	r1, #1
    left_align = false;
 800301c:	2100      	movne	r1, #0
    if (*fmt == '+') {
 800301e:	2b2b      	cmp	r3, #43	; 0x2b
      do_sign = true;
 8003020:	bf05      	ittet	eq
 8003022:	f04f 0c01 	moveq.w	ip, #1
 8003026:	7853      	ldrbeq	r3, [r2, #1]
    do_sign = false;
 8003028:	f04f 0c00 	movne.w	ip, #0
      fmt++;
 800302c:	4462      	addeq	r2, ip
    if (*fmt == '0') {
 800302e:	2b30      	cmp	r3, #48	; 0x30
 8003030:	bf03      	ittte	eq
 8003032:	7853      	ldrbeq	r3, [r2, #1]
      filler = '0';
 8003034:	f04f 0830 	moveq.w	r8, #48	; 0x30
      fmt++;
 8003038:	3201      	addeq	r2, #1
    filler = ' ';
 800303a:	f04f 0820 	movne.w	r8, #32
    if ( *fmt == '*') {
 800303e:	2b2a      	cmp	r3, #42	; 0x2a
 8003040:	d14d      	bne.n	80030de <chprintf+0xfe>
      width = va_arg(ap, int);
 8003042:	f8db 6000 	ldr.w	r6, [fp]
      c = *fmt++;
 8003046:	7853      	ldrb	r3, [r2, #1]
      width = va_arg(ap, int);
 8003048:	f10b 0004 	add.w	r0, fp, #4
      c = *fmt++;
 800304c:	1c94      	adds	r4, r2, #2
    if (c == '.') {
 800304e:	2b2e      	cmp	r3, #46	; 0x2e
 8003050:	f104 0e01 	add.w	lr, r4, #1
 8003054:	f000 809f 	beq.w	8003196 <chprintf+0x1b6>
    precision = 0;
 8003058:	2200      	movs	r2, #0
    if (c == 'l' || c == 'L') {
 800305a:	f003 09df 	and.w	r9, r3, #223	; 0xdf
 800305e:	f1b9 0f4c 	cmp.w	r9, #76	; 0x4c
 8003062:	d059      	beq.n	8003118 <chprintf+0x138>
    switch (c) {
 8003064:	f1a3 0e44 	sub.w	lr, r3, #68	; 0x44
 8003068:	f1be 0f34 	cmp.w	lr, #52	; 0x34
 800306c:	f200 81b7 	bhi.w	80033de <chprintf+0x3fe>
 8003070:	e8df f01e 	tbh	[pc, lr, lsl #1]
 8003074:	01b50169 	.word	0x01b50169
 8003078:	01b501b5 	.word	0x01b501b5
 800307c:	016901b5 	.word	0x016901b5
 8003080:	01b501b5 	.word	0x01b501b5
 8003084:	01b501b5 	.word	0x01b501b5
 8003088:	015401b5 	.word	0x015401b5
 800308c:	01b500b5 	.word	0x01b500b5
 8003090:	01b501b5 	.word	0x01b501b5
 8003094:	015801b5 	.word	0x015801b5
 8003098:	01b501b5 	.word	0x01b501b5
 800309c:	01b500b5 	.word	0x01b500b5
 80030a0:	01b501b5 	.word	0x01b501b5
 80030a4:	01b501b5 	.word	0x01b501b5
 80030a8:	01b501b5 	.word	0x01b501b5
 80030ac:	01b501b5 	.word	0x01b501b5
 80030b0:	015c01b5 	.word	0x015c01b5
 80030b4:	01b50169 	.word	0x01b50169
 80030b8:	01b501b5 	.word	0x01b501b5
 80030bc:	016901b5 	.word	0x016901b5
 80030c0:	01b501b5 	.word	0x01b501b5
 80030c4:	01b501b5 	.word	0x01b501b5
 80030c8:	015401b5 	.word	0x015401b5
 80030cc:	01b500b5 	.word	0x01b500b5
 80030d0:	012701b5 	.word	0x012701b5
 80030d4:	015801b5 	.word	0x015801b5
 80030d8:	01b501b5 	.word	0x01b501b5
 80030dc:	00b5      	.short	0x00b5
        c = *fmt++;
 80030de:	1c54      	adds	r4, r2, #1
        if (c == 0) {
 80030e0:	b1a3      	cbz	r3, 800310c <chprintf+0x12c>
        if (c >= '0' && c <= '9') {
 80030e2:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80030e6:	b2d2      	uxtb	r2, r2
 80030e8:	2a09      	cmp	r2, #9
      width = 0;
 80030ea:	bf98      	it	ls
 80030ec:	2600      	movls	r6, #0
        if (c >= '0' && c <= '9') {
 80030ee:	d902      	bls.n	80030f6 <chprintf+0x116>
 80030f0:	e18e      	b.n	8003410 <chprintf+0x430>
 80030f2:	2a09      	cmp	r2, #9
 80030f4:	d85b      	bhi.n	80031ae <chprintf+0x1ce>
        c = *fmt++;
 80030f6:	f814 3b01 	ldrb.w	r3, [r4], #1
          width = width * 10 + c;
 80030fa:	eb06 0686 	add.w	r6, r6, r6, lsl #2
        if (c >= '0' && c <= '9') {
 80030fe:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
          width = width * 10 + c;
 8003102:	eb02 0646 	add.w	r6, r2, r6, lsl #1
        if (c >= '0' && c <= '9') {
 8003106:	b2c2      	uxtb	r2, r0
        if (c == 0) {
 8003108:	2b00      	cmp	r3, #0
 800310a:	d1f2      	bne.n	80030f2 <chprintf+0x112>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 800310c:	4638      	mov	r0, r7
 800310e:	b006      	add	sp, #24
 8003110:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003114:	b003      	add	sp, #12
 8003116:	4770      	bx	lr
      c = *fmt++;
 8003118:	7823      	ldrb	r3, [r4, #0]
      if (c == 0) {
 800311a:	2b00      	cmp	r3, #0
 800311c:	d0f6      	beq.n	800310c <chprintf+0x12c>
    switch (c) {
 800311e:	f1a3 0444 	sub.w	r4, r3, #68	; 0x44
 8003122:	2c34      	cmp	r4, #52	; 0x34
 8003124:	f200 815a 	bhi.w	80033dc <chprintf+0x3fc>
 8003128:	e8df f014 	tbh	[pc, r4, lsl #1]
 800312c:	01580153 	.word	0x01580153
 8003130:	01580158 	.word	0x01580158
 8003134:	01530158 	.word	0x01530158
 8003138:	01580158 	.word	0x01580158
 800313c:	01580158 	.word	0x01580158
 8003140:	00f70158 	.word	0x00f70158
 8003144:	01580058 	.word	0x01580058
 8003148:	01580158 	.word	0x01580158
 800314c:	00fb0158 	.word	0x00fb0158
 8003150:	01580158 	.word	0x01580158
 8003154:	01580058 	.word	0x01580058
 8003158:	01580158 	.word	0x01580158
 800315c:	01580158 	.word	0x01580158
 8003160:	01580158 	.word	0x01580158
 8003164:	01580158 	.word	0x01580158
 8003168:	00ff0158 	.word	0x00ff0158
 800316c:	01580153 	.word	0x01580153
 8003170:	01580158 	.word	0x01580158
 8003174:	01530158 	.word	0x01530158
 8003178:	01580158 	.word	0x01580158
 800317c:	01580158 	.word	0x01580158
 8003180:	00f70158 	.word	0x00f70158
 8003184:	01580058 	.word	0x01580058
 8003188:	00ca0158 	.word	0x00ca0158
 800318c:	00fb0158 	.word	0x00fb0158
 8003190:	01580158 	.word	0x01580158
 8003194:	0058      	.short	0x0058
      c = *fmt++;
 8003196:	7823      	ldrb	r3, [r4, #0]
      if (c == 0) {
 8003198:	2b00      	cmp	r3, #0
 800319a:	d0b7      	beq.n	800310c <chprintf+0x12c>
      if (c == '*') {
 800319c:	2b2a      	cmp	r3, #42	; 0x2a
 800319e:	d108      	bne.n	80031b2 <chprintf+0x1d2>
        precision = va_arg(ap, int);
 80031a0:	6802      	ldr	r2, [r0, #0]
        c = *fmt++;
 80031a2:	7863      	ldrb	r3, [r4, #1]
 80031a4:	f104 0e03 	add.w	lr, r4, #3
        precision = va_arg(ap, int);
 80031a8:	3004      	adds	r0, #4
        c = *fmt++;
 80031aa:	3402      	adds	r4, #2
 80031ac:	e755      	b.n	800305a <chprintf+0x7a>
        if (c >= '0' && c <= '9') {
 80031ae:	4658      	mov	r0, fp
 80031b0:	e74d      	b.n	800304e <chprintf+0x6e>
    precision = 0;
 80031b2:	2200      	movs	r2, #0
 80031b4:	e006      	b.n	80031c4 <chprintf+0x1e4>
          c = *fmt++;
 80031b6:	f819 3c01 	ldrb.w	r3, [r9, #-1]
          precision = precision * 10 + c;
 80031ba:	eb04 024a 	add.w	r2, r4, sl, lsl #1
 80031be:	46ce      	mov	lr, r9
          if (c == 0) {
 80031c0:	2b00      	cmp	r3, #0
 80031c2:	d0a3      	beq.n	800310c <chprintf+0x12c>
        while (c >= '0' && c <= '9') {
 80031c4:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
 80031c8:	b2e4      	uxtb	r4, r4
 80031ca:	2c09      	cmp	r4, #9
 80031cc:	f10e 0901 	add.w	r9, lr, #1
          precision = precision * 10 + c;
 80031d0:	eb02 0a82 	add.w	sl, r2, r2, lsl #2
        while (c >= '0' && c <= '9') {
 80031d4:	d9ef      	bls.n	80031b6 <chprintf+0x1d6>
 80031d6:	4674      	mov	r4, lr
 80031d8:	46ce      	mov	lr, r9
 80031da:	e73e      	b.n	800305a <chprintf+0x7a>
      c = *fmt++;
 80031dc:	4674      	mov	r4, lr
    switch (c) {
 80031de:	f04f 0e10 	mov.w	lr, #16
 80031e2:	4683      	mov	fp, r0
  q = p + MAX_FILLER;
 80031e4:	f10d 0017 	add.w	r0, sp, #23
 80031e8:	f85b 2b04 	ldr.w	r2, [fp], #4
 80031ec:	e000      	b.n	80031f0 <chprintf+0x210>
  } while ((ll /= radix) != 0);
 80031ee:	4650      	mov	r0, sl
    i = (int)(l % radix);
 80031f0:	fbb2 fcfe 	udiv	ip, r2, lr
 80031f4:	fb0e 221c 	mls	r2, lr, ip, r2
    i += '0';
 80031f8:	f102 0330 	add.w	r3, r2, #48	; 0x30
    if (i > '9') {
 80031fc:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 80031fe:	bfc8      	it	gt
 8003200:	f102 0337 	addgt.w	r3, r2, #55	; 0x37
    l /= radix;
 8003204:	4662      	mov	r2, ip
    *--q = i;
 8003206:	b2db      	uxtb	r3, r3
 8003208:	f800 3c01 	strb.w	r3, [r0, #-1]
 800320c:	f100 3aff 	add.w	sl, r0, #4294967295	; 0xffffffff
  } while ((ll /= radix) != 0);
 8003210:	2a00      	cmp	r2, #0
 8003212:	d1ec      	bne.n	80031ee <chprintf+0x20e>
 8003214:	4602      	mov	r2, r0
  i = (int)(p + MAX_FILLER - q);
 8003216:	f10d 0017 	add.w	r0, sp, #23
 800321a:	f10d 090c 	add.w	r9, sp, #12
 800321e:	eba0 0e0a 	sub.w	lr, r0, sl
 8003222:	46cc      	mov	ip, r9
 8003224:	eb0a 000e 	add.w	r0, sl, lr
 8003228:	e001      	b.n	800322e <chprintf+0x24e>
 800322a:	f812 3b01 	ldrb.w	r3, [r2], #1
  while (--i);
 800322e:	4282      	cmp	r2, r0
    *p++ = *q++;
 8003230:	f80c 3b01 	strb.w	r3, [ip], #1
  while (--i);
 8003234:	d1f9      	bne.n	800322a <chprintf+0x24a>
 8003236:	f10e 33ff 	add.w	r3, lr, #4294967295	; 0xffffffff
 800323a:	eba6 060e 	sub.w	r6, r6, lr
 800323e:	9300      	str	r3, [sp, #0]
    if ((width -= i) < 0) {
 8003240:	2e00      	cmp	r6, #0
 8003242:	db64      	blt.n	800330e <chprintf+0x32e>
    if (left_align == false) {
 8003244:	2900      	cmp	r1, #0
 8003246:	f040 80d4 	bne.w	80033f2 <chprintf+0x412>
      width = -width;
 800324a:	4273      	negs	r3, r6
    if (width < 0) {
 800324c:	2e00      	cmp	r6, #0
 800324e:	f000 80cf 	beq.w	80033f0 <chprintf+0x410>
      if (*s == '-' && filler == '0') {
 8003252:	f899 1000 	ldrb.w	r1, [r9]
 8003256:	682a      	ldr	r2, [r5, #0]
 8003258:	292d      	cmp	r1, #45	; 0x2d
 800325a:	68d2      	ldr	r2, [r2, #12]
 800325c:	f000 80a7 	beq.w	80033ae <chprintf+0x3ce>
 8003260:	469a      	mov	sl, r3
 8003262:	e001      	b.n	8003268 <chprintf+0x288>
 8003264:	682b      	ldr	r3, [r5, #0]
 8003266:	68da      	ldr	r2, [r3, #12]
        streamPut(chp, (uint8_t)filler);
 8003268:	4641      	mov	r1, r8
 800326a:	4628      	mov	r0, r5
 800326c:	4790      	blx	r2
      } while (++width != 0);
 800326e:	f11a 0a01 	adds.w	sl, sl, #1
 8003272:	d1f7      	bne.n	8003264 <chprintf+0x284>
    while (--i >= 0) {
 8003274:	9a00      	ldr	r2, [sp, #0]
 8003276:	4653      	mov	r3, sl
 8003278:	2a00      	cmp	r2, #0
 800327a:	4437      	add	r7, r6
 800327c:	f6ff aec2 	blt.w	8003004 <chprintf+0x24>
 8003280:	461e      	mov	r6, r3
      width = -width;
 8003282:	f8dd a000 	ldr.w	sl, [sp]
      streamPut(chp, (uint8_t)*s++);
 8003286:	682b      	ldr	r3, [r5, #0]
    while (--i >= 0) {
 8003288:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
      streamPut(chp, (uint8_t)*s++);
 800328c:	68db      	ldr	r3, [r3, #12]
 800328e:	f819 1b01 	ldrb.w	r1, [r9], #1
 8003292:	4628      	mov	r0, r5
 8003294:	4798      	blx	r3
    while (--i >= 0) {
 8003296:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 800329a:	d1f4      	bne.n	8003286 <chprintf+0x2a6>
 800329c:	9b00      	ldr	r3, [sp, #0]
 800329e:	3701      	adds	r7, #1
 80032a0:	443b      	add	r3, r7
 80032a2:	461f      	mov	r7, r3
    while (width) {
 80032a4:	2e00      	cmp	r6, #0
 80032a6:	f43f aead 	beq.w	8003004 <chprintf+0x24>
 80032aa:	46b1      	mov	r9, r6
      streamPut(chp, (uint8_t)filler);
 80032ac:	682b      	ldr	r3, [r5, #0]
 80032ae:	4641      	mov	r1, r8
 80032b0:	68db      	ldr	r3, [r3, #12]
 80032b2:	4628      	mov	r0, r5
 80032b4:	4798      	blx	r3
    while (width) {
 80032b6:	f1b9 0901 	subs.w	r9, r9, #1
 80032ba:	d1f7      	bne.n	80032ac <chprintf+0x2cc>
 80032bc:	4437      	add	r7, r6
 80032be:	e6a1      	b.n	8003004 <chprintf+0x24>
      c = *fmt++;
 80032c0:	4674      	mov	r4, lr
      if ((s = va_arg(ap, char *)) == 0) {
 80032c2:	f8d0 9000 	ldr.w	r9, [r0]
 80032c6:	f100 0b04 	add.w	fp, r0, #4
 80032ca:	f1b9 0f00 	cmp.w	r9, #0
 80032ce:	f000 80af 	beq.w	8003430 <chprintf+0x450>
 80032d2:	f899 3000 	ldrb.w	r3, [r9]
 80032d6:	46ca      	mov	sl, r9
      if (precision == 0) {
 80032d8:	2a00      	cmp	r2, #0
 80032da:	f040 808f 	bne.w	80033fc <chprintf+0x41c>
      for (p = s; *p && (--precision >= 0); p++)
 80032de:	2b00      	cmp	r3, #0
 80032e0:	f000 8090 	beq.w	8003404 <chprintf+0x424>
 80032e4:	f647 72fe 	movw	r2, #32766	; 0x7ffe
 80032e8:	464b      	mov	r3, r9
 80032ea:	e001      	b.n	80032f0 <chprintf+0x310>
 80032ec:	1c50      	adds	r0, r2, #1
 80032ee:	d004      	beq.n	80032fa <chprintf+0x31a>
 80032f0:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 80032f4:	3a01      	subs	r2, #1
 80032f6:	2800      	cmp	r0, #0
 80032f8:	d1f8      	bne.n	80032ec <chprintf+0x30c>
 80032fa:	eba3 030a 	sub.w	r3, r3, sl
 80032fe:	1af6      	subs	r6, r6, r3
    if ((width -= i) < 0) {
 8003300:	2e00      	cmp	r6, #0
 8003302:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 8003306:	9300      	str	r3, [sp, #0]
      filler = ' ';
 8003308:	f04f 0820 	mov.w	r8, #32
    if ((width -= i) < 0) {
 800330c:	da9a      	bge.n	8003244 <chprintf+0x264>
    while (--i >= 0) {
 800330e:	9b00      	ldr	r3, [sp, #0]
 8003310:	2b00      	cmp	r3, #0
 8003312:	f6ff ae77 	blt.w	8003004 <chprintf+0x24>
      width = 0;
 8003316:	2600      	movs	r6, #0
 8003318:	e7b3      	b.n	8003282 <chprintf+0x2a2>
      c = *fmt++;
 800331a:	4674      	mov	r4, lr
    case 'O':
 800331c:	f04f 0e08 	mov.w	lr, #8
 8003320:	e75f      	b.n	80031e2 <chprintf+0x202>
      c = *fmt++;
 8003322:	4674      	mov	r4, lr
    case 'U':
 8003324:	f04f 0e0a 	mov.w	lr, #10
 8003328:	e75b      	b.n	80031e2 <chprintf+0x202>
      c = *fmt++;
 800332a:	4674      	mov	r4, lr
      *p++ = va_arg(ap, int);
 800332c:	6803      	ldr	r3, [r0, #0]
 800332e:	f10d 0918 	add.w	r9, sp, #24
 8003332:	f809 3d0c 	strb.w	r3, [r9, #-12]!
 8003336:	2300      	movs	r3, #0
 8003338:	3e01      	subs	r6, #1
 800333a:	f100 0b04 	add.w	fp, r0, #4
 800333e:	9300      	str	r3, [sp, #0]
      filler = ' ';
 8003340:	f04f 0820 	mov.w	r8, #32
 8003344:	e77c      	b.n	8003240 <chprintf+0x260>
 8003346:	4683      	mov	fp, r0
 8003348:	f85b 2b04 	ldr.w	r2, [fp], #4
      if (l < 0) {
 800334c:	2a00      	cmp	r2, #0
 800334e:	db62      	blt.n	8003416 <chprintf+0x436>
        if (do_sign) {
 8003350:	f1bc 0f00 	cmp.w	ip, #0
 8003354:	d068      	beq.n	8003428 <chprintf+0x448>
          *p++ = '+';
 8003356:	232b      	movs	r3, #43	; 0x2b
 8003358:	f10d 0c0d 	add.w	ip, sp, #13
 800335c:	f88d 300c 	strb.w	r3, [sp, #12]
 8003360:	f10d 090c 	add.w	r9, sp, #12
  q = p + MAX_FILLER;
 8003364:	f10c 0a0b 	add.w	sl, ip, #11
 8003368:	4650      	mov	r0, sl
    i = (int)(l % radix);
 800336a:	4b35      	ldr	r3, [pc, #212]	; (8003440 <chprintf+0x460>)
 800336c:	fba3 e302 	umull	lr, r3, r3, r2
 8003370:	08db      	lsrs	r3, r3, #3
 8003372:	469e      	mov	lr, r3
 8003374:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003378:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
  } while ((ll /= radix) != 0);
 800337c:	4672      	mov	r2, lr
    i += '0';
 800337e:	3330      	adds	r3, #48	; 0x30
    *--q = i;
 8003380:	b2db      	uxtb	r3, r3
 8003382:	f800 3d01 	strb.w	r3, [r0, #-1]!
  } while ((ll /= radix) != 0);
 8003386:	2a00      	cmp	r2, #0
 8003388:	d1ef      	bne.n	800336a <chprintf+0x38a>
  i = (int)(p + MAX_FILLER - q);
 800338a:	ebaa 0200 	sub.w	r2, sl, r0
 800338e:	4462      	add	r2, ip
 8003390:	e001      	b.n	8003396 <chprintf+0x3b6>
 8003392:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    *p++ = *q++;
 8003396:	f80c 3b01 	strb.w	r3, [ip], #1
  while (--i);
 800339a:	4594      	cmp	ip, r2
 800339c:	d1f9      	bne.n	8003392 <chprintf+0x3b2>
 800339e:	ebac 0c09 	sub.w	ip, ip, r9
 80033a2:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
 80033a6:	eba6 060c 	sub.w	r6, r6, ip
 80033aa:	9300      	str	r3, [sp, #0]
 80033ac:	e748      	b.n	8003240 <chprintf+0x260>
      if (*s == '-' && filler == '0') {
 80033ae:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 80033b2:	f47f af55 	bne.w	8003260 <chprintf+0x280>
        streamPut(chp, (uint8_t)*s++);
 80033b6:	4628      	mov	r0, r5
 80033b8:	9301      	str	r3, [sp, #4]
 80033ba:	4790      	blx	r2
 80033bc:	9b00      	ldr	r3, [sp, #0]
 80033be:	682a      	ldr	r2, [r5, #0]
 80033c0:	3b01      	subs	r3, #1
 80033c2:	9300      	str	r3, [sp, #0]
 80033c4:	9b01      	ldr	r3, [sp, #4]
 80033c6:	3701      	adds	r7, #1
 80033c8:	68d2      	ldr	r2, [r2, #12]
 80033ca:	f109 0901 	add.w	r9, r9, #1
 80033ce:	469a      	mov	sl, r3
 80033d0:	e74a      	b.n	8003268 <chprintf+0x288>
 80033d2:	4683      	mov	fp, r0
      c = *fmt++;
 80033d4:	4674      	mov	r4, lr
 80033d6:	f85b 2b04 	ldr.w	r2, [fp], #4
 80033da:	e7b7      	b.n	800334c <chprintf+0x36c>
 80033dc:	4674      	mov	r4, lr
      *p++ = c;
 80033de:	f10d 0918 	add.w	r9, sp, #24
 80033e2:	f809 3d0c 	strb.w	r3, [r9, #-12]!
 80033e6:	2300      	movs	r3, #0
 80033e8:	3e01      	subs	r6, #1
 80033ea:	4683      	mov	fp, r0
 80033ec:	9300      	str	r3, [sp, #0]
 80033ee:	e727      	b.n	8003240 <chprintf+0x260>
      width = -width;
 80033f0:	461e      	mov	r6, r3
    while (--i >= 0) {
 80033f2:	9b00      	ldr	r3, [sp, #0]
 80033f4:	2b00      	cmp	r3, #0
 80033f6:	f6bf af44 	bge.w	8003282 <chprintf+0x2a2>
 80033fa:	e753      	b.n	80032a4 <chprintf+0x2c4>
      for (p = s; *p && (--precision >= 0); p++)
 80033fc:	b113      	cbz	r3, 8003404 <chprintf+0x424>
 80033fe:	3a01      	subs	r2, #1
 8003400:	f57f af72 	bpl.w	80032e8 <chprintf+0x308>
 8003404:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
      filler = ' ';
 8003408:	f04f 0820 	mov.w	r8, #32
      for (p = s; *p && (--precision >= 0); p++)
 800340c:	9300      	str	r3, [sp, #0]
 800340e:	e717      	b.n	8003240 <chprintf+0x260>
        if (c >= '0' && c <= '9') {
 8003410:	4658      	mov	r0, fp
      width = 0;
 8003412:	2600      	movs	r6, #0
 8003414:	e61b      	b.n	800304e <chprintf+0x6e>
        *p++ = '-';
 8003416:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8003418:	4252      	negs	r2, r2
        *p++ = '-';
 800341a:	f88d 300c 	strb.w	r3, [sp, #12]
 800341e:	f10d 0c0d 	add.w	ip, sp, #13
 8003422:	f10d 090c 	add.w	r9, sp, #12
 8003426:	e79d      	b.n	8003364 <chprintf+0x384>
    p = tmpbuf;
 8003428:	f10d 090c 	add.w	r9, sp, #12
 800342c:	46cc      	mov	ip, r9
 800342e:	e799      	b.n	8003364 <chprintf+0x384>
 8003430:	f8df a010 	ldr.w	sl, [pc, #16]	; 8003444 <chprintf+0x464>
      if (precision == 0) {
 8003434:	46d1      	mov	r9, sl
 8003436:	2a00      	cmp	r2, #0
 8003438:	f43f af54 	beq.w	80032e4 <chprintf+0x304>
 800343c:	e7df      	b.n	80033fe <chprintf+0x41e>
 800343e:	bf00      	nop
 8003440:	cccccccd 	.word	0xcccccccd
 8003444:	0800aa24 	.word	0x0800aa24
	...

08003450 <cmd_write>:
                "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";

        (void)argv;
        if (argc > 0) {
 8003450:	2900      	cmp	r1, #0
 8003452:	dc18      	bgt.n	8003486 <cmd_write+0x36>
static void cmd_write(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003454:	b570      	push	{r4, r5, r6, lr}
 8003456:	4604      	mov	r4, r0
        }

        while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
        #if 1
                /* Writing in channel mode.*/
                chnWrite(&SDU1, buf, sizeof buf - 1);
 8003458:	4e0c      	ldr	r6, [pc, #48]	; (800348c <cmd_write+0x3c>)
 800345a:	4d0d      	ldr	r5, [pc, #52]	; (8003490 <cmd_write+0x40>)
 800345c:	e005      	b.n	800346a <cmd_write+0x1a>
 800345e:	6833      	ldr	r3, [r6, #0]
 8003460:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8003464:	685b      	ldr	r3, [r3, #4]
 8003466:	4629      	mov	r1, r5
 8003468:	4798      	blx	r3
        while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
 800346a:	6823      	ldr	r3, [r4, #0]
 800346c:	2100      	movs	r1, #0
 800346e:	699b      	ldr	r3, [r3, #24]
 8003470:	4620      	mov	r0, r4
 8003472:	4798      	blx	r3
 8003474:	3001      	adds	r0, #1
                chnWrite(&SDU1, buf, sizeof buf - 1);
 8003476:	4805      	ldr	r0, [pc, #20]	; (800348c <cmd_write+0x3c>)
        while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
 8003478:	d0f1      	beq.n	800345e <cmd_write+0xe>
                (void) obqGetEmptyBufferTimeout(&SDU1.obqueue, TIME_INFINITE);
                memcpy(SDU1.obqueue.ptr, buf, SERIAL_USB_BUFFERS_SIZE);
                obqPostFullBuffer(&SDU1.obqueue, SERIAL_USB_BUFFERS_SIZE);
        #endif
        }
        chprintf(chp, "\r\n\nstopped\r\n");
 800347a:	4620      	mov	r0, r4
}
 800347c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        chprintf(chp, "\r\n\nstopped\r\n");
 8003480:	4904      	ldr	r1, [pc, #16]	; (8003494 <cmd_write+0x44>)
 8003482:	f7ff bdad 	b.w	8002fe0 <chprintf>
                chprintf(chp, "Usage: write\r\n");
 8003486:	4904      	ldr	r1, [pc, #16]	; (8003498 <cmd_write+0x48>)
 8003488:	f7ff bdaa 	b.w	8002fe0 <chprintf>
 800348c:	20000ce8 	.word	0x20000ce8
 8003490:	20000800 	.word	0x20000800
 8003494:	0800ac70 	.word	0x0800ac70
 8003498:	0800ac80 	.word	0x0800ac80
 800349c:	00000000 	.word	0x00000000

080034a0 <cmd_systime>:

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 80034a0:	2900      	cmp	r1, #0
 80034a2:	dd03      	ble.n	80034ac <cmd_systime+0xc>
    shellUsage(chp, "systime");
 80034a4:	4a08      	ldr	r2, [pc, #32]	; (80034c8 <cmd_systime+0x28>)
 80034a6:	4909      	ldr	r1, [pc, #36]	; (80034cc <cmd_systime+0x2c>)
 80034a8:	f7ff bd9a 	b.w	8002fe0 <chprintf>
 80034ac:	2320      	movs	r3, #32
 80034ae:	f383 8811 	msr	BASEPRI, r3
  return (systime_t)STM32_ST_TIM->CNT;
 80034b2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80034b6:	2300      	movs	r3, #0
 80034b8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80034ba:	f383 8811 	msr	BASEPRI, r3
    return;
  }
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 80034be:	4904      	ldr	r1, [pc, #16]	; (80034d0 <cmd_systime+0x30>)
 80034c0:	b292      	uxth	r2, r2
 80034c2:	f7ff bd8d 	b.w	8002fe0 <chprintf>
 80034c6:	bf00      	nop
 80034c8:	0800abc8 	.word	0x0800abc8
 80034cc:	0800abd0 	.word	0x0800abd0
 80034d0:	0800abdc 	.word	0x0800abdc
	...

080034e0 <cmd_echo>:
  if (argc != 1) {
 80034e0:	2901      	cmp	r1, #1
 80034e2:	d003      	beq.n	80034ec <cmd_echo+0xc>
    shellUsage(chp, "echo \"message\"");
 80034e4:	4a03      	ldr	r2, [pc, #12]	; (80034f4 <cmd_echo+0x14>)
 80034e6:	4904      	ldr	r1, [pc, #16]	; (80034f8 <cmd_echo+0x18>)
 80034e8:	f7ff bd7a 	b.w	8002fe0 <chprintf>
  chprintf(chp, "%s" SHELL_NEWLINE_STR, argv[0]);
 80034ec:	6812      	ldr	r2, [r2, #0]
 80034ee:	4903      	ldr	r1, [pc, #12]	; (80034fc <cmd_echo+0x1c>)
 80034f0:	f7ff bd76 	b.w	8002fe0 <chprintf>
 80034f4:	0800aa2c 	.word	0x0800aa2c
 80034f8:	0800abd0 	.word	0x0800abd0
 80034fc:	0800aa3c 	.word	0x0800aa3c

08003500 <cmd_info>:
  if (argc > 0) {
 8003500:	2900      	cmp	r1, #0
 8003502:	dd03      	ble.n	800350c <cmd_info+0xc>
    shellUsage(chp, "info");
 8003504:	4a19      	ldr	r2, [pc, #100]	; (800356c <cmd_info+0x6c>)
 8003506:	491a      	ldr	r1, [pc, #104]	; (8003570 <cmd_info+0x70>)
 8003508:	f7ff bd6a 	b.w	8002fe0 <chprintf>
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 800350c:	b510      	push	{r4, lr}
 800350e:	4604      	mov	r4, r0
 8003510:	b082      	sub	sp, #8
  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8003512:	4a18      	ldr	r2, [pc, #96]	; (8003574 <cmd_info+0x74>)
 8003514:	4918      	ldr	r1, [pc, #96]	; (8003578 <cmd_info+0x78>)
 8003516:	f7ff fd63 	bl	8002fe0 <chprintf>
  chprintf(chp, "Compiler:     %s" SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
 800351a:	4a18      	ldr	r2, [pc, #96]	; (800357c <cmd_info+0x7c>)
 800351c:	4918      	ldr	r1, [pc, #96]	; (8003580 <cmd_info+0x80>)
 800351e:	4620      	mov	r0, r4
 8003520:	f7ff fd5e 	bl	8002fe0 <chprintf>
  chprintf(chp, "Architecture: %s" SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 8003524:	4a17      	ldr	r2, [pc, #92]	; (8003584 <cmd_info+0x84>)
 8003526:	4918      	ldr	r1, [pc, #96]	; (8003588 <cmd_info+0x88>)
 8003528:	4620      	mov	r0, r4
 800352a:	f7ff fd59 	bl	8002fe0 <chprintf>
  chprintf(chp, "Core Variant: %s" SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
 800352e:	4a17      	ldr	r2, [pc, #92]	; (800358c <cmd_info+0x8c>)
 8003530:	4917      	ldr	r1, [pc, #92]	; (8003590 <cmd_info+0x90>)
 8003532:	4620      	mov	r0, r4
 8003534:	f7ff fd54 	bl	8002fe0 <chprintf>
  chprintf(chp, "Port Info:    %s" SHELL_NEWLINE_STR, PORT_INFO);
 8003538:	4a16      	ldr	r2, [pc, #88]	; (8003594 <cmd_info+0x94>)
 800353a:	4917      	ldr	r1, [pc, #92]	; (8003598 <cmd_info+0x98>)
 800353c:	4620      	mov	r0, r4
 800353e:	f7ff fd4f 	bl	8002fe0 <chprintf>
  chprintf(chp, "Platform:     %s" SHELL_NEWLINE_STR, PLATFORM_NAME);
 8003542:	4a16      	ldr	r2, [pc, #88]	; (800359c <cmd_info+0x9c>)
 8003544:	4916      	ldr	r1, [pc, #88]	; (80035a0 <cmd_info+0xa0>)
 8003546:	4620      	mov	r0, r4
 8003548:	f7ff fd4a 	bl	8002fe0 <chprintf>
  chprintf(chp, "Board:        %s" SHELL_NEWLINE_STR, BOARD_NAME);
 800354c:	4a15      	ldr	r2, [pc, #84]	; (80035a4 <cmd_info+0xa4>)
 800354e:	4916      	ldr	r1, [pc, #88]	; (80035a8 <cmd_info+0xa8>)
 8003550:	4620      	mov	r0, r4
 8003552:	f7ff fd45 	bl	8002fe0 <chprintf>
  chprintf(chp, "Build time:   %s%s%s" SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 8003556:	4b15      	ldr	r3, [pc, #84]	; (80035ac <cmd_info+0xac>)
 8003558:	4620      	mov	r0, r4
 800355a:	9300      	str	r3, [sp, #0]
 800355c:	4a14      	ldr	r2, [pc, #80]	; (80035b0 <cmd_info+0xb0>)
 800355e:	4b15      	ldr	r3, [pc, #84]	; (80035b4 <cmd_info+0xb4>)
 8003560:	4915      	ldr	r1, [pc, #84]	; (80035b8 <cmd_info+0xb8>)
 8003562:	f7ff fd3d 	bl	8002fe0 <chprintf>
}
 8003566:	b002      	add	sp, #8
 8003568:	bd10      	pop	{r4, pc}
 800356a:	bf00      	nop
 800356c:	0800aa44 	.word	0x0800aa44
 8003570:	0800abd0 	.word	0x0800abd0
 8003574:	0800b914 	.word	0x0800b914
 8003578:	0800aa4c 	.word	0x0800aa4c
 800357c:	0800b7c0 	.word	0x0800b7c0
 8003580:	0800aa60 	.word	0x0800aa60
 8003584:	0800b754 	.word	0x0800b754
 8003588:	0800aa74 	.word	0x0800aa74
 800358c:	0800b788 	.word	0x0800b788
 8003590:	0800aa88 	.word	0x0800aa88
 8003594:	0800b834 	.word	0x0800b834
 8003598:	0800aa9c 	.word	0x0800aa9c
 800359c:	0800aab0 	.word	0x0800aab0
 80035a0:	0800aadc 	.word	0x0800aadc
 80035a4:	0800aaf0 	.word	0x0800aaf0
 80035a8:	0800ab04 	.word	0x0800ab04
 80035ac:	0800ab40 	.word	0x0800ab40
 80035b0:	0800ab1c 	.word	0x0800ab1c
 80035b4:	0800ab18 	.word	0x0800ab18
 80035b8:	0800ab28 	.word	0x0800ab28
 80035bc:	00000000 	.word	0x00000000

080035c0 <dyn_find_object>:
    chPoolFree(mp, (void *)dep);
  }
}
#endif /* CH_FACTORY_REQUIRES_POOLS */

static dyn_element_t *dyn_find_object(const char *name, dyn_list_t *dlp) {
 80035c0:	b570      	push	{r4, r5, r6, lr}
  dyn_element_t *p = dlp->next;
 80035c2:	680c      	ldr	r4, [r1, #0]
  while (p != (dyn_element_t *)dlp) {
 80035c4:	42a1      	cmp	r1, r4
 80035c6:	d012      	beq.n	80035ee <dyn_find_object+0x2e>
 80035c8:	460d      	mov	r5, r1
 80035ca:	4606      	mov	r6, r0
 80035cc:	e002      	b.n	80035d4 <dyn_find_object+0x14>
    p = p->next;
 80035ce:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 80035d0:	42a5      	cmp	r5, r4
 80035d2:	d00c      	beq.n	80035ee <dyn_find_object+0x2e>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 80035d4:	2208      	movs	r2, #8
 80035d6:	4631      	mov	r1, r6
 80035d8:	18a0      	adds	r0, r4, r2
 80035da:	f7fd f88b 	bl	80006f4 <strncmp>
 80035de:	2800      	cmp	r0, #0
 80035e0:	d1f5      	bne.n	80035ce <dyn_find_object+0xe>

  chDbgCheck(name != NULL);

  /* Checking if an object with this name has already been created.*/
  dep = dyn_list_find(name, dlp);
  if (dep != NULL) {
 80035e2:	b12c      	cbz	r4, 80035f0 <dyn_find_object+0x30>
    /* Increasing references counter.*/
    dep->refs++;
 80035e4:	6863      	ldr	r3, [r4, #4]
  }

  return dep;
}
 80035e6:	4620      	mov	r0, r4
    dep->refs++;
 80035e8:	3301      	adds	r3, #1
 80035ea:	6063      	str	r3, [r4, #4]
}
 80035ec:	bd70      	pop	{r4, r5, r6, pc}
  return NULL;
 80035ee:	2400      	movs	r4, #0
}
 80035f0:	4620      	mov	r0, r4
 80035f2:	bd70      	pop	{r4, r5, r6, pc}
	...

08003600 <dyn_create_object_pool>:
                                             memory_pool_t *mp) {
 8003600:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_element_t *p = dlp->next;
 8003602:	680c      	ldr	r4, [r1, #0]
                                             memory_pool_t *mp) {
 8003604:	460d      	mov	r5, r1
  while (p != (dyn_element_t *)dlp) {
 8003606:	42a1      	cmp	r1, r4
                                             memory_pool_t *mp) {
 8003608:	4606      	mov	r6, r0
 800360a:	4617      	mov	r7, r2
  while (p != (dyn_element_t *)dlp) {
 800360c:	d103      	bne.n	8003616 <dyn_create_object_pool+0x16>
 800360e:	e00d      	b.n	800362c <dyn_create_object_pool+0x2c>
    p = p->next;
 8003610:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8003612:	42a5      	cmp	r5, r4
 8003614:	d00a      	beq.n	800362c <dyn_create_object_pool+0x2c>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8003616:	2208      	movs	r2, #8
 8003618:	4631      	mov	r1, r6
 800361a:	18a0      	adds	r0, r4, r2
 800361c:	f7fd f86a 	bl	80006f4 <strncmp>
 8003620:	2800      	cmp	r0, #0
 8003622:	d1f5      	bne.n	8003610 <dyn_create_object_pool+0x10>
  if (dep != NULL) {
 8003624:	b114      	cbz	r4, 800362c <dyn_create_object_pool+0x2c>
    return NULL;
 8003626:	4604      	mov	r4, r0
}
 8003628:	4620      	mov	r0, r4
 800362a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  dep = (dyn_element_t *)chPoolAlloc(mp);
 800362c:	4638      	mov	r0, r7
 800362e:	f7fd fdef 	bl	8001210 <chPoolAlloc>
  if (dep == NULL) {
 8003632:	4604      	mov	r4, r0
 8003634:	b148      	cbz	r0, 800364a <dyn_create_object_pool+0x4a>
  strncpy(dep->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 8003636:	2208      	movs	r2, #8
 8003638:	4631      	mov	r1, r6
 800363a:	4410      	add	r0, r2
 800363c:	f7fd f8a4 	bl	8000788 <strncpy>
  dep->refs = (ucnt_t)1;
 8003640:	2201      	movs	r2, #1
  dep->next = dlp->next;
 8003642:	682b      	ldr	r3, [r5, #0]
 8003644:	e9c4 3200 	strd	r3, r2, [r4]
  dlp->next = (dyn_element_t *)dep;
 8003648:	602c      	str	r4, [r5, #0]
}
 800364a:	4620      	mov	r0, r4
 800364c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800364e:	bf00      	nop

08003650 <chThdYield>:
void chThdYield(void) {
 8003650:	b570      	push	{r4, r5, r6, lr}
 8003652:	2320      	movs	r3, #32
 8003654:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 8003658:	4a12      	ldr	r2, [pc, #72]	; (80036a4 <chThdYield+0x54>)
 800365a:	6810      	ldr	r0, [r2, #0]
 800365c:	6994      	ldr	r4, [r2, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 800365e:	6883      	ldr	r3, [r0, #8]
  return firstprio(&ch.rlist.queue) >= currp->prio;
 8003660:	68a1      	ldr	r1, [r4, #8]
  if (chSchCanYieldS()) {
 8003662:	428b      	cmp	r3, r1
 8003664:	d203      	bcs.n	800366e <chThdYield+0x1e>
 8003666:	2300      	movs	r3, #0
 8003668:	f383 8811 	msr	BASEPRI, r3
}
 800366c:	bd70      	pop	{r4, r5, r6, pc}
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800366e:	2601      	movs	r6, #1
  tp->state = CH_STATE_READY;
 8003670:	2500      	movs	r5, #0
  tqp->next             = tp->queue.next;
 8003672:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003674:	605a      	str	r2, [r3, #4]
  tqp->next             = tp->queue.next;
 8003676:	6013      	str	r3, [r2, #0]
  currp->state = CH_STATE_CURRENT;
 8003678:	f880 6020 	strb.w	r6, [r0, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
 800367c:	6190      	str	r0, [r2, #24]
  tp->state = CH_STATE_READY;
 800367e:	f884 5020 	strb.w	r5, [r4, #32]
 8003682:	e000      	b.n	8003686 <chThdYield+0x36>
 8003684:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8003686:	689a      	ldr	r2, [r3, #8]
 8003688:	4291      	cmp	r1, r2
 800368a:	d9fb      	bls.n	8003684 <chThdYield+0x34>
  tp->queue.prev             = cp->queue.prev;
 800368c:	685a      	ldr	r2, [r3, #4]

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800368e:	4621      	mov	r1, r4
  tp->queue.prev             = cp->queue.prev;
 8003690:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8003694:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8003696:	605c      	str	r4, [r3, #4]
  chSysSwitch(currp, otp);
 8003698:	f7fc fdd2 	bl	8000240 <_port_switch>
 800369c:	2300      	movs	r3, #0
 800369e:	f383 8811 	msr	BASEPRI, r3
 80036a2:	bd70      	pop	{r4, r5, r6, pc}
 80036a4:	20001254 	.word	0x20001254
	...

080036b0 <bmk_thread8>:
static THD_FUNCTION(bmk_thread8, p) {
 80036b0:	b538      	push	{r3, r4, r5, lr}
 80036b2:	4604      	mov	r4, r0
 80036b4:	4d08      	ldr	r5, [pc, #32]	; (80036d8 <bmk_thread8+0x28>)
    chThdYield();
 80036b6:	f7ff ffcb 	bl	8003650 <chThdYield>
    chThdYield();
 80036ba:	f7ff ffc9 	bl	8003650 <chThdYield>
    chThdYield();
 80036be:	f7ff ffc7 	bl	8003650 <chThdYield>
    chThdYield();
 80036c2:	f7ff ffc5 	bl	8003650 <chThdYield>
    (*(uint32_t *)p) += 4;
 80036c6:	6823      	ldr	r3, [r4, #0]
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 80036c8:	69aa      	ldr	r2, [r5, #24]
 80036ca:	3304      	adds	r3, #4
 80036cc:	6023      	str	r3, [r4, #0]
  } while(!chThdShouldTerminateX());
 80036ce:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 80036d2:	075b      	lsls	r3, r3, #29
 80036d4:	d5ef      	bpl.n	80036b6 <bmk_thread8+0x6>
}
 80036d6:	bd38      	pop	{r3, r4, r5, pc}
 80036d8:	20001254 	.word	0x20001254
 80036dc:	00000000 	.word	0x00000000

080036e0 <chSchWakeupS>:
  thread_t *otp = currp;
 80036e0:	4b16      	ldr	r3, [pc, #88]	; (800373c <chSchWakeupS+0x5c>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80036e2:	b470      	push	{r4, r5, r6}
  thread_t *otp = currp;
 80036e4:	699e      	ldr	r6, [r3, #24]
  if (ntp->prio <= otp->prio) {
 80036e6:	6885      	ldr	r5, [r0, #8]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80036e8:	4604      	mov	r4, r0
  ntp->u.rdymsg = msg;
 80036ea:	6241      	str	r1, [r0, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 80036ec:	68b0      	ldr	r0, [r6, #8]
 80036ee:	4285      	cmp	r5, r0
 80036f0:	d80d      	bhi.n	800370e <chSchWakeupS+0x2e>
  tp->state = CH_STATE_READY;
 80036f2:	2200      	movs	r2, #0
 80036f4:	f884 2020 	strb.w	r2, [r4, #32]
    cp = cp->queue.next;
 80036f8:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80036fa:	689a      	ldr	r2, [r3, #8]
 80036fc:	4295      	cmp	r5, r2
 80036fe:	d9fb      	bls.n	80036f8 <chSchWakeupS+0x18>
  tp->queue.prev             = cp->queue.prev;
 8003700:	685a      	ldr	r2, [r3, #4]
 8003702:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8003706:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8003708:	605c      	str	r4, [r3, #4]
}
 800370a:	bc70      	pop	{r4, r5, r6}
 800370c:	4770      	bx	lr
  tp->state = CH_STATE_READY;
 800370e:	2100      	movs	r1, #0
  cp = (thread_t *)&ch.rlist.queue;
 8003710:	461a      	mov	r2, r3
  tp->state = CH_STATE_READY;
 8003712:	f886 1020 	strb.w	r1, [r6, #32]
    cp = cp->queue.next;
 8003716:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio > tp->prio);
 8003718:	6891      	ldr	r1, [r2, #8]
 800371a:	4288      	cmp	r0, r1
 800371c:	d3fb      	bcc.n	8003716 <chSchWakeupS+0x36>
    ntp->state = CH_STATE_CURRENT;
 800371e:	2001      	movs	r0, #1
  tp->queue.prev             = cp->queue.prev;
 8003720:	6851      	ldr	r1, [r2, #4]
 8003722:	e9c6 2100 	strd	r2, r1, [r6]
  tp->queue.prev->queue.next = tp;
 8003726:	600e      	str	r6, [r1, #0]
  cp->queue.prev             = tp;
 8003728:	6056      	str	r6, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
 800372a:	f884 0020 	strb.w	r0, [r4, #32]
    chSysSwitch(ntp, otp);
 800372e:	4631      	mov	r1, r6
 8003730:	4620      	mov	r0, r4
    currp = ntp;
 8003732:	619c      	str	r4, [r3, #24]
}
 8003734:	bc70      	pop	{r4, r5, r6}
    chSysSwitch(ntp, otp);
 8003736:	f7fc bd83 	b.w	8000240 <_port_switch>
 800373a:	bf00      	nop
 800373c:	20001254 	.word	0x20001254

08003740 <chThdCreateStatic.constprop.68>:
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8003740:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003742:	2420      	movs	r4, #32
 8003744:	f384 8811 	msr	BASEPRI, r4
  tp->flags     = CH_FLAG_MODE_STATIC;
 8003748:	2401      	movs	r4, #1
  tp->mtxlist   = NULL;
 800374a:	2500      	movs	r5, #0
  tp->state     = CH_STATE_WTSTART;
 800374c:	2702      	movs	r7, #2
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800374e:	e9c0 2337 	strd	r2, r3, [r0, #220]	; 0xdc
 8003752:	f100 03dc 	add.w	r3, r0, #220	; 0xdc
  REG_INSERT(tp);
 8003756:	4e19      	ldr	r6, [pc, #100]	; (80037bc <chThdCreateStatic.constprop.68+0x7c>)
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003758:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
 800375c:	4b18      	ldr	r3, [pc, #96]	; (80037c0 <chThdCreateStatic.constprop.68+0x80>)
  tp->name      = name;
 800375e:	4a19      	ldr	r2, [pc, #100]	; (80037c4 <chThdCreateStatic.constprop.68+0x84>)
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003760:	f8c0 30fc 	str.w	r3, [r0, #252]	; 0xfc
  REG_INSERT(tp);
 8003764:	6973      	ldr	r3, [r6, #20]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8003766:	f880 4122 	strb.w	r4, [r0, #290]	; 0x122
  tp = (thread_t *)((uint8_t *)wsp + size -
 800376a:	f500 7480 	add.w	r4, r0, #256	; 0x100
  tp->prio      = prio;
 800376e:	f8c0 1108 	str.w	r1, [r0, #264]	; 0x108
  tp->realprio  = prio;
 8003772:	f8c0 113c 	str.w	r1, [r0, #316]	; 0x13c
  tp->state     = CH_STATE_WTSTART;
 8003776:	f8a0 7120 	strh.w	r7, [r0, #288]	; 0x120
  tp->name      = name;
 800377a:	f8c0 2118 	str.w	r2, [r0, #280]	; 0x118
  tp->mtxlist   = NULL;
 800377e:	f8c0 5138 	str.w	r5, [r0, #312]	; 0x138
  list_init(&tp->waiting);
 8003782:	f500 7294 	add.w	r2, r0, #296	; 0x128
  tp->epending  = (eventmask_t)0;
 8003786:	f8c0 5134 	str.w	r5, [r0, #308]	; 0x134
  REG_INSERT(tp);
 800378a:	f8c0 6110 	str.w	r6, [r0, #272]	; 0x110
 800378e:	f8c0 3114 	str.w	r3, [r0, #276]	; 0x114
  tp->wabase = (stkalign_t *)wsp;
 8003792:	f8c0 011c 	str.w	r0, [r0, #284]	; 0x11c
  REG_INSERT(tp);
 8003796:	611c      	str	r4, [r3, #16]
  queue_init(&tp->msgqueue);
 8003798:	f500 7396 	add.w	r3, r0, #300	; 0x12c
  tlp->next = (thread_t *)tlp;
 800379c:	f8c0 2128 	str.w	r2, [r0, #296]	; 0x128
  tqp->next = (thread_t *)tqp;
 80037a0:	f8c0 312c 	str.w	r3, [r0, #300]	; 0x12c
  tqp->prev = (thread_t *)tqp;
 80037a4:	f8c0 3130 	str.w	r3, [r0, #304]	; 0x130
  chSchWakeupS(tp, MSG_OK);
 80037a8:	4629      	mov	r1, r5
 80037aa:	4620      	mov	r0, r4
  REG_INSERT(tp);
 80037ac:	6174      	str	r4, [r6, #20]
  chSchWakeupS(tp, MSG_OK);
 80037ae:	f7ff ff97 	bl	80036e0 <chSchWakeupS>
 80037b2:	f385 8811 	msr	BASEPRI, r5
}
 80037b6:	4620      	mov	r0, r4
 80037b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80037ba:	bf00      	nop
 80037bc:	20001254 	.word	0x20001254
 80037c0:	08000251 	.word	0x08000251
 80037c4:	0800aa04 	.word	0x0800aa04
	...

080037d0 <chCondSignal.constprop.59>:
void chCondSignal(condition_variable_t *cp) {
 80037d0:	b508      	push	{r3, lr}
 80037d2:	2320      	movs	r3, #32
 80037d4:	f383 8811 	msr	BASEPRI, r3
  return (bool)(tqp->next != (const thread_t *)tqp);
 80037d8:	4b06      	ldr	r3, [pc, #24]	; (80037f4 <chCondSignal.constprop.59+0x24>)
 80037da:	6818      	ldr	r0, [r3, #0]
  if (queue_notempty(&cp->queue)) {
 80037dc:	4298      	cmp	r0, r3
 80037de:	d005      	beq.n	80037ec <chCondSignal.constprop.59+0x1c>
  tqp->next             = tp->queue.next;
 80037e0:	6802      	ldr	r2, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 80037e2:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80037e4:	6053      	str	r3, [r2, #4]
  tqp->next             = tp->queue.next;
 80037e6:	601a      	str	r2, [r3, #0]
 80037e8:	f7ff ff7a 	bl	80036e0 <chSchWakeupS>
 80037ec:	2300      	movs	r3, #0
 80037ee:	f383 8811 	msr	BASEPRI, r3
}
 80037f2:	bd08      	pop	{r3, pc}
 80037f4:	20000c04 	.word	0x20000c04
	...

08003800 <chThdCreateFromMemoryPool.constprop.40>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8003800:	b5f0      	push	{r4, r5, r6, r7, lr}
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8003802:	4d14      	ldr	r5, [pc, #80]	; (8003854 <chThdCreateFromMemoryPool.constprop.40+0x54>)
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8003804:	b087      	sub	sp, #28
 8003806:	4607      	mov	r7, r0
  wsp = chPoolAlloc(mp);
 8003808:	4628      	mov	r0, r5
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 800380a:	460e      	mov	r6, r1
 800380c:	4614      	mov	r4, r2
  wsp = chPoolAlloc(mp);
 800380e:	f7fd fcff 	bl	8001210 <chPoolAlloc>
  if (wsp == NULL) {
 8003812:	b1e0      	cbz	r0, 800384e <chThdCreateFromMemoryPool.constprop.40+0x4e>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8003814:	686b      	ldr	r3, [r5, #4]
  thread_descriptor_t td = {
 8003816:	4a10      	ldr	r2, [pc, #64]	; (8003858 <chThdCreateFromMemoryPool.constprop.40+0x58>)
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8003818:	4403      	add	r3, r0
  thread_descriptor_t td = {
 800381a:	9302      	str	r3, [sp, #8]
 800381c:	9700      	str	r7, [sp, #0]
 800381e:	9001      	str	r0, [sp, #4]
 8003820:	9603      	str	r6, [sp, #12]
 8003822:	9405      	str	r4, [sp, #20]
 8003824:	9204      	str	r2, [sp, #16]
 8003826:	2320      	movs	r3, #32
 8003828:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 800382c:	4668      	mov	r0, sp
 800382e:	f7fd fe67 	bl	8001500 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_MPOOL;
 8003832:	2302      	movs	r3, #2
  tp->mpool = mp;
 8003834:	6405      	str	r5, [r0, #64]	; 0x40
  tp->flags = CH_FLAG_MODE_MPOOL;
 8003836:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 800383a:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(&td);
 800383c:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 800383e:	f7ff ff4f 	bl	80036e0 <chSchWakeupS>
 8003842:	2300      	movs	r3, #0
 8003844:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8003848:	4620      	mov	r0, r4
 800384a:	b007      	add	sp, #28
 800384c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NULL;
 800384e:	4604      	mov	r4, r0
 8003850:	e7fa      	b.n	8003848 <chThdCreateFromMemoryPool.constprop.40+0x48>
 8003852:	bf00      	nop
 8003854:	20001530 	.word	0x20001530
 8003858:	08001011 	.word	0x08001011
 800385c:	00000000 	.word	0x00000000

08003860 <chSemSignal>:
void chSemSignal(semaphore_t *sp) {
 8003860:	b508      	push	{r3, lr}
 8003862:	2320      	movs	r3, #32
 8003864:	f383 8811 	msr	BASEPRI, r3
  if (++sp->cnt <= (cnt_t)0) {
 8003868:	6883      	ldr	r3, [r0, #8]
 800386a:	3301      	adds	r3, #1
 800386c:	2b00      	cmp	r3, #0
 800386e:	6083      	str	r3, [r0, #8]
 8003870:	dd03      	ble.n	800387a <chSemSignal+0x1a>
 8003872:	2300      	movs	r3, #0
 8003874:	f383 8811 	msr	BASEPRI, r3
}
 8003878:	bd08      	pop	{r3, pc}
 800387a:	4603      	mov	r3, r0
  thread_t *tp = tqp->next;
 800387c:	6800      	ldr	r0, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 800387e:	2100      	movs	r1, #0
  tqp->next             = tp->queue.next;
 8003880:	6802      	ldr	r2, [r0, #0]
 8003882:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003884:	6053      	str	r3, [r2, #4]
 8003886:	f7ff ff2b 	bl	80036e0 <chSchWakeupS>
 800388a:	2300      	movs	r3, #0
 800388c:	f383 8811 	msr	BASEPRI, r3
}
 8003890:	bd08      	pop	{r3, pc}
 8003892:	bf00      	nop
	...

080038a0 <chThdCreate>:
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 80038a0:	b510      	push	{r4, lr}
 80038a2:	2320      	movs	r3, #32
 80038a4:	f383 8811 	msr	BASEPRI, r3
  tp = chThdCreateSuspendedI(tdp);
 80038a8:	f7fd fe2a 	bl	8001500 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 80038ac:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(tdp);
 80038ae:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 80038b0:	f7ff ff16 	bl	80036e0 <chSchWakeupS>
 80038b4:	2300      	movs	r3, #0
 80038b6:	f383 8811 	msr	BASEPRI, r3
}
 80038ba:	4620      	mov	r0, r4
 80038bc:	bd10      	pop	{r4, pc}
 80038be:	bf00      	nop

080038c0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 80038c0:	b430      	push	{r4, r5}
  currp->state = CH_STATE_CURRENT;
 80038c2:	2501      	movs	r5, #1
  thread_t *otp = currp;
 80038c4:	4b07      	ldr	r3, [pc, #28]	; (80038e4 <chSchGoSleepS+0x24>)
 80038c6:	6999      	ldr	r1, [r3, #24]
  thread_t *tp = tqp->next;
 80038c8:	681a      	ldr	r2, [r3, #0]
  otp->state = newstate;
 80038ca:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next             = tp->queue.next;
 80038ce:	6814      	ldr	r4, [r2, #0]
  chSysSwitch(currp, otp);
 80038d0:	4610      	mov	r0, r2
  tqp->next->queue.prev = (thread_t *)tqp;
 80038d2:	6063      	str	r3, [r4, #4]
  currp->state = CH_STATE_CURRENT;
 80038d4:	f882 5020 	strb.w	r5, [r2, #32]
  tqp->next             = tp->queue.next;
 80038d8:	601c      	str	r4, [r3, #0]
}
 80038da:	bc30      	pop	{r4, r5}
  currp = queue_fifo_remove(&ch.rlist.queue);
 80038dc:	619a      	str	r2, [r3, #24]
  chSysSwitch(currp, otp);
 80038de:	f7fc bcaf 	b.w	8000240 <_port_switch>
 80038e2:	bf00      	nop
 80038e4:	20001254 	.word	0x20001254
	...

080038f0 <chEvtWaitOne.constprop.47>:
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
 80038f0:	4a0b      	ldr	r2, [pc, #44]	; (8003920 <chEvtWaitOne.constprop.47+0x30>)
eventmask_t chEvtWaitOne(eventmask_t events) {
 80038f2:	b510      	push	{r4, lr}
 80038f4:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 80038f6:	6994      	ldr	r4, [r2, #24]
 80038f8:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 80038fc:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80038fe:	b933      	cbnz	r3, 800390e <chEvtWaitOne.constprop.47+0x1e>
    ctp->u.ewmask = events;
 8003900:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    chSchGoSleepS(CH_STATE_WTOREVT);
 8003904:	200a      	movs	r0, #10
    ctp->u.ewmask = events;
 8003906:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8003908:	f7ff ffda 	bl	80038c0 <chSchGoSleepS>
    m = ctp->epending & events;
 800390c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 800390e:	4258      	negs	r0, r3
 8003910:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8003912:	ea23 0300 	bic.w	r3, r3, r0
 8003916:	6363      	str	r3, [r4, #52]	; 0x34
 8003918:	2300      	movs	r3, #0
 800391a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 800391e:	bd10      	pop	{r4, pc}
 8003920:	20001254 	.word	0x20001254
	...

08003930 <chEvtWaitAny.constprop.46>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
 8003930:	4a09      	ldr	r2, [pc, #36]	; (8003958 <chEvtWaitAny.constprop.46+0x28>)
eventmask_t chEvtWaitAny(eventmask_t events) {
 8003932:	b510      	push	{r4, lr}
 8003934:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 8003936:	6994      	ldr	r4, [r2, #24]
 8003938:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 800393c:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800393e:	b930      	cbnz	r0, 800394e <chEvtWaitAny.constprop.46+0x1e>
    ctp->u.ewmask = events;
 8003940:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    chSchGoSleepS(CH_STATE_WTOREVT);
 8003944:	200a      	movs	r0, #10
    ctp->u.ewmask = events;
 8003946:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8003948:	f7ff ffba 	bl	80038c0 <chSchGoSleepS>
    m = ctp->epending & events;
 800394c:	6b60      	ldr	r0, [r4, #52]	; 0x34
  }
  ctp->epending &= ~m;
 800394e:	2300      	movs	r3, #0
 8003950:	6363      	str	r3, [r4, #52]	; 0x34
 8003952:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8003956:	bd10      	pop	{r4, pc}
 8003958:	20001254 	.word	0x20001254
 800395c:	00000000 	.word	0x00000000

08003960 <chEvtWaitAll.constprop.45>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;
 8003960:	4a0c      	ldr	r2, [pc, #48]	; (8003994 <chEvtWaitAll.constprop.45+0x34>)
eventmask_t chEvtWaitAll(eventmask_t events) {
 8003962:	b510      	push	{r4, lr}
 8003964:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 8003966:	6994      	ldr	r4, [r2, #24]
 8003968:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->epending & events) != events) {
 800396c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800396e:	f003 0205 	and.w	r2, r3, #5
 8003972:	2a05      	cmp	r2, #5
 8003974:	d005      	beq.n	8003982 <chEvtWaitAll.constprop.45+0x22>
    ctp->u.ewmask = events;
 8003976:	2305      	movs	r3, #5
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8003978:	200b      	movs	r0, #11
    ctp->u.ewmask = events;
 800397a:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 800397c:	f7ff ffa0 	bl	80038c0 <chSchGoSleepS>
 8003980:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  ctp->epending &= ~events;
 8003982:	f023 0305 	bic.w	r3, r3, #5
 8003986:	6363      	str	r3, [r4, #52]	; 0x34
 8003988:	2300      	movs	r3, #0
 800398a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
 800398e:	2005      	movs	r0, #5
 8003990:	bd10      	pop	{r4, pc}
 8003992:	bf00      	nop
 8003994:	20001254 	.word	0x20001254
	...

080039a0 <bmk_thread4>:
  return ch.rlist.current;
 80039a0:	4a07      	ldr	r2, [pc, #28]	; (80039c0 <bmk_thread4+0x20>)
static THD_FUNCTION(bmk_thread4, p) {
 80039a2:	b510      	push	{r4, lr}
 80039a4:	2320      	movs	r3, #32
 80039a6:	6994      	ldr	r4, [r2, #24]
 80039a8:	f383 8811 	msr	BASEPRI, r3
    chSchGoSleepS(CH_STATE_SUSPENDED);
 80039ac:	2003      	movs	r0, #3
 80039ae:	f7ff ff87 	bl	80038c0 <chSchGoSleepS>
  } while (msg == MSG_OK);
 80039b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80039b4:	2b00      	cmp	r3, #0
 80039b6:	d0f9      	beq.n	80039ac <bmk_thread4+0xc>
 80039b8:	2300      	movs	r3, #0
 80039ba:	f383 8811 	msr	BASEPRI, r3
}
 80039be:	bd10      	pop	{r4, pc}
 80039c0:	20001254 	.word	0x20001254
	...

080039d0 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80039d0:	b530      	push	{r4, r5, lr}
  if (TIME_INFINITE != timeout) {
 80039d2:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80039d4:	b087      	sub	sp, #28
  if (TIME_INFINITE != timeout) {
 80039d6:	d012      	beq.n	80039fe <chSchGoSleepTimeoutS+0x2e>
 80039d8:	4605      	mov	r5, r0
    chVTDoSetI(&vt, timeout, wakeup, currp);
 80039da:	4c0c      	ldr	r4, [pc, #48]	; (8003a0c <chSchGoSleepTimeoutS+0x3c>)
 80039dc:	a801      	add	r0, sp, #4
 80039de:	69a3      	ldr	r3, [r4, #24]
 80039e0:	4a0b      	ldr	r2, [pc, #44]	; (8003a10 <chSchGoSleepTimeoutS+0x40>)
 80039e2:	f7fd ffcd 	bl	8001980 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80039e6:	4628      	mov	r0, r5
 80039e8:	f7ff ff6a 	bl	80038c0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80039ec:	9b04      	ldr	r3, [sp, #16]
 80039ee:	b113      	cbz	r3, 80039f6 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 80039f0:	a801      	add	r0, sp, #4
 80039f2:	f7fd ff7d 	bl	80018f0 <chVTDoResetI>
  return currp->u.rdymsg;
 80039f6:	69a3      	ldr	r3, [r4, #24]
}
 80039f8:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80039fa:	b007      	add	sp, #28
 80039fc:	bd30      	pop	{r4, r5, pc}
    chSchGoSleepS(newstate);
 80039fe:	f7ff ff5f 	bl	80038c0 <chSchGoSleepS>
 8003a02:	4c02      	ldr	r4, [pc, #8]	; (8003a0c <chSchGoSleepTimeoutS+0x3c>)
  return currp->u.rdymsg;
 8003a04:	69a3      	ldr	r3, [r4, #24]
}
 8003a06:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8003a08:	b007      	add	sp, #28
 8003a0a:	bd30      	pop	{r4, r5, pc}
 8003a0c:	20001254 	.word	0x20001254
 8003a10:	08001581 	.word	0x08001581
	...

08003a20 <chSemWaitTimeout.constprop.65>:
 8003a20:	2320      	movs	r3, #32
 8003a22:	f383 8811 	msr	BASEPRI, r3
  if (--sp->cnt < (cnt_t)0) {
 8003a26:	4b10      	ldr	r3, [pc, #64]	; (8003a68 <chSemWaitTimeout.constprop.65+0x48>)
 8003a28:	6899      	ldr	r1, [r3, #8]
 8003a2a:	1e4a      	subs	r2, r1, #1
 8003a2c:	2a00      	cmp	r2, #0
 8003a2e:	609a      	str	r2, [r3, #8]
 8003a30:	db04      	blt.n	8003a3c <chSemWaitTimeout.constprop.65+0x1c>
  return MSG_OK;
 8003a32:	2000      	movs	r0, #0
 8003a34:	2300      	movs	r3, #0
 8003a36:	f383 8811 	msr	BASEPRI, r3
}
 8003a3a:	4770      	bx	lr
    if (TIME_IMMEDIATE == timeout) {
 8003a3c:	b180      	cbz	r0, 8003a60 <chSemWaitTimeout.constprop.65+0x40>
    currp->u.wtsemp = sp;
 8003a3e:	4a0b      	ldr	r2, [pc, #44]	; (8003a6c <chSemWaitTimeout.constprop.65+0x4c>)
msg_t chSemWaitTimeout(semaphore_t *sp, sysinterval_t timeout) {
 8003a40:	b510      	push	{r4, lr}
    currp->u.wtsemp = sp;
 8003a42:	6992      	ldr	r2, [r2, #24]
  tp->queue.prev             = tqp->prev;
 8003a44:	685c      	ldr	r4, [r3, #4]
 8003a46:	6253      	str	r3, [r2, #36]	; 0x24
 8003a48:	e9c2 3400 	strd	r3, r4, [r2]
 8003a4c:	4601      	mov	r1, r0
  tp->queue.prev->queue.next = tp;
 8003a4e:	6022      	str	r2, [r4, #0]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8003a50:	2005      	movs	r0, #5
  tqp->prev                  = tp;
 8003a52:	605a      	str	r2, [r3, #4]
 8003a54:	f7ff ffbc 	bl	80039d0 <chSchGoSleepTimeoutS>
 8003a58:	2300      	movs	r3, #0
 8003a5a:	f383 8811 	msr	BASEPRI, r3
}
 8003a5e:	bd10      	pop	{r4, pc}
      sp->cnt++;
 8003a60:	6099      	str	r1, [r3, #8]
      return MSG_TIMEOUT;
 8003a62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003a66:	e7e5      	b.n	8003a34 <chSemWaitTimeout.constprop.65+0x14>
 8003a68:	20001660 	.word	0x20001660
 8003a6c:	20001254 	.word	0x20001254

08003a70 <rt_test_009_006_execute>:
  test_set_step(1);
 8003a70:	2001      	movs	r0, #1
static void rt_test_009_006_execute(void) {
 8003a72:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 8003a74:	4d55      	ldr	r5, [pc, #340]	; (8003bcc <rt_test_009_006_execute+0x15c>)
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 8003a76:	4c56      	ldr	r4, [pc, #344]	; (8003bd0 <rt_test_009_006_execute+0x160>)
 8003a78:	6028      	str	r0, [r5, #0]
 8003a7a:	69a2      	ldr	r2, [r4, #24]
 8003a7c:	2320      	movs	r3, #32
 8003a7e:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8003a82:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8003a84:	b933      	cbnz	r3, 8003a94 <rt_test_009_006_execute+0x24>
 8003a86:	f383 8811 	msr	BASEPRI, r3
    test_assert(m == 0, "spurious event");
 8003a8a:	4952      	ldr	r1, [pc, #328]	; (8003bd4 <rt_test_009_006_execute+0x164>)
 8003a8c:	f7fd f980 	bl	8000d90 <_test_assert>
 8003a90:	b180      	cbz	r0, 8003ab4 <rt_test_009_006_execute+0x44>
}
 8003a92:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 8003a94:	4258      	negs	r0, r3
 8003a96:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8003a98:	ea23 0300 	bic.w	r3, r3, r0
 8003a9c:	6353      	str	r3, [r2, #52]	; 0x34
 8003a9e:	2300      	movs	r3, #0
 8003aa0:	f383 8811 	msr	BASEPRI, r3
 8003aa4:	fab0 f080 	clz	r0, r0
    test_assert(m == 0, "spurious event");
 8003aa8:	494a      	ldr	r1, [pc, #296]	; (8003bd4 <rt_test_009_006_execute+0x164>)
 8003aaa:	0940      	lsrs	r0, r0, #5
 8003aac:	f7fd f970 	bl	8000d90 <_test_assert>
 8003ab0:	2800      	cmp	r0, #0
 8003ab2:	d1ee      	bne.n	8003a92 <rt_test_009_006_execute+0x22>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 8003ab4:	69a3      	ldr	r3, [r4, #24]
 8003ab6:	2220      	movs	r2, #32
 8003ab8:	f382 8811 	msr	BASEPRI, r2
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
 8003abc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003abe:	2a00      	cmp	r2, #0
 8003ac0:	d06f      	beq.n	8003ba2 <rt_test_009_006_execute+0x132>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  ctp->epending &= ~m;
 8003ac2:	6358      	str	r0, [r3, #52]	; 0x34
 8003ac4:	f380 8811 	msr	BASEPRI, r0
    test_assert(m == 0, "spurious event");
 8003ac8:	4942      	ldr	r1, [pc, #264]	; (8003bd4 <rt_test_009_006_execute+0x164>)
 8003aca:	f7fd f961 	bl	8000d90 <_test_assert>
 8003ace:	2800      	cmp	r0, #0
 8003ad0:	d1df      	bne.n	8003a92 <rt_test_009_006_execute+0x22>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 8003ad2:	69a3      	ldr	r3, [r4, #24]
 8003ad4:	2220      	movs	r2, #32
 8003ad6:	f382 8811 	msr	BASEPRI, r2

  chSysLock();
  if ((ctp->epending & events) != events) {
 8003ada:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003adc:	3201      	adds	r2, #1
 8003ade:	d064      	beq.n	8003baa <rt_test_009_006_execute+0x13a>
 8003ae0:	f380 8811 	msr	BASEPRI, r0
 8003ae4:	2001      	movs	r0, #1
    test_assert(m == 0, "spurious event");
 8003ae6:	493b      	ldr	r1, [pc, #236]	; (8003bd4 <rt_test_009_006_execute+0x164>)
 8003ae8:	f7fd f952 	bl	8000d90 <_test_assert>
 8003aec:	2800      	cmp	r0, #0
 8003aee:	d1d0      	bne.n	8003a92 <rt_test_009_006_execute+0x22>
  test_set_step(2);
 8003af0:	2302      	movs	r3, #2
  thread_t *ctp = currp;
 8003af2:	69a6      	ldr	r6, [r4, #24]
 8003af4:	602b      	str	r3, [r5, #0]
 8003af6:	2320      	movs	r3, #32
 8003af8:	f383 8811 	msr	BASEPRI, r3
  m = ctp->epending & events;
 8003afc:	6b75      	ldr	r5, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8003afe:	b94d      	cbnz	r5, 8003b14 <rt_test_009_006_execute+0xa4>
    ctp->u.ewmask = events;
 8003b00:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8003b04:	2164      	movs	r1, #100	; 0x64
    ctp->u.ewmask = events;
 8003b06:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8003b08:	200a      	movs	r0, #10
 8003b0a:	f7ff ff61 	bl	80039d0 <chSchGoSleepTimeoutS>
 8003b0e:	2800      	cmp	r0, #0
 8003b10:	db4f      	blt.n	8003bb2 <rt_test_009_006_execute+0x142>
    m = ctp->epending & events;
 8003b12:	6b75      	ldr	r5, [r6, #52]	; 0x34
  m ^= m & (m - (eventmask_t)1);
 8003b14:	4268      	negs	r0, r5
 8003b16:	4028      	ands	r0, r5
  ctp->epending &= ~m;
 8003b18:	ea25 0500 	bic.w	r5, r5, r0
 8003b1c:	6375      	str	r5, [r6, #52]	; 0x34
 8003b1e:	2300      	movs	r3, #0
 8003b20:	f383 8811 	msr	BASEPRI, r3
 8003b24:	fab0 f080 	clz	r0, r0
 8003b28:	0940      	lsrs	r0, r0, #5
    test_assert(m == 0, "spurious event");
 8003b2a:	492a      	ldr	r1, [pc, #168]	; (8003bd4 <rt_test_009_006_execute+0x164>)
 8003b2c:	f7fd f930 	bl	8000d90 <_test_assert>
 8003b30:	2800      	cmp	r0, #0
 8003b32:	d1ae      	bne.n	8003a92 <rt_test_009_006_execute+0x22>
  thread_t *ctp = currp;
 8003b34:	69a6      	ldr	r6, [r4, #24]
 8003b36:	2320      	movs	r3, #32
 8003b38:	f383 8811 	msr	BASEPRI, r3
  m = ctp->epending & events;
 8003b3c:	6b75      	ldr	r5, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8003b3e:	b94d      	cbnz	r5, 8003b54 <rt_test_009_006_execute+0xe4>
    ctp->u.ewmask = events;
 8003b40:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8003b44:	2164      	movs	r1, #100	; 0x64
    ctp->u.ewmask = events;
 8003b46:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8003b48:	200a      	movs	r0, #10
 8003b4a:	f7ff ff41 	bl	80039d0 <chSchGoSleepTimeoutS>
 8003b4e:	2800      	cmp	r0, #0
 8003b50:	db33      	blt.n	8003bba <rt_test_009_006_execute+0x14a>
    m = ctp->epending & events;
 8003b52:	6b75      	ldr	r5, [r6, #52]	; 0x34
  ctp->epending &= ~m;
 8003b54:	2300      	movs	r3, #0
 8003b56:	6373      	str	r3, [r6, #52]	; 0x34
 8003b58:	f383 8811 	msr	BASEPRI, r3
 8003b5c:	fab5 f085 	clz	r0, r5
 8003b60:	0940      	lsrs	r0, r0, #5
    test_assert(m == 0, "spurious event");
 8003b62:	491c      	ldr	r1, [pc, #112]	; (8003bd4 <rt_test_009_006_execute+0x164>)
 8003b64:	f7fd f914 	bl	8000d90 <_test_assert>
 8003b68:	4605      	mov	r5, r0
 8003b6a:	2800      	cmp	r0, #0
 8003b6c:	d191      	bne.n	8003a92 <rt_test_009_006_execute+0x22>
  thread_t *ctp = currp;
 8003b6e:	69a4      	ldr	r4, [r4, #24]
 8003b70:	2320      	movs	r3, #32
 8003b72:	f383 8811 	msr	BASEPRI, r3
  if ((ctp->epending & events) != events) {
 8003b76:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003b78:	3301      	adds	r3, #1
 8003b7a:	d008      	beq.n	8003b8e <rt_test_009_006_execute+0x11e>
    if (TIME_IMMEDIATE == timeout) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8003b7c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
 8003b80:	2164      	movs	r1, #100	; 0x64
    ctp->u.ewmask = events;
 8003b82:	6263      	str	r3, [r4, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
 8003b84:	200b      	movs	r0, #11
 8003b86:	f7ff ff23 	bl	80039d0 <chSchGoSleepTimeoutS>
 8003b8a:	2800      	cmp	r0, #0
 8003b8c:	db19      	blt.n	8003bc2 <rt_test_009_006_execute+0x152>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->epending &= ~events;
 8003b8e:	2300      	movs	r3, #0
 8003b90:	6363      	str	r3, [r4, #52]	; 0x34
 8003b92:	f383 8811 	msr	BASEPRI, r3
    test_assert(m == 0, "spurious event");
 8003b96:	4628      	mov	r0, r5
}
 8003b98:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert(m == 0, "spurious event");
 8003b9c:	490d      	ldr	r1, [pc, #52]	; (8003bd4 <rt_test_009_006_execute+0x164>)
 8003b9e:	f7fd b8f7 	b.w	8000d90 <_test_assert>
 8003ba2:	f382 8811 	msr	BASEPRI, r2
 8003ba6:	2001      	movs	r0, #1
 8003ba8:	e78e      	b.n	8003ac8 <rt_test_009_006_execute+0x58>
 8003baa:	6358      	str	r0, [r3, #52]	; 0x34
 8003bac:	f380 8811 	msr	BASEPRI, r0
 8003bb0:	e799      	b.n	8003ae6 <rt_test_009_006_execute+0x76>
 8003bb2:	f385 8811 	msr	BASEPRI, r5
 8003bb6:	2001      	movs	r0, #1
 8003bb8:	e7b7      	b.n	8003b2a <rt_test_009_006_execute+0xba>
 8003bba:	f385 8811 	msr	BASEPRI, r5
 8003bbe:	2001      	movs	r0, #1
 8003bc0:	e7cf      	b.n	8003b62 <rt_test_009_006_execute+0xf2>
 8003bc2:	f385 8811 	msr	BASEPRI, r5
 8003bc6:	2501      	movs	r5, #1
 8003bc8:	e7e5      	b.n	8003b96 <rt_test_009_006_execute+0x126>
 8003bca:	bf00      	nop
 8003bcc:	20001d94 	.word	0x20001d94
 8003bd0:	20001254 	.word	0x20001254
 8003bd4:	0800c30c 	.word	0x0800c30c
	...

08003be0 <chGuardedPoolAllocTimeout>:
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
                                sysinterval_t timeout) {
 8003be0:	b510      	push	{r4, lr}
 8003be2:	2320      	movs	r3, #32
 8003be4:	4604      	mov	r4, r0
 8003be6:	f383 8811 	msr	BASEPRI, r3
  if (--sp->cnt < (cnt_t)0) {
 8003bea:	6882      	ldr	r2, [r0, #8]
 8003bec:	1e53      	subs	r3, r2, #1
 8003bee:	2b00      	cmp	r3, #0
 8003bf0:	6083      	str	r3, [r0, #8]
 8003bf2:	db07      	blt.n	8003c04 <chGuardedPoolAllocTimeout+0x24>
  objp = mp->next;
 8003bf4:	68e0      	ldr	r0, [r4, #12]
  if (objp != NULL) {
 8003bf6:	b1b0      	cbz	r0, 8003c26 <chGuardedPoolAllocTimeout+0x46>
    mp->next = mp->next->next;
 8003bf8:	6803      	ldr	r3, [r0, #0]
 8003bfa:	60e3      	str	r3, [r4, #12]
 8003bfc:	2300      	movs	r3, #0
 8003bfe:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
 8003c02:	bd10      	pop	{r4, pc}
 8003c04:	4608      	mov	r0, r1
    if (TIME_IMMEDIATE == timeout) {
 8003c06:	b1c1      	cbz	r1, 8003c3a <chGuardedPoolAllocTimeout+0x5a>
    currp->u.wtsemp = sp;
 8003c08:	4b0d      	ldr	r3, [pc, #52]	; (8003c40 <chGuardedPoolAllocTimeout+0x60>)
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8003c0a:	2005      	movs	r0, #5
    currp->u.wtsemp = sp;
 8003c0c:	699b      	ldr	r3, [r3, #24]
 8003c0e:	625c      	str	r4, [r3, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
 8003c10:	6862      	ldr	r2, [r4, #4]
 8003c12:	e9c3 4200 	strd	r4, r2, [r3]
  tp->queue.prev->queue.next = tp;
 8003c16:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 8003c18:	6063      	str	r3, [r4, #4]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8003c1a:	f7ff fed9 	bl	80039d0 <chSchGoSleepTimeoutS>
  if (msg != MSG_OK) {
 8003c1e:	2800      	cmp	r0, #0
 8003c20:	d0e8      	beq.n	8003bf4 <chGuardedPoolAllocTimeout+0x14>
    return NULL;
 8003c22:	2000      	movs	r0, #0
 8003c24:	e7ea      	b.n	8003bfc <chGuardedPoolAllocTimeout+0x1c>
  else if (mp->provider != NULL) {
 8003c26:	69a3      	ldr	r3, [r4, #24]
 8003c28:	2b00      	cmp	r3, #0
 8003c2a:	d0fa      	beq.n	8003c22 <chGuardedPoolAllocTimeout+0x42>
    objp = mp->provider(mp->object_size, mp->align);
 8003c2c:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 8003c30:	4798      	blx	r3
 8003c32:	2300      	movs	r3, #0
 8003c34:	f383 8811 	msr	BASEPRI, r3
}
 8003c38:	bd10      	pop	{r4, pc}
      sp->cnt++;
 8003c3a:	60a2      	str	r2, [r4, #8]
 8003c3c:	e7de      	b.n	8003bfc <chGuardedPoolAllocTimeout+0x1c>
 8003c3e:	bf00      	nop
 8003c40:	20001254 	.word	0x20001254
	...

08003c50 <oslib_test_007_003_execute>:

static void oslib_test_007_003_execute(void) {

  /* [7.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8003c50:	2201      	movs	r2, #1
static void oslib_test_007_003_execute(void) {
 8003c52:	b508      	push	{r3, lr}
  test_set_step(1);
 8003c54:	4b06      	ldr	r3, [pc, #24]	; (8003c70 <oslib_test_007_003_execute+0x20>)
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 8003c56:	21c8      	movs	r1, #200	; 0xc8
 8003c58:	4806      	ldr	r0, [pc, #24]	; (8003c74 <oslib_test_007_003_execute+0x24>)
  test_set_step(1);
 8003c5a:	601a      	str	r2, [r3, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 8003c5c:	f7ff ffc0 	bl	8003be0 <chGuardedPoolAllocTimeout>
  }
  test_end_step(1);
}
 8003c60:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 8003c64:	fab0 f080 	clz	r0, r0
 8003c68:	4903      	ldr	r1, [pc, #12]	; (8003c78 <oslib_test_007_003_execute+0x28>)
 8003c6a:	0940      	lsrs	r0, r0, #5
 8003c6c:	f7fd b890 	b.w	8000d90 <_test_assert>
 8003c70:	20001d94 	.word	0x20001d94
 8003c74:	20000c14 	.word	0x20000c14
 8003c78:	0800b3b0 	.word	0x0800b3b0
 8003c7c:	00000000 	.word	0x00000000

08003c80 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
 8003c80:	b161      	cbz	r1, 8003c9c <chThdEnqueueTimeoutS+0x1c>
 8003c82:	4602      	mov	r2, r0
  queue_insert(currp, tqp);
 8003c84:	4b07      	ldr	r3, [pc, #28]	; (8003ca4 <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8003c86:	b410      	push	{r4}
  queue_insert(currp, tqp);
 8003c88:	699b      	ldr	r3, [r3, #24]
  tp->queue.prev             = tqp->prev;
 8003c8a:	6844      	ldr	r4, [r0, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8003c8c:	2004      	movs	r0, #4
 8003c8e:	e9c3 2400 	strd	r2, r4, [r3]
  tp->queue.prev->queue.next = tp;
 8003c92:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 8003c94:	6053      	str	r3, [r2, #4]
}
 8003c96:	bc10      	pop	{r4}
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8003c98:	f7ff be9a 	b.w	80039d0 <chSchGoSleepTimeoutS>
}
 8003c9c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003ca0:	4770      	bx	lr
 8003ca2:	bf00      	nop
 8003ca4:	20001254 	.word	0x20001254
	...

08003cb0 <obqGetEmptyBufferTimeoutS>:
                                sysinterval_t timeout) {
 8003cb0:	b538      	push	{r3, r4, r5, lr}
 8003cb2:	4604      	mov	r4, r0
 8003cb4:	460d      	mov	r5, r1
 8003cb6:	e007      	b.n	8003cc8 <obqGetEmptyBufferTimeoutS+0x18>
    if (obqp->suspended) {
 8003cb8:	7a23      	ldrb	r3, [r4, #8]
 8003cba:	b983      	cbnz	r3, 8003cde <obqGetEmptyBufferTimeoutS+0x2e>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8003cbc:	4629      	mov	r1, r5
 8003cbe:	4620      	mov	r0, r4
 8003cc0:	f7ff ffde 	bl	8003c80 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8003cc4:	2800      	cmp	r0, #0
 8003cc6:	db09      	blt.n	8003cdc <obqGetEmptyBufferTimeoutS+0x2c>
  while (obqIsFullI(obqp)) {
 8003cc8:	68e3      	ldr	r3, [r4, #12]
 8003cca:	2b00      	cmp	r3, #0
 8003ccc:	d0f4      	beq.n	8003cb8 <obqGetEmptyBufferTimeoutS+0x8>
  obqp->top = obqp->bwrptr + obqp->bsize;
 8003cce:	2000      	movs	r0, #0
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8003cd0:	6923      	ldr	r3, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
 8003cd2:	69e1      	ldr	r1, [r4, #28]
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8003cd4:	1d1a      	adds	r2, r3, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
 8003cd6:	440b      	add	r3, r1
 8003cd8:	e9c4 230a 	strd	r2, r3, [r4, #40]	; 0x28
}
 8003cdc:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 8003cde:	f06f 0001 	mvn.w	r0, #1
}
 8003ce2:	bd38      	pop	{r3, r4, r5, pc}
	...

08003cf0 <obqWriteTimeout>:
                       size_t n, sysinterval_t timeout) {
 8003cf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003cf4:	b083      	sub	sp, #12
 8003cf6:	4604      	mov	r4, r0
 8003cf8:	460f      	mov	r7, r1
 8003cfa:	4690      	mov	r8, r2
 8003cfc:	9301      	str	r3, [sp, #4]
 8003cfe:	f04f 0a20 	mov.w	sl, #32
 8003d02:	f38a 8811 	msr	BASEPRI, sl
  size_t w = 0;
 8003d06:	f04f 0b00 	mov.w	fp, #0
    if (obqp->ptr == NULL) {
 8003d0a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  obqp->ptr = NULL;
 8003d0c:	46d9      	mov	r9, fp
    if (obqp->ptr == NULL) {
 8003d0e:	2e00      	cmp	r6, #0
 8003d10:	d040      	beq.n	8003d94 <obqWriteTimeout+0xa4>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8003d12:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    if (size > (n - w)) {
 8003d14:	eba8 050b 	sub.w	r5, r8, fp
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8003d18:	1b92      	subs	r2, r2, r6
 8003d1a:	4295      	cmp	r5, r2
 8003d1c:	bf28      	it	cs
 8003d1e:	4615      	movcs	r5, r2
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8003d20:	2d40      	cmp	r5, #64	; 0x40
 8003d22:	d93e      	bls.n	8003da2 <obqWriteTimeout+0xb2>
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
 8003d24:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8003d28:	f8d7 c000 	ldr.w	ip, [r7]
 8003d2c:	687d      	ldr	r5, [r7, #4]
 8003d2e:	68b8      	ldr	r0, [r7, #8]
 8003d30:	68f9      	ldr	r1, [r7, #12]
 8003d32:	3710      	adds	r7, #16
 8003d34:	4297      	cmp	r7, r2
 8003d36:	f8c6 c000 	str.w	ip, [r6]
 8003d3a:	6075      	str	r5, [r6, #4]
 8003d3c:	60b0      	str	r0, [r6, #8]
 8003d3e:	60f1      	str	r1, [r6, #12]
 8003d40:	f106 0610 	add.w	r6, r6, #16
 8003d44:	d1f0      	bne.n	8003d28 <obqWriteTimeout+0x38>
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003d46:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
 8003d48:	f10b 0b40 	add.w	fp, fp, #64	; 0x40
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003d4c:	3240      	adds	r2, #64	; 0x40
 8003d4e:	62a2      	str	r2, [r4, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 8003d50:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8003d52:	4291      	cmp	r1, r2
 8003d54:	d815      	bhi.n	8003d82 <obqWriteTimeout+0x92>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8003d56:	69e1      	ldr	r1, [r4, #28]
  *((size_t *)obqp->bwrptr) = size;
 8003d58:	6922      	ldr	r2, [r4, #16]
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8003d5a:	3904      	subs	r1, #4
  *((size_t *)obqp->bwrptr) = size;
 8003d5c:	6011      	str	r1, [r2, #0]
  obqp->bwrptr += obqp->bsize;
 8003d5e:	69e5      	ldr	r5, [r4, #28]
  if (obqp->bwrptr >= obqp->btop) {
 8003d60:	69a1      	ldr	r1, [r4, #24]
  obqp->bwrptr += obqp->bsize;
 8003d62:	442a      	add	r2, r5
  if (obqp->bwrptr >= obqp->btop) {
 8003d64:	428a      	cmp	r2, r1
  obqp->bwrptr += obqp->bsize;
 8003d66:	6122      	str	r2, [r4, #16]
    obqp->bwrptr = obqp->buffers;
 8003d68:	bf28      	it	cs
 8003d6a:	6a62      	ldrcs	r2, [r4, #36]	; 0x24
  obqp->bcounter--;
 8003d6c:	68e0      	ldr	r0, [r4, #12]
    obqp->bwrptr = obqp->buffers;
 8003d6e:	bf28      	it	cs
 8003d70:	6122      	strcs	r2, [r4, #16]
  if (obqp->notify != NULL) {
 8003d72:	6b22      	ldr	r2, [r4, #48]	; 0x30
  obqp->bcounter--;
 8003d74:	3801      	subs	r0, #1
 8003d76:	60e0      	str	r0, [r4, #12]
  obqp->ptr = NULL;
 8003d78:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
  if (obqp->notify != NULL) {
 8003d7c:	b10a      	cbz	r2, 8003d82 <obqWriteTimeout+0x92>
    obqp->notify(obqp);
 8003d7e:	4620      	mov	r0, r4
 8003d80:	4790      	blx	r2
 8003d82:	f389 8811 	msr	BASEPRI, r9
    if (w >= n) {
 8003d86:	45c3      	cmp	fp, r8
 8003d88:	d218      	bcs.n	8003dbc <obqWriteTimeout+0xcc>
 8003d8a:	f38a 8811 	msr	BASEPRI, sl
    if (obqp->ptr == NULL) {
 8003d8e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8003d90:	2e00      	cmp	r6, #0
 8003d92:	d1be      	bne.n	8003d12 <obqWriteTimeout+0x22>
      msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8003d94:	9901      	ldr	r1, [sp, #4]
 8003d96:	4620      	mov	r0, r4
 8003d98:	f7ff ff8a 	bl	8003cb0 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 8003d9c:	b960      	cbnz	r0, 8003db8 <obqWriteTimeout+0xc8>
 8003d9e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8003da0:	e7b7      	b.n	8003d12 <obqWriteTimeout+0x22>
      memcpy(obqp->ptr, bp, size);
 8003da2:	462a      	mov	r2, r5
 8003da4:	4639      	mov	r1, r7
 8003da6:	4630      	mov	r0, r6
 8003da8:	f7fc fa92 	bl	80002d0 <memcpy>
      obqp->ptr += size;
 8003dac:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      w         += size;
 8003dae:	44ab      	add	fp, r5
      obqp->ptr += size;
 8003db0:	442a      	add	r2, r5
      bp        += size;
 8003db2:	442f      	add	r7, r5
      obqp->ptr += size;
 8003db4:	62a2      	str	r2, [r4, #40]	; 0x28
 8003db6:	e7cb      	b.n	8003d50 <obqWriteTimeout+0x60>
 8003db8:	f386 8811 	msr	BASEPRI, r6
}
 8003dbc:	4658      	mov	r0, fp
 8003dbe:	b003      	add	sp, #12
 8003dc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08003dd0 <_writet>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 8003dd0:	3044      	adds	r0, #68	; 0x44
 8003dd2:	f7ff bf8d 	b.w	8003cf0 <obqWriteTimeout>
 8003dd6:	bf00      	nop
	...

08003de0 <_write>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 8003de0:	3044      	adds	r0, #68	; 0x44
 8003de2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003de6:	f7ff bf83 	b.w	8003cf0 <obqWriteTimeout>
 8003dea:	bf00      	nop
 8003dec:	0000      	movs	r0, r0
	...

08003df0 <obqPutTimeout>:
                    sysinterval_t timeout) {
 8003df0:	b570      	push	{r4, r5, r6, lr}
 8003df2:	2320      	movs	r3, #32
 8003df4:	460e      	mov	r6, r1
 8003df6:	4604      	mov	r4, r0
 8003df8:	f383 8811 	msr	BASEPRI, r3
  if (obqp->ptr == NULL) {
 8003dfc:	6a85      	ldr	r5, [r0, #40]	; 0x28
 8003dfe:	b305      	cbz	r5, 8003e42 <obqPutTimeout+0x52>
  *obqp->ptr = b;
 8003e00:	702e      	strb	r6, [r5, #0]
  if (obqp->ptr >= obqp->top) {
 8003e02:	e9d4 320a 	ldrd	r3, r2, [r4, #40]	; 0x28
  obqp->ptr++;
 8003e06:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 8003e08:	4293      	cmp	r3, r2
  obqp->ptr++;
 8003e0a:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 8003e0c:	d315      	bcc.n	8003e3a <obqPutTimeout+0x4a>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8003e0e:	69e2      	ldr	r2, [r4, #28]
  *((size_t *)obqp->bwrptr) = size;
 8003e10:	6923      	ldr	r3, [r4, #16]
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8003e12:	3a04      	subs	r2, #4
  *((size_t *)obqp->bwrptr) = size;
 8003e14:	601a      	str	r2, [r3, #0]
  obqp->bcounter--;
 8003e16:	68e2      	ldr	r2, [r4, #12]
  obqp->bwrptr += obqp->bsize;
 8003e18:	69e0      	ldr	r0, [r4, #28]
  obqp->bcounter--;
 8003e1a:	3a01      	subs	r2, #1
 8003e1c:	60e2      	str	r2, [r4, #12]
  obqp->ptr = NULL;
 8003e1e:	2200      	movs	r2, #0
  if (obqp->bwrptr >= obqp->btop) {
 8003e20:	69a1      	ldr	r1, [r4, #24]
  obqp->bwrptr += obqp->bsize;
 8003e22:	4403      	add	r3, r0
  if (obqp->bwrptr >= obqp->btop) {
 8003e24:	428b      	cmp	r3, r1
  obqp->bwrptr += obqp->bsize;
 8003e26:	6123      	str	r3, [r4, #16]
    obqp->bwrptr = obqp->buffers;
 8003e28:	bf28      	it	cs
 8003e2a:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
  obqp->ptr = NULL;
 8003e2c:	62a2      	str	r2, [r4, #40]	; 0x28
    obqp->bwrptr = obqp->buffers;
 8003e2e:	bf28      	it	cs
 8003e30:	6123      	strcs	r3, [r4, #16]
  if (obqp->notify != NULL) {
 8003e32:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003e34:	b10b      	cbz	r3, 8003e3a <obqPutTimeout+0x4a>
    obqp->notify(obqp);
 8003e36:	4620      	mov	r0, r4
 8003e38:	4798      	blx	r3
 8003e3a:	2000      	movs	r0, #0
 8003e3c:	f380 8811 	msr	BASEPRI, r0
}
 8003e40:	bd70      	pop	{r4, r5, r6, pc}
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8003e42:	4611      	mov	r1, r2
 8003e44:	f7ff ff34 	bl	8003cb0 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8003e48:	b908      	cbnz	r0, 8003e4e <obqPutTimeout+0x5e>
 8003e4a:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 8003e4c:	e7d8      	b.n	8003e00 <obqPutTimeout+0x10>
 8003e4e:	f385 8811 	msr	BASEPRI, r5
}
 8003e52:	bd70      	pop	{r4, r5, r6, pc}
	...

08003e60 <_putt>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8003e60:	3044      	adds	r0, #68	; 0x44
 8003e62:	f7ff bfc5 	b.w	8003df0 <obqPutTimeout>
 8003e66:	bf00      	nop
	...

08003e70 <_put>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8003e70:	3044      	adds	r0, #68	; 0x44
 8003e72:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003e76:	f7ff bfbb 	b.w	8003df0 <obqPutTimeout>
 8003e7a:	bf00      	nop
 8003e7c:	0000      	movs	r0, r0
	...

08003e80 <ibqGetFullBufferTimeoutS>:
                                 sysinterval_t timeout) {
 8003e80:	b538      	push	{r3, r4, r5, lr}
 8003e82:	4604      	mov	r4, r0
 8003e84:	460d      	mov	r5, r1
 8003e86:	e007      	b.n	8003e98 <ibqGetFullBufferTimeoutS+0x18>
    if (ibqp->suspended) {
 8003e88:	7a23      	ldrb	r3, [r4, #8]
 8003e8a:	b983      	cbnz	r3, 8003eae <ibqGetFullBufferTimeoutS+0x2e>
 8003e8c:	4629      	mov	r1, r5
 8003e8e:	4620      	mov	r0, r4
 8003e90:	f7ff fef6 	bl	8003c80 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8003e94:	2800      	cmp	r0, #0
 8003e96:	db09      	blt.n	8003eac <ibqGetFullBufferTimeoutS+0x2c>
  while (ibqIsEmptyI(ibqp)) {
 8003e98:	68e3      	ldr	r3, [r4, #12]
 8003e9a:	2b00      	cmp	r3, #0
 8003e9c:	d0f4      	beq.n	8003e88 <ibqGetFullBufferTimeoutS+0x8>
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8003e9e:	2000      	movs	r0, #0
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8003ea0:	6963      	ldr	r3, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8003ea2:	681a      	ldr	r2, [r3, #0]
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8003ea4:	3304      	adds	r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8003ea6:	441a      	add	r2, r3
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8003ea8:	e9c4 320a 	strd	r3, r2, [r4, #40]	; 0x28
}
 8003eac:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 8003eae:	f06f 0001 	mvn.w	r0, #1
}
 8003eb2:	bd38      	pop	{r3, r4, r5, pc}
	...

08003ec0 <ibqReadTimeout>:
                      size_t n, sysinterval_t timeout) {
 8003ec0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003ec4:	4604      	mov	r4, r0
 8003ec6:	b083      	sub	sp, #12
 8003ec8:	460e      	mov	r6, r1
 8003eca:	4617      	mov	r7, r2
 8003ecc:	469a      	mov	sl, r3
 8003ece:	f04f 0920 	mov.w	r9, #32
 8003ed2:	f389 8811 	msr	BASEPRI, r9
  size_t r = 0;
 8003ed6:	f04f 0b00 	mov.w	fp, #0
    if (ibqp->ptr == NULL) {
 8003eda:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  ibqp->ptr = NULL;
 8003edc:	46d8      	mov	r8, fp
    if (ibqp->ptr == NULL) {
 8003ede:	2b00      	cmp	r3, #0
 8003ee0:	d043      	beq.n	8003f6a <ibqReadTimeout+0xaa>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8003ee2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    if (size > (n - r)) {
 8003ee4:	eba7 050b 	sub.w	r5, r7, fp
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8003ee8:	1ad2      	subs	r2, r2, r3
 8003eea:	4295      	cmp	r5, r2
 8003eec:	bf28      	it	cs
 8003eee:	4615      	movcs	r5, r2
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8003ef0:	2d40      	cmp	r5, #64	; 0x40
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
 8003ef2:	4619      	mov	r1, r3
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8003ef4:	d942      	bls.n	8003f7c <ibqReadTimeout+0xbc>
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
 8003ef6:	4633      	mov	r3, r6
 8003ef8:	f101 0240 	add.w	r2, r1, #64	; 0x40
 8003efc:	f8d1 e000 	ldr.w	lr, [r1]
 8003f00:	f8d1 c004 	ldr.w	ip, [r1, #4]
 8003f04:	688d      	ldr	r5, [r1, #8]
 8003f06:	68c8      	ldr	r0, [r1, #12]
 8003f08:	3110      	adds	r1, #16
 8003f0a:	4291      	cmp	r1, r2
 8003f0c:	f8c3 e000 	str.w	lr, [r3]
 8003f10:	f8c3 c004 	str.w	ip, [r3, #4]
 8003f14:	609d      	str	r5, [r3, #8]
 8003f16:	60d8      	str	r0, [r3, #12]
 8003f18:	f103 0310 	add.w	r3, r3, #16
 8003f1c:	d1ee      	bne.n	8003efc <ibqReadTimeout+0x3c>
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003f1e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 8003f20:	3640      	adds	r6, #64	; 0x40
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003f22:	3340      	adds	r3, #64	; 0x40
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
 8003f24:	f10b 0b40 	add.w	fp, fp, #64	; 0x40
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003f28:	62a3      	str	r3, [r4, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 8003f2a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8003f2c:	429a      	cmp	r2, r3
 8003f2e:	d813      	bhi.n	8003f58 <ibqReadTimeout+0x98>
  if (ibqp->brdptr >= ibqp->btop) {
 8003f30:	e9d4 2106 	ldrd	r2, r1, [r4, #24]
  ibqp->brdptr += ibqp->bsize;
 8003f34:	6963      	ldr	r3, [r4, #20]
  ibqp->bcounter--;
 8003f36:	68e0      	ldr	r0, [r4, #12]
  ibqp->brdptr += ibqp->bsize;
 8003f38:	440b      	add	r3, r1
  if (ibqp->brdptr >= ibqp->btop) {
 8003f3a:	4293      	cmp	r3, r2
  ibqp->brdptr += ibqp->bsize;
 8003f3c:	6163      	str	r3, [r4, #20]
    ibqp->brdptr = ibqp->buffers;
 8003f3e:	bf28      	it	cs
 8003f40:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
  ibqp->bcounter--;
 8003f42:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    ibqp->brdptr = ibqp->buffers;
 8003f46:	bf28      	it	cs
 8003f48:	6163      	strcs	r3, [r4, #20]
  if (ibqp->notify != NULL) {
 8003f4a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  ibqp->bcounter--;
 8003f4c:	60e0      	str	r0, [r4, #12]
  ibqp->ptr = NULL;
 8003f4e:	f8c4 8028 	str.w	r8, [r4, #40]	; 0x28
  if (ibqp->notify != NULL) {
 8003f52:	b10b      	cbz	r3, 8003f58 <ibqReadTimeout+0x98>
    ibqp->notify(ibqp);
 8003f54:	4620      	mov	r0, r4
 8003f56:	4798      	blx	r3
 8003f58:	f388 8811 	msr	BASEPRI, r8
    if (r >= n) {
 8003f5c:	45bb      	cmp	fp, r7
 8003f5e:	d219      	bcs.n	8003f94 <ibqReadTimeout+0xd4>
 8003f60:	f389 8811 	msr	BASEPRI, r9
    if (ibqp->ptr == NULL) {
 8003f64:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003f66:	2b00      	cmp	r3, #0
 8003f68:	d1bb      	bne.n	8003ee2 <ibqReadTimeout+0x22>
      msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8003f6a:	4651      	mov	r1, sl
 8003f6c:	4620      	mov	r0, r4
 8003f6e:	9301      	str	r3, [sp, #4]
 8003f70:	f7ff ff86 	bl	8003e80 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 8003f74:	9b01      	ldr	r3, [sp, #4]
 8003f76:	b958      	cbnz	r0, 8003f90 <ibqReadTimeout+0xd0>
 8003f78:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003f7a:	e7b2      	b.n	8003ee2 <ibqReadTimeout+0x22>
      memcpy(bp, ibqp->ptr, size);
 8003f7c:	4630      	mov	r0, r6
 8003f7e:	462a      	mov	r2, r5
 8003f80:	f7fc f9a6 	bl	80002d0 <memcpy>
      ibqp->ptr += size;
 8003f84:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      r         += size;
 8003f86:	44ab      	add	fp, r5
      ibqp->ptr += size;
 8003f88:	442b      	add	r3, r5
      bp        += size;
 8003f8a:	442e      	add	r6, r5
      ibqp->ptr += size;
 8003f8c:	62a3      	str	r3, [r4, #40]	; 0x28
 8003f8e:	e7cc      	b.n	8003f2a <ibqReadTimeout+0x6a>
 8003f90:	f383 8811 	msr	BASEPRI, r3
}
 8003f94:	4658      	mov	r0, fp
 8003f96:	b003      	add	sp, #12
 8003f98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003f9c:	0000      	movs	r0, r0
	...

08003fa0 <_readt>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 8003fa0:	300c      	adds	r0, #12
 8003fa2:	f7ff bf8d 	b.w	8003ec0 <ibqReadTimeout>
 8003fa6:	bf00      	nop
	...

08003fb0 <_read>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 8003fb0:	300c      	adds	r0, #12
 8003fb2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003fb6:	f7ff bf83 	b.w	8003ec0 <ibqReadTimeout>
 8003fba:	bf00      	nop
 8003fbc:	0000      	movs	r0, r0
	...

08003fc0 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
 8003fc0:	b570      	push	{r4, r5, r6, lr}
 8003fc2:	2320      	movs	r3, #32
 8003fc4:	4604      	mov	r4, r0
 8003fc6:	f383 8811 	msr	BASEPRI, r3
  if (ibqp->ptr == NULL) {
 8003fca:	6a85      	ldr	r5, [r0, #40]	; 0x28
 8003fcc:	b1ed      	cbz	r5, 800400a <ibqGetTimeout+0x4a>
  msg = (msg_t)*ibqp->ptr;
 8003fce:	f815 6b01 	ldrb.w	r6, [r5], #1
  if (ibqp->ptr >= ibqp->top) {
 8003fd2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  ibqp->ptr++;
 8003fd4:	62a5      	str	r5, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 8003fd6:	4295      	cmp	r5, r2
 8003fd8:	d312      	bcc.n	8004000 <ibqGetTimeout+0x40>
  if (ibqp->brdptr >= ibqp->btop) {
 8003fda:	e9d4 1006 	ldrd	r1, r0, [r4, #24]
  ibqp->bcounter--;
 8003fde:	68e2      	ldr	r2, [r4, #12]
  ibqp->brdptr += ibqp->bsize;
 8003fe0:	6963      	ldr	r3, [r4, #20]
  ibqp->bcounter--;
 8003fe2:	3a01      	subs	r2, #1
 8003fe4:	60e2      	str	r2, [r4, #12]
  ibqp->ptr = NULL;
 8003fe6:	2200      	movs	r2, #0
  ibqp->brdptr += ibqp->bsize;
 8003fe8:	4403      	add	r3, r0
  if (ibqp->brdptr >= ibqp->btop) {
 8003fea:	428b      	cmp	r3, r1
  ibqp->brdptr += ibqp->bsize;
 8003fec:	6163      	str	r3, [r4, #20]
    ibqp->brdptr = ibqp->buffers;
 8003fee:	bf28      	it	cs
 8003ff0:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
  ibqp->ptr = NULL;
 8003ff2:	62a2      	str	r2, [r4, #40]	; 0x28
    ibqp->brdptr = ibqp->buffers;
 8003ff4:	bf28      	it	cs
 8003ff6:	6163      	strcs	r3, [r4, #20]
  if (ibqp->notify != NULL) {
 8003ff8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003ffa:	b10b      	cbz	r3, 8004000 <ibqGetTimeout+0x40>
    ibqp->notify(ibqp);
 8003ffc:	4620      	mov	r0, r4
 8003ffe:	4798      	blx	r3
 8004000:	2300      	movs	r3, #0
 8004002:	f383 8811 	msr	BASEPRI, r3
}
 8004006:	4630      	mov	r0, r6
 8004008:	bd70      	pop	{r4, r5, r6, pc}
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 800400a:	f7ff ff39 	bl	8003e80 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 800400e:	4606      	mov	r6, r0
 8004010:	b908      	cbnz	r0, 8004016 <ibqGetTimeout+0x56>
 8004012:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 8004014:	e7db      	b.n	8003fce <ibqGetTimeout+0xe>
 8004016:	f385 8811 	msr	BASEPRI, r5
 800401a:	e7f4      	b.n	8004006 <ibqGetTimeout+0x46>
 800401c:	0000      	movs	r0, r0
	...

08004020 <_gett>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 8004020:	300c      	adds	r0, #12
 8004022:	f7ff bfcd 	b.w	8003fc0 <ibqGetTimeout>
 8004026:	bf00      	nop
	...

08004030 <_get>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 8004030:	300c      	adds	r0, #12
 8004032:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004036:	f7ff bfc3 	b.w	8003fc0 <ibqGetTimeout>
 800403a:	bf00      	nop
 800403c:	0000      	movs	r0, r0
	...

08004040 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
 8004040:	b508      	push	{r3, lr}
 8004042:	4601      	mov	r1, r0
 8004044:	2320      	movs	r3, #32
 8004046:	f383 8811 	msr	BASEPRI, r3
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 800404a:	2008      	movs	r0, #8
 800404c:	f7ff fcc0 	bl	80039d0 <chSchGoSleepTimeoutS>
 8004050:	2300      	movs	r3, #0
 8004052:	f383 8811 	msr	BASEPRI, r3
}
 8004056:	bd08      	pop	{r3, pc}
	...

08004060 <Thread1.lto_priv.109>:

        (void)arg;
        chRegSetThreadName("blinker");
        while (true) {
                systime_t time = serusbcfg.usbp->state == USB_ACTIVE ? 100 : 100;
                palClearPad(GPIOA, GPIOA_LED);
 8004060:	2504      	movs	r5, #4
 8004062:	462e      	mov	r6, r5
{
 8004064:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8004066:	4b07      	ldr	r3, [pc, #28]	; (8004084 <Thread1.lto_priv.109+0x24>)
 8004068:	4a07      	ldr	r2, [pc, #28]	; (8004088 <Thread1.lto_priv.109+0x28>)
 800406a:	699b      	ldr	r3, [r3, #24]
                palClearPad(GPIOA, GPIOA_LED);
 800406c:	4c07      	ldr	r4, [pc, #28]	; (800408c <Thread1.lto_priv.109+0x2c>)
 800406e:	619a      	str	r2, [r3, #24]
                chThdSleepMilliseconds(time);
 8004070:	20c8      	movs	r0, #200	; 0xc8
                palClearPad(GPIOA, GPIOA_LED);
 8004072:	6166      	str	r6, [r4, #20]
                chThdSleepMilliseconds(time);
 8004074:	f7ff ffe4 	bl	8004040 <chThdSleep>
                palSetPad(GPIOA, GPIOA_LED);
 8004078:	6125      	str	r5, [r4, #16]
                chThdSleepMilliseconds(time);
 800407a:	20c8      	movs	r0, #200	; 0xc8
 800407c:	f7ff ffe0 	bl	8004040 <chThdSleep>
                palReadPad(GPIOA, GPIOA_LED);
 8004080:	68a3      	ldr	r3, [r4, #8]
 8004082:	e7f5      	b.n	8004070 <Thread1.lto_priv.109+0x10>
 8004084:	20001254 	.word	0x20001254
 8004088:	0800a9b4 	.word	0x0800a9b4
 800408c:	40010800 	.word	0x40010800

08004090 <job_slow>:

static jobs_queue_t jq;
static job_descriptor_t jobs[JOBS_QUEUE_SIZE];
static msg_t msg_queue[JOBS_QUEUE_SIZE];

static void job_slow(void *arg) {
 8004090:	b508      	push	{r3, lr}

  test_emit_token((int)arg);
 8004092:	b2c0      	uxtb	r0, r0
 8004094:	f7fc ff24 	bl	8000ee0 <test_emit_token>
  chThdSleepMilliseconds(10);
}
 8004098:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chThdSleepMilliseconds(10);
 800409c:	2014      	movs	r0, #20
 800409e:	f7ff bfcf 	b.w	8004040 <chThdSleep>
 80040a2:	bf00      	nop
	...

080040b0 <rt_test_004_001_execute>:
  systime_t time;

  /* [4.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
 80040b0:	2301      	movs	r3, #1
static void rt_test_004_001_execute(void) {
 80040b2:	b570      	push	{r4, r5, r6, lr}
 80040b4:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
  test_set_step(1);
 80040b8:	4e30      	ldr	r6, [pc, #192]	; (800417c <rt_test_004_001_execute+0xcc>)
  {
    time = chVTGetSystemTimeX();
    chThdSleep(100);
 80040ba:	2064      	movs	r0, #100	; 0x64
  test_set_step(1);
 80040bc:	6033      	str	r3, [r6, #0]
 80040be:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleep(100);
 80040c0:	f7ff ffbe 	bl	8004040 <chThdSleep>
 80040c4:	b2a4      	uxth	r4, r4
 80040c6:	f104 0167 	add.w	r1, r4, #103	; 0x67
 80040ca:	f104 0064 	add.w	r0, r4, #100	; 0x64
    test_assert_time_window(chTimeAddX(time, 100),
 80040ce:	b289      	uxth	r1, r1
 80040d0:	b280      	uxth	r0, r0
 80040d2:	f7fc fbfd 	bl	80008d0 <_test_assert_time_window.constprop.3>
 80040d6:	b100      	cbz	r0, 80040da <rt_test_004_001_execute+0x2a>
    test_assert_time_window(chTimeAddX(time, 100),
                            chTimeAddX(time, 100 + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
  }
  test_end_step(5);
}
 80040d8:	bd70      	pop	{r4, r5, r6, pc}
  test_set_step(2);
 80040da:	2302      	movs	r3, #2
 80040dc:	6033      	str	r3, [r6, #0]
 80040de:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepMicroseconds(100000);
 80040e0:	20c8      	movs	r0, #200	; 0xc8
 80040e2:	b2a4      	uxth	r4, r4
 80040e4:	f7ff ffac 	bl	8004040 <chThdSleep>
 80040e8:	f104 01cb 	add.w	r1, r4, #203	; 0xcb
 80040ec:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
    test_assert_time_window(chTimeAddX(time, TIME_US2I(100000)),
 80040f0:	b289      	uxth	r1, r1
 80040f2:	b280      	uxth	r0, r0
 80040f4:	f7fc fbec 	bl	80008d0 <_test_assert_time_window.constprop.3>
 80040f8:	2800      	cmp	r0, #0
 80040fa:	d1ed      	bne.n	80040d8 <rt_test_004_001_execute+0x28>
  test_set_step(3);
 80040fc:	2303      	movs	r3, #3
 80040fe:	6033      	str	r3, [r6, #0]
 8004100:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepMilliseconds(100);
 8004102:	20c8      	movs	r0, #200	; 0xc8
 8004104:	b2a4      	uxth	r4, r4
 8004106:	f7ff ff9b 	bl	8004040 <chThdSleep>
 800410a:	f104 01cb 	add.w	r1, r4, #203	; 0xcb
 800410e:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(100)),
 8004112:	b289      	uxth	r1, r1
 8004114:	b280      	uxth	r0, r0
 8004116:	f7fc fbdb 	bl	80008d0 <_test_assert_time_window.constprop.3>
 800411a:	2800      	cmp	r0, #0
 800411c:	d1dc      	bne.n	80040d8 <rt_test_004_001_execute+0x28>
  test_set_step(4);
 800411e:	2304      	movs	r3, #4
 8004120:	6033      	str	r3, [r6, #0]
 8004122:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepSeconds(1);
 8004124:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8004128:	b2a4      	uxth	r4, r4
 800412a:	f7ff ff89 	bl	8004040 <chThdSleep>
 800412e:	f204 71d3 	addw	r1, r4, #2003	; 0x7d3
 8004132:	f504 60fa 	add.w	r0, r4, #2000	; 0x7d0
    test_assert_time_window(chTimeAddX(time, TIME_S2I(1)),
 8004136:	b289      	uxth	r1, r1
 8004138:	b280      	uxth	r0, r0
 800413a:	f7fc fbc9 	bl	80008d0 <_test_assert_time_window.constprop.3>
 800413e:	2800      	cmp	r0, #0
 8004140:	d1ca      	bne.n	80040d8 <rt_test_004_001_execute+0x28>
  test_set_step(5);
 8004142:	2305      	movs	r3, #5
 8004144:	6033      	str	r3, [r6, #0]
 8004146:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8004148:	2320      	movs	r3, #32
 800414a:	b2a4      	uxth	r4, r4
 800414c:	f104 0664 	add.w	r6, r4, #100	; 0x64
 8004150:	b2b6      	uxth	r6, r6
 8004152:	f383 8811 	msr	BASEPRI, r3
 8004156:	6a69      	ldr	r1, [r5, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8004158:	1a71      	subs	r1, r6, r1
 800415a:	b289      	uxth	r1, r1
  if (interval > (sysinterval_t)0) {
 800415c:	b111      	cbz	r1, 8004164 <rt_test_004_001_execute+0xb4>
 800415e:	2008      	movs	r0, #8
 8004160:	f7ff fc36 	bl	80039d0 <chSchGoSleepTimeoutS>
 8004164:	2300      	movs	r3, #0
 8004166:	f383 8811 	msr	BASEPRI, r3
  return systime + (systime_t)interval;
 800416a:	f104 0167 	add.w	r1, r4, #103	; 0x67
    test_assert_time_window(chTimeAddX(time, 100),
 800416e:	4630      	mov	r0, r6
}
 8004170:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert_time_window(chTimeAddX(time, 100),
 8004174:	b289      	uxth	r1, r1
 8004176:	f7fc bbab 	b.w	80008d0 <_test_assert_time_window.constprop.3>
 800417a:	bf00      	nop
 800417c:	20001d94 	.word	0x20001d94

08004180 <test_wait_tick>:
}

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 8004180:	b508      	push	{r3, lr}

  chThdSleep(1);
 8004182:	2001      	movs	r0, #1
 8004184:	f7ff ff5c 	bl	8004040 <chThdSleep>
 8004188:	2320      	movs	r3, #32
 800418a:	f383 8811 	msr	BASEPRI, r3
 800418e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8004192:	2300      	movs	r3, #0
 8004194:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8004196:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 800419a:	b280      	uxth	r0, r0
 800419c:	bd08      	pop	{r3, pc}
 800419e:	bf00      	nop

080041a0 <rt_test_011_009_execute>:
static void rt_test_011_009_execute(void) {
 80041a0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_set_step(1);
 80041a4:	2301      	movs	r3, #1
 80041a6:	f8df b08c 	ldr.w	fp, [pc, #140]	; 8004234 <rt_test_011_009_execute+0x94>
    n = 0;
 80041aa:	2400      	movs	r4, #0
  test_set_step(1);
 80041ac:	f8cb 3000 	str.w	r3, [fp]
    start = test_wait_tick();
 80041b0:	f7ff ffe6 	bl	8004180 <test_wait_tick>
      chVTDoSetI(&vt1, 1, tmo, NULL);
 80041b4:	46a2      	mov	sl, r4
 80041b6:	f04f 0920 	mov.w	r9, #32
    start = test_wait_tick();
 80041ba:	4680      	mov	r8, r0
      chVTDoSetI(&vt1, 1, tmo, NULL);
 80041bc:	4f18      	ldr	r7, [pc, #96]	; (8004220 <rt_test_011_009_execute+0x80>)
 80041be:	4e19      	ldr	r6, [pc, #100]	; (8004224 <rt_test_011_009_execute+0x84>)
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 80041c0:	4d19      	ldr	r5, [pc, #100]	; (8004228 <rt_test_011_009_execute+0x88>)
 80041c2:	f389 8811 	msr	BASEPRI, r9
      chVTDoSetI(&vt1, 1, tmo, NULL);
 80041c6:	2300      	movs	r3, #0
 80041c8:	463a      	mov	r2, r7
 80041ca:	4630      	mov	r0, r6
 80041cc:	2101      	movs	r1, #1
 80041ce:	f7fd fbd7 	bl	8001980 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 80041d2:	463a      	mov	r2, r7
 80041d4:	2300      	movs	r3, #0
 80041d6:	f242 7110 	movw	r1, #10000	; 0x2710
 80041da:	4628      	mov	r0, r5
 80041dc:	f7fd fbd0 	bl	8001980 <chVTDoSetI>
      chVTDoResetI(&vt1);
 80041e0:	4630      	mov	r0, r6
 80041e2:	f7fd fb85 	bl	80018f0 <chVTDoResetI>
      chVTDoResetI(&vt2);
 80041e6:	4628      	mov	r0, r5
 80041e8:	f7fd fb82 	bl	80018f0 <chVTDoResetI>
 80041ec:	f38a 8811 	msr	BASEPRI, sl
 80041f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80041f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      n++;
 80041f6:	3401      	adds	r4, #1
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 80041f8:	eba3 0308 	sub.w	r3, r3, r8
    } while (chVTIsSystemTimeWithinX(start, end));
 80041fc:	b29b      	uxth	r3, r3
 80041fe:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8004202:	d3de      	bcc.n	80041c2 <rt_test_011_009_execute+0x22>
  test_set_step(2);
 8004204:	2302      	movs	r3, #2
    test_print("--- Score : ");
 8004206:	4809      	ldr	r0, [pc, #36]	; (800422c <rt_test_011_009_execute+0x8c>)
  test_set_step(2);
 8004208:	f8cb 3000 	str.w	r3, [fp]
    test_print("--- Score : ");
 800420c:	f7fc ff28 	bl	8001060 <test_print>
    test_printn(n * 2);
 8004210:	0060      	lsls	r0, r4, #1
 8004212:	f7fc fe55 	bl	8000ec0 <test_printn>
}
 8004216:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_println(" timers/S");
 800421a:	4805      	ldr	r0, [pc, #20]	; (8004230 <rt_test_011_009_execute+0x90>)
 800421c:	f7fc bf00 	b.w	8001020 <test_println>
 8004220:	08000ba1 	.word	0x08000ba1
 8004224:	20001dc4 	.word	0x20001dc4
 8004228:	20001dd8 	.word	0x20001dd8
 800422c:	0800c4fc 	.word	0x0800c4fc
 8004230:	0800c50c 	.word	0x0800c50c
 8004234:	20001d94 	.word	0x20001d94
	...

08004240 <test_execute>:
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 *
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream, const testsuite_t *tsp) {
 8004240:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004244:	4688      	mov	r8, r1
  int tseq, tcase;

  test_chp = stream;
 8004246:	4ca8      	ldr	r4, [pc, #672]	; (80044e8 <test_execute+0x2a8>)
 8004248:	6020      	str	r0, [r4, #0]
  test_println("");
 800424a:	48a8      	ldr	r0, [pc, #672]	; (80044ec <test_execute+0x2ac>)
 800424c:	f7fc fee8 	bl	8001020 <test_println>
  if (tsp->name != NULL) {
 8004250:	f8d8 3000 	ldr.w	r3, [r8]
 8004254:	2b00      	cmp	r3, #0
 8004256:	f000 81e4 	beq.w	8004622 <test_execute+0x3e2>
  while (*msgp)
 800425a:	212a      	movs	r1, #42	; 0x2a
  if (tsp->name != NULL) {
 800425c:	4da4      	ldr	r5, [pc, #656]	; (80044f0 <test_execute+0x2b0>)
    streamPut(test_chp, *msgp++);
 800425e:	6820      	ldr	r0, [r4, #0]
 8004260:	6803      	ldr	r3, [r0, #0]
 8004262:	68db      	ldr	r3, [r3, #12]
 8004264:	4798      	blx	r3
  while (*msgp)
 8004266:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 800426a:	2900      	cmp	r1, #0
 800426c:	d1f7      	bne.n	800425e <test_execute+0x1e>
    test_print("*** ");
    test_println(tsp->name);
 800426e:	f8d8 0000 	ldr.w	r0, [r8]
 8004272:	f7fc fed5 	bl	8001020 <test_println>
  }
  else {
    test_println("*** Test Suite");
  }
  test_println("***");
 8004276:	489f      	ldr	r0, [pc, #636]	; (80044f4 <test_execute+0x2b4>)
 8004278:	f7fc fed2 	bl	8001020 <test_println>
  while (*msgp)
 800427c:	212a      	movs	r1, #42	; 0x2a
  test_println("***");
 800427e:	4d9e      	ldr	r5, [pc, #632]	; (80044f8 <test_execute+0x2b8>)
    streamPut(test_chp, *msgp++);
 8004280:	6820      	ldr	r0, [r4, #0]
 8004282:	6803      	ldr	r3, [r0, #0]
 8004284:	68db      	ldr	r3, [r3, #12]
 8004286:	4798      	blx	r3
  while (*msgp)
 8004288:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 800428c:	2900      	cmp	r1, #0
 800428e:	d1f7      	bne.n	8004280 <test_execute+0x40>
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8004290:	489a      	ldr	r0, [pc, #616]	; (80044fc <test_execute+0x2bc>)
 8004292:	f7fc fec5 	bl	8001020 <test_println>
  while (*msgp)
 8004296:	212a      	movs	r1, #42	; 0x2a
  test_println(__DATE__ " - " __TIME__);
 8004298:	4d99      	ldr	r5, [pc, #612]	; (8004500 <test_execute+0x2c0>)
    streamPut(test_chp, *msgp++);
 800429a:	6820      	ldr	r0, [r4, #0]
 800429c:	6803      	ldr	r3, [r0, #0]
 800429e:	68db      	ldr	r3, [r3, #12]
 80042a0:	4798      	blx	r3
  while (*msgp)
 80042a2:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80042a6:	2900      	cmp	r1, #0
 80042a8:	d1f7      	bne.n	800429a <test_execute+0x5a>
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 80042aa:	4896      	ldr	r0, [pc, #600]	; (8004504 <test_execute+0x2c4>)
 80042ac:	f7fc feb8 	bl	8001020 <test_println>
  while (*msgp)
 80042b0:	212a      	movs	r1, #42	; 0x2a
  test_println(PLATFORM_NAME);
 80042b2:	4d95      	ldr	r5, [pc, #596]	; (8004508 <test_execute+0x2c8>)
    streamPut(test_chp, *msgp++);
 80042b4:	6820      	ldr	r0, [r4, #0]
 80042b6:	6803      	ldr	r3, [r0, #0]
 80042b8:	68db      	ldr	r3, [r3, #12]
 80042ba:	4798      	blx	r3
  while (*msgp)
 80042bc:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80042c0:	2900      	cmp	r1, #0
 80042c2:	d1f7      	bne.n	80042b4 <test_execute+0x74>
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 80042c4:	4891      	ldr	r0, [pc, #580]	; (800450c <test_execute+0x2cc>)
 80042c6:	f7fc feab 	bl	8001020 <test_println>
  {
    extern uint8_t __text_base__,   __text_end__,
                   __rodata_base__, __rodata_end__,
                   __data_base__,   __data_end__,
                   __bss_base__,    __bss_end__;
    test_println("***");
 80042ca:	488a      	ldr	r0, [pc, #552]	; (80044f4 <test_execute+0x2b4>)
 80042cc:	f7fc fea8 	bl	8001020 <test_println>
  while (*msgp)
 80042d0:	212a      	movs	r1, #42	; 0x2a
    test_println("***");
 80042d2:	4d8f      	ldr	r5, [pc, #572]	; (8004510 <test_execute+0x2d0>)
    streamPut(test_chp, *msgp++);
 80042d4:	6820      	ldr	r0, [r4, #0]
 80042d6:	6803      	ldr	r3, [r0, #0]
 80042d8:	68db      	ldr	r3, [r3, #12]
 80042da:	4798      	blx	r3
  while (*msgp)
 80042dc:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80042e0:	2900      	cmp	r1, #0
 80042e2:	d1f7      	bne.n	80042d4 <test_execute+0x94>
    test_print("*** Text size:    ");
    test_printn((uint32_t)(&__text_end__ - &__text_base__));
 80042e4:	4b8b      	ldr	r3, [pc, #556]	; (8004514 <test_execute+0x2d4>)
 80042e6:	488c      	ldr	r0, [pc, #560]	; (8004518 <test_execute+0x2d8>)
    test_println(" bytes");
 80042e8:	4d8c      	ldr	r5, [pc, #560]	; (800451c <test_execute+0x2dc>)
    test_printn((uint32_t)(&__text_end__ - &__text_base__));
 80042ea:	1ac0      	subs	r0, r0, r3
 80042ec:	f7fc fde8 	bl	8000ec0 <test_printn>
    test_println(" bytes");
 80042f0:	488b      	ldr	r0, [pc, #556]	; (8004520 <test_execute+0x2e0>)
 80042f2:	f7fc fe95 	bl	8001020 <test_println>
  while (*msgp)
 80042f6:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 80042f8:	6820      	ldr	r0, [r4, #0]
 80042fa:	6803      	ldr	r3, [r0, #0]
 80042fc:	68db      	ldr	r3, [r3, #12]
 80042fe:	4798      	blx	r3
  while (*msgp)
 8004300:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8004304:	2900      	cmp	r1, #0
 8004306:	d1f7      	bne.n	80042f8 <test_execute+0xb8>
    test_print("*** RO data size: ");
    test_printn((uint32_t)(&__rodata_end__ - &__rodata_base__));
 8004308:	4b86      	ldr	r3, [pc, #536]	; (8004524 <test_execute+0x2e4>)
 800430a:	4887      	ldr	r0, [pc, #540]	; (8004528 <test_execute+0x2e8>)
    test_println(" bytes");
 800430c:	4d87      	ldr	r5, [pc, #540]	; (800452c <test_execute+0x2ec>)
    test_printn((uint32_t)(&__rodata_end__ - &__rodata_base__));
 800430e:	1ac0      	subs	r0, r0, r3
 8004310:	f7fc fdd6 	bl	8000ec0 <test_printn>
    test_println(" bytes");
 8004314:	4882      	ldr	r0, [pc, #520]	; (8004520 <test_execute+0x2e0>)
 8004316:	f7fc fe83 	bl	8001020 <test_println>
  while (*msgp)
 800431a:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 800431c:	6820      	ldr	r0, [r4, #0]
 800431e:	6803      	ldr	r3, [r0, #0]
 8004320:	68db      	ldr	r3, [r3, #12]
 8004322:	4798      	blx	r3
  while (*msgp)
 8004324:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8004328:	2900      	cmp	r1, #0
 800432a:	d1f7      	bne.n	800431c <test_execute+0xdc>
 800432c:	252a      	movs	r5, #42	; 0x2a
    test_print("*** Data size:    ");
    test_printn((uint32_t)(&__data_end__ - &__data_base__));
 800432e:	4b80      	ldr	r3, [pc, #512]	; (8004530 <test_execute+0x2f0>)
 8004330:	4880      	ldr	r0, [pc, #512]	; (8004534 <test_execute+0x2f4>)
    test_println(" bytes");
 8004332:	4e81      	ldr	r6, [pc, #516]	; (8004538 <test_execute+0x2f8>)
    test_printn((uint32_t)(&__data_end__ - &__data_base__));
 8004334:	1ac0      	subs	r0, r0, r3
 8004336:	f7fc fdc3 	bl	8000ec0 <test_printn>
    test_println(" bytes");
 800433a:	4879      	ldr	r0, [pc, #484]	; (8004520 <test_execute+0x2e0>)
 800433c:	f7fc fe70 	bl	8001020 <test_println>
 8004340:	4629      	mov	r1, r5
    streamPut(test_chp, *msgp++);
 8004342:	6820      	ldr	r0, [r4, #0]
 8004344:	6803      	ldr	r3, [r0, #0]
 8004346:	68db      	ldr	r3, [r3, #12]
 8004348:	4798      	blx	r3
  while (*msgp)
 800434a:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800434e:	2900      	cmp	r1, #0
 8004350:	d1f7      	bne.n	8004342 <test_execute+0x102>
 8004352:	460d      	mov	r5, r1
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");

  test_global_fail = false;
  tseq = 0;
 8004354:	46ab      	mov	fp, r5
    test_printn((uint32_t)(&__bss_end__ - &__bss_base__));
 8004356:	4b79      	ldr	r3, [pc, #484]	; (800453c <test_execute+0x2fc>)
 8004358:	4879      	ldr	r0, [pc, #484]	; (8004540 <test_execute+0x300>)
  test_tokp = test_tokens_buffer;
 800435a:	4e7a      	ldr	r6, [pc, #488]	; (8004544 <test_execute+0x304>)
    test_printn((uint32_t)(&__bss_end__ - &__bss_base__));
 800435c:	1ac0      	subs	r0, r0, r3
 800435e:	f7fc fdaf 	bl	8000ec0 <test_printn>
    test_println(" bytes");
 8004362:	486f      	ldr	r0, [pc, #444]	; (8004520 <test_execute+0x2e0>)
 8004364:	f7fc fe5c 	bl	8001020 <test_println>
  test_println("");
 8004368:	4860      	ldr	r0, [pc, #384]	; (80044ec <test_execute+0x2ac>)
 800436a:	f7fc fe59 	bl	8001020 <test_println>
  test_global_fail = false;
 800436e:	4b76      	ldr	r3, [pc, #472]	; (8004548 <test_execute+0x308>)
 8004370:	701d      	strb	r5, [r3, #0]
 8004372:	f8d8 3004 	ldr.w	r3, [r8, #4]
  while (tsp->sequences[tseq] != NULL) {
 8004376:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
 800437a:	ea4f 078b 	mov.w	r7, fp, lsl #2
 800437e:	2b00      	cmp	r3, #0
 8004380:	f000 812f 	beq.w	80045e2 <test_execute+0x3a2>
 8004384:	254c      	movs	r5, #76	; 0x4c
    streamPut(test_chp, '=');
 8004386:	6820      	ldr	r0, [r4, #0]
 8004388:	213d      	movs	r1, #61	; 0x3d
 800438a:	6803      	ldr	r3, [r0, #0]
 800438c:	68db      	ldr	r3, [r3, #12]
 800438e:	4798      	blx	r3
  for (i = 0; i < 76; i++)
 8004390:	3d01      	subs	r5, #1
 8004392:	d1f8      	bne.n	8004386 <test_execute+0x146>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8004394:	6820      	ldr	r0, [r4, #0]
 8004396:	496d      	ldr	r1, [pc, #436]	; (800454c <test_execute+0x30c>)
 8004398:	6803      	ldr	r3, [r0, #0]
 800439a:	2202      	movs	r2, #2
 800439c:	685b      	ldr	r3, [r3, #4]
 800439e:	4798      	blx	r3
  while (*msgp)
 80043a0:	213d      	movs	r1, #61	; 0x3d
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 80043a2:	4d6b      	ldr	r5, [pc, #428]	; (8004550 <test_execute+0x310>)
    streamPut(test_chp, *msgp++);
 80043a4:	6820      	ldr	r0, [r4, #0]
 80043a6:	6803      	ldr	r3, [r0, #0]
 80043a8:	68db      	ldr	r3, [r3, #12]
 80043aa:	4798      	blx	r3
  while (*msgp)
 80043ac:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80043b0:	2900      	cmp	r1, #0
 80043b2:	d1f7      	bne.n	80043a4 <test_execute+0x164>
#if TEST_CFG_SHOW_SEQUENCES == TRUE
    print_fat_line();
    test_print("=== Test Sequence ");
    test_printn(tseq + 1);
 80043b4:	f10b 0b01 	add.w	fp, fp, #1
 80043b8:	4658      	mov	r0, fp
 80043ba:	f7fc fd81 	bl	8000ec0 <test_printn>
  while (*msgp)
 80043be:	2120      	movs	r1, #32
    test_printn(tseq + 1);
 80043c0:	4d64      	ldr	r5, [pc, #400]	; (8004554 <test_execute+0x314>)
    streamPut(test_chp, *msgp++);
 80043c2:	6820      	ldr	r0, [r4, #0]
 80043c4:	6803      	ldr	r3, [r0, #0]
 80043c6:	68db      	ldr	r3, [r3, #12]
 80043c8:	4798      	blx	r3
  while (*msgp)
 80043ca:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80043ce:	2900      	cmp	r1, #0
 80043d0:	d1f7      	bne.n	80043c2 <test_execute+0x182>
    test_print(" (");
    test_print(tsp->sequences[tseq]->name);
 80043d2:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80043d6:	59db      	ldr	r3, [r3, r7]
 80043d8:	681d      	ldr	r5, [r3, #0]
  while (*msgp)
 80043da:	7829      	ldrb	r1, [r5, #0]
 80043dc:	b139      	cbz	r1, 80043ee <test_execute+0x1ae>
    streamPut(test_chp, *msgp++);
 80043de:	6820      	ldr	r0, [r4, #0]
 80043e0:	6803      	ldr	r3, [r0, #0]
 80043e2:	68db      	ldr	r3, [r3, #12]
 80043e4:	4798      	blx	r3
  while (*msgp)
 80043e6:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80043ea:	2900      	cmp	r1, #0
 80043ec:	d1f7      	bne.n	80043de <test_execute+0x19e>
    test_println(")");
 80043ee:	485a      	ldr	r0, [pc, #360]	; (8004558 <test_execute+0x318>)
 80043f0:	f7fc fe16 	bl	8001020 <test_println>
#endif
    tcase = 0;
 80043f4:	2500      	movs	r5, #0
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
 80043f6:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80043fa:	ea4f 0985 	mov.w	r9, r5, lsl #2
 80043fe:	59da      	ldr	r2, [r3, r7]
 8004400:	6852      	ldr	r2, [r2, #4]
 8004402:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
 8004406:	2a00      	cmp	r2, #0
 8004408:	d0b5      	beq.n	8004376 <test_execute+0x136>
      print_line();
 800440a:	f7fc fe91 	bl	8001130 <print_line>
  while (*msgp)
 800440e:	212d      	movs	r1, #45	; 0x2d
      print_line();
 8004410:	f8df a150 	ldr.w	sl, [pc, #336]	; 8004564 <test_execute+0x324>
    streamPut(test_chp, *msgp++);
 8004414:	6820      	ldr	r0, [r4, #0]
 8004416:	6803      	ldr	r3, [r0, #0]
 8004418:	68db      	ldr	r3, [r3, #12]
 800441a:	4798      	blx	r3
  while (*msgp)
 800441c:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
 8004420:	2900      	cmp	r1, #0
 8004422:	d1f7      	bne.n	8004414 <test_execute+0x1d4>
      test_print("--- Test Case ");
      test_printn(tseq + 1);
 8004424:	4658      	mov	r0, fp
 8004426:	f7fc fd4b 	bl	8000ec0 <test_printn>
    streamPut(test_chp, *msgp++);
 800442a:	6820      	ldr	r0, [r4, #0]
 800442c:	212e      	movs	r1, #46	; 0x2e
 800442e:	6803      	ldr	r3, [r0, #0]
      test_print(".");
      test_printn(tcase + 1);
 8004430:	3501      	adds	r5, #1
    streamPut(test_chp, *msgp++);
 8004432:	68db      	ldr	r3, [r3, #12]
 8004434:	4798      	blx	r3
      test_printn(tcase + 1);
 8004436:	4628      	mov	r0, r5
 8004438:	f7fc fd42 	bl	8000ec0 <test_printn>
  while (*msgp)
 800443c:	2120      	movs	r1, #32
      test_printn(tcase + 1);
 800443e:	f8df a114 	ldr.w	sl, [pc, #276]	; 8004554 <test_execute+0x314>
    streamPut(test_chp, *msgp++);
 8004442:	6820      	ldr	r0, [r4, #0]
 8004444:	6803      	ldr	r3, [r0, #0]
 8004446:	68db      	ldr	r3, [r3, #12]
 8004448:	4798      	blx	r3
  while (*msgp)
 800444a:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
 800444e:	2900      	cmp	r1, #0
 8004450:	d1f7      	bne.n	8004442 <test_execute+0x202>
      test_print(" (");
      test_print(tsp->sequences[tseq]->cases[tcase]->name);
 8004452:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8004456:	59db      	ldr	r3, [r3, r7]
 8004458:	685b      	ldr	r3, [r3, #4]
 800445a:	f853 3009 	ldr.w	r3, [r3, r9]
 800445e:	f8d3 a000 	ldr.w	sl, [r3]
  while (*msgp)
 8004462:	f89a 1000 	ldrb.w	r1, [sl]
 8004466:	b139      	cbz	r1, 8004478 <test_execute+0x238>
    streamPut(test_chp, *msgp++);
 8004468:	6820      	ldr	r0, [r4, #0]
 800446a:	6803      	ldr	r3, [r0, #0]
 800446c:	68db      	ldr	r3, [r3, #12]
 800446e:	4798      	blx	r3
  while (*msgp)
 8004470:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
 8004474:	2900      	cmp	r1, #0
 8004476:	d1f7      	bne.n	8004468 <test_execute+0x228>
      test_println(")");
 8004478:	4837      	ldr	r0, [pc, #220]	; (8004558 <test_execute+0x318>)
 800447a:	f7fc fdd1 	bl	8001020 <test_println>
  chThdSleep(delay);
 800447e:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8004482:	f7ff fddd 	bl	8004040 <chThdSleep>
  test_local_fail = false;
 8004486:	2200      	movs	r2, #0
#if TEST_CFG_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_CFG_DELAY_BETWEEN_TESTS);
#endif
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 8004488:	f8d8 3004 	ldr.w	r3, [r8, #4]
  test_local_fail = false;
 800448c:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 8004568 <test_execute+0x328>
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 8004490:	59db      	ldr	r3, [r3, r7]
  test_tokp = test_tokens_buffer;
 8004492:	4932      	ldr	r1, [pc, #200]	; (800455c <test_execute+0x31c>)
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 8004494:	685b      	ldr	r3, [r3, #4]
  test_tokp = test_tokens_buffer;
 8004496:	6031      	str	r1, [r6, #0]
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 8004498:	f853 9009 	ldr.w	r9, [r3, r9]
  test_local_fail = false;
 800449c:	f88a 2000 	strb.w	r2, [sl]
  if (tcp->setup != NULL)
 80044a0:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80044a4:	b103      	cbz	r3, 80044a8 <test_execute+0x268>
    tcp->setup();
 80044a6:	4798      	blx	r3
  tcp->execute();
 80044a8:	f8d9 300c 	ldr.w	r3, [r9, #12]
 80044ac:	4798      	blx	r3
  if (tcp->teardown != NULL)
 80044ae:	f8d9 3008 	ldr.w	r3, [r9, #8]
 80044b2:	b103      	cbz	r3, 80044b6 <test_execute+0x276>
    tcp->teardown();
 80044b4:	4798      	blx	r3
      if (test_local_fail) {
 80044b6:	f89a 3000 	ldrb.w	r3, [sl]
 80044ba:	2b00      	cmp	r3, #0
 80044bc:	f000 808d 	beq.w	80045da <test_execute+0x39a>
  while (*msgp)
 80044c0:	212d      	movs	r1, #45	; 0x2d
      if (test_local_fail) {
 80044c2:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 800456c <test_execute+0x32c>
    streamPut(test_chp, *msgp++);
 80044c6:	6820      	ldr	r0, [r4, #0]
 80044c8:	6803      	ldr	r3, [r0, #0]
 80044ca:	68db      	ldr	r3, [r3, #12]
 80044cc:	4798      	blx	r3
  while (*msgp)
 80044ce:	f819 1f01 	ldrb.w	r1, [r9, #1]!
 80044d2:	2900      	cmp	r1, #0
 80044d4:	d1f7      	bne.n	80044c6 <test_execute+0x286>
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
 80044d6:	4b22      	ldr	r3, [pc, #136]	; (8004560 <test_execute+0x320>)
 80044d8:	f8df 9094 	ldr.w	r9, [pc, #148]	; 8004570 <test_execute+0x330>
 80044dc:	6818      	ldr	r0, [r3, #0]
 80044de:	f7fc fcef 	bl	8000ec0 <test_printn>
  while (*msgp)
 80044e2:	2120      	movs	r1, #32
 80044e4:	e046      	b.n	8004574 <test_execute+0x334>
 80044e6:	bf00      	nop
 80044e8:	20001ce8 	.word	0x20001ce8
 80044ec:	0800c7f4 	.word	0x0800c7f4
 80044f0:	0800d2f4 	.word	0x0800d2f4
 80044f4:	0800d3f0 	.word	0x0800d3f0
 80044f8:	0800d2fc 	.word	0x0800d2fc
 80044fc:	0800d3f4 	.word	0x0800d3f4
 8004500:	0800d310 	.word	0x0800d310
 8004504:	0800aab0 	.word	0x0800aab0
 8004508:	0800d324 	.word	0x0800d324
 800450c:	0800aaf0 	.word	0x0800aaf0
 8004510:	0800d338 	.word	0x0800d338
 8004514:	08000160 	.word	0x08000160
 8004518:	0800a9b4 	.word	0x0800a9b4
 800451c:	0800d34c 	.word	0x0800d34c
 8004520:	0800c578 	.word	0x0800c578
 8004524:	0800a9b4 	.word	0x0800a9b4
 8004528:	0800d574 	.word	0x0800d574
 800452c:	0800d360 	.word	0x0800d360
 8004530:	20000800 	.word	0x20000800
 8004534:	20000ce8 	.word	0x20000ce8
 8004538:	0800d374 	.word	0x0800d374
 800453c:	20000ce8 	.word	0x20000ce8
 8004540:	20002490 	.word	0x20002490
 8004544:	20001da8 	.word	0x20001da8
 8004548:	20001cf0 	.word	0x20001cf0
 800454c:	0800ac8c 	.word	0x0800ac8c
 8004550:	0800d388 	.word	0x0800d388
 8004554:	0800d39c 	.word	0x0800d39c
 8004558:	0800d40c 	.word	0x0800d40c
 800455c:	20001d98 	.word	0x20001d98
 8004560:	20001d94 	.word	0x20001d94
 8004564:	0800d3a0 	.word	0x0800d3a0
 8004568:	20001d90 	.word	0x20001d90
 800456c:	0800d3b0 	.word	0x0800d3b0
 8004570:	0800d3c8 	.word	0x0800d3c8
    streamPut(test_chp, *msgp++);
 8004574:	6820      	ldr	r0, [r4, #0]
 8004576:	6803      	ldr	r3, [r0, #0]
 8004578:	68db      	ldr	r3, [r3, #12]
 800457a:	4798      	blx	r3
  while (*msgp)
 800457c:	f819 1f01 	ldrb.w	r1, [r9, #1]!
 8004580:	2900      	cmp	r1, #0
 8004582:	d1f7      	bne.n	8004574 <test_execute+0x334>
  while (cp < test_tokp)
 8004584:	6833      	ldr	r3, [r6, #0]
 8004586:	4a29      	ldr	r2, [pc, #164]	; (800462c <test_execute+0x3ec>)
 8004588:	4293      	cmp	r3, r2
 800458a:	d909      	bls.n	80045a0 <test_execute+0x360>
  char *cp = test_tokens_buffer;
 800458c:	4691      	mov	r9, r2
    streamPut(test_chp, *cp++);
 800458e:	6820      	ldr	r0, [r4, #0]
 8004590:	f819 1b01 	ldrb.w	r1, [r9], #1
 8004594:	6803      	ldr	r3, [r0, #0]
 8004596:	68db      	ldr	r3, [r3, #12]
 8004598:	4798      	blx	r3
  while (cp < test_tokp)
 800459a:	6833      	ldr	r3, [r6, #0]
 800459c:	4599      	cmp	r9, r3
 800459e:	d3f6      	bcc.n	800458e <test_execute+0x34e>
  while (*msgp)
 80045a0:	215d      	movs	r1, #93	; 0x5d
 80045a2:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 8004654 <test_execute+0x414>
    streamPut(test_chp, *msgp++);
 80045a6:	6820      	ldr	r0, [r4, #0]
 80045a8:	6803      	ldr	r3, [r0, #0]
 80045aa:	68db      	ldr	r3, [r3, #12]
 80045ac:	4798      	blx	r3
  while (*msgp)
 80045ae:	f819 1f01 	ldrb.w	r1, [r9, #1]!
 80045b2:	2900      	cmp	r1, #0
 80045b4:	d1f7      	bne.n	80045a6 <test_execute+0x366>
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
 80045b6:	4b1e      	ldr	r3, [pc, #120]	; (8004630 <test_execute+0x3f0>)
 80045b8:	f8d3 9000 	ldr.w	r9, [r3]
  while (*msgp)
 80045bc:	f899 1000 	ldrb.w	r1, [r9]
 80045c0:	b139      	cbz	r1, 80045d2 <test_execute+0x392>
    streamPut(test_chp, *msgp++);
 80045c2:	6820      	ldr	r0, [r4, #0]
 80045c4:	6803      	ldr	r3, [r0, #0]
 80045c6:	68db      	ldr	r3, [r3, #12]
 80045c8:	4798      	blx	r3
  while (*msgp)
 80045ca:	f819 1f01 	ldrb.w	r1, [r9, #1]!
 80045ce:	2900      	cmp	r1, #0
 80045d0:	d1f7      	bne.n	80045c2 <test_execute+0x382>
        test_println("\")");
 80045d2:	4818      	ldr	r0, [pc, #96]	; (8004634 <test_execute+0x3f4>)
 80045d4:	f7fc fd24 	bl	8001020 <test_println>
 80045d8:	e70d      	b.n	80043f6 <test_execute+0x1b6>
      }
      else {
        test_println("--- Result: SUCCESS");
 80045da:	4817      	ldr	r0, [pc, #92]	; (8004638 <test_execute+0x3f8>)
 80045dc:	f7fc fd20 	bl	8001020 <test_println>
 80045e0:	e709      	b.n	80043f6 <test_execute+0x1b6>
      }
      tcase++;
    }
    tseq++;
  }
  print_line();
 80045e2:	f7fc fda5 	bl	8001130 <print_line>
  test_println("");
 80045e6:	4815      	ldr	r0, [pc, #84]	; (800463c <test_execute+0x3fc>)
 80045e8:	f7fc fd1a 	bl	8001020 <test_println>
  while (*msgp)
 80045ec:	2146      	movs	r1, #70	; 0x46
  test_println("");
 80045ee:	4d14      	ldr	r5, [pc, #80]	; (8004640 <test_execute+0x400>)
    streamPut(test_chp, *msgp++);
 80045f0:	6820      	ldr	r0, [r4, #0]
 80045f2:	6803      	ldr	r3, [r0, #0]
 80045f4:	68db      	ldr	r3, [r3, #12]
 80045f6:	4798      	blx	r3
  while (*msgp)
 80045f8:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80045fc:	2900      	cmp	r1, #0
 80045fe:	d1f7      	bne.n	80045f0 <test_execute+0x3b0>
  test_print("Final result: ");
  if (test_global_fail)
 8004600:	4b10      	ldr	r3, [pc, #64]	; (8004644 <test_execute+0x404>)
 8004602:	781b      	ldrb	r3, [r3, #0]
 8004604:	b933      	cbnz	r3, 8004614 <test_execute+0x3d4>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8004606:	4810      	ldr	r0, [pc, #64]	; (8004648 <test_execute+0x408>)
 8004608:	f7fc fd0a 	bl	8001020 <test_println>
#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END
#endif

  return (msg_t)test_global_fail;
}
 800460c:	4b0d      	ldr	r3, [pc, #52]	; (8004644 <test_execute+0x404>)
 800460e:	7818      	ldrb	r0, [r3, #0]
 8004610:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    test_println("FAILURE");
 8004614:	480d      	ldr	r0, [pc, #52]	; (800464c <test_execute+0x40c>)
 8004616:	f7fc fd03 	bl	8001020 <test_println>
}
 800461a:	4b0a      	ldr	r3, [pc, #40]	; (8004644 <test_execute+0x404>)
 800461c:	7818      	ldrb	r0, [r3, #0]
 800461e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    test_println("*** Test Suite");
 8004622:	480b      	ldr	r0, [pc, #44]	; (8004650 <test_execute+0x410>)
 8004624:	f7fc fcfc 	bl	8001020 <test_println>
 8004628:	e625      	b.n	8004276 <test_execute+0x36>
 800462a:	bf00      	nop
 800462c:	20001d98 	.word	0x20001d98
 8004630:	20001cec 	.word	0x20001cec
 8004634:	0800d410 	.word	0x0800d410
 8004638:	0800d414 	.word	0x0800d414
 800463c:	0800c7f4 	.word	0x0800c7f4
 8004640:	0800d3d0 	.word	0x0800d3d0
 8004644:	20001cf0 	.word	0x20001cf0
 8004648:	0800d420 	.word	0x0800d420
 800464c:	0800d428 	.word	0x0800d428
 8004650:	0800d3e0 	.word	0x0800d3e0
 8004654:	0800d3cc 	.word	0x0800d3cc
	...

08004660 <test_rt>:
#endif

#if (SHELL_CMD_TEST_ENABLED == TRUE) || defined(__DOXYGEN__)
static THD_FUNCTION(test_rt, arg) {
  BaseSequentialStream *chp = (BaseSequentialStream *)arg;
  test_execute(chp, &rt_test_suite);
 8004660:	4901      	ldr	r1, [pc, #4]	; (8004668 <test_rt+0x8>)
 8004662:	f7ff bded 	b.w	8004240 <test_execute>
 8004666:	bf00      	nop
 8004668:	0800c740 	.word	0x0800c740
 800466c:	00000000 	.word	0x00000000

08004670 <test_oslib>:
}

static THD_FUNCTION(test_oslib, arg) {
  BaseSequentialStream *chp = (BaseSequentialStream *)arg;
  test_execute(chp, &oslib_test_suite);
 8004670:	4901      	ldr	r1, [pc, #4]	; (8004678 <test_oslib+0x8>)
 8004672:	f7ff bde5 	b.w	8004240 <test_execute>
 8004676:	bf00      	nop
 8004678:	0800b650 	.word	0x0800b650
 800467c:	00000000 	.word	0x00000000

08004680 <chMsgWaitS>:
 *
 * @return              A pointer to the thread carrying the message.
 *
 * @sclass
 */
thread_t *chMsgWaitS(void) {
 8004680:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp;

  chDbgCheckClassS();

  if (!chMsgIsPendingI(currp)) {
 8004682:	4c0b      	ldr	r4, [pc, #44]	; (80046b0 <chMsgWaitS+0x30>)
 8004684:	69a1      	ldr	r1, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 8004686:	460a      	mov	r2, r1
 8004688:	f852 3f2c 	ldr.w	r3, [r2, #44]!
 800468c:	4293      	cmp	r3, r2
 800468e:	d007      	beq.n	80046a0 <chMsgWaitS+0x20>
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->msgqueue);
  tp->state = CH_STATE_SNDMSG;
 8004690:	250d      	movs	r5, #13
  tqp->next             = tp->queue.next;
 8004692:	681c      	ldr	r4, [r3, #0]

  return tp;
}
 8004694:	4618      	mov	r0, r3
 8004696:	62cc      	str	r4, [r1, #44]	; 0x2c
  tqp->next->queue.prev = (thread_t *)tqp;
 8004698:	6062      	str	r2, [r4, #4]
  tp->state = CH_STATE_SNDMSG;
 800469a:	f883 5020 	strb.w	r5, [r3, #32]
}
 800469e:	bd38      	pop	{r3, r4, r5, pc}
    chSchGoSleepS(CH_STATE_WTMSG);
 80046a0:	200e      	movs	r0, #14
 80046a2:	f7ff f90d 	bl	80038c0 <chSchGoSleepS>
 80046a6:	69a1      	ldr	r1, [r4, #24]
 80046a8:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80046aa:	f101 022c 	add.w	r2, r1, #44	; 0x2c
 80046ae:	e7ef      	b.n	8004690 <chMsgWaitS+0x10>
 80046b0:	20001254 	.word	0x20001254
	...

080046c0 <bmk_thread1>:
static THD_FUNCTION(bmk_thread1, p) {
 80046c0:	b570      	push	{r4, r5, r6, lr}
 80046c2:	2620      	movs	r6, #32
 80046c4:	2500      	movs	r5, #0
 80046c6:	f386 8811 	msr	BASEPRI, r6
  tp = chMsgWaitS();
 80046ca:	f7ff ffd9 	bl	8004680 <chMsgWaitS>
 80046ce:	f385 8811 	msr	BASEPRI, r5
    msg = chMsgGet(tp);
 80046d2:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80046d4:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 80046d8:	4621      	mov	r1, r4
 80046da:	f7ff f801 	bl	80036e0 <chSchWakeupS>
 80046de:	f385 8811 	msr	BASEPRI, r5
  } while (msg);
 80046e2:	2c00      	cmp	r4, #0
 80046e4:	d1ef      	bne.n	80046c6 <bmk_thread1+0x6>
}
 80046e6:	bd70      	pop	{r4, r5, r6, pc}
	...

080046f0 <chMsgSend>:
  thread_t *ctp = currp;
 80046f0:	4b0e      	ldr	r3, [pc, #56]	; (800472c <chMsgSend+0x3c>)
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 80046f2:	b510      	push	{r4, lr}
 80046f4:	2220      	movs	r2, #32
  thread_t *ctp = currp;
 80046f6:	699c      	ldr	r4, [r3, #24]
 80046f8:	f382 8811 	msr	BASEPRI, r2
  ctp->u.sentmsg = msg;
 80046fc:	6261      	str	r1, [r4, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
 80046fe:	6b02      	ldr	r2, [r0, #48]	; 0x30
  msg_insert(ctp, &tp->msgqueue);
 8004700:	f100 012c 	add.w	r1, r0, #44	; 0x2c
 8004704:	e9c4 1200 	strd	r1, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8004708:	6014      	str	r4, [r2, #0]
  if (tp->state == CH_STATE_WTMSG) {
 800470a:	f890 2020 	ldrb.w	r2, [r0, #32]
  tqp->prev                  = tp;
 800470e:	6304      	str	r4, [r0, #48]	; 0x30
 8004710:	2a0e      	cmp	r2, #14
 8004712:	d007      	beq.n	8004724 <chMsgSend+0x34>
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8004714:	200c      	movs	r0, #12
 8004716:	f7ff f8d3 	bl	80038c0 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 800471a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800471c:	2300      	movs	r3, #0
 800471e:	f383 8811 	msr	BASEPRI, r3
}
 8004722:	bd10      	pop	{r4, pc}
    (void) chSchReadyI(tp);
 8004724:	f7fc ff64 	bl	80015f0 <chSchReadyI>
 8004728:	e7f4      	b.n	8004714 <chMsgSend+0x24>
 800472a:	bf00      	nop
 800472c:	20001254 	.word	0x20001254

08004730 <msg_loop_test>:
NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 8004730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004732:	4605      	mov	r5, r0
  start = test_wait_tick();
 8004734:	f7ff fd24 	bl	8004180 <test_wait_tick>
  uint32_t n = 0;
 8004738:	2400      	movs	r4, #0
  start = test_wait_tick();
 800473a:	4607      	mov	r7, r0
 800473c:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
    (void)chMsgSend(tp, 1);
 8004740:	2101      	movs	r1, #1
 8004742:	4628      	mov	r0, r5
 8004744:	f7ff ffd4 	bl	80046f0 <chMsgSend>
 8004748:	6a73      	ldr	r3, [r6, #36]	; 0x24
    n++;
 800474a:	3401      	adds	r4, #1
 800474c:	1bdb      	subs	r3, r3, r7
  } while (chVTIsSystemTimeWithinX(start, end));
 800474e:	b29b      	uxth	r3, r3
 8004750:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8004754:	d3f4      	bcc.n	8004740 <msg_loop_test+0x10>
  (void)chMsgSend(tp, 0);
 8004756:	4628      	mov	r0, r5
 8004758:	2100      	movs	r1, #0
 800475a:	f7ff ffc9 	bl	80046f0 <chMsgSend>
}
 800475e:	4620      	mov	r0, r4
 8004760:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004762:	bf00      	nop
	...

08004770 <msg_thread1>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8004770:	b510      	push	{r4, lr}
 8004772:	4604      	mov	r4, r0

  chMsgSend(p, 'A');
 8004774:	2141      	movs	r1, #65	; 0x41
 8004776:	f7ff ffbb 	bl	80046f0 <chMsgSend>
  chMsgSend(p, 'B');
 800477a:	4620      	mov	r0, r4
 800477c:	2142      	movs	r1, #66	; 0x42
 800477e:	f7ff ffb7 	bl	80046f0 <chMsgSend>
  chMsgSend(p, 'C');
 8004782:	4620      	mov	r0, r4
 8004784:	2143      	movs	r1, #67	; 0x43
 8004786:	f7ff ffb3 	bl	80046f0 <chMsgSend>
  chMsgSend(p, 'D');
 800478a:	4620      	mov	r0, r4
}
 800478c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMsgSend(p, 'D');
 8004790:	2144      	movs	r1, #68	; 0x44
 8004792:	f7ff bfad 	b.w	80046f0 <chMsgSend>
 8004796:	bf00      	nop
	...

080047a0 <chDelegateCallVeneer>:
 * @param[in] veneer    pointer to the veneer function to be called
 * @param[in] ...       variable number of parameters
 * @return              The function return value casted to msg_t. It is
 *                      garbage for functions returning @p void.
 */
msg_t chDelegateCallVeneer(thread_t *tp, delegate_veneer_t veneer, ...) {
 80047a0:	b40e      	push	{r1, r2, r3}
 80047a2:	b510      	push	{r4, lr}
 80047a4:	b085      	sub	sp, #20
 80047a6:	ab07      	add	r3, sp, #28
 80047a8:	f853 4b04 	ldr.w	r4, [r3], #4

  va_start(args, veneer);

  /* Preparing the call message.*/
  cm.veneer = veneer;
  cm.argsp  = &args;
 80047ac:	aa01      	add	r2, sp, #4
  (void)cm; /* Suppresses a lint warning.*/

  /* Sending the message to the dispatcher thread, the return value is
     contained in the returned message.*/
  msg = chMsgSend(tp, (msg_t)&cm);
 80047ae:	a902      	add	r1, sp, #8
  cm.veneer = veneer;
 80047b0:	e9cd 3401 	strd	r3, r4, [sp, #4]
  cm.argsp  = &args;
 80047b4:	9203      	str	r2, [sp, #12]
  msg = chMsgSend(tp, (msg_t)&cm);
 80047b6:	f7ff ff9b 	bl	80046f0 <chMsgSend>

  va_end(args);

  return msg;
}
 80047ba:	b005      	add	sp, #20
 80047bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80047c0:	b003      	add	sp, #12
 80047c2:	4770      	bx	lr
	...

080047d0 <chMtxLockS>:
void chMtxLockS(mutex_t *mp) {
 80047d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 80047d2:	4a38      	ldr	r2, [pc, #224]	; (80048b4 <chMtxLockS+0xe4>)
  if (mp->owner != NULL) {
 80047d4:	6883      	ldr	r3, [r0, #8]
  thread_t *ctp = currp;
 80047d6:	6995      	ldr	r5, [r2, #24]
  if (mp->owner != NULL) {
 80047d8:	2b00      	cmp	r3, #0
 80047da:	d040      	beq.n	800485e <chMtxLockS+0x8e>
      while (tp->prio < ctp->prio) {
 80047dc:	68a9      	ldr	r1, [r5, #8]
 80047de:	689a      	ldr	r2, [r3, #8]
 80047e0:	4604      	mov	r4, r0
 80047e2:	4291      	cmp	r1, r2
 80047e4:	d907      	bls.n	80047f6 <chMtxLockS+0x26>
        switch (tp->state) {
 80047e6:	f893 2020 	ldrb.w	r2, [r3, #32]
        tp->prio = ctp->prio;
 80047ea:	6099      	str	r1, [r3, #8]
        switch (tp->state) {
 80047ec:	2a06      	cmp	r2, #6
 80047ee:	d03b      	beq.n	8004868 <chMtxLockS+0x98>
 80047f0:	2a07      	cmp	r2, #7
 80047f2:	d015      	beq.n	8004820 <chMtxLockS+0x50>
 80047f4:	b342      	cbz	r2, 8004848 <chMtxLockS+0x78>
      queue_prio_insert(ctp, &mp->queue);
 80047f6:	4626      	mov	r6, r4
 80047f8:	4623      	mov	r3, r4
 80047fa:	e003      	b.n	8004804 <chMtxLockS+0x34>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80047fc:	6899      	ldr	r1, [r3, #8]
 80047fe:	68aa      	ldr	r2, [r5, #8]
 8004800:	4291      	cmp	r1, r2
 8004802:	d32a      	bcc.n	800485a <chMtxLockS+0x8a>
    cp = cp->queue.next;
 8004804:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004806:	429c      	cmp	r4, r3
 8004808:	d1f8      	bne.n	80047fc <chMtxLockS+0x2c>
  tp->queue.prev             = cp->queue.prev;
 800480a:	6873      	ldr	r3, [r6, #4]
      chSchGoSleepS(CH_STATE_WTMTX);
 800480c:	2006      	movs	r0, #6
 800480e:	e9c5 6300 	strd	r6, r3, [r5]
  tp->queue.prev->queue.next = tp;
 8004812:	601d      	str	r5, [r3, #0]
  cp->queue.prev             = tp;
 8004814:	6075      	str	r5, [r6, #4]
      ctp->u.wtmtxp = mp;
 8004816:	626c      	str	r4, [r5, #36]	; 0x24
}
 8004818:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      chSchGoSleepS(CH_STATE_WTMTX);
 800481c:	f7ff b850 	b.w	80038c0 <chSchGoSleepS>
  tp->queue.prev->queue.next = tp->queue.next;
 8004820:	681f      	ldr	r7, [r3, #0]
 8004822:	6858      	ldr	r0, [r3, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8004824:	6a5e      	ldr	r6, [r3, #36]	; 0x24
 8004826:	6007      	str	r7, [r0, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8004828:	681f      	ldr	r7, [r3, #0]
 800482a:	4632      	mov	r2, r6
 800482c:	6078      	str	r0, [r7, #4]
 800482e:	e002      	b.n	8004836 <chMtxLockS+0x66>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004830:	6890      	ldr	r0, [r2, #8]
 8004832:	4288      	cmp	r0, r1
 8004834:	d334      	bcc.n	80048a0 <chMtxLockS+0xd0>
    cp = cp->queue.next;
 8004836:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004838:	4296      	cmp	r6, r2
 800483a:	d1f9      	bne.n	8004830 <chMtxLockS+0x60>
  tp->queue.prev             = cp->queue.prev;
 800483c:	6872      	ldr	r2, [r6, #4]
 800483e:	e9c3 6200 	strd	r6, r2, [r3]
  tp->queue.prev->queue.next = tp;
 8004842:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
 8004844:	6073      	str	r3, [r6, #4]
 8004846:	e7d6      	b.n	80047f6 <chMtxLockS+0x26>
  tp->queue.prev->queue.next = tp->queue.next;
 8004848:	e9d3 1200 	ldrd	r1, r2, [r3]
 800484c:	6011      	str	r1, [r2, #0]
          (void) chSchReadyI(queue_dequeue(tp));
 800484e:	4618      	mov	r0, r3
  tp->queue.next->queue.prev = tp->queue.prev;
 8004850:	681b      	ldr	r3, [r3, #0]
 8004852:	605a      	str	r2, [r3, #4]
 8004854:	f7fc fecc 	bl	80015f0 <chSchReadyI>
 8004858:	e7cd      	b.n	80047f6 <chMtxLockS+0x26>
    cp = cp->queue.next;
 800485a:	461e      	mov	r6, r3
 800485c:	e7d5      	b.n	800480a <chMtxLockS+0x3a>
    mp->next = ctp->mtxlist;
 800485e:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8004860:	e9c0 5302 	strd	r5, r3, [r0, #8]
    ctp->mtxlist = mp;
 8004864:	63a8      	str	r0, [r5, #56]	; 0x38
}
 8004866:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  tp->queue.prev->queue.next = tp->queue.next;
 8004868:	681f      	ldr	r7, [r3, #0]
 800486a:	6858      	ldr	r0, [r3, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800486c:	6a5e      	ldr	r6, [r3, #36]	; 0x24
 800486e:	6007      	str	r7, [r0, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8004870:	681f      	ldr	r7, [r3, #0]
 8004872:	46b4      	mov	ip, r6
 8004874:	4632      	mov	r2, r6
 8004876:	6078      	str	r0, [r7, #4]
 8004878:	e002      	b.n	8004880 <chMtxLockS+0xb0>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800487a:	6890      	ldr	r0, [r2, #8]
 800487c:	4288      	cmp	r0, r1
 800487e:	d316      	bcc.n	80048ae <chMtxLockS+0xde>
    cp = cp->queue.next;
 8004880:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004882:	4296      	cmp	r6, r2
 8004884:	d1f9      	bne.n	800487a <chMtxLockS+0xaa>
  tp->queue.prev             = cp->queue.prev;
 8004886:	f8dc 2004 	ldr.w	r2, [ip, #4]
      while (tp->prio < ctp->prio) {
 800488a:	68a9      	ldr	r1, [r5, #8]
 800488c:	e9c3 c200 	strd	ip, r2, [r3]
  tp->queue.prev->queue.next = tp;
 8004890:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
 8004892:	f8cc 3004 	str.w	r3, [ip, #4]
          tp = tp->u.wtmtxp->owner;
 8004896:	68b3      	ldr	r3, [r6, #8]
      while (tp->prio < ctp->prio) {
 8004898:	689a      	ldr	r2, [r3, #8]
 800489a:	428a      	cmp	r2, r1
 800489c:	d3a3      	bcc.n	80047e6 <chMtxLockS+0x16>
 800489e:	e7aa      	b.n	80047f6 <chMtxLockS+0x26>
    cp = cp->queue.next;
 80048a0:	4616      	mov	r6, r2
  tp->queue.prev             = cp->queue.prev;
 80048a2:	6872      	ldr	r2, [r6, #4]
 80048a4:	e9c3 6200 	strd	r6, r2, [r3]
  tp->queue.prev->queue.next = tp;
 80048a8:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
 80048aa:	6073      	str	r3, [r6, #4]
 80048ac:	e7a3      	b.n	80047f6 <chMtxLockS+0x26>
    cp = cp->queue.next;
 80048ae:	4694      	mov	ip, r2
 80048b0:	e7e9      	b.n	8004886 <chMtxLockS+0xb6>
 80048b2:	bf00      	nop
 80048b4:	20001254 	.word	0x20001254
	...

080048c0 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
 80048c0:	b508      	push	{r3, lr}
 80048c2:	2320      	movs	r3, #32
 80048c4:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(mp);
 80048c8:	f7ff ff82 	bl	80047d0 <chMtxLockS>
 80048cc:	2300      	movs	r3, #0
 80048ce:	f383 8811 	msr	BASEPRI, r3
}
 80048d2:	bd08      	pop	{r3, pc}
	...

080048e0 <chSemWaitS.part.0>:
msg_t chSemWaitS(semaphore_t *sp) {
 80048e0:	4602      	mov	r2, r0
 80048e2:	b510      	push	{r4, lr}
    currp->u.wtsemp = sp;
 80048e4:	4c06      	ldr	r4, [pc, #24]	; (8004900 <chSemWaitS.part.0+0x20>)
    chSchGoSleepS(CH_STATE_WTSEM);
 80048e6:	2005      	movs	r0, #5
    currp->u.wtsemp = sp;
 80048e8:	69a3      	ldr	r3, [r4, #24]
 80048ea:	625a      	str	r2, [r3, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
 80048ec:	6851      	ldr	r1, [r2, #4]
 80048ee:	e9c3 2100 	strd	r2, r1, [r3]
  tp->queue.prev->queue.next = tp;
 80048f2:	600b      	str	r3, [r1, #0]
  tqp->prev                  = tp;
 80048f4:	6053      	str	r3, [r2, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 80048f6:	f7fe ffe3 	bl	80038c0 <chSchGoSleepS>
    return currp->u.rdymsg;
 80048fa:	69a3      	ldr	r3, [r4, #24]
}
 80048fc:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80048fe:	bd10      	pop	{r4, pc}
 8004900:	20001254 	.word	0x20001254
	...

08004910 <chCacheGetObject.constprop.20>:
oc_object_t *chCacheGetObject(objects_cache_t *ocp,
 8004910:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004914:	4605      	mov	r5, r0
 8004916:	2320      	movs	r3, #32
 8004918:	f383 8811 	msr	BASEPRI, r3
  objp = hash_get_s(ocp, group, key);
 800491c:	4e3e      	ldr	r6, [pc, #248]	; (8004a18 <chCacheGetObject.constprop.20+0x108>)
  hhp  = &ocp->hashp[OC_HASH_FUNCTION(ocp, group, key)];
 800491e:	e9d6 3200 	ldrd	r3, r2, [r6]
 8004922:	3b01      	subs	r3, #1
 8004924:	4003      	ands	r3, r0
  objp = hhp->hash_next;
 8004926:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
  hhp  = &ocp->hashp[OC_HASH_FUNCTION(ocp, group, key)];
 800492a:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  while (objp != (oc_object_t *)hhp) {
 800492e:	42a2      	cmp	r2, r4
 8004930:	d103      	bne.n	800493a <chCacheGetObject.constprop.20+0x2a>
 8004932:	e01d      	b.n	8004970 <chCacheGetObject.constprop.20+0x60>
    objp = objp->hash_next;
 8004934:	6824      	ldr	r4, [r4, #0]
  while (objp != (oc_object_t *)hhp) {
 8004936:	42a2      	cmp	r2, r4
 8004938:	d01a      	beq.n	8004970 <chCacheGetObject.constprop.20+0x60>
    if ((objp->obj_key == key) && (objp->obj_group == group)) {
 800493a:	6963      	ldr	r3, [r4, #20]
 800493c:	429d      	cmp	r5, r3
 800493e:	d1f9      	bne.n	8004934 <chCacheGetObject.constprop.20+0x24>
 8004940:	6923      	ldr	r3, [r4, #16]
 8004942:	2b00      	cmp	r3, #0
 8004944:	d1f6      	bne.n	8004934 <chCacheGetObject.constprop.20+0x24>
    if (chSemGetCounterI(&objp->obj_sem) > (cnt_t)0) {
 8004946:	6a23      	ldr	r3, [r4, #32]
 8004948:	2b00      	cmp	r3, #0
 800494a:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
 800494e:	dd39      	ble.n	80049c4 <chCacheGetObject.constprop.20+0xb4>
      LRU_REMOVE(objp);
 8004950:	e9d4 0202 	ldrd	r0, r2, [r4, #8]
      objp->obj_flags &= ~OC_FLAG_INLRU;
 8004954:	6a63      	ldr	r3, [r4, #36]	; 0x24
      LRU_REMOVE(objp);
 8004956:	6090      	str	r0, [r2, #8]
 8004958:	68a0      	ldr	r0, [r4, #8]
      objp->obj_flags &= ~OC_FLAG_INLRU;
 800495a:	f023 0301 	bic.w	r3, r3, #1
      LRU_REMOVE(objp);
 800495e:	60c2      	str	r2, [r0, #12]
      objp->obj_flags &= ~OC_FLAG_INLRU;
 8004960:	e9c4 1308 	strd	r1, r3, [r4, #32]
 8004964:	2300      	movs	r3, #0
 8004966:	f383 8811 	msr	BASEPRI, r3
}
 800496a:	4620      	mov	r0, r4
 800496c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004970:	4f2a      	ldr	r7, [pc, #168]	; (8004a1c <chCacheGetObject.constprop.20+0x10c>)
 8004972:	f04f 0900 	mov.w	r9, #0
    (void) ocp->writef(ocp, objp, true);
 8004976:	f1a7 0830 	sub.w	r8, r7, #48	; 0x30
 800497a:	e01a      	b.n	80049b2 <chCacheGetObject.constprop.20+0xa2>
    objp = ocp->lru.lru_prev;
 800497c:	6a34      	ldr	r4, [r6, #32]
    objp->obj_flags &= ~OC_FLAG_INLRU;
 800497e:	6a61      	ldr	r1, [r4, #36]	; 0x24
    LRU_REMOVE(objp);
 8004980:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
 8004984:	6083      	str	r3, [r0, #8]
 8004986:	68a2      	ldr	r2, [r4, #8]
  sp->cnt--;
 8004988:	6a23      	ldr	r3, [r4, #32]
 800498a:	60d0      	str	r0, [r2, #12]
 800498c:	3b01      	subs	r3, #1
    objp->obj_flags &= ~OC_FLAG_INLRU;
 800498e:	f021 0201 	bic.w	r2, r1, #1
 8004992:	e9c4 3208 	strd	r3, r2, [r4, #32]
    if ((objp->obj_flags & OC_FLAG_LAZYWRITE) == 0U) {
 8004996:	06ca      	lsls	r2, r1, #27
 8004998:	d51f      	bpl.n	80049da <chCacheGetObject.constprop.20+0xca>
 800499a:	f389 8811 	msr	BASEPRI, r9
    objp->obj_flags = OC_FLAG_INHASH | OC_FLAG_FORGET;
 800499e:	2322      	movs	r3, #34	; 0x22
    (void) ocp->writef(ocp, objp, true);
 80049a0:	4621      	mov	r1, r4
    objp->obj_flags = OC_FLAG_INHASH | OC_FLAG_FORGET;
 80049a2:	6263      	str	r3, [r4, #36]	; 0x24
    (void) ocp->writef(ocp, objp, true);
 80049a4:	4640      	mov	r0, r8
 80049a6:	6c33      	ldr	r3, [r6, #64]	; 0x40
 80049a8:	2201      	movs	r2, #1
 80049aa:	4798      	blx	r3
 80049ac:	2320      	movs	r3, #32
 80049ae:	f383 8811 	msr	BASEPRI, r3
  if (--sp->cnt < (cnt_t)0) {
 80049b2:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 80049b4:	3b01      	subs	r3, #1
 80049b6:	2b00      	cmp	r3, #0
 80049b8:	63b3      	str	r3, [r6, #56]	; 0x38
 80049ba:	dadf      	bge.n	800497c <chCacheGetObject.constprop.20+0x6c>
 80049bc:	4638      	mov	r0, r7
 80049be:	f7ff ff8f 	bl	80048e0 <chSemWaitS.part.0>
 80049c2:	e7db      	b.n	800497c <chCacheGetObject.constprop.20+0x6c>
 80049c4:	6221      	str	r1, [r4, #32]
 80049c6:	f104 0018 	add.w	r0, r4, #24
 80049ca:	f7ff ff89 	bl	80048e0 <chSemWaitS.part.0>
 80049ce:	2300      	movs	r3, #0
 80049d0:	f383 8811 	msr	BASEPRI, r3
}
 80049d4:	4620      	mov	r0, r4
 80049d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if ((objp->obj_flags & OC_FLAG_INHASH) != 0U) {
 80049da:	078b      	lsls	r3, r1, #30
 80049dc:	d504      	bpl.n	80049e8 <chCacheGetObject.constprop.20+0xd8>
        HASH_REMOVE(objp);
 80049de:	e9d4 2300 	ldrd	r2, r3, [r4]
 80049e2:	601a      	str	r2, [r3, #0]
 80049e4:	6822      	ldr	r2, [r4, #0]
 80049e6:	6053      	str	r3, [r2, #4]
    objp->obj_group = group;
 80049e8:	2700      	movs	r7, #0
    HASH_INSERT(ocp, objp, group, key);
 80049ea:	e9d6 3200 	ldrd	r3, r2, [r6]
    objp->obj_flags = OC_FLAG_INHASH | OC_FLAG_NOTSYNC;
 80049ee:	200a      	movs	r0, #10
    HASH_INSERT(ocp, objp, group, key);
 80049f0:	3b01      	subs	r3, #1
 80049f2:	402b      	ands	r3, r5
 80049f4:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    objp->obj_key   = key;
 80049f8:	6165      	str	r5, [r4, #20]
    HASH_INSERT(ocp, objp, group, key);
 80049fa:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 80049fe:	e9c4 1500 	strd	r1, r5, [r4]
    objp->obj_group = group;
 8004a02:	6127      	str	r7, [r4, #16]
    objp->obj_flags = OC_FLAG_INHASH | OC_FLAG_NOTSYNC;
 8004a04:	6260      	str	r0, [r4, #36]	; 0x24
    HASH_INSERT(ocp, objp, group, key);
 8004a06:	604c      	str	r4, [r1, #4]
 8004a08:	f842 4033 	str.w	r4, [r2, r3, lsl #3]
 8004a0c:	2300      	movs	r3, #0
 8004a0e:	f383 8811 	msr	BASEPRI, r3
}
 8004a12:	4620      	mov	r0, r4
 8004a14:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004a18:	20001210 	.word	0x20001210
 8004a1c:	20001240 	.word	0x20001240

08004a20 <chSemWait>:
msg_t chSemWait(semaphore_t *sp) {
 8004a20:	b508      	push	{r3, lr}
 8004a22:	2320      	movs	r3, #32
 8004a24:	f383 8811 	msr	BASEPRI, r3
  if (--sp->cnt < (cnt_t)0) {
 8004a28:	6883      	ldr	r3, [r0, #8]
 8004a2a:	3b01      	subs	r3, #1
 8004a2c:	2b00      	cmp	r3, #0
 8004a2e:	6083      	str	r3, [r0, #8]
 8004a30:	db04      	blt.n	8004a3c <chSemWait+0x1c>
  return MSG_OK;
 8004a32:	2000      	movs	r0, #0
 8004a34:	2300      	movs	r3, #0
 8004a36:	f383 8811 	msr	BASEPRI, r3
}
 8004a3a:	bd08      	pop	{r3, pc}
 8004a3c:	f7ff ff50 	bl	80048e0 <chSemWaitS.part.0>
 8004a40:	2300      	movs	r3, #0
 8004a42:	f383 8811 	msr	BASEPRI, r3
 8004a46:	bd08      	pop	{r3, pc}
	...

08004a50 <rt_test_011_010_execute>:
  test_set_step(1);
 8004a50:	2301      	movs	r3, #1
static void rt_test_011_010_execute(void) {
 8004a52:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8004a56:	f8df 807c 	ldr.w	r8, [pc, #124]	; 8004ad4 <rt_test_011_010_execute+0x84>
    n = 0;
 8004a5a:	2500      	movs	r5, #0
  test_set_step(1);
 8004a5c:	f8c8 3000 	str.w	r3, [r8]
    start = test_wait_tick();
 8004a60:	f7ff fb8e 	bl	8004180 <test_wait_tick>
 8004a64:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 8004a68:	4606      	mov	r6, r0
      chSemWait(&sem1);
 8004a6a:	4c17      	ldr	r4, [pc, #92]	; (8004ac8 <rt_test_011_010_execute+0x78>)
 8004a6c:	4620      	mov	r0, r4
 8004a6e:	f7ff ffd7 	bl	8004a20 <chSemWait>
      chSemSignal(&sem1);
 8004a72:	4620      	mov	r0, r4
 8004a74:	f7fe fef4 	bl	8003860 <chSemSignal>
      chSemWait(&sem1);
 8004a78:	4620      	mov	r0, r4
 8004a7a:	f7ff ffd1 	bl	8004a20 <chSemWait>
      chSemSignal(&sem1);
 8004a7e:	4620      	mov	r0, r4
 8004a80:	f7fe feee 	bl	8003860 <chSemSignal>
      chSemWait(&sem1);
 8004a84:	4620      	mov	r0, r4
 8004a86:	f7ff ffcb 	bl	8004a20 <chSemWait>
      chSemSignal(&sem1);
 8004a8a:	4620      	mov	r0, r4
 8004a8c:	f7fe fee8 	bl	8003860 <chSemSignal>
      chSemWait(&sem1);
 8004a90:	4620      	mov	r0, r4
 8004a92:	f7ff ffc5 	bl	8004a20 <chSemWait>
      chSemSignal(&sem1);
 8004a96:	4620      	mov	r0, r4
 8004a98:	f7fe fee2 	bl	8003860 <chSemSignal>
 8004a9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      n++;
 8004a9e:	3501      	adds	r5, #1
 8004aa0:	1b9b      	subs	r3, r3, r6
    } while (chVTIsSystemTimeWithinX(start, end));
 8004aa2:	b29b      	uxth	r3, r3
 8004aa4:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8004aa8:	d3e0      	bcc.n	8004a6c <rt_test_011_010_execute+0x1c>
  test_set_step(2);
 8004aaa:	2302      	movs	r3, #2
    test_print("--- Score : ");
 8004aac:	4807      	ldr	r0, [pc, #28]	; (8004acc <rt_test_011_010_execute+0x7c>)
  test_set_step(2);
 8004aae:	f8c8 3000 	str.w	r3, [r8]
    test_print("--- Score : ");
 8004ab2:	f7fc fad5 	bl	8001060 <test_print>
    test_printn(n * 4);
 8004ab6:	00a8      	lsls	r0, r5, #2
 8004ab8:	f7fc fa02 	bl	8000ec0 <test_printn>
}
 8004abc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_println(" wait+signal/S");
 8004ac0:	4803      	ldr	r0, [pc, #12]	; (8004ad0 <rt_test_011_010_execute+0x80>)
 8004ac2:	f7fc baad 	b.w	8001020 <test_println>
 8004ac6:	bf00      	nop
 8004ac8:	2000166c 	.word	0x2000166c
 8004acc:	0800c4fc 	.word	0x0800c4fc
 8004ad0:	0800c528 	.word	0x0800c528
 8004ad4:	20001d94 	.word	0x20001d94
	...

08004ae0 <bmk_thread7>:
static THD_FUNCTION(bmk_thread7, p) {
 8004ae0:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 8004ae2:	4c08      	ldr	r4, [pc, #32]	; (8004b04 <bmk_thread7+0x24>)
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8004ae4:	69a3      	ldr	r3, [r4, #24]
  while (!chThdShouldTerminateX())
 8004ae6:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8004aea:	075a      	lsls	r2, r3, #29
 8004aec:	d408      	bmi.n	8004b00 <bmk_thread7+0x20>
    chSemWait(&sem1);
 8004aee:	4d06      	ldr	r5, [pc, #24]	; (8004b08 <bmk_thread7+0x28>)
 8004af0:	4628      	mov	r0, r5
 8004af2:	f7ff ff95 	bl	8004a20 <chSemWait>
 8004af6:	69a3      	ldr	r3, [r4, #24]
  while (!chThdShouldTerminateX())
 8004af8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8004afc:	075b      	lsls	r3, r3, #29
 8004afe:	d5f7      	bpl.n	8004af0 <bmk_thread7+0x10>
}
 8004b00:	bd38      	pop	{r3, r4, r5, pc}
 8004b02:	bf00      	nop
 8004b04:	20001254 	.word	0x20001254
 8004b08:	2000166c 	.word	0x2000166c
 8004b0c:	00000000 	.word	0x00000000

08004b10 <thread3>:
static THD_FUNCTION(thread3, p) {
 8004b10:	b510      	push	{r4, lr}
  chSemWait(&sem1);
 8004b12:	4c04      	ldr	r4, [pc, #16]	; (8004b24 <thread3+0x14>)
 8004b14:	4620      	mov	r0, r4
 8004b16:	f7ff ff83 	bl	8004a20 <chSemWait>
  chSemSignal(&sem1);
 8004b1a:	4620      	mov	r0, r4
}
 8004b1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chSemSignal(&sem1);
 8004b20:	f7fe be9e 	b.w	8003860 <chSemSignal>
 8004b24:	20001660 	.word	0x20001660
	...

08004b30 <thread1.lto_priv.113>:
static THD_FUNCTION(thread1, p) {
 8004b30:	b510      	push	{r4, lr}
 8004b32:	4604      	mov	r4, r0
  chSemWait(&sem1);
 8004b34:	4803      	ldr	r0, [pc, #12]	; (8004b44 <thread1.lto_priv.113+0x14>)
 8004b36:	f7ff ff73 	bl	8004a20 <chSemWait>
  test_emit_token(*(char *)p);
 8004b3a:	7820      	ldrb	r0, [r4, #0]
}
 8004b3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(*(char *)p);
 8004b40:	f7fc b9ce 	b.w	8000ee0 <test_emit_token>
 8004b44:	20001660 	.word	0x20001660
	...

08004b50 <chThdExitS>:
void chThdExitS(msg_t msg) {
 8004b50:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8004b52:	4b10      	ldr	r3, [pc, #64]	; (8004b94 <chThdExitS+0x44>)
 8004b54:	699c      	ldr	r4, [r3, #24]
  return (bool)(tlp->next != (thread_t *)tlp);
 8004b56:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8004b58:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8004b5c:	42ab      	cmp	r3, r5
  tp->u.exitcode = msg;
 8004b5e:	6260      	str	r0, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 8004b60:	d007      	beq.n	8004b72 <chThdExitS+0x22>
  tlp->next = tp->queue.next;
 8004b62:	681a      	ldr	r2, [r3, #0]
    (void) chSchReadyI(list_remove(&tp->waiting));
 8004b64:	4618      	mov	r0, r3
 8004b66:	62a2      	str	r2, [r4, #40]	; 0x28
 8004b68:	f7fc fd42 	bl	80015f0 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8004b6c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8004b6e:	42ab      	cmp	r3, r5
 8004b70:	d1f7      	bne.n	8004b62 <chThdExitS+0x12>
  if ((tp->refs == (trefs_t)0) &&
 8004b72:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8004b76:	b943      	cbnz	r3, 8004b8a <chThdExitS+0x3a>
 8004b78:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8004b7c:	079b      	lsls	r3, r3, #30
 8004b7e:	d104      	bne.n	8004b8a <chThdExitS+0x3a>
    REG_REMOVE(tp);
 8004b80:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
 8004b84:	611a      	str	r2, [r3, #16]
 8004b86:	6922      	ldr	r2, [r4, #16]
 8004b88:	6153      	str	r3, [r2, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 8004b8a:	200f      	movs	r0, #15
}
 8004b8c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 8004b90:	f7fe be96 	b.w	80038c0 <chSchGoSleepS>
 8004b94:	20001254 	.word	0x20001254
	...

08004ba0 <shellThread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
 8004ba0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004ba4:	4680      	mov	r8, r0
 8004ba6:	f8df 9230 	ldr.w	r9, [pc, #560]	; 8004dd8 <shellThread+0x238>
  int n;
  ShellConfig *scfg = p;
  BaseSequentialStream *chp = scfg->sc_channel;
 8004baa:	6807      	ldr	r7, [r0, #0]
  const ShellCommand *scp = scfg->sc_commands;
 8004bac:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8004bb0:	f8d9 3018 	ldr.w	r3, [r9, #24]
 8004bb4:	4a79      	ldr	r2, [pc, #484]	; (8004d9c <shellThread+0x1fc>)
THD_FUNCTION(shellThread, p) {
 8004bb6:	b09b      	sub	sp, #108	; 0x6c
  const ShellCommand *scp = scfg->sc_commands;
 8004bb8:	9101      	str	r1, [sp, #4]
 8004bba:	619a      	str	r2, [r3, #24]
  ShellHistory *shp = &hist;
#else
  ShellHistory *shp = NULL;
#endif

  chprintf(chp, SHELL_NEWLINE_STR);
 8004bbc:	4978      	ldr	r1, [pc, #480]	; (8004da0 <shellThread+0x200>)
 8004bbe:	4638      	mov	r0, r7
 8004bc0:	f7fe fa0e 	bl	8002fe0 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
 8004bc4:	4638      	mov	r0, r7
 8004bc6:	4977      	ldr	r1, [pc, #476]	; (8004da4 <shellThread+0x204>)
 8004bc8:	f7fe fa0a 	bl	8002fe0 <chprintf>
#if !defined(_CHIBIOS_NIL_)
  while (!chThdShouldTerminateX()) {
#else
  while (true) {
#endif
    chprintf(chp, SHELL_PROMPT_STR);
 8004bcc:	f8df a20c 	ldr.w	sl, [pc, #524]	; 8004ddc <shellThread+0x23c>
 8004bd0:	f8d9 3018 	ldr.w	r3, [r9, #24]
  while (!chThdShouldTerminateX()) {
 8004bd4:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8004bd8:	075b      	lsls	r3, r3, #29
 8004bda:	f100 8088 	bmi.w	8004cee <shellThread+0x14e>
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
  char *p = line;
 8004bde:	ae0a      	add	r6, sp, #40	; 0x28
 8004be0:	4635      	mov	r5, r6
    chprintf(chp, SHELL_PROMPT_STR);
 8004be2:	4651      	mov	r1, sl
 8004be4:	4638      	mov	r0, r7
 8004be6:	f7fe f9fb 	bl	8002fe0 <chprintf>
  BaseSequentialStream *chp = scfg->sc_channel;
 8004bea:	f8d8 4000 	ldr.w	r4, [r8]
 8004bee:	6823      	ldr	r3, [r4, #0]
#endif

  while (true) {
    char c;

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8004bf0:	689b      	ldr	r3, [r3, #8]
 8004bf2:	2201      	movs	r2, #1
 8004bf4:	f10d 010f 	add.w	r1, sp, #15
 8004bf8:	4620      	mov	r0, r4
 8004bfa:	4798      	blx	r3
 8004bfc:	2800      	cmp	r0, #0
 8004bfe:	d06e      	beq.n	8004cde <shellThread+0x13e>
      }
      continue;
    }
#endif
#if (SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)
    if (c == 4) {
 8004c00:	f89d 100f 	ldrb.w	r1, [sp, #15]
 8004c04:	2904      	cmp	r1, #4
 8004c06:	d066      	beq.n	8004cd6 <shellThread+0x136>
      chprintf(chp, "^D");
      return true;
    }
#endif
    if ((c == 8) || (c == 127)) {
 8004c08:	2908      	cmp	r1, #8
      continue;
    }
#endif
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 8004c0a:	f10d 0267 	add.w	r2, sp, #103	; 0x67
    if ((c == 8) || (c == 127)) {
 8004c0e:	d012      	beq.n	8004c36 <shellThread+0x96>
 8004c10:	297f      	cmp	r1, #127	; 0x7f
 8004c12:	d010      	beq.n	8004c36 <shellThread+0x96>
    if (c == '\r') {
 8004c14:	290d      	cmp	r1, #13
 8004c16:	d022      	beq.n	8004c5e <shellThread+0xbe>
    if (c < 0x20)
 8004c18:	291f      	cmp	r1, #31
 8004c1a:	6823      	ldr	r3, [r4, #0]
 8004c1c:	d9e8      	bls.n	8004bf0 <shellThread+0x50>
    if (p < line + size - 1) {
 8004c1e:	4295      	cmp	r5, r2
 8004c20:	d2e6      	bcs.n	8004bf0 <shellThread+0x50>
      streamPut(chp, c);
 8004c22:	68db      	ldr	r3, [r3, #12]
 8004c24:	4620      	mov	r0, r4
 8004c26:	4798      	blx	r3
      *p++ = (char)c;
 8004c28:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004c2c:	3501      	adds	r5, #1
 8004c2e:	f805 3c01 	strb.w	r3, [r5, #-1]
 8004c32:	6823      	ldr	r3, [r4, #0]
 8004c34:	e7dc      	b.n	8004bf0 <shellThread+0x50>
      if (p != line) {
 8004c36:	42b5      	cmp	r5, r6
 8004c38:	6823      	ldr	r3, [r4, #0]
 8004c3a:	d0d9      	beq.n	8004bf0 <shellThread+0x50>
        streamPut(chp, 0x08);
 8004c3c:	68db      	ldr	r3, [r3, #12]
 8004c3e:	2108      	movs	r1, #8
 8004c40:	4620      	mov	r0, r4
 8004c42:	4798      	blx	r3
        streamPut(chp, 0x20);
 8004c44:	6823      	ldr	r3, [r4, #0]
 8004c46:	2120      	movs	r1, #32
 8004c48:	68db      	ldr	r3, [r3, #12]
 8004c4a:	4620      	mov	r0, r4
 8004c4c:	4798      	blx	r3
        streamPut(chp, 0x08);
 8004c4e:	6823      	ldr	r3, [r4, #0]
 8004c50:	2108      	movs	r1, #8
 8004c52:	68db      	ldr	r3, [r3, #12]
 8004c54:	4620      	mov	r0, r4
 8004c56:	4798      	blx	r3
        p--;
 8004c58:	3d01      	subs	r5, #1
 8004c5a:	6823      	ldr	r3, [r4, #0]
 8004c5c:	e7c8      	b.n	8004bf0 <shellThread+0x50>
      *p = 0;
 8004c5e:	f04f 0b00 	mov.w	fp, #0
      chprintf(chp, SHELL_NEWLINE_STR);
 8004c62:	494f      	ldr	r1, [pc, #316]	; (8004da0 <shellThread+0x200>)
 8004c64:	4620      	mov	r0, r4
 8004c66:	f7fe f9bb 	bl	8002fe0 <chprintf>
    lp = parse_arguments(line, &tokp);
 8004c6a:	4630      	mov	r0, r6
 8004c6c:	a904      	add	r1, sp, #16
      *p = 0;
 8004c6e:	f885 b000 	strb.w	fp, [r5]
    lp = parse_arguments(line, &tokp);
 8004c72:	f7fe f985 	bl	8002f80 <parse_arguments>
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8004c76:	a904      	add	r1, sp, #16
    lp = parse_arguments(line, &tokp);
 8004c78:	4606      	mov	r6, r0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8004c7a:	2000      	movs	r0, #0
 8004c7c:	ad05      	add	r5, sp, #20
 8004c7e:	f7fe f97f 	bl	8002f80 <parse_arguments>
 8004c82:	b160      	cbz	r0, 8004c9e <shellThread+0xfe>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8004c84:	f1bb 0f04 	cmp.w	fp, #4
 8004c88:	d01e      	beq.n	8004cc8 <shellThread+0x128>
      args[n++] = lp;
 8004c8a:	f845 0b04 	str.w	r0, [r5], #4
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8004c8e:	a904      	add	r1, sp, #16
 8004c90:	2000      	movs	r0, #0
      args[n++] = lp;
 8004c92:	f10b 0b01 	add.w	fp, fp, #1
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8004c96:	f7fe f973 	bl	8002f80 <parse_arguments>
 8004c9a:	2800      	cmp	r0, #0
 8004c9c:	d1f2      	bne.n	8004c84 <shellThread+0xe4>
    args[n] = NULL;
 8004c9e:	ab1a      	add	r3, sp, #104	; 0x68
 8004ca0:	eb03 038b 	add.w	r3, r3, fp, lsl #2
 8004ca4:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 8004ca8:	2e00      	cmp	r6, #0
 8004caa:	d091      	beq.n	8004bd0 <shellThread+0x30>
      if (strcmp(cmd, "help") == 0) {
 8004cac:	493e      	ldr	r1, [pc, #248]	; (8004da8 <shellThread+0x208>)
 8004cae:	4630      	mov	r0, r6
 8004cb0:	f7fb fc42 	bl	8000538 <strcmp>
 8004cb4:	bb40      	cbnz	r0, 8004d08 <shellThread+0x168>
        if (n > 0) {
 8004cb6:	f1bb 0f00 	cmp.w	fp, #0
 8004cba:	d036      	beq.n	8004d2a <shellThread+0x18a>
          shellUsage(chp, "help");
 8004cbc:	4a3a      	ldr	r2, [pc, #232]	; (8004da8 <shellThread+0x208>)
 8004cbe:	493b      	ldr	r1, [pc, #236]	; (8004dac <shellThread+0x20c>)
 8004cc0:	4638      	mov	r0, r7
 8004cc2:	f7fe f98d 	bl	8002fe0 <chprintf>
 8004cc6:	e783      	b.n	8004bd0 <shellThread+0x30>
        chprintf(chp, "too many arguments" SHELL_NEWLINE_STR);
 8004cc8:	4939      	ldr	r1, [pc, #228]	; (8004db0 <shellThread+0x210>)
 8004cca:	4638      	mov	r0, r7
 8004ccc:	f7fe f988 	bl	8002fe0 <chprintf>
    args[n] = NULL;
 8004cd0:	2300      	movs	r3, #0
 8004cd2:	9309      	str	r3, [sp, #36]	; 0x24
 8004cd4:	e77c      	b.n	8004bd0 <shellThread+0x30>
      chprintf(chp, "^D");
 8004cd6:	4620      	mov	r0, r4
 8004cd8:	4936      	ldr	r1, [pc, #216]	; (8004db4 <shellThread+0x214>)
 8004cda:	f7fe f981 	bl	8002fe0 <chprintf>
      chprintf(chp, SHELL_NEWLINE_STR);
 8004cde:	4930      	ldr	r1, [pc, #192]	; (8004da0 <shellThread+0x200>)
 8004ce0:	4638      	mov	r0, r7
 8004ce2:	f7fe f97d 	bl	8002fe0 <chprintf>
      chprintf(chp, "logout");
 8004ce6:	4638      	mov	r0, r7
 8004ce8:	4933      	ldr	r1, [pc, #204]	; (8004db8 <shellThread+0x218>)
 8004cea:	f7fe f979 	bl	8002fe0 <chprintf>
 8004cee:	2320      	movs	r3, #32
 8004cf0:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8004cf4:	2100      	movs	r1, #0
 8004cf6:	4831      	ldr	r0, [pc, #196]	; (8004dbc <shellThread+0x21c>)
 8004cf8:	f7fc fd62 	bl	80017c0 <chEvtBroadcastFlagsI>
  chThdExitS(msg);
 8004cfc:	2000      	movs	r0, #0
 8004cfe:	f7ff ff27 	bl	8004b50 <chThdExitS>
}
 8004d02:	b01b      	add	sp, #108	; 0x6c
 8004d04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004d08:	4d2d      	ldr	r5, [pc, #180]	; (8004dc0 <shellThread+0x220>)
  while (scp->sc_name != NULL) {
 8004d0a:	482e      	ldr	r0, [pc, #184]	; (8004dc4 <shellThread+0x224>)
 8004d0c:	e002      	b.n	8004d14 <shellThread+0x174>
 8004d0e:	f855 0f08 	ldr.w	r0, [r5, #8]!
 8004d12:	b358      	cbz	r0, 8004d6c <shellThread+0x1cc>
    if (strcmp(scp->sc_name, name) == 0) {
 8004d14:	4631      	mov	r1, r6
 8004d16:	f7fb fc0f 	bl	8000538 <strcmp>
 8004d1a:	2800      	cmp	r0, #0
 8004d1c:	d1f7      	bne.n	8004d0e <shellThread+0x16e>
      scp->sc_function(chp, argc, argv);
 8004d1e:	686b      	ldr	r3, [r5, #4]
 8004d20:	aa05      	add	r2, sp, #20
 8004d22:	4659      	mov	r1, fp
 8004d24:	4638      	mov	r0, r7
 8004d26:	4798      	blx	r3
 8004d28:	e752      	b.n	8004bd0 <shellThread+0x30>
        chprintf(chp, "Commands: help ");
 8004d2a:	4927      	ldr	r1, [pc, #156]	; (8004dc8 <shellThread+0x228>)
 8004d2c:	4638      	mov	r0, r7
 8004d2e:	f7fe f957 	bl	8002fe0 <chprintf>
 8004d32:	4c23      	ldr	r4, [pc, #140]	; (8004dc0 <shellThread+0x220>)
  while (scp->sc_name != NULL) {
 8004d34:	4a23      	ldr	r2, [pc, #140]	; (8004dc4 <shellThread+0x224>)
    chprintf(chp, "%s ", scp->sc_name);
 8004d36:	4d25      	ldr	r5, [pc, #148]	; (8004dcc <shellThread+0x22c>)
 8004d38:	4629      	mov	r1, r5
 8004d3a:	4638      	mov	r0, r7
 8004d3c:	f7fe f950 	bl	8002fe0 <chprintf>
  while (scp->sc_name != NULL) {
 8004d40:	f854 2f08 	ldr.w	r2, [r4, #8]!
 8004d44:	2a00      	cmp	r2, #0
 8004d46:	d1f7      	bne.n	8004d38 <shellThread+0x198>
        if (scp != NULL)
 8004d48:	9c01      	ldr	r4, [sp, #4]
 8004d4a:	b154      	cbz	r4, 8004d62 <shellThread+0x1c2>
  while (scp->sc_name != NULL) {
 8004d4c:	6822      	ldr	r2, [r4, #0]
 8004d4e:	b142      	cbz	r2, 8004d62 <shellThread+0x1c2>
    chprintf(chp, "%s ", scp->sc_name);
 8004d50:	4d1e      	ldr	r5, [pc, #120]	; (8004dcc <shellThread+0x22c>)
 8004d52:	4629      	mov	r1, r5
 8004d54:	4638      	mov	r0, r7
 8004d56:	f7fe f943 	bl	8002fe0 <chprintf>
  while (scp->sc_name != NULL) {
 8004d5a:	f854 2f08 	ldr.w	r2, [r4, #8]!
 8004d5e:	2a00      	cmp	r2, #0
 8004d60:	d1f7      	bne.n	8004d52 <shellThread+0x1b2>
        chprintf(chp, SHELL_NEWLINE_STR);
 8004d62:	490f      	ldr	r1, [pc, #60]	; (8004da0 <shellThread+0x200>)
 8004d64:	4638      	mov	r0, r7
 8004d66:	f7fe f93b 	bl	8002fe0 <chprintf>
 8004d6a:	e731      	b.n	8004bd0 <shellThread+0x30>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 8004d6c:	9d01      	ldr	r5, [sp, #4]
 8004d6e:	b15d      	cbz	r5, 8004d88 <shellThread+0x1e8>
  while (scp->sc_name != NULL) {
 8004d70:	6828      	ldr	r0, [r5, #0]
 8004d72:	b918      	cbnz	r0, 8004d7c <shellThread+0x1dc>
 8004d74:	e008      	b.n	8004d88 <shellThread+0x1e8>
 8004d76:	f855 0f08 	ldr.w	r0, [r5, #8]!
 8004d7a:	b128      	cbz	r0, 8004d88 <shellThread+0x1e8>
    if (strcmp(scp->sc_name, name) == 0) {
 8004d7c:	4631      	mov	r1, r6
 8004d7e:	f7fb fbdb 	bl	8000538 <strcmp>
 8004d82:	2800      	cmp	r0, #0
 8004d84:	d1f7      	bne.n	8004d76 <shellThread+0x1d6>
 8004d86:	e7ca      	b.n	8004d1e <shellThread+0x17e>
        chprintf(chp, "%s", cmd);
 8004d88:	4632      	mov	r2, r6
 8004d8a:	4911      	ldr	r1, [pc, #68]	; (8004dd0 <shellThread+0x230>)
 8004d8c:	4638      	mov	r0, r7
 8004d8e:	f7fe f927 	bl	8002fe0 <chprintf>
        chprintf(chp, " ?" SHELL_NEWLINE_STR);
 8004d92:	4910      	ldr	r1, [pc, #64]	; (8004dd4 <shellThread+0x234>)
 8004d94:	4638      	mov	r0, r7
 8004d96:	f7fe f923 	bl	8002fe0 <chprintf>
 8004d9a:	e719      	b.n	8004bd0 <shellThread+0x30>
 8004d9c:	0800c788 	.word	0x0800c788
 8004da0:	0800ac8c 	.word	0x0800ac8c
 8004da4:	0800c790 	.word	0x0800c790
 8004da8:	0800c7d0 	.word	0x0800c7d0
 8004dac:	0800abd0 	.word	0x0800abd0
 8004db0:	0800c7b8 	.word	0x0800c7b8
 8004db4:	0800c7ac 	.word	0x0800c7ac
 8004db8:	0800c7b0 	.word	0x0800c7b0
 8004dbc:	20001678 	.word	0x20001678
 8004dc0:	0800c800 	.word	0x0800c800
 8004dc4:	0800c780 	.word	0x0800c780
 8004dc8:	0800c7d8 	.word	0x0800c7d8
 8004dcc:	0800c7e8 	.word	0x0800c7e8
 8004dd0:	0800c7ec 	.word	0x0800c7ec
 8004dd4:	0800c7f0 	.word	0x0800c7f0
 8004dd8:	20001254 	.word	0x20001254
 8004ddc:	0800c7a4 	.word	0x0800c7a4

08004de0 <cmd_exit>:
  if (argc > 0) {
 8004de0:	2900      	cmp	r1, #0
 8004de2:	dd03      	ble.n	8004dec <cmd_exit+0xc>
    shellUsage(chp, "exit");
 8004de4:	4a08      	ldr	r2, [pc, #32]	; (8004e08 <cmd_exit+0x28>)
 8004de6:	4909      	ldr	r1, [pc, #36]	; (8004e0c <cmd_exit+0x2c>)
 8004de8:	f7fe b8fa 	b.w	8002fe0 <chprintf>
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004dec:	b508      	push	{r3, lr}
 8004dee:	2320      	movs	r3, #32
 8004df0:	f383 8811 	msr	BASEPRI, r3
 8004df4:	4806      	ldr	r0, [pc, #24]	; (8004e10 <cmd_exit+0x30>)
 8004df6:	2100      	movs	r1, #0
 8004df8:	f7fc fce2 	bl	80017c0 <chEvtBroadcastFlagsI>
}
 8004dfc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chThdExitS(msg);
 8004e00:	2000      	movs	r0, #0
 8004e02:	f7ff bea5 	b.w	8004b50 <chThdExitS>
 8004e06:	bf00      	nop
 8004e08:	0800c780 	.word	0x0800c780
 8004e0c:	0800abd0 	.word	0x0800abd0
 8004e10:	20001678 	.word	0x20001678
	...

08004e20 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004e20:	f3ef 8309 	mrs	r3, PSP
    psp += sizeof (struct port_extctx);
 8004e24:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004e26:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004e2a:	2300      	movs	r3, #0
 8004e2c:	f383 8811 	msr	BASEPRI, r3
}
 8004e30:	4770      	bx	lr
 8004e32:	bf00      	nop
	...

08004e40 <chThdExit>:
 8004e40:	2320      	movs	r3, #32
 8004e42:	f383 8811 	msr	BASEPRI, r3
  chThdExitS(msg);
 8004e46:	f7ff be83 	b.w	8004b50 <chThdExitS>
 8004e4a:	bf00      	nop
 8004e4c:	0000      	movs	r0, r0
	...

08004e50 <Thread1.lto_priv.108>:

static THD_WORKING_AREA(waThread1, 256);
static THD_FUNCTION(Thread1, arg) {
 8004e50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  (void)arg;

  exit_flag = false;
 8004e52:	2300      	movs	r3, #0
 8004e54:	2620      	movs	r6, #32
 8004e56:	461d      	mov	r5, r3
 8004e58:	4f0e      	ldr	r7, [pc, #56]	; (8004e94 <Thread1.lto_priv.108+0x44>)
 8004e5a:	703b      	strb	r3, [r7, #0]
 8004e5c:	f386 8811 	msr	BASEPRI, r6
  tp = chMsgWaitS();
 8004e60:	f7ff fc0e 	bl	8004680 <chMsgWaitS>
 8004e64:	4604      	mov	r4, r0
 8004e66:	f385 8811 	msr	BASEPRI, r5
  thread_t *tp;
  const call_message_t *cmp;
  msg_t ret;

  tp = chMsgWait();
  cmp = (const call_message_t *)chMsgGet(tp);
 8004e6a:	6a43      	ldr	r3, [r0, #36]	; 0x24
  ret = cmp->veneer(cmp->argsp);
 8004e6c:	e9d3 2000 	ldrd	r2, r0, [r3]
 8004e70:	4790      	blx	r2
 8004e72:	4601      	mov	r1, r0
 8004e74:	f386 8811 	msr	BASEPRI, r6
  chSchWakeupS(tp, msg);
 8004e78:	4620      	mov	r0, r4
 8004e7a:	f7fe fc31 	bl	80036e0 <chSchWakeupS>
 8004e7e:	f385 8811 	msr	BASEPRI, r5
  do {
    chDelegateDispatch();
  } while (!exit_flag);
 8004e82:	783b      	ldrb	r3, [r7, #0]
 8004e84:	2b00      	cmp	r3, #0
 8004e86:	d0e9      	beq.n	8004e5c <Thread1.lto_priv.108+0xc>

  chThdExit(0x0FA5);
}
 8004e88:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chThdExit(0x0FA5);
 8004e8c:	f640 70a5 	movw	r0, #4005	; 0xfa5
 8004e90:	f7ff bfd6 	b.w	8004e40 <chThdExit>
 8004e94:	2000145c 	.word	0x2000145c
	...

08004ea0 <bmk_thread3>:
  chThdExit((msg_t)p);
 8004ea0:	f7ff bfce 	b.w	8004e40 <chThdExit>
	...

08004eb0 <chSchDoReschedule>:
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8004eb0:	2101      	movs	r1, #1
void chSchDoRescheduleAhead(void) {
 8004eb2:	b430      	push	{r4, r5}
  tp->state = CH_STATE_READY;
 8004eb4:	2500      	movs	r5, #0
  thread_t *otp = currp;
 8004eb6:	4a0d      	ldr	r2, [pc, #52]	; (8004eec <chSchDoReschedule+0x3c>)
  thread_t *tp = tqp->next;
 8004eb8:	6810      	ldr	r0, [r2, #0]
 8004eba:	6994      	ldr	r4, [r2, #24]
  tqp->next             = tp->queue.next;
 8004ebc:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8004ebe:	605a      	str	r2, [r3, #4]
  currp->state = CH_STATE_CURRENT;
 8004ec0:	f880 1020 	strb.w	r1, [r0, #32]

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
 8004ec4:	68a1      	ldr	r1, [r4, #8]
  tqp->next             = tp->queue.next;
 8004ec6:	6013      	str	r3, [r2, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8004ec8:	6190      	str	r0, [r2, #24]
  tp->state = CH_STATE_READY;
 8004eca:	f884 5020 	strb.w	r5, [r4, #32]
 8004ece:	e000      	b.n	8004ed2 <chSchDoReschedule+0x22>
 8004ed0:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8004ed2:	689a      	ldr	r2, [r3, #8]
 8004ed4:	4291      	cmp	r1, r2
 8004ed6:	d3fb      	bcc.n	8004ed0 <chSchDoReschedule+0x20>
  tp->queue.prev             = cp->queue.prev;
 8004ed8:	685a      	ldr	r2, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8004eda:	4621      	mov	r1, r4
  tp->queue.prev             = cp->queue.prev;
 8004edc:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8004ee0:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8004ee2:	605c      	str	r4, [r3, #4]
}
 8004ee4:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
 8004ee6:	f7fb b9ab 	b.w	8000240 <_port_switch>
 8004eea:	bf00      	nop
 8004eec:	20001254 	.word	0x20001254

08004ef0 <chSchRescheduleS>:
  return firstprio(&ch.rlist.queue) > currp->prio;
 8004ef0:	4b04      	ldr	r3, [pc, #16]	; (8004f04 <chSchRescheduleS+0x14>)
 8004ef2:	681a      	ldr	r2, [r3, #0]
 8004ef4:	699b      	ldr	r3, [r3, #24]
  if (chSchIsRescRequiredI()) {
 8004ef6:	6892      	ldr	r2, [r2, #8]
 8004ef8:	689b      	ldr	r3, [r3, #8]
 8004efa:	429a      	cmp	r2, r3
 8004efc:	d800      	bhi.n	8004f00 <chSchRescheduleS+0x10>
}
 8004efe:	4770      	bx	lr
    chSchDoRescheduleAhead();
 8004f00:	f7ff bfd6 	b.w	8004eb0 <chSchDoReschedule>
 8004f04:	20001254 	.word	0x20001254
	...

08004f10 <chSemResetWithMessage.constprop.66>:
void chSemResetWithMessage(semaphore_t *sp, cnt_t n, msg_t msg) {
 8004f10:	b570      	push	{r4, r5, r6, lr}
 8004f12:	2320      	movs	r3, #32
 8004f14:	f383 8811 	msr	BASEPRI, r3
  cnt = sp->cnt;
 8004f18:	6884      	ldr	r4, [r0, #8]
  sp->cnt = n;
 8004f1a:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 8004f1c:	3401      	adds	r4, #1
 8004f1e:	2c00      	cmp	r4, #0
 8004f20:	dc0c      	bgt.n	8004f3c <chSemResetWithMessage.constprop.66+0x2c>
 8004f22:	4605      	mov	r5, r0
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = msg;
 8004f24:	f06f 0601 	mvn.w	r6, #1
  thread_t *tp = tqp->prev;
 8004f28:	6868      	ldr	r0, [r5, #4]
  while (++cnt <= (cnt_t)0) {
 8004f2a:	3401      	adds	r4, #1
  tqp->prev             = tp->queue.prev;
 8004f2c:	6843      	ldr	r3, [r0, #4]
 8004f2e:	606b      	str	r3, [r5, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 8004f30:	601d      	str	r5, [r3, #0]
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = msg;
 8004f32:	f7fc fb5d 	bl	80015f0 <chSchReadyI>
  while (++cnt <= (cnt_t)0) {
 8004f36:	2c01      	cmp	r4, #1
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = msg;
 8004f38:	6246      	str	r6, [r0, #36]	; 0x24
  while (++cnt <= (cnt_t)0) {
 8004f3a:	d1f5      	bne.n	8004f28 <chSemResetWithMessage.constprop.66+0x18>
  chSchRescheduleS();
 8004f3c:	f7ff ffd8 	bl	8004ef0 <chSchRescheduleS>
 8004f40:	2300      	movs	r3, #0
 8004f42:	f383 8811 	msr	BASEPRI, r3
}
 8004f46:	bd70      	pop	{r4, r5, r6, pc}
	...

08004f50 <rt_test_006_001_execute>:
static void rt_test_006_001_execute(void) {
 8004f50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_set_step(1);
 8004f54:	2301      	movs	r3, #1
    msg = chSemWait(&sem1);
 8004f56:	4c29      	ldr	r4, [pc, #164]	; (8004ffc <rt_test_006_001_execute+0xac>)
  test_set_step(1);
 8004f58:	4e29      	ldr	r6, [pc, #164]	; (8005000 <rt_test_006_001_execute+0xb0>)
    msg = chSemWait(&sem1);
 8004f5a:	4620      	mov	r0, r4
  test_set_step(1);
 8004f5c:	6033      	str	r3, [r6, #0]
    msg = chSemWait(&sem1);
 8004f5e:	f7ff fd5f 	bl	8004a20 <chSemWait>
 8004f62:	2520      	movs	r5, #32
 8004f64:	4607      	mov	r7, r0
 8004f66:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 8004f6a:	68a0      	ldr	r0, [r4, #8]
 8004f6c:	4925      	ldr	r1, [pc, #148]	; (8005004 <rt_test_006_001_execute+0xb4>)
 8004f6e:	fab0 f080 	clz	r0, r0
 8004f72:	0940      	lsrs	r0, r0, #5
 8004f74:	f7fb ff0c 	bl	8000d90 <_test_assert>
 8004f78:	b120      	cbz	r0, 8004f84 <rt_test_006_001_execute+0x34>
 8004f7a:	2300      	movs	r3, #0
 8004f7c:	f383 8811 	msr	BASEPRI, r3
}
 8004f80:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004f84:	f380 8811 	msr	BASEPRI, r0
    test_assert(MSG_OK == msg, "wrong returned message");
 8004f88:	fab7 f087 	clz	r0, r7
 8004f8c:	491e      	ldr	r1, [pc, #120]	; (8005008 <rt_test_006_001_execute+0xb8>)
 8004f8e:	0940      	lsrs	r0, r0, #5
 8004f90:	f7fb fefe 	bl	8000d90 <_test_assert>
 8004f94:	4607      	mov	r7, r0
 8004f96:	2800      	cmp	r0, #0
 8004f98:	d1f2      	bne.n	8004f80 <rt_test_006_001_execute+0x30>
  test_set_step(2);
 8004f9a:	f04f 0902 	mov.w	r9, #2
    chSemSignal(&sem1);
 8004f9e:	4620      	mov	r0, r4
  test_set_step(2);
 8004fa0:	f8c6 9000 	str.w	r9, [r6]
    chSemSignal(&sem1);
 8004fa4:	f7fe fc5c 	bl	8003860 <chSemSignal>
 8004fa8:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 8004fac:	68a0      	ldr	r0, [r4, #8]
 8004fae:	4915      	ldr	r1, [pc, #84]	; (8005004 <rt_test_006_001_execute+0xb4>)
 8004fb0:	f1a0 0001 	sub.w	r0, r0, #1
 8004fb4:	fab0 f080 	clz	r0, r0
 8004fb8:	0940      	lsrs	r0, r0, #5
 8004fba:	f7fb fee9 	bl	8000d90 <_test_assert>
 8004fbe:	4680      	mov	r8, r0
 8004fc0:	b110      	cbz	r0, 8004fc8 <rt_test_006_001_execute+0x78>
 8004fc2:	f387 8811 	msr	BASEPRI, r7
 8004fc6:	e7db      	b.n	8004f80 <rt_test_006_001_execute+0x30>
 8004fc8:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 8004fcc:	2303      	movs	r3, #3
  chSemResetWithMessage(sp, n, MSG_RESET);
 8004fce:	4649      	mov	r1, r9
 8004fd0:	4620      	mov	r0, r4
 8004fd2:	6033      	str	r3, [r6, #0]
 8004fd4:	f7ff ff9c 	bl	8004f10 <chSemResetWithMessage.constprop.66>
 8004fd8:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 8004fdc:	68a0      	ldr	r0, [r4, #8]
 8004fde:	4909      	ldr	r1, [pc, #36]	; (8005004 <rt_test_006_001_execute+0xb4>)
 8004fe0:	f1a0 0002 	sub.w	r0, r0, #2
 8004fe4:	fab0 f080 	clz	r0, r0
 8004fe8:	0940      	lsrs	r0, r0, #5
 8004fea:	f7fb fed1 	bl	8000d90 <_test_assert>
 8004fee:	b910      	cbnz	r0, 8004ff6 <rt_test_006_001_execute+0xa6>
 8004ff0:	f380 8811 	msr	BASEPRI, r0
 8004ff4:	e7c4      	b.n	8004f80 <rt_test_006_001_execute+0x30>
 8004ff6:	f388 8811 	msr	BASEPRI, r8
 8004ffa:	e7c1      	b.n	8004f80 <rt_test_006_001_execute+0x30>
 8004ffc:	20001660 	.word	0x20001660
 8005000:	20001d94 	.word	0x20001d94
 8005004:	0800c074 	.word	0x0800c074
 8005008:	0800c088 	.word	0x0800c088
 800500c:	00000000 	.word	0x00000000

08005010 <rt_test_006_001_teardown>:
 8005010:	2100      	movs	r1, #0
 8005012:	4801      	ldr	r0, [pc, #4]	; (8005018 <rt_test_006_001_teardown+0x8>)
 8005014:	f7ff bf7c 	b.w	8004f10 <chSemResetWithMessage.constprop.66>
 8005018:	20001660 	.word	0x20001660
 800501c:	00000000 	.word	0x00000000

08005020 <chSemSignalWait.constprop.63>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8005020:	b538      	push	{r3, r4, r5, lr}
 8005022:	2320      	movs	r3, #32
 8005024:	f383 8811 	msr	BASEPRI, r3
              ((sps->cnt < (cnt_t)0) && queue_notempty(&sps->queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
 8005028:	4c15      	ldr	r4, [pc, #84]	; (8005080 <chSemSignalWait.constprop.63+0x60>)
 800502a:	68a3      	ldr	r3, [r4, #8]
 800502c:	3301      	adds	r3, #1
 800502e:	2b00      	cmp	r3, #0
 8005030:	60a3      	str	r3, [r4, #8]
 8005032:	dd1a      	ble.n	800506a <chSemSignalWait.constprop.63+0x4a>
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
 8005034:	3b01      	subs	r3, #1
 8005036:	2b00      	cmp	r3, #0
 8005038:	60a3      	str	r3, [r4, #8]
 800503a:	db06      	blt.n	800504a <chSemSignalWait.constprop.63+0x2a>
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->u.rdymsg;
  }
  else {
    chSchRescheduleS();
 800503c:	f7ff ff58 	bl	8004ef0 <chSchRescheduleS>
    msg = MSG_OK;
 8005040:	2000      	movs	r0, #0
 8005042:	2300      	movs	r3, #0
 8005044:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 8005048:	bd38      	pop	{r3, r4, r5, pc}
    thread_t *ctp = currp;
 800504a:	4a0e      	ldr	r2, [pc, #56]	; (8005084 <chSemSignalWait.constprop.63+0x64>)
  tp->queue.prev             = tqp->prev;
 800504c:	6863      	ldr	r3, [r4, #4]
 800504e:	6995      	ldr	r5, [r2, #24]
    chSchGoSleepS(CH_STATE_WTSEM);
 8005050:	2005      	movs	r0, #5
 8005052:	e9c5 4300 	strd	r4, r3, [r5]
  tp->queue.prev->queue.next = tp;
 8005056:	601d      	str	r5, [r3, #0]
    ctp->u.wtsemp = spw;
 8005058:	626c      	str	r4, [r5, #36]	; 0x24
  tqp->prev                  = tp;
 800505a:	6065      	str	r5, [r4, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 800505c:	f7fe fc30 	bl	80038c0 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 8005060:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8005062:	2300      	movs	r3, #0
 8005064:	f383 8811 	msr	BASEPRI, r3
}
 8005068:	bd38      	pop	{r3, r4, r5, pc}
  thread_t *tp = tqp->next;
 800506a:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
 800506c:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800506e:	605c      	str	r4, [r3, #4]
  tqp->next             = tp->queue.next;
 8005070:	6023      	str	r3, [r4, #0]
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 8005072:	f7fc fabd 	bl	80015f0 <chSchReadyI>
 8005076:	2200      	movs	r2, #0
 8005078:	68a3      	ldr	r3, [r4, #8]
 800507a:	6242      	str	r2, [r0, #36]	; 0x24
 800507c:	e7da      	b.n	8005034 <chSemSignalWait.constprop.63+0x14>
 800507e:	bf00      	nop
 8005080:	20001660 	.word	0x20001660
 8005084:	20001254 	.word	0x20001254
	...

08005090 <rt_test_006_005_execute>:

static void rt_test_006_005_teardown(void) {
  test_wait_threads();
}

static void rt_test_006_005_execute(void) {
 8005090:	b538      	push	{r3, r4, r5, lr}

  /* [6.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 8005092:	2401      	movs	r4, #1
  return ch.rlist.current;
 8005094:	4b1d      	ldr	r3, [pc, #116]	; (800510c <rt_test_006_005_execute+0x7c>)
 8005096:	4d1e      	ldr	r5, [pc, #120]	; (8005110 <rt_test_006_005_execute+0x80>)
  return chThdGetSelfX()->prio;
 8005098:	699a      	ldr	r2, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 800509a:	481e      	ldr	r0, [pc, #120]	; (8005114 <rt_test_006_005_execute+0x84>)
 800509c:	6891      	ldr	r1, [r2, #8]
 800509e:	2300      	movs	r3, #0
 80050a0:	4421      	add	r1, r4
 80050a2:	4a1d      	ldr	r2, [pc, #116]	; (8005118 <rt_test_006_005_execute+0x88>)
  test_set_step(1);
 80050a4:	602c      	str	r4, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80050a6:	f7fe fb4b 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_end_step(1);

  /* [6.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 80050aa:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80050ac:	4a1b      	ldr	r2, [pc, #108]	; (800511c <rt_test_006_005_execute+0x8c>)
  return (bool)(tqp->next == (const thread_t *)tqp);
 80050ae:	4c1c      	ldr	r4, [pc, #112]	; (8005120 <rt_test_006_005_execute+0x90>)
 80050b0:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 80050b2:	602b      	str	r3, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 80050b4:	f7ff ffb4 	bl	8005020 <chSemSignalWait.constprop.63>
 80050b8:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80050ba:	491a      	ldr	r1, [pc, #104]	; (8005124 <rt_test_006_005_execute+0x94>)
 80050bc:	1b00      	subs	r0, r0, r4
 80050be:	fab0 f080 	clz	r0, r0
 80050c2:	0940      	lsrs	r0, r0, #5
 80050c4:	f7fb fe64 	bl	8000d90 <_test_assert>
 80050c8:	b100      	cbz	r0, 80050cc <rt_test_006_005_execute+0x3c>
    chSemSignalWait(&sem1, &sem1);
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
  }
  test_end_step(3);
}
 80050ca:	bd38      	pop	{r3, r4, r5, pc}
    test_assert(sem1.cnt == 0, "counter not zero");
 80050cc:	68a0      	ldr	r0, [r4, #8]
 80050ce:	4916      	ldr	r1, [pc, #88]	; (8005128 <rt_test_006_005_execute+0x98>)
 80050d0:	fab0 f080 	clz	r0, r0
 80050d4:	0940      	lsrs	r0, r0, #5
 80050d6:	f7fb fe5b 	bl	8000d90 <_test_assert>
 80050da:	2800      	cmp	r0, #0
 80050dc:	d1f5      	bne.n	80050ca <rt_test_006_005_execute+0x3a>
  test_set_step(3);
 80050de:	2303      	movs	r3, #3
 80050e0:	602b      	str	r3, [r5, #0]
    chSemSignalWait(&sem1, &sem1);
 80050e2:	f7ff ff9d 	bl	8005020 <chSemSignalWait.constprop.63>
 80050e6:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80050e8:	490e      	ldr	r1, [pc, #56]	; (8005124 <rt_test_006_005_execute+0x94>)
 80050ea:	1b00      	subs	r0, r0, r4
 80050ec:	fab0 f080 	clz	r0, r0
 80050f0:	0940      	lsrs	r0, r0, #5
 80050f2:	f7fb fe4d 	bl	8000d90 <_test_assert>
 80050f6:	2800      	cmp	r0, #0
 80050f8:	d1e7      	bne.n	80050ca <rt_test_006_005_execute+0x3a>
    test_assert(sem1.cnt == 0, "counter not zero");
 80050fa:	68a0      	ldr	r0, [r4, #8]
 80050fc:	490a      	ldr	r1, [pc, #40]	; (8005128 <rt_test_006_005_execute+0x98>)
 80050fe:	fab0 f080 	clz	r0, r0
}
 8005102:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert(sem1.cnt == 0, "counter not zero");
 8005106:	0940      	lsrs	r0, r0, #5
 8005108:	f7fb be42 	b.w	8000d90 <_test_assert>
 800510c:	20001254 	.word	0x20001254
 8005110:	20001d94 	.word	0x20001d94
 8005114:	20001680 	.word	0x20001680
 8005118:	08004b11 	.word	0x08004b11
 800511c:	20001dac 	.word	0x20001dac
 8005120:	20001660 	.word	0x20001660
 8005124:	0800c0f0 	.word	0x0800c0f0
 8005128:	0800c100 	.word	0x0800c100
 800512c:	00000000 	.word	0x00000000

08005130 <chMBReset.constprop.38>:
void chMBReset(mailbox_t *mbp) {
 8005130:	b538      	push	{r3, r4, r5, lr}
 8005132:	2320      	movs	r3, #32
 8005134:	f383 8811 	msr	BASEPRI, r3
  mbp->reset = true;
 8005138:	2201      	movs	r2, #1
  mbp->cnt   = (size_t)0;
 800513a:	2500      	movs	r5, #0
  mbp->wrptr = mbp->buffer;
 800513c:	4c09      	ldr	r4, [pc, #36]	; (8005164 <chMBReset.constprop.38+0x34>)
 800513e:	6823      	ldr	r3, [r4, #0]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8005140:	f104 0018 	add.w	r0, r4, #24
  mbp->reset = true;
 8005144:	7522      	strb	r2, [r4, #20]
  mbp->rdptr = mbp->buffer;
 8005146:	e9c4 3302 	strd	r3, r3, [r4, #8]
  mbp->cnt   = (size_t)0;
 800514a:	6125      	str	r5, [r4, #16]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 800514c:	f7fc fa68 	bl	8001620 <chThdDequeueAllI.constprop.97>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8005150:	f104 0020 	add.w	r0, r4, #32
 8005154:	f7fc fa64 	bl	8001620 <chThdDequeueAllI.constprop.97>
  chSchRescheduleS();
 8005158:	f7ff feca 	bl	8004ef0 <chSchRescheduleS>
 800515c:	f385 8811 	msr	BASEPRI, r5
}
 8005160:	bd38      	pop	{r3, r4, r5, pc}
 8005162:	bf00      	nop
 8005164:	20000c58 	.word	0x20000c58
	...

08005170 <oslib_test_002_003_teardown>:

static void oslib_test_002_003_teardown(void) {
  chMBReset(&mb1);
 8005170:	f7ff bfde 	b.w	8005130 <chMBReset.constprop.38>
	...

08005180 <oslib_test_002_002_teardown>:
 8005180:	f7ff bff6 	b.w	8005170 <oslib_test_002_003_teardown>
	...

08005190 <oslib_test_002_001_teardown>:
 8005190:	f7ff bfee 	b.w	8005170 <oslib_test_002_003_teardown>
	...

080051a0 <chMBPostAheadTimeout.constprop.35>:
msg_t chMBPostAheadTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 80051a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80051a2:	4607      	mov	r7, r0
 80051a4:	460e      	mov	r6, r1
 80051a6:	2320      	movs	r3, #32
 80051a8:	f383 8811 	msr	BASEPRI, r3
 80051ac:	4c15      	ldr	r4, [pc, #84]	; (8005204 <chMBPostAheadTimeout.constprop.35+0x64>)
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 80051ae:	f104 0518 	add.w	r5, r4, #24
 80051b2:	e00b      	b.n	80051cc <chMBPostAheadTimeout.constprop.35+0x2c>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80051b4:	6923      	ldr	r3, [r4, #16]
 80051b6:	e9d4 2100 	ldrd	r2, r1, [r4]
  return (size_t)(mbp->top - mbp->buffer);
 80051ba:	1a88      	subs	r0, r1, r2
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 80051bc:	ebb3 0fa0 	cmp.w	r3, r0, asr #2
 80051c0:	d10d      	bne.n	80051de <chMBPostAheadTimeout.constprop.35+0x3e>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 80051c2:	4631      	mov	r1, r6
 80051c4:	4628      	mov	r0, r5
 80051c6:	f7fe fd5b 	bl	8003c80 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 80051ca:	b920      	cbnz	r0, 80051d6 <chMBPostAheadTimeout.constprop.35+0x36>
    if (mbp->reset) {
 80051cc:	7d23      	ldrb	r3, [r4, #20]
 80051ce:	2b00      	cmp	r3, #0
 80051d0:	d0f0      	beq.n	80051b4 <chMBPostAheadTimeout.constprop.35+0x14>
      return MSG_RESET;
 80051d2:	f06f 0001 	mvn.w	r0, #1
 80051d6:	2300      	movs	r3, #0
 80051d8:	f383 8811 	msr	BASEPRI, r3
}
 80051dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (--mbp->rdptr < mbp->buffer) {
 80051de:	68e0      	ldr	r0, [r4, #12]
      mbp->cnt++;
 80051e0:	3301      	adds	r3, #1
      if (--mbp->rdptr < mbp->buffer) {
 80051e2:	3804      	subs	r0, #4
 80051e4:	4282      	cmp	r2, r0
        mbp->rdptr = mbp->top - 1;
 80051e6:	bf88      	it	hi
 80051e8:	1f08      	subhi	r0, r1, #4
 80051ea:	60e0      	str	r0, [r4, #12]
      *mbp->rdptr = msg;
 80051ec:	6007      	str	r7, [r0, #0]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 80051ee:	4806      	ldr	r0, [pc, #24]	; (8005208 <chMBPostAheadTimeout.constprop.35+0x68>)
      mbp->cnt++;
 80051f0:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 80051f2:	f7fc fa2d 	bl	8001650 <chThdDequeueNextI.constprop.95>
      chSchRescheduleS();
 80051f6:	f7ff fe7b 	bl	8004ef0 <chSchRescheduleS>
      return MSG_OK;
 80051fa:	2000      	movs	r0, #0
 80051fc:	2300      	movs	r3, #0
 80051fe:	f383 8811 	msr	BASEPRI, r3
}
 8005202:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005204:	20000c58 	.word	0x20000c58
 8005208:	20000c78 	.word	0x20000c78
 800520c:	00000000 	.word	0x00000000

08005210 <oslib_test_006_001_execute>:
 * - [6.1.5] Checking cached objects.
 * - [6.1.6] Checking non-cached objects.
 * .
 */

static void oslib_test_006_001_execute(void) {
 8005210:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ocp->hashn            = hashn;
 8005214:	2508      	movs	r5, #8
  ocp->hashp            = hashp;
 8005216:	4ac9      	ldr	r2, [pc, #804]	; (800553c <oslib_test_006_001_execute+0x32c>)
  ocp->lru.hash_next    = NULL;
 8005218:	2100      	movs	r1, #0
  sp->cnt = n;
 800521a:	2701      	movs	r7, #1
  ocp->lru.lru_prev     = (oc_object_t *)&ocp->lru;
 800521c:	4613      	mov	r3, r2
 800521e:	2004      	movs	r0, #4
  tqp->next = (thread_t *)tqp;
 8005220:	4cc7      	ldr	r4, [pc, #796]	; (8005540 <oslib_test_006_001_execute+0x330>)
  ocp->objvp            = objvp;
 8005222:	4ec8      	ldr	r6, [pc, #800]	; (8005544 <oslib_test_006_001_execute+0x334>)
  ocp->hashn            = hashn;
 8005224:	6025      	str	r5, [r4, #0]
  ocp->readf            = readf;
 8005226:	4dc8      	ldr	r5, [pc, #800]	; (8005548 <oslib_test_006_001_execute+0x338>)
  ocp->hashp            = hashp;
 8005228:	6062      	str	r2, [r4, #4]
  ocp->readf            = readf;
 800522a:	63e5      	str	r5, [r4, #60]	; 0x3c
 800522c:	f104 0524 	add.w	r5, r4, #36	; 0x24
  tqp->prev = (thread_t *)tqp;
 8005230:	e9c4 5509 	strd	r5, r5, [r4, #36]	; 0x24
  tqp->next = (thread_t *)tqp;
 8005234:	f104 0530 	add.w	r5, r4, #48	; 0x30
  ocp->writef           = writef;
 8005238:	4ac4      	ldr	r2, [pc, #784]	; (800554c <oslib_test_006_001_execute+0x33c>)
  tqp->prev = (thread_t *)tqp;
 800523a:	e9c4 550c 	strd	r5, r5, [r4, #48]	; 0x30
  ocp->lru.hash_prev    = NULL;
 800523e:	e9c4 1105 	strd	r1, r1, [r4, #20]
 8005242:	62e7      	str	r7, [r4, #44]	; 0x2c
  ocp->lru.lru_prev     = (oc_object_t *)&ocp->lru;
 8005244:	f104 0714 	add.w	r7, r4, #20
  ocp->writef           = writef;
 8005248:	6422      	str	r2, [r4, #64]	; 0x40
  ocp->objvp            = objvp;
 800524a:	6126      	str	r6, [r4, #16]
 800524c:	f103 0240 	add.w	r2, r3, #64	; 0x40
  ocp->lru.lru_prev     = (oc_object_t *)&ocp->lru;
 8005250:	6227      	str	r7, [r4, #32]
 8005252:	63a0      	str	r0, [r4, #56]	; 0x38
  ocp->objn             = objn;
 8005254:	60a0      	str	r0, [r4, #8]
    hashp->hash_prev = (oc_object_t *)hashp;
 8005256:	e9c3 3300 	strd	r3, r3, [r3]
    hashp++;
 800525a:	3308      	adds	r3, #8
  } while (hashp < &ocp->hashp[ocp->hashn]);
 800525c:	4293      	cmp	r3, r2
 800525e:	d1fa      	bne.n	8005256 <oslib_test_006_001_execute+0x46>
 8005260:	4bb8      	ldr	r3, [pc, #736]	; (8005544 <oslib_test_006_001_execute+0x334>)
 8005262:	49bb      	ldr	r1, [pc, #748]	; (8005550 <oslib_test_006_001_execute+0x340>)
 8005264:	f103 0cf0 	add.w	ip, r3, #240	; 0xf0
 8005268:	2601      	movs	r6, #1
    objp->obj_group = 0U;
 800526a:	2200      	movs	r2, #0
 800526c:	e000      	b.n	8005270 <oslib_test_006_001_execute+0x60>
  } while (objn > (ucnt_t)0);
 800526e:	462b      	mov	r3, r5
    objvp = (void *)((uint8_t *)objvp + objsz);
 8005270:	f103 053c 	add.w	r5, r3, #60	; 0x3c
 8005274:	f103 0018 	add.w	r0, r3, #24
  } while (objn > (ucnt_t)0);
 8005278:	4565      	cmp	r5, ip
    LRU_INSERT_HEAD(ocp, objp);
 800527a:	e9c3 1702 	strd	r1, r7, [r3, #8]
 800527e:	621e      	str	r6, [r3, #32]
 8005280:	e9c3 0006 	strd	r0, r0, [r3, #24]
 8005284:	60cb      	str	r3, [r1, #12]
    objp->obj_key   = 0U;
 8005286:	e9c3 2204 	strd	r2, r2, [r3, #16]
    objp->dptr      = NULL;
 800528a:	e9c3 6209 	strd	r6, r2, [r3, #36]	; 0x24
 800528e:	4619      	mov	r1, r3
  } while (objn > (ucnt_t)0);
 8005290:	d1ed      	bne.n	800526e <oslib_test_006_001_execute+0x5e>
                      obj_write);
  }
  test_end_step(1);

  /* [6.1.2] Getting and releasing objects without initialization.*/
  test_set_step(2);
 8005292:	2202      	movs	r2, #2
  {
    uint32_t i;

    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
 8005294:	2500      	movs	r5, #0
  test_set_step(2);
 8005296:	f8df a2d8 	ldr.w	sl, [pc, #728]	; 8005570 <oslib_test_006_001_execute+0x360>
 800529a:	4bae      	ldr	r3, [pc, #696]	; (8005554 <oslib_test_006_001_execute+0x344>)
      oc_object_t * objp = chCacheGetObject(&cache1, 0U, i);

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 800529c:	f8df 82c0 	ldr.w	r8, [pc, #704]	; 8005560 <oslib_test_006_001_execute+0x350>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "should not be in sync");
 80052a0:	f8df 92d0 	ldr.w	r9, [pc, #720]	; 8005574 <oslib_test_006_001_execute+0x364>
 */
static inline void chCacheReleaseObject(objects_cache_t *ocp,
                                        oc_object_t *objp) {

  chSysLock();
  chCacheReleaseObjectI(ocp, objp);
 80052a4:	f8df b298 	ldr.w	fp, [pc, #664]	; 8005540 <oslib_test_006_001_execute+0x330>
  test_set_step(2);
 80052a8:	f8ca 2000 	str.w	r2, [sl]
 80052ac:	61e3      	str	r3, [r4, #28]
      oc_object_t * objp = chCacheGetObject(&cache1, 0U, i);
 80052ae:	4628      	mov	r0, r5
 80052b0:	f7ff fb2e 	bl	8004910 <chCacheGetObject.constprop.20>
 80052b4:	4606      	mov	r6, r0
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80052b6:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80052b8:	4641      	mov	r1, r8
 80052ba:	f3c0 0040 	ubfx	r0, r0, #1, #1
 80052be:	f7fb fd67 	bl	8000d90 <_test_assert>
 80052c2:	2800      	cmp	r0, #0
 80052c4:	f040 8138 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "should not be in sync");
 80052c8:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80052ca:	4649      	mov	r1, r9
 80052cc:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 80052d0:	f7fb fd5e 	bl	8000d90 <_test_assert>
 80052d4:	4607      	mov	r7, r0
 80052d6:	2800      	cmp	r0, #0
 80052d8:	f040 812e 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
 80052dc:	2320      	movs	r3, #32
 80052de:	f383 8811 	msr	BASEPRI, r3
 80052e2:	4631      	mov	r1, r6
 80052e4:	4658      	mov	r0, fp
 80052e6:	f7fc fac3 	bl	8001870 <chCacheReleaseObjectI>
  chSchRescheduleS();
 80052ea:	f7ff fe01 	bl	8004ef0 <chSchRescheduleS>
 80052ee:	f387 8811 	msr	BASEPRI, r7
    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
 80052f2:	3501      	adds	r5, #1
 80052f4:	2d08      	cmp	r5, #8
 80052f6:	d1da      	bne.n	80052ae <oslib_test_006_001_execute+0x9e>

      chCacheReleaseObject(&cache1, objp);
    }

    test_assert_sequence("", "unexpected tokens");
 80052f8:	4997      	ldr	r1, [pc, #604]	; (8005558 <oslib_test_006_001_execute+0x348>)
 80052fa:	4898      	ldr	r0, [pc, #608]	; (800555c <oslib_test_006_001_execute+0x34c>)
 80052fc:	f7fb fec8 	bl	8001090 <_test_assert_sequence>
 8005300:	2800      	cmp	r0, #0
 8005302:	f040 8119 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
  }
  test_end_step(2);

  /* [6.1.3] Getting and releasing objects with synchronous
     initialization.*/
  test_set_step(3);
 8005306:	2303      	movs	r3, #3
  {
    uint32_t i;
    bool error;

    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
 8005308:	4606      	mov	r6, r0
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 800530a:	4f95      	ldr	r7, [pc, #596]	; (8005560 <oslib_test_006_001_execute+0x350>)
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 800530c:	f8df 9268 	ldr.w	r9, [pc, #616]	; 8005578 <oslib_test_006_001_execute+0x368>
  /* Marking it as OC_FLAG_NOTSYNC because the read operation is going
     to corrupt it in case of failure. It is responsibility of the read
     implementation to clear it if the operation succeeds.*/
  objp->obj_flags |= OC_FLAG_NOTSYNC;

  return ocp->readf(ocp, objp, async);
 8005310:	f8df 822c 	ldr.w	r8, [pc, #556]	; 8005540 <oslib_test_006_001_execute+0x330>
  test_set_step(3);
 8005314:	f8ca 3000 	str.w	r3, [sl]
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 8005318:	4630      	mov	r0, r6
 800531a:	f7ff faf9 	bl	8004910 <chCacheGetObject.constprop.20>
 800531e:	4605      	mov	r5, r0
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8005320:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8005322:	4639      	mov	r1, r7
 8005324:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8005328:	f7fb fd32 	bl	8000d90 <_test_assert>
 800532c:	2800      	cmp	r0, #0
 800532e:	f040 8103 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 8005332:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8005334:	4649      	mov	r1, r9
 8005336:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 800533a:	f7fb fd29 	bl	8000d90 <_test_assert>
 800533e:	2800      	cmp	r0, #0
 8005340:	f040 80fa 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
  objp->obj_flags |= OC_FLAG_NOTSYNC;
 8005344:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  return ocp->readf(ocp, objp, async);
 8005346:	4602      	mov	r2, r0
  objp->obj_flags |= OC_FLAG_NOTSYNC;
 8005348:	f043 0308 	orr.w	r3, r3, #8
 800534c:	626b      	str	r3, [r5, #36]	; 0x24
  return ocp->readf(ocp, objp, async);
 800534e:	4629      	mov	r1, r5
 8005350:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005352:	4640      	mov	r0, r8
 8005354:	4798      	blx	r3

      error = chCacheReadObject(&cache1, objp, false);

      test_assert(error == false, "returned error");
 8005356:	f080 0001 	eor.w	r0, r0, #1
 800535a:	b2c0      	uxtb	r0, r0
 800535c:	4981      	ldr	r1, [pc, #516]	; (8005564 <oslib_test_006_001_execute+0x354>)
 800535e:	f7fb fd17 	bl	8000d90 <_test_assert>
 8005362:	2800      	cmp	r0, #0
 8005364:	f040 80e8 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8005368:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800536a:	4639      	mov	r1, r7
 800536c:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8005370:	f7fb fd0e 	bl	8000d90 <_test_assert>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 8005374:	497c      	ldr	r1, [pc, #496]	; (8005568 <oslib_test_006_001_execute+0x358>)
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8005376:	2800      	cmp	r0, #0
 8005378:	f040 80de 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 800537c:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800537e:	f080 0008 	eor.w	r0, r0, #8
 8005382:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 8005386:	f7fb fd03 	bl	8000d90 <_test_assert>
 800538a:	4683      	mov	fp, r0
 800538c:	2800      	cmp	r0, #0
 800538e:	f040 80d3 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
 8005392:	2320      	movs	r3, #32
 8005394:	f383 8811 	msr	BASEPRI, r3
  chCacheReleaseObjectI(ocp, objp);
 8005398:	4629      	mov	r1, r5
 800539a:	4640      	mov	r0, r8
 800539c:	f7fc fa68 	bl	8001870 <chCacheReleaseObjectI>
  chSchRescheduleS();
 80053a0:	f7ff fda6 	bl	8004ef0 <chSchRescheduleS>
 80053a4:	f38b 8811 	msr	BASEPRI, fp
    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
 80053a8:	3601      	adds	r6, #1
 80053aa:	2e08      	cmp	r6, #8
 80053ac:	d1b4      	bne.n	8005318 <oslib_test_006_001_execute+0x108>

      chCacheReleaseObject(&cache1, objp);
    }

    test_assert_sequence("abcdefgh", "unexpected tokens");
 80053ae:	496a      	ldr	r1, [pc, #424]	; (8005558 <oslib_test_006_001_execute+0x348>)
 80053b0:	486e      	ldr	r0, [pc, #440]	; (800556c <oslib_test_006_001_execute+0x35c>)
 80053b2:	f7fb fe6d 	bl	8001090 <_test_assert_sequence>
 80053b6:	2800      	cmp	r0, #0
 80053b8:	f040 80be 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
  }
  test_end_step(3);

  /* [6.1.4] Getting and releasing objects with asynchronous
     initialization.*/
  test_set_step(4);
 80053bc:	2304      	movs	r3, #4
  {
    uint32_t i;
    bool error;

    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
 80053be:	4605      	mov	r5, r0
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80053c0:	4f67      	ldr	r7, [pc, #412]	; (8005560 <oslib_test_006_001_execute+0x350>)
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 80053c2:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 8005578 <oslib_test_006_001_execute+0x368>
 80053c6:	f8df 8178 	ldr.w	r8, [pc, #376]	; 8005540 <oslib_test_006_001_execute+0x330>
  test_set_step(4);
 80053ca:	f8ca 3000 	str.w	r3, [sl]
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 80053ce:	4628      	mov	r0, r5
 80053d0:	f7ff fa9e 	bl	8004910 <chCacheGetObject.constprop.20>
 80053d4:	4606      	mov	r6, r0
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80053d6:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80053d8:	4639      	mov	r1, r7
 80053da:	f3c0 0040 	ubfx	r0, r0, #1, #1
 80053de:	f7fb fcd7 	bl	8000d90 <_test_assert>
 80053e2:	2800      	cmp	r0, #0
 80053e4:	f040 80a8 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 80053e8:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80053ea:	4649      	mov	r1, r9
 80053ec:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 80053f0:	f7fb fcce 	bl	8000d90 <_test_assert>
 80053f4:	2800      	cmp	r0, #0
 80053f6:	f040 809f 	bne.w	8005538 <oslib_test_006_001_execute+0x328>
  objp->obj_flags |= OC_FLAG_NOTSYNC;
 80053fa:	6a73      	ldr	r3, [r6, #36]	; 0x24
  return ocp->readf(ocp, objp, async);
 80053fc:	4631      	mov	r1, r6
  objp->obj_flags |= OC_FLAG_NOTSYNC;
 80053fe:	f043 0308 	orr.w	r3, r3, #8
 8005402:	6273      	str	r3, [r6, #36]	; 0x24
  return ocp->readf(ocp, objp, async);
 8005404:	2201      	movs	r2, #1
 8005406:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005408:	4640      	mov	r0, r8
 800540a:	4798      	blx	r3

      error = chCacheReadObject(&cache1, objp, true);

      test_assert(error == false, "returned error");
 800540c:	f080 0001 	eor.w	r0, r0, #1
 8005410:	b2c0      	uxtb	r0, r0
 8005412:	4954      	ldr	r1, [pc, #336]	; (8005564 <oslib_test_006_001_execute+0x354>)
 8005414:	f7fb fcbc 	bl	8000d90 <_test_assert>
 8005418:	2800      	cmp	r0, #0
 800541a:	f040 808d 	bne.w	8005538 <oslib_test_006_001_execute+0x328>

      objp = chCacheGetObject(&cache1, 0U, i);
 800541e:	4628      	mov	r0, r5
 8005420:	f7ff fa76 	bl	8004910 <chCacheGetObject.constprop.20>
 8005424:	4606      	mov	r6, r0

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8005426:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8005428:	4639      	mov	r1, r7
 800542a:	f3c0 0040 	ubfx	r0, r0, #1, #1
 800542e:	f7fb fcaf 	bl	8000d90 <_test_assert>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 8005432:	494d      	ldr	r1, [pc, #308]	; (8005568 <oslib_test_006_001_execute+0x358>)
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8005434:	2800      	cmp	r0, #0
 8005436:	d17f      	bne.n	8005538 <oslib_test_006_001_execute+0x328>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 8005438:	6a70      	ldr	r0, [r6, #36]	; 0x24
 800543a:	f080 0008 	eor.w	r0, r0, #8
 800543e:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 8005442:	f7fb fca5 	bl	8000d90 <_test_assert>
 8005446:	4683      	mov	fp, r0
 8005448:	2800      	cmp	r0, #0
 800544a:	d175      	bne.n	8005538 <oslib_test_006_001_execute+0x328>
 800544c:	2320      	movs	r3, #32
 800544e:	f383 8811 	msr	BASEPRI, r3
  chCacheReleaseObjectI(ocp, objp);
 8005452:	4631      	mov	r1, r6
 8005454:	4640      	mov	r0, r8
 8005456:	f7fc fa0b 	bl	8001870 <chCacheReleaseObjectI>
  chSchRescheduleS();
 800545a:	f7ff fd49 	bl	8004ef0 <chSchRescheduleS>
 800545e:	f38b 8811 	msr	BASEPRI, fp
    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
 8005462:	3501      	adds	r5, #1
 8005464:	2d08      	cmp	r5, #8
 8005466:	d1b2      	bne.n	80053ce <oslib_test_006_001_execute+0x1be>

      chCacheReleaseObject(&cache1, objp);
    }

    test_assert_sequence("abcdefgh", "unexpected tokens");
 8005468:	493b      	ldr	r1, [pc, #236]	; (8005558 <oslib_test_006_001_execute+0x348>)
 800546a:	4840      	ldr	r0, [pc, #256]	; (800556c <oslib_test_006_001_execute+0x35c>)
 800546c:	f7fb fe10 	bl	8001090 <_test_assert_sequence>
 8005470:	2800      	cmp	r0, #0
 8005472:	d161      	bne.n	8005538 <oslib_test_006_001_execute+0x328>
  }
  test_end_step(4);

  /* [6.1.5] Checking cached objects.*/
  test_set_step(5);
 8005474:	2305      	movs	r3, #5
  {
    uint32_t i;

    for (i = NUM_OBJECTS; i < (NUM_OBJECTS * 2); i++) {
 8005476:	2404      	movs	r4, #4
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8005478:	4e39      	ldr	r6, [pc, #228]	; (8005560 <oslib_test_006_001_execute+0x350>)
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 800547a:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 8005568 <oslib_test_006_001_execute+0x358>
  chCacheReleaseObjectI(ocp, objp);
 800547e:	4f30      	ldr	r7, [pc, #192]	; (8005540 <oslib_test_006_001_execute+0x330>)
  test_set_step(5);
 8005480:	f8ca 3000 	str.w	r3, [sl]
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 8005484:	4620      	mov	r0, r4
 8005486:	f7ff fa43 	bl	8004910 <chCacheGetObject.constprop.20>
 800548a:	4605      	mov	r5, r0
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 800548c:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800548e:	4631      	mov	r1, r6
 8005490:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8005494:	f7fb fc7c 	bl	8000d90 <_test_assert>
 8005498:	2800      	cmp	r0, #0
 800549a:	d14d      	bne.n	8005538 <oslib_test_006_001_execute+0x328>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 800549c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800549e:	4641      	mov	r1, r8
 80054a0:	f083 0308 	eor.w	r3, r3, #8
 80054a4:	f3c3 00c0 	ubfx	r0, r3, #3, #1
 80054a8:	f7fb fc72 	bl	8000d90 <_test_assert>
 80054ac:	4681      	mov	r9, r0
 80054ae:	2800      	cmp	r0, #0
 80054b0:	d142      	bne.n	8005538 <oslib_test_006_001_execute+0x328>
 80054b2:	2320      	movs	r3, #32
 80054b4:	f383 8811 	msr	BASEPRI, r3
 80054b8:	4629      	mov	r1, r5
 80054ba:	4638      	mov	r0, r7
 80054bc:	f7fc f9d8 	bl	8001870 <chCacheReleaseObjectI>
  chSchRescheduleS();
 80054c0:	f7ff fd16 	bl	8004ef0 <chSchRescheduleS>
 80054c4:	f389 8811 	msr	BASEPRI, r9
    for (i = NUM_OBJECTS; i < (NUM_OBJECTS * 2); i++) {
 80054c8:	3401      	adds	r4, #1
 80054ca:	2c08      	cmp	r4, #8
 80054cc:	d1da      	bne.n	8005484 <oslib_test_006_001_execute+0x274>

      chCacheReleaseObject(&cache1, objp);
    }

    test_assert_sequence("", "unexpected tokens");
 80054ce:	4922      	ldr	r1, [pc, #136]	; (8005558 <oslib_test_006_001_execute+0x348>)
 80054d0:	4822      	ldr	r0, [pc, #136]	; (800555c <oslib_test_006_001_execute+0x34c>)
 80054d2:	f7fb fddd 	bl	8001090 <_test_assert_sequence>
 80054d6:	bb78      	cbnz	r0, 8005538 <oslib_test_006_001_execute+0x328>
  }
  test_end_step(5);

  /* [6.1.6] Checking non-cached objects.*/
  test_set_step(6);
 80054d8:	2306      	movs	r3, #6
  {
    uint32_t i;

    for (i = 0; i < NUM_OBJECTS; i++) {
 80054da:	4604      	mov	r4, r0
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80054dc:	f8df 9080 	ldr.w	r9, [pc, #128]	; 8005560 <oslib_test_006_001_execute+0x350>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 80054e0:	f8df 8094 	ldr.w	r8, [pc, #148]	; 8005578 <oslib_test_006_001_execute+0x368>
  chCacheReleaseObjectI(ocp, objp);
 80054e4:	4f16      	ldr	r7, [pc, #88]	; (8005540 <oslib_test_006_001_execute+0x330>)
  test_set_step(6);
 80054e6:	f8ca 3000 	str.w	r3, [sl]
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 80054ea:	4620      	mov	r0, r4
 80054ec:	f7ff fa10 	bl	8004910 <chCacheGetObject.constprop.20>
 80054f0:	4605      	mov	r5, r0
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80054f2:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80054f4:	4649      	mov	r1, r9
 80054f6:	f3c0 0040 	ubfx	r0, r0, #1, #1
 80054fa:	f7fb fc49 	bl	8000d90 <_test_assert>
 80054fe:	b9d8      	cbnz	r0, 8005538 <oslib_test_006_001_execute+0x328>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 8005500:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8005502:	4641      	mov	r1, r8
 8005504:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 8005508:	f7fb fc42 	bl	8000d90 <_test_assert>
 800550c:	4606      	mov	r6, r0
 800550e:	b998      	cbnz	r0, 8005538 <oslib_test_006_001_execute+0x328>
 8005510:	2320      	movs	r3, #32
 8005512:	f383 8811 	msr	BASEPRI, r3
 8005516:	4629      	mov	r1, r5
 8005518:	4638      	mov	r0, r7
 800551a:	f7fc f9a9 	bl	8001870 <chCacheReleaseObjectI>
  chSchRescheduleS();
 800551e:	f7ff fce7 	bl	8004ef0 <chSchRescheduleS>
 8005522:	f386 8811 	msr	BASEPRI, r6
    for (i = 0; i < NUM_OBJECTS; i++) {
 8005526:	3401      	adds	r4, #1
 8005528:	2c04      	cmp	r4, #4
 800552a:	d1de      	bne.n	80054ea <oslib_test_006_001_execute+0x2da>
    }

    test_assert_sequence("", "unexpected tokens");
  }
  test_end_step(6);
}
 800552c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_assert_sequence("", "unexpected tokens");
 8005530:	4909      	ldr	r1, [pc, #36]	; (8005558 <oslib_test_006_001_execute+0x348>)
 8005532:	480a      	ldr	r0, [pc, #40]	; (800555c <oslib_test_006_001_execute+0x34c>)
 8005534:	f7fb bdac 	b.w	8001090 <_test_assert_sequence>
}
 8005538:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800553c:	20001460 	.word	0x20001460
 8005540:	20001210 	.word	0x20001210
 8005544:	20001560 	.word	0x20001560
 8005548:	08005581 	.word	0x08005581
 800554c:	08000f11 	.word	0x08000f11
 8005550:	20001224 	.word	0x20001224
 8005554:	20001614 	.word	0x20001614
 8005558:	0800b358 	.word	0x0800b358
 800555c:	0800c7f4 	.word	0x0800c7f4
 8005560:	0800b334 	.word	0x0800b334
 8005564:	0800b36c 	.word	0x0800b36c
 8005568:	0800b37c 	.word	0x0800b37c
 800556c:	0800b388 	.word	0x0800b388
 8005570:	20001d94 	.word	0x20001d94
 8005574:	0800b340 	.word	0x0800b340
 8005578:	0800b380 	.word	0x0800b380
 800557c:	00000000 	.word	0x00000000

08005580 <obj_read>:
                     bool async) {
 8005580:	b570      	push	{r4, r5, r6, lr}
 8005582:	460c      	mov	r4, r1
 8005584:	4615      	mov	r5, r2
  test_emit_token('a' + objp->obj_key);
 8005586:	694b      	ldr	r3, [r1, #20]
                     bool async) {
 8005588:	4606      	mov	r6, r0
  test_emit_token('a' + objp->obj_key);
 800558a:	f103 0061 	add.w	r0, r3, #97	; 0x61
 800558e:	b2c0      	uxtb	r0, r0
 8005590:	f7fb fca6 	bl	8000ee0 <test_emit_token>
  objp->obj_flags &= ~OC_FLAG_NOTSYNC;
 8005594:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005596:	f023 0308 	bic.w	r3, r3, #8
 800559a:	6263      	str	r3, [r4, #36]	; 0x24
  if (async) {
 800559c:	b15d      	cbz	r5, 80055b6 <obj_read+0x36>
 800559e:	2320      	movs	r3, #32
 80055a0:	f383 8811 	msr	BASEPRI, r3
  chCacheReleaseObjectI(ocp, objp);
 80055a4:	4621      	mov	r1, r4
 80055a6:	4630      	mov	r0, r6
 80055a8:	f7fc f962 	bl	8001870 <chCacheReleaseObjectI>
  chSchRescheduleS();
 80055ac:	f7ff fca0 	bl	8004ef0 <chSchRescheduleS>
 80055b0:	2300      	movs	r3, #0
 80055b2:	f383 8811 	msr	BASEPRI, r3
}
 80055b6:	2000      	movs	r0, #0
 80055b8:	bd70      	pop	{r4, r5, r6, pc}
 80055ba:	bf00      	nop
 80055bc:	0000      	movs	r0, r0
	...

080055c0 <evt_thread7>:
static THD_FUNCTION(evt_thread7, p) {
 80055c0:	b538      	push	{r3, r4, r5, lr}
 80055c2:	2520      	movs	r5, #32
 80055c4:	f385 8811 	msr	BASEPRI, r5
  chEvtBroadcastFlagsI(esp, flags);
 80055c8:	2100      	movs	r1, #0
 80055ca:	480b      	ldr	r0, [pc, #44]	; (80055f8 <evt_thread7+0x38>)
 80055cc:	f7fc f8f8 	bl	80017c0 <chEvtBroadcastFlagsI>
 80055d0:	2400      	movs	r4, #0
  chSchRescheduleS();
 80055d2:	f7ff fc8d 	bl	8004ef0 <chSchRescheduleS>
 80055d6:	f384 8811 	msr	BASEPRI, r4
  chThdSleepMilliseconds(50);
 80055da:	2064      	movs	r0, #100	; 0x64
 80055dc:	f7fe fd30 	bl	8004040 <chThdSleep>
 80055e0:	f385 8811 	msr	BASEPRI, r5
  chEvtBroadcastFlagsI(esp, flags);
 80055e4:	4805      	ldr	r0, [pc, #20]	; (80055fc <evt_thread7+0x3c>)
 80055e6:	4621      	mov	r1, r4
 80055e8:	f7fc f8ea 	bl	80017c0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80055ec:	f7ff fc80 	bl	8004ef0 <chSchRescheduleS>
 80055f0:	f384 8811 	msr	BASEPRI, r4
}
 80055f4:	bd38      	pop	{r3, r4, r5, pc}
 80055f6:	bf00      	nop
 80055f8:	20000c0c 	.word	0x20000c0c
 80055fc:	20000c10 	.word	0x20000c10

08005600 <evt_thread3>:
static THD_FUNCTION(evt_thread3, p) {
 8005600:	b510      	push	{r4, lr}
 8005602:	4604      	mov	r4, r0
  chThdSleepMilliseconds(50);
 8005604:	2064      	movs	r0, #100	; 0x64
 8005606:	f7fe fd1b 	bl	8004040 <chThdSleep>
 800560a:	2320      	movs	r3, #32
 800560c:	f383 8811 	msr	BASEPRI, r3
  chEvtSignalI(tp, events);
 8005610:	2101      	movs	r1, #1
 8005612:	4620      	mov	r0, r4
 8005614:	f7fc f8bc 	bl	8001790 <chEvtSignalI>
  chSchRescheduleS();
 8005618:	f7ff fc6a 	bl	8004ef0 <chSchRescheduleS>
 800561c:	2300      	movs	r3, #0
 800561e:	f383 8811 	msr	BASEPRI, r3
}
 8005622:	bd10      	pop	{r4, pc}
	...

08005630 <thread4B>:
static THD_FUNCTION(thread4B, p) {
 8005630:	b510      	push	{r4, lr}
  chThdSleepMilliseconds(150);
 8005632:	f44f 7096 	mov.w	r0, #300	; 0x12c
 8005636:	f7fe fd03 	bl	8004040 <chThdSleep>
 800563a:	2320      	movs	r3, #32
 800563c:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 8005640:	4c06      	ldr	r4, [pc, #24]	; (800565c <thread4B+0x2c>)
 8005642:	4620      	mov	r0, r4
 8005644:	f7ff f8c4 	bl	80047d0 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 8005648:	4620      	mov	r0, r4
 800564a:	f7fc f8d1 	bl	80017f0 <chMtxUnlockS>
  chSchRescheduleS();
 800564e:	f7ff fc4f 	bl	8004ef0 <chSchRescheduleS>
 8005652:	2300      	movs	r3, #0
 8005654:	f383 8811 	msr	BASEPRI, r3
}
 8005658:	bd10      	pop	{r4, pc}
 800565a:	bf00      	nop
 800565c:	20000c48 	.word	0x20000c48

08005660 <rt_test_006_006_execute>:

static void rt_test_006_006_teardown(void) {
  test_wait_threads();
}

static void rt_test_006_006_execute(void) {
 8005660:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  binary_semaphore_t bsem;
  msg_t msg;

  /* [6.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8005664:	2301      	movs	r3, #1
 8005666:	2600      	movs	r6, #0
static void rt_test_006_006_execute(void) {
 8005668:	b084      	sub	sp, #16
  test_set_step(1);
 800566a:	4f5f      	ldr	r7, [pc, #380]	; (80057e8 <rt_test_006_006_execute+0x188>)
  tqp->next = (thread_t *)tqp;
 800566c:	ac01      	add	r4, sp, #4
 800566e:	603b      	str	r3, [r7, #0]
 8005670:	9603      	str	r6, [sp, #12]
  tqp->prev = (thread_t *)tqp;
 8005672:	e9cd 4401 	strd	r4, r4, [sp, #4]
 8005676:	f04f 0820 	mov.w	r8, #32
 800567a:	f388 8811 	msr	BASEPRI, r8
 */
static inline bool chBSemGetStateI(const binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 800567e:	9803      	ldr	r0, [sp, #12]
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8005680:	495a      	ldr	r1, [pc, #360]	; (80057ec <rt_test_006_006_execute+0x18c>)
 8005682:	42b0      	cmp	r0, r6
 8005684:	bfcc      	ite	gt
 8005686:	2000      	movgt	r0, #0
 8005688:	2001      	movle	r0, #1
 800568a:	f7fb fb81 	bl	8000d90 <_test_assert>
 800568e:	b120      	cbz	r0, 800569a <rt_test_006_006_execute+0x3a>
 8005690:	f386 8811 	msr	BASEPRI, r6
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
  test_end_step(6);
}
 8005694:	b004      	add	sp, #16
 8005696:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800569a:	4605      	mov	r5, r0
 800569c:	f380 8811 	msr	BASEPRI, r0
  test_set_step(2);
 80056a0:	2302      	movs	r3, #2
 80056a2:	4601      	mov	r1, r0
 80056a4:	4620      	mov	r0, r4
 80056a6:	603b      	str	r3, [r7, #0]
 80056a8:	f7ff fc32 	bl	8004f10 <chSemResetWithMessage.constprop.66>
 80056ac:	f388 8811 	msr	BASEPRI, r8
 80056b0:	9803      	ldr	r0, [sp, #12]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80056b2:	494e      	ldr	r1, [pc, #312]	; (80057ec <rt_test_006_006_execute+0x18c>)
 80056b4:	2800      	cmp	r0, #0
 80056b6:	bfcc      	ite	gt
 80056b8:	2000      	movgt	r0, #0
 80056ba:	2001      	movle	r0, #1
 80056bc:	f7fb fb68 	bl	8000d90 <_test_assert>
 80056c0:	4606      	mov	r6, r0
 80056c2:	b120      	cbz	r0, 80056ce <rt_test_006_006_execute+0x6e>
 80056c4:	f385 8811 	msr	BASEPRI, r5
}
 80056c8:	b004      	add	sp, #16
 80056ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80056ce:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 80056d2:	2503      	movs	r5, #3
  return ch.rlist.current;
 80056d4:	4a46      	ldr	r2, [pc, #280]	; (80057f0 <rt_test_006_006_execute+0x190>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 80056d6:	4623      	mov	r3, r4
  return chThdGetSelfX()->prio;
 80056d8:	6991      	ldr	r1, [r2, #24]
 80056da:	4846      	ldr	r0, [pc, #280]	; (80057f4 <rt_test_006_006_execute+0x194>)
 80056dc:	6889      	ldr	r1, [r1, #8]
 80056de:	4a46      	ldr	r2, [pc, #280]	; (80057f8 <rt_test_006_006_execute+0x198>)
 80056e0:	3901      	subs	r1, #1
  test_set_step(3);
 80056e2:	603d      	str	r5, [r7, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 80056e4:	f7fe f82c 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(4);
 80056e8:	2204      	movs	r2, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 80056ea:	4b44      	ldr	r3, [pc, #272]	; (80057fc <rt_test_006_006_execute+0x19c>)
  test_set_step(4);
 80056ec:	603a      	str	r2, [r7, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 80056ee:	6018      	str	r0, [r3, #0]
  return chSemWait(&bsp->sem);
 80056f0:	4620      	mov	r0, r4
 80056f2:	f7ff f995 	bl	8004a20 <chSemWait>
 80056f6:	4605      	mov	r5, r0
 80056f8:	f388 8811 	msr	BASEPRI, r8
  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 80056fc:	9803      	ldr	r0, [sp, #12]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80056fe:	493b      	ldr	r1, [pc, #236]	; (80057ec <rt_test_006_006_execute+0x18c>)
 8005700:	2800      	cmp	r0, #0
 8005702:	bfcc      	ite	gt
 8005704:	2000      	movgt	r0, #0
 8005706:	2001      	movle	r0, #1
 8005708:	f7fb fb42 	bl	8000d90 <_test_assert>
 800570c:	2800      	cmp	r0, #0
 800570e:	d1bf      	bne.n	8005690 <rt_test_006_006_execute+0x30>
 8005710:	f380 8811 	msr	BASEPRI, r0
    test_assert(msg == MSG_OK, "unexpected message");
 8005714:	fab5 f085 	clz	r0, r5
 8005718:	4939      	ldr	r1, [pc, #228]	; (8005800 <rt_test_006_006_execute+0x1a0>)
 800571a:	0940      	lsrs	r0, r0, #5
 800571c:	f7fb fb38 	bl	8000d90 <_test_assert>
 8005720:	2800      	cmp	r0, #0
 8005722:	d1b7      	bne.n	8005694 <rt_test_006_006_execute+0x34>
  test_set_step(5);
 8005724:	2305      	movs	r3, #5
 8005726:	603b      	str	r3, [r7, #0]
 8005728:	f388 8811 	msr	BASEPRI, r8
  if (bsp->sem.cnt < (cnt_t)1) {
 800572c:	9b03      	ldr	r3, [sp, #12]
 800572e:	2b00      	cmp	r3, #0
 8005730:	dd4e      	ble.n	80057d0 <rt_test_006_006_execute+0x170>
  chSchRescheduleS();
 8005732:	f7ff fbdd 	bl	8004ef0 <chSchRescheduleS>
 8005736:	2500      	movs	r5, #0
 8005738:	f385 8811 	msr	BASEPRI, r5
 800573c:	f04f 0820 	mov.w	r8, #32
 8005740:	f388 8811 	msr	BASEPRI, r8
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 8005744:	9803      	ldr	r0, [sp, #12]
 8005746:	492f      	ldr	r1, [pc, #188]	; (8005804 <rt_test_006_006_execute+0x1a4>)
 8005748:	42a8      	cmp	r0, r5
 800574a:	bfd4      	ite	le
 800574c:	2000      	movle	r0, #0
 800574e:	2001      	movgt	r0, #1
 8005750:	f7fb fb1e 	bl	8000d90 <_test_assert>
 8005754:	4606      	mov	r6, r0
 8005756:	2800      	cmp	r0, #0
 8005758:	d1b4      	bne.n	80056c4 <rt_test_006_006_execute+0x64>
 800575a:	f380 8811 	msr	BASEPRI, r0
 800575e:	f388 8811 	msr	BASEPRI, r8
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8005762:	9803      	ldr	r0, [sp, #12]
 8005764:	4928      	ldr	r1, [pc, #160]	; (8005808 <rt_test_006_006_execute+0x1a8>)
 8005766:	f1a0 0001 	sub.w	r0, r0, #1
 800576a:	fab0 f080 	clz	r0, r0
 800576e:	0940      	lsrs	r0, r0, #5
 8005770:	f7fb fb0e 	bl	8000d90 <_test_assert>
 8005774:	2800      	cmp	r0, #0
 8005776:	d18b      	bne.n	8005690 <rt_test_006_006_execute+0x30>
 8005778:	f380 8811 	msr	BASEPRI, r0
  test_set_step(6);
 800577c:	2306      	movs	r3, #6
 800577e:	603b      	str	r3, [r7, #0]
 8005780:	f388 8811 	msr	BASEPRI, r8
  if (bsp->sem.cnt < (cnt_t)1) {
 8005784:	9b03      	ldr	r3, [sp, #12]
 8005786:	2b00      	cmp	r3, #0
 8005788:	dd26      	ble.n	80057d8 <rt_test_006_006_execute+0x178>
  chSchRescheduleS();
 800578a:	f7ff fbb1 	bl	8004ef0 <chSchRescheduleS>
 800578e:	2600      	movs	r6, #0
 8005790:	f386 8811 	msr	BASEPRI, r6
 8005794:	2520      	movs	r5, #32
 8005796:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 800579a:	9803      	ldr	r0, [sp, #12]
 800579c:	491b      	ldr	r1, [pc, #108]	; (800580c <rt_test_006_006_execute+0x1ac>)
 800579e:	42b0      	cmp	r0, r6
 80057a0:	bfd4      	ite	le
 80057a2:	2000      	movle	r0, #0
 80057a4:	2001      	movgt	r0, #1
 80057a6:	f7fb faf3 	bl	8000d90 <_test_assert>
 80057aa:	4604      	mov	r4, r0
 80057ac:	2800      	cmp	r0, #0
 80057ae:	f47f af6f 	bne.w	8005690 <rt_test_006_006_execute+0x30>
 80057b2:	f380 8811 	msr	BASEPRI, r0
 80057b6:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 80057ba:	9803      	ldr	r0, [sp, #12]
 80057bc:	4912      	ldr	r1, [pc, #72]	; (8005808 <rt_test_006_006_execute+0x1a8>)
 80057be:	1e43      	subs	r3, r0, #1
 80057c0:	4258      	negs	r0, r3
 80057c2:	4158      	adcs	r0, r3
 80057c4:	f7fb fae4 	bl	8000d90 <_test_assert>
 80057c8:	b150      	cbz	r0, 80057e0 <rt_test_006_006_execute+0x180>
 80057ca:	f384 8811 	msr	BASEPRI, r4
 80057ce:	e761      	b.n	8005694 <rt_test_006_006_execute+0x34>
    chSemSignalI(&bsp->sem);
 80057d0:	4620      	mov	r0, r4
 80057d2:	f7fc f835 	bl	8001840 <chSemSignalI>
 80057d6:	e7ac      	b.n	8005732 <rt_test_006_006_execute+0xd2>
 80057d8:	4620      	mov	r0, r4
 80057da:	f7fc f831 	bl	8001840 <chSemSignalI>
 80057de:	e7d4      	b.n	800578a <rt_test_006_006_execute+0x12a>
 80057e0:	f380 8811 	msr	BASEPRI, r0
 80057e4:	e756      	b.n	8005694 <rt_test_006_006_execute+0x34>
 80057e6:	bf00      	nop
 80057e8:	20001d94 	.word	0x20001d94
 80057ec:	0800c124 	.word	0x0800c124
 80057f0:	20001254 	.word	0x20001254
 80057f4:	20001680 	.word	0x20001680
 80057f8:	08005841 	.word	0x08005841
 80057fc:	20001dac 	.word	0x20001dac
 8005800:	0800c130 	.word	0x0800c130
 8005804:	0800c144 	.word	0x0800c144
 8005808:	0800c150 	.word	0x0800c150
 800580c:	0800c128 	.word	0x0800c128

08005810 <thread2>:
static THD_FUNCTION(thread2, p) {
 8005810:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(50);
 8005812:	2064      	movs	r0, #100	; 0x64
 8005814:	f7fe fc14 	bl	8004040 <chThdSleep>
 8005818:	2320      	movs	r3, #32
 800581a:	f383 8811 	msr	BASEPRI, r3
  chSemSignalI(&sem1); /* For coverage reasons */
 800581e:	4804      	ldr	r0, [pc, #16]	; (8005830 <thread2+0x20>)
 8005820:	f7fc f80e 	bl	8001840 <chSemSignalI>
  chSchRescheduleS();
 8005824:	f7ff fb64 	bl	8004ef0 <chSchRescheduleS>
 8005828:	2300      	movs	r3, #0
 800582a:	f383 8811 	msr	BASEPRI, r3
}
 800582e:	bd08      	pop	{r3, pc}
 8005830:	20001660 	.word	0x20001660
	...

08005840 <thread4>:
static THD_FUNCTION(thread4, p) {
 8005840:	b508      	push	{r3, lr}
 8005842:	2220      	movs	r2, #32
 8005844:	f382 8811 	msr	BASEPRI, r2
  if (bsp->sem.cnt < (cnt_t)1) {
 8005848:	6883      	ldr	r3, [r0, #8]
 800584a:	2b00      	cmp	r3, #0
 800584c:	dd05      	ble.n	800585a <thread4+0x1a>
  chSchRescheduleS();
 800584e:	f7ff fb4f 	bl	8004ef0 <chSchRescheduleS>
 8005852:	2300      	movs	r3, #0
 8005854:	f383 8811 	msr	BASEPRI, r3
}
 8005858:	bd08      	pop	{r3, pc}
    chSemSignalI(&bsp->sem);
 800585a:	f7fb fff1 	bl	8001840 <chSemSignalI>
  chSchRescheduleS();
 800585e:	f7ff fb47 	bl	8004ef0 <chSchRescheduleS>
 8005862:	2300      	movs	r3, #0
 8005864:	f383 8811 	msr	BASEPRI, r3
 8005868:	bd08      	pop	{r3, pc}
 800586a:	bf00      	nop
 800586c:	0000      	movs	r0, r0
	...

08005870 <thread1.lto_priv.112>:
static THD_FUNCTION(thread1, p) {
 8005870:	b510      	push	{r4, lr}
 8005872:	2320      	movs	r3, #32
 8005874:	4604      	mov	r4, r0
 8005876:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 800587a:	4a09      	ldr	r2, [pc, #36]	; (80058a0 <thread1.lto_priv.112+0x30>)
 800587c:	6813      	ldr	r3, [r2, #0]
 800587e:	b12b      	cbz	r3, 800588c <thread1.lto_priv.112+0x1c>
    *trp = NULL;
 8005880:	2100      	movs	r1, #0
    (void) chSchReadyI(tp);
 8005882:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 8005884:	6259      	str	r1, [r3, #36]	; 0x24
    *trp = NULL;
 8005886:	6011      	str	r1, [r2, #0]
    (void) chSchReadyI(tp);
 8005888:	f7fb feb2 	bl	80015f0 <chSchReadyI>
  chSchRescheduleS();
 800588c:	f7ff fb30 	bl	8004ef0 <chSchRescheduleS>
 8005890:	2300      	movs	r3, #0
 8005892:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
 8005896:	7820      	ldrb	r0, [r4, #0]
}
 8005898:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(*(char *)p);
 800589c:	f7fb bb20 	b.w	8000ee0 <test_emit_token>
 80058a0:	20001dc0 	.word	0x20001dc0
	...

080058b0 <chGuardedPoolLoadArray>:
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
 80058b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80058b4:	4605      	mov	r5, r0
 80058b6:	460c      	mov	r4, r1
 80058b8:	4616      	mov	r6, r2
 80058ba:	f04f 0820 	mov.w	r8, #32
 80058be:	2700      	movs	r7, #0
 80058c0:	f388 8811 	msr	BASEPRI, r8
  php->next = mp->next;
 80058c4:	68eb      	ldr	r3, [r5, #12]
 * @iclass
 */
static inline void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 80058c6:	4628      	mov	r0, r5
 80058c8:	6023      	str	r3, [r4, #0]
  mp->next = php;
 80058ca:	60ec      	str	r4, [r5, #12]
 80058cc:	f7fb ffb8 	bl	8001840 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 80058d0:	f7ff fb0e 	bl	8004ef0 <chSchRescheduleS>
 80058d4:	f387 8811 	msr	BASEPRI, r7
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 80058d8:	692b      	ldr	r3, [r5, #16]
  while (n != 0U) {
 80058da:	3e01      	subs	r6, #1
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 80058dc:	441c      	add	r4, r3
  while (n != 0U) {
 80058de:	d1ef      	bne.n	80058c0 <chGuardedPoolLoadArray+0x10>
}
 80058e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

080058f0 <oslib_test_007_002_execute>:
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 80058f0:	4833      	ldr	r0, [pc, #204]	; (80059c0 <oslib_test_007_002_execute+0xd0>)
  test_set_step(1);
 80058f2:	2301      	movs	r3, #1
static void oslib_test_007_002_execute(void) {
 80058f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80058f8:	4606      	mov	r6, r0
  test_set_step(1);
 80058fa:	4f32      	ldr	r7, [pc, #200]	; (80059c4 <oslib_test_007_002_execute+0xd4>)
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 80058fc:	2204      	movs	r2, #4
 80058fe:	4932      	ldr	r1, [pc, #200]	; (80059c8 <oslib_test_007_002_execute+0xd8>)
  test_set_step(1);
 8005900:	603b      	str	r3, [r7, #0]
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 8005902:	f7ff ffd5 	bl	80058b0 <chGuardedPoolLoadArray>
  test_set_step(2);
 8005906:	2302      	movs	r3, #2
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8005908:	46b0      	mov	r8, r6
  test_set_step(2);
 800590a:	2404      	movs	r4, #4
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 800590c:	4d2f      	ldr	r5, [pc, #188]	; (80059cc <oslib_test_007_002_execute+0xdc>)
  test_set_step(2);
 800590e:	603b      	str	r3, [r7, #0]
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8005910:	2100      	movs	r1, #0
 8005912:	4640      	mov	r0, r8
 8005914:	f7fe f964 	bl	8003be0 <chGuardedPoolAllocTimeout>
 8005918:	3000      	adds	r0, #0
 800591a:	bf18      	it	ne
 800591c:	2001      	movne	r0, #1
 800591e:	4629      	mov	r1, r5
 8005920:	f7fb fa36 	bl	8000d90 <_test_assert>
 8005924:	2800      	cmp	r0, #0
 8005926:	d148      	bne.n	80059ba <oslib_test_007_002_execute+0xca>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8005928:	3c01      	subs	r4, #1
 800592a:	d1f1      	bne.n	8005910 <oslib_test_007_002_execute+0x20>
  test_set_step(3);
 800592c:	2303      	movs	r3, #3
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 800592e:	4621      	mov	r1, r4
 8005930:	4823      	ldr	r0, [pc, #140]	; (80059c0 <oslib_test_007_002_execute+0xd0>)
  test_set_step(3);
 8005932:	603b      	str	r3, [r7, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8005934:	f7fe f954 	bl	8003be0 <chGuardedPoolAllocTimeout>
 8005938:	fab0 f080 	clz	r0, r0
 800593c:	4924      	ldr	r1, [pc, #144]	; (80059d0 <oslib_test_007_002_execute+0xe0>)
 800593e:	0940      	lsrs	r0, r0, #5
 8005940:	f7fb fa26 	bl	8000d90 <_test_assert>
 8005944:	2800      	cmp	r0, #0
 8005946:	d138      	bne.n	80059ba <oslib_test_007_002_execute+0xca>
  test_set_step(4);
 8005948:	2304      	movs	r3, #4
 800594a:	f04f 0a20 	mov.w	sl, #32
 800594e:	4d1e      	ldr	r5, [pc, #120]	; (80059c8 <oslib_test_007_002_execute+0xd8>)
 8005950:	f8df 906c 	ldr.w	r9, [pc, #108]	; 80059c0 <oslib_test_007_002_execute+0xd0>
 8005954:	603b      	str	r3, [r7, #0]
 8005956:	f105 0810 	add.w	r8, r5, #16
      chGuardedPoolFree(&gmp1, &objects[i]);
 800595a:	462b      	mov	r3, r5
 800595c:	f38a 8811 	msr	BASEPRI, sl
  php->next = mp->next;
 8005960:	68f2      	ldr	r2, [r6, #12]
 8005962:	4648      	mov	r0, r9
 8005964:	f845 2b04 	str.w	r2, [r5], #4
  mp->next = php;
 8005968:	60f3      	str	r3, [r6, #12]
 800596a:	f7fb ff69 	bl	8001840 <chSemSignalI>
  chSchRescheduleS();
 800596e:	f7ff fabf 	bl	8004ef0 <chSchRescheduleS>
 8005972:	f384 8811 	msr	BASEPRI, r4
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8005976:	4545      	cmp	r5, r8
 8005978:	d1ef      	bne.n	800595a <oslib_test_007_002_execute+0x6a>
  test_set_step(5);
 800597a:	2305      	movs	r3, #5
 800597c:	2404      	movs	r4, #4
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 800597e:	4e10      	ldr	r6, [pc, #64]	; (80059c0 <oslib_test_007_002_execute+0xd0>)
 8005980:	4d12      	ldr	r5, [pc, #72]	; (80059cc <oslib_test_007_002_execute+0xdc>)
  test_set_step(5);
 8005982:	603b      	str	r3, [r7, #0]
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8005984:	2100      	movs	r1, #0
 8005986:	4630      	mov	r0, r6
 8005988:	f7fe f92a 	bl	8003be0 <chGuardedPoolAllocTimeout>
 800598c:	3000      	adds	r0, #0
 800598e:	bf18      	it	ne
 8005990:	2001      	movne	r0, #1
 8005992:	4629      	mov	r1, r5
 8005994:	f7fb f9fc 	bl	8000d90 <_test_assert>
 8005998:	b978      	cbnz	r0, 80059ba <oslib_test_007_002_execute+0xca>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800599a:	3c01      	subs	r4, #1
 800599c:	d1f2      	bne.n	8005984 <oslib_test_007_002_execute+0x94>
  test_set_step(6);
 800599e:	2306      	movs	r3, #6
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80059a0:	4621      	mov	r1, r4
 80059a2:	4807      	ldr	r0, [pc, #28]	; (80059c0 <oslib_test_007_002_execute+0xd0>)
  test_set_step(6);
 80059a4:	603b      	str	r3, [r7, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80059a6:	f7fe f91b 	bl	8003be0 <chGuardedPoolAllocTimeout>
}
 80059aa:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80059ae:	fab0 f080 	clz	r0, r0
 80059b2:	4907      	ldr	r1, [pc, #28]	; (80059d0 <oslib_test_007_002_execute+0xe0>)
 80059b4:	0940      	lsrs	r0, r0, #5
 80059b6:	f7fb b9eb 	b.w	8000d90 <_test_assert>
}
 80059ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80059be:	bf00      	nop
 80059c0:	20000c14 	.word	0x20000c14
 80059c4:	20001d94 	.word	0x20001d94
 80059c8:	20001650 	.word	0x20001650
 80059cc:	0800b3a4 	.word	0x0800b3a4
 80059d0:	0800b3b0 	.word	0x0800b3b0
	...

080059e0 <chMBFetchTimeout>:
msg_t chMBFetchTimeout(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 80059e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80059e2:	4604      	mov	r4, r0
 80059e4:	460f      	mov	r7, r1
 80059e6:	4616      	mov	r6, r2
 80059e8:	2320      	movs	r3, #32
 80059ea:	f383 8811 	msr	BASEPRI, r3
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 80059ee:	18c5      	adds	r5, r0, r3
 80059f0:	e006      	b.n	8005a00 <chMBFetchTimeout+0x20>
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
 80059f2:	6923      	ldr	r3, [r4, #16]
 80059f4:	b96b      	cbnz	r3, 8005a12 <chMBFetchTimeout+0x32>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 80059f6:	4631      	mov	r1, r6
 80059f8:	4628      	mov	r0, r5
 80059fa:	f7fe f941 	bl	8003c80 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 80059fe:	b920      	cbnz	r0, 8005a0a <chMBFetchTimeout+0x2a>
    if (mbp->reset) {
 8005a00:	7d23      	ldrb	r3, [r4, #20]
 8005a02:	2b00      	cmp	r3, #0
 8005a04:	d0f5      	beq.n	80059f2 <chMBFetchTimeout+0x12>
      return MSG_RESET;
 8005a06:	f06f 0001 	mvn.w	r0, #1
 8005a0a:	2300      	movs	r3, #0
 8005a0c:	f383 8811 	msr	BASEPRI, r3
}
 8005a10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      *msgp = *mbp->rdptr++;
 8005a12:	68e1      	ldr	r1, [r4, #12]
      if (mbp->rdptr >= mbp->top) {
 8005a14:	6860      	ldr	r0, [r4, #4]
      *msgp = *mbp->rdptr++;
 8005a16:	1d0a      	adds	r2, r1, #4
      if (mbp->rdptr >= mbp->top) {
 8005a18:	4282      	cmp	r2, r0
      *msgp = *mbp->rdptr++;
 8005a1a:	6809      	ldr	r1, [r1, #0]
 8005a1c:	60e2      	str	r2, [r4, #12]
        mbp->rdptr = mbp->buffer;
 8005a1e:	bf28      	it	cs
 8005a20:	6822      	ldrcs	r2, [r4, #0]
      mbp->cnt--;
 8005a22:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
      *msgp = *mbp->rdptr++;
 8005a26:	6039      	str	r1, [r7, #0]
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8005a28:	f104 0018 	add.w	r0, r4, #24
        mbp->rdptr = mbp->buffer;
 8005a2c:	bf28      	it	cs
 8005a2e:	60e2      	strcs	r2, [r4, #12]
      mbp->cnt--;
 8005a30:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8005a32:	f7fb fe0d 	bl	8001650 <chThdDequeueNextI.constprop.95>
      chSchRescheduleS();
 8005a36:	f7ff fa5b 	bl	8004ef0 <chSchRescheduleS>
      return MSG_OK;
 8005a3a:	2000      	movs	r0, #0
 8005a3c:	2300      	movs	r3, #0
 8005a3e:	f383 8811 	msr	BASEPRI, r3
}
 8005a42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08005a50 <Thread1.lto_priv.107>:

static THD_WORKING_AREA(wa1Thread1, 256);
static THD_WORKING_AREA(wa2Thread1, 256);
static THD_FUNCTION(Thread1, arg) {
 8005a50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005a54:	4e11      	ldr	r6, [pc, #68]	; (8005a9c <Thread1.lto_priv.107+0x4c>)
 8005a56:	b082      	sub	sp, #8
 8005a58:	46b0      	mov	r8, r6
 */
static inline msg_t chJobDispatch(jobs_queue_t *jqp) {
  msg_t msg, jmsg;

  /* Waiting for a job.*/
  msg = chMBFetchTimeout(&jqp->mbx, &jmsg, TIME_INFINITE);
 8005a5a:	f106 071c 	add.w	r7, r6, #28
 8005a5e:	e011      	b.n	8005a84 <Thread1.lto_priv.107+0x34>
  if (msg == MSG_OK) {
    job_descriptor_t *jp = (job_descriptor_t *)jmsg;
 8005a60:	9c01      	ldr	r4, [sp, #4]

    chDbgAssert(jp != NULL, "is NULL");

    if (jp->jobfunc != NULL) {
 8005a62:	6823      	ldr	r3, [r4, #0]
 8005a64:	b1bb      	cbz	r3, 8005a96 <Thread1.lto_priv.107+0x46>

      /* Invoking the job function.*/
      jp->jobfunc(jp->jobarg);
 8005a66:	6860      	ldr	r0, [r4, #4]
 8005a68:	4798      	blx	r3
 8005a6a:	2320      	movs	r3, #32
 8005a6c:	f383 8811 	msr	BASEPRI, r3
  php->next = mp->next;
 8005a70:	68f3      	ldr	r3, [r6, #12]
 8005a72:	4640      	mov	r0, r8
 8005a74:	6023      	str	r3, [r4, #0]
  mp->next = php;
 8005a76:	60f4      	str	r4, [r6, #12]
 8005a78:	f7fb fee2 	bl	8001840 <chSemSignalI>
  chSchRescheduleS();
 8005a7c:	f7ff fa38 	bl	8004ef0 <chSchRescheduleS>
 8005a80:	f385 8811 	msr	BASEPRI, r5
  msg = chMBFetchTimeout(&jqp->mbx, &jmsg, TIME_INFINITE);
 8005a84:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005a88:	a901      	add	r1, sp, #4
 8005a8a:	4638      	mov	r0, r7
 8005a8c:	f7ff ffa8 	bl	80059e0 <chMBFetchTimeout>
  if (msg == MSG_OK) {
 8005a90:	4605      	mov	r5, r0
 8005a92:	2800      	cmp	r0, #0
 8005a94:	d0e4      	beq.n	8005a60 <Thread1.lto_priv.107+0x10>
  (void)arg;

  do {
    msg = chJobDispatch(&jq);
  } while (msg == MSG_OK);
}
 8005a96:	b002      	add	sp, #8
 8005a98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005a9c:	200014dc 	.word	0x200014dc

08005aa0 <chMBPostTimeout>:
msg_t chMBPostTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8005aa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005aa2:	4604      	mov	r4, r0
 8005aa4:	460f      	mov	r7, r1
 8005aa6:	4616      	mov	r6, r2
 8005aa8:	2320      	movs	r3, #32
 8005aaa:	f383 8811 	msr	BASEPRI, r3
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8005aae:	f100 0518 	add.w	r5, r0, #24
 8005ab2:	e00b      	b.n	8005acc <chMBPostTimeout+0x2c>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005ab4:	6923      	ldr	r3, [r4, #16]
 8005ab6:	e9d4 1200 	ldrd	r1, r2, [r4]
  return (size_t)(mbp->top - mbp->buffer);
 8005aba:	1a50      	subs	r0, r2, r1
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8005abc:	ebb3 0fa0 	cmp.w	r3, r0, asr #2
 8005ac0:	d10d      	bne.n	8005ade <chMBPostTimeout+0x3e>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8005ac2:	4631      	mov	r1, r6
 8005ac4:	4628      	mov	r0, r5
 8005ac6:	f7fe f8db 	bl	8003c80 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8005aca:	b920      	cbnz	r0, 8005ad6 <chMBPostTimeout+0x36>
    if (mbp->reset) {
 8005acc:	7d23      	ldrb	r3, [r4, #20]
 8005ace:	2b00      	cmp	r3, #0
 8005ad0:	d0f0      	beq.n	8005ab4 <chMBPostTimeout+0x14>
      return MSG_RESET;
 8005ad2:	f06f 0001 	mvn.w	r0, #1
 8005ad6:	2300      	movs	r3, #0
 8005ad8:	f383 8811 	msr	BASEPRI, r3
}
 8005adc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      *mbp->wrptr++ = msg;
 8005ade:	68a5      	ldr	r5, [r4, #8]
      mbp->cnt++;
 8005ae0:	3301      	adds	r3, #1
      *mbp->wrptr++ = msg;
 8005ae2:	1d28      	adds	r0, r5, #4
      if (mbp->wrptr >= mbp->top) {
 8005ae4:	4282      	cmp	r2, r0
      *mbp->wrptr++ = msg;
 8005ae6:	60a0      	str	r0, [r4, #8]
 8005ae8:	602f      	str	r7, [r5, #0]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8005aea:	f104 0020 	add.w	r0, r4, #32
        mbp->wrptr = mbp->buffer;
 8005aee:	bf98      	it	ls
 8005af0:	60a1      	strls	r1, [r4, #8]
      mbp->cnt++;
 8005af2:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8005af4:	f7fb fdac 	bl	8001650 <chThdDequeueNextI.constprop.95>
      chSchRescheduleS();
 8005af8:	f7ff f9fa 	bl	8004ef0 <chSchRescheduleS>
      return MSG_OK;
 8005afc:	2000      	movs	r0, #0
 8005afe:	2300      	movs	r3, #0
 8005b00:	f383 8811 	msr	BASEPRI, r3
}
 8005b04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005b06:	bf00      	nop
	...

08005b10 <oslib_test_002_003_execute>:
}

static void oslib_test_002_003_execute(void) {
 8005b10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005b14:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8005c30 <oslib_test_002_003_execute+0x120>
  msg_t msg1, msg2;
  unsigned i;

  /* [2.3.1] Filling the mailbox.*/
  test_set_step(1);
 8005b18:	2301      	movs	r3, #1
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8005b1a:	4646      	mov	r6, r8
  test_set_step(1);
 8005b1c:	2442      	movs	r4, #66	; 0x42
 8005b1e:	4f42      	ldr	r7, [pc, #264]	; (8005c28 <oslib_test_002_003_execute+0x118>)
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005b20:	4d42      	ldr	r5, [pc, #264]	; (8005c2c <oslib_test_002_003_execute+0x11c>)
static void oslib_test_002_003_execute(void) {
 8005b22:	b082      	sub	sp, #8
  test_set_step(1);
 8005b24:	603b      	str	r3, [r7, #0]
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8005b26:	4621      	mov	r1, r4
 8005b28:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005b2c:	4630      	mov	r0, r6
 8005b2e:	f7ff ffb7 	bl	8005aa0 <chMBPostTimeout>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005b32:	fab0 f080 	clz	r0, r0
 8005b36:	4629      	mov	r1, r5
 8005b38:	0940      	lsrs	r0, r0, #5
 8005b3a:	f7fb f929 	bl	8000d90 <_test_assert>
 8005b3e:	3401      	adds	r4, #1
 8005b40:	b990      	cbnz	r0, 8005b68 <oslib_test_002_003_execute+0x58>
    for (i = 0; i < MB_SIZE; i++) {
 8005b42:	2c46      	cmp	r4, #70	; 0x46
 8005b44:	d1ef      	bne.n	8005b26 <oslib_test_002_003_execute+0x16>
  }
  test_end_step(1);

  /* [2.3.2] Testing chMBPostTimeout(), chMBPostI(),
     chMBPostAheadTimeout() and chMBPostAheadI() timeout.*/
  test_set_step(2);
 8005b46:	2302      	movs	r3, #2
  {
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
 8005b48:	2201      	movs	r2, #1
 8005b4a:	2158      	movs	r1, #88	; 0x58
 8005b4c:	4838      	ldr	r0, [pc, #224]	; (8005c30 <oslib_test_002_003_execute+0x120>)
  test_set_step(2);
 8005b4e:	603b      	str	r3, [r7, #0]
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
 8005b50:	f7ff ffa6 	bl	8005aa0 <chMBPostTimeout>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005b54:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8005b58:	fab0 f080 	clz	r0, r0
 8005b5c:	4933      	ldr	r1, [pc, #204]	; (8005c2c <oslib_test_002_003_execute+0x11c>)
 8005b5e:	0940      	lsrs	r0, r0, #5
 8005b60:	f7fb f916 	bl	8000d90 <_test_assert>
 8005b64:	4604      	mov	r4, r0
 8005b66:	b110      	cbz	r0, 8005b6e <oslib_test_002_003_execute+0x5e>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  }
  test_end_step(4);
}
 8005b68:	b002      	add	sp, #8
 8005b6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005b6e:	2520      	movs	r5, #32
 8005b70:	f385 8811 	msr	BASEPRI, r5
    msg1 = chMBPostI(&mb1, 'X');
 8005b74:	2058      	movs	r0, #88	; 0x58
 8005b76:	f7fb fd7b 	bl	8001670 <chMBPostI.constprop.37>
 8005b7a:	f384 8811 	msr	BASEPRI, r4
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005b7e:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8005b82:	fab0 f080 	clz	r0, r0
 8005b86:	4929      	ldr	r1, [pc, #164]	; (8005c2c <oslib_test_002_003_execute+0x11c>)
 8005b88:	0940      	lsrs	r0, r0, #5
 8005b8a:	f7fb f901 	bl	8000d90 <_test_assert>
 8005b8e:	2800      	cmp	r0, #0
 8005b90:	d1ea      	bne.n	8005b68 <oslib_test_002_003_execute+0x58>
    msg1 = chMBPostAheadTimeout(&mb1, 'X', 1);
 8005b92:	2101      	movs	r1, #1
 8005b94:	2058      	movs	r0, #88	; 0x58
 8005b96:	f7ff fb03 	bl	80051a0 <chMBPostAheadTimeout.constprop.35>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005b9a:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8005b9e:	fab0 f080 	clz	r0, r0
 8005ba2:	4922      	ldr	r1, [pc, #136]	; (8005c2c <oslib_test_002_003_execute+0x11c>)
 8005ba4:	0940      	lsrs	r0, r0, #5
 8005ba6:	f7fb f8f3 	bl	8000d90 <_test_assert>
 8005baa:	4604      	mov	r4, r0
 8005bac:	2800      	cmp	r0, #0
 8005bae:	d1db      	bne.n	8005b68 <oslib_test_002_003_execute+0x58>
 8005bb0:	f385 8811 	msr	BASEPRI, r5
    msg1 = chMBPostAheadI(&mb1, 'X');
 8005bb4:	2058      	movs	r0, #88	; 0x58
 8005bb6:	f7fb fd83 	bl	80016c0 <chMBPostAheadI.constprop.34>
 8005bba:	f384 8811 	msr	BASEPRI, r4
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005bbe:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8005bc2:	fab0 f080 	clz	r0, r0
 8005bc6:	4919      	ldr	r1, [pc, #100]	; (8005c2c <oslib_test_002_003_execute+0x11c>)
 8005bc8:	0940      	lsrs	r0, r0, #5
 8005bca:	f7fb f8e1 	bl	8000d90 <_test_assert>
 8005bce:	4604      	mov	r4, r0
 8005bd0:	2800      	cmp	r0, #0
 8005bd2:	d1c9      	bne.n	8005b68 <oslib_test_002_003_execute+0x58>
  test_set_step(3);
 8005bd4:	2303      	movs	r3, #3
 8005bd6:	603b      	str	r3, [r7, #0]
    chMBReset(&mb1);
 8005bd8:	f7ff faaa 	bl	8005130 <chMBReset.constprop.38>
  test_set_step(4);
 8005bdc:	2304      	movs	r3, #4
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
 8005bde:	2201      	movs	r2, #1
 8005be0:	eb0d 0103 	add.w	r1, sp, r3
 8005be4:	4812      	ldr	r0, [pc, #72]	; (8005c30 <oslib_test_002_003_execute+0x120>)
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {

  mbp->reset = false;
 8005be6:	f888 4014 	strb.w	r4, [r8, #20]
  test_set_step(4);
 8005bea:	603b      	str	r3, [r7, #0]
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
 8005bec:	f7ff fef8 	bl	80059e0 <chMBFetchTimeout>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005bf0:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8005bf4:	fab0 f080 	clz	r0, r0
 8005bf8:	490c      	ldr	r1, [pc, #48]	; (8005c2c <oslib_test_002_003_execute+0x11c>)
 8005bfa:	0940      	lsrs	r0, r0, #5
 8005bfc:	f7fb f8c8 	bl	8000d90 <_test_assert>
 8005c00:	4604      	mov	r4, r0
 8005c02:	2800      	cmp	r0, #0
 8005c04:	d1b0      	bne.n	8005b68 <oslib_test_002_003_execute+0x58>
 8005c06:	f385 8811 	msr	BASEPRI, r5
    msg1 = chMBFetchI(&mb1, &msg2);
 8005c0a:	a801      	add	r0, sp, #4
 8005c0c:	f7fb fd80 	bl	8001710 <chMBFetchI.constprop.33>
 8005c10:	f384 8811 	msr	BASEPRI, r4
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005c14:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8005c18:	fab0 f080 	clz	r0, r0
 8005c1c:	4903      	ldr	r1, [pc, #12]	; (8005c2c <oslib_test_002_003_execute+0x11c>)
 8005c1e:	0940      	lsrs	r0, r0, #5
 8005c20:	f7fb f8b6 	bl	8000d90 <_test_assert>
 8005c24:	e7a0      	b.n	8005b68 <oslib_test_002_003_execute+0x58>
 8005c26:	bf00      	nop
 8005c28:	20001d94 	.word	0x20001d94
 8005c2c:	0800b238 	.word	0x0800b238
 8005c30:	20000c58 	.word	0x20000c58
	...

08005c40 <oslib_test_002_002_execute>:
static void oslib_test_002_002_execute(void) {
 8005c40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  test_set_step(1);
 8005c44:	f04f 0801 	mov.w	r8, #1
 8005c48:	4fad      	ldr	r7, [pc, #692]	; (8005f00 <oslib_test_002_002_execute+0x2c0>)
static void oslib_test_002_002_execute(void) {
 8005c4a:	b082      	sub	sp, #8
 8005c4c:	2620      	movs	r6, #32
  test_set_step(1);
 8005c4e:	f8c7 8000 	str.w	r8, [r7]
 8005c52:	f386 8811 	msr	BASEPRI, r6
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005c56:	4cab      	ldr	r4, [pc, #684]	; (8005f04 <oslib_test_002_002_execute+0x2c4>)
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8005c58:	49ab      	ldr	r1, [pc, #684]	; (8005f08 <oslib_test_002_002_execute+0x2c8>)
 8005c5a:	6920      	ldr	r0, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8005c5c:	e9d4 2300 	ldrd	r2, r3, [r4]
 8005c60:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005c62:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
 8005c66:	f1a0 0004 	sub.w	r0, r0, #4
 8005c6a:	fab0 f080 	clz	r0, r0
 8005c6e:	0940      	lsrs	r0, r0, #5
 8005c70:	f7fb f88e 	bl	8000d90 <_test_assert>
 8005c74:	b128      	cbz	r0, 8005c82 <oslib_test_002_002_execute+0x42>
 8005c76:	2300      	movs	r3, #0
 8005c78:	f383 8811 	msr	BASEPRI, r3
}
 8005c7c:	b002      	add	sp, #8
 8005c7e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005c82:	4605      	mov	r5, r0
 8005c84:	f380 8811 	msr	BASEPRI, r0
  test_set_step(2);
 8005c88:	2302      	movs	r3, #2
 8005c8a:	603b      	str	r3, [r7, #0]
 8005c8c:	f386 8811 	msr	BASEPRI, r6
  mbp->wrptr = mbp->buffer;
 8005c90:	6823      	ldr	r3, [r4, #0]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8005c92:	f104 0018 	add.w	r0, r4, #24
  mbp->rdptr = mbp->buffer;
 8005c96:	e9c4 3302 	strd	r3, r3, [r4, #8]
  mbp->cnt   = (size_t)0;
 8005c9a:	6125      	str	r5, [r4, #16]
  mbp->reset = true;
 8005c9c:	f884 8014 	strb.w	r8, [r4, #20]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8005ca0:	f7fb fcbe 	bl	8001620 <chThdDequeueAllI.constprop.97>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8005ca4:	f104 0020 	add.w	r0, r4, #32
 8005ca8:	f7fb fcba 	bl	8001620 <chThdDequeueAllI.constprop.97>
 8005cac:	f385 8811 	msr	BASEPRI, r5
 8005cb0:	f386 8811 	msr	BASEPRI, r6
  return (size_t)(mbp->top - mbp->buffer);
 8005cb4:	e9d4 2300 	ldrd	r2, r3, [r4]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005cb8:	6920      	ldr	r0, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8005cba:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005cbc:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8005cc0:	f1a0 0004 	sub.w	r0, r0, #4
 8005cc4:	fab0 f080 	clz	r0, r0
 8005cc8:	4990      	ldr	r1, [pc, #576]	; (8005f0c <oslib_test_002_002_execute+0x2cc>)
 8005cca:	0940      	lsrs	r0, r0, #5
 8005ccc:	f7fb f860 	bl	8000d90 <_test_assert>
 8005cd0:	4680      	mov	r8, r0
 8005cd2:	b120      	cbz	r0, 8005cde <oslib_test_002_002_execute+0x9e>
 8005cd4:	f385 8811 	msr	BASEPRI, r5
}
 8005cd8:	b002      	add	sp, #8
 8005cda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005cde:	f380 8811 	msr	BASEPRI, r0
 8005ce2:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8005ce6:	6920      	ldr	r0, [r4, #16]
 8005ce8:	4989      	ldr	r1, [pc, #548]	; (8005f10 <oslib_test_002_002_execute+0x2d0>)
 8005cea:	fab0 f080 	clz	r0, r0
 8005cee:	0940      	lsrs	r0, r0, #5
 8005cf0:	f7fb f84e 	bl	8000d90 <_test_assert>
 8005cf4:	4605      	mov	r5, r0
 8005cf6:	b110      	cbz	r0, 8005cfe <oslib_test_002_002_execute+0xbe>
 8005cf8:	f388 8811 	msr	BASEPRI, r8
 8005cfc:	e7be      	b.n	8005c7c <oslib_test_002_002_execute+0x3c>
 8005cfe:	f380 8811 	msr	BASEPRI, r0
 8005d02:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8005d06:	6820      	ldr	r0, [r4, #0]
 8005d08:	68a3      	ldr	r3, [r4, #8]
 8005d0a:	4982      	ldr	r1, [pc, #520]	; (8005f14 <oslib_test_002_002_execute+0x2d4>)
 8005d0c:	1ac0      	subs	r0, r0, r3
 8005d0e:	fab0 f080 	clz	r0, r0
 8005d12:	0940      	lsrs	r0, r0, #5
 8005d14:	f7fb f83c 	bl	8000d90 <_test_assert>
 8005d18:	4680      	mov	r8, r0
 8005d1a:	2800      	cmp	r0, #0
 8005d1c:	d1da      	bne.n	8005cd4 <oslib_test_002_002_execute+0x94>
 8005d1e:	f380 8811 	msr	BASEPRI, r0
 8005d22:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8005d26:	6820      	ldr	r0, [r4, #0]
 8005d28:	68e3      	ldr	r3, [r4, #12]
 8005d2a:	497b      	ldr	r1, [pc, #492]	; (8005f18 <oslib_test_002_002_execute+0x2d8>)
 8005d2c:	1ac0      	subs	r0, r0, r3
 8005d2e:	fab0 f080 	clz	r0, r0
 8005d32:	0940      	lsrs	r0, r0, #5
 8005d34:	f7fb f82c 	bl	8000d90 <_test_assert>
 8005d38:	2800      	cmp	r0, #0
 8005d3a:	d1dd      	bne.n	8005cf8 <oslib_test_002_002_execute+0xb8>
 8005d3c:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 8005d40:	2303      	movs	r3, #3
 8005d42:	4681      	mov	r9, r0
 8005d44:	2542      	movs	r5, #66	; 0x42
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005d46:	f8df a1d4 	ldr.w	sl, [pc, #468]	; 8005f1c <oslib_test_002_002_execute+0x2dc>
  mbp->reset = false;
 8005d4a:	7520      	strb	r0, [r4, #20]
  test_set_step(3);
 8005d4c:	603b      	str	r3, [r7, #0]
 8005d4e:	f386 8811 	msr	BASEPRI, r6
      msg1 = chMBPostI(&mb1, 'B' + i);
 8005d52:	4628      	mov	r0, r5
 8005d54:	f7fb fc8c 	bl	8001670 <chMBPostI.constprop.37>
 8005d58:	f389 8811 	msr	BASEPRI, r9
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005d5c:	fab0 f080 	clz	r0, r0
 8005d60:	4651      	mov	r1, sl
 8005d62:	0940      	lsrs	r0, r0, #5
 8005d64:	f7fb f814 	bl	8000d90 <_test_assert>
 8005d68:	3501      	adds	r5, #1
 8005d6a:	4680      	mov	r8, r0
 8005d6c:	2800      	cmp	r0, #0
 8005d6e:	d185      	bne.n	8005c7c <oslib_test_002_002_execute+0x3c>
    for (i = 0; i < MB_SIZE - 1; i++) {
 8005d70:	2d45      	cmp	r5, #69	; 0x45
 8005d72:	d1ec      	bne.n	8005d4e <oslib_test_002_002_execute+0x10e>
 8005d74:	f386 8811 	msr	BASEPRI, r6
    msg1 = chMBPostAheadI(&mb1, 'A');
 8005d78:	2041      	movs	r0, #65	; 0x41
 8005d7a:	f7fb fca1 	bl	80016c0 <chMBPostAheadI.constprop.34>
 8005d7e:	f388 8811 	msr	BASEPRI, r8
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005d82:	fab0 f080 	clz	r0, r0
 8005d86:	4965      	ldr	r1, [pc, #404]	; (8005f1c <oslib_test_002_002_execute+0x2dc>)
 8005d88:	0940      	lsrs	r0, r0, #5
 8005d8a:	f7fb f801 	bl	8000d90 <_test_assert>
 8005d8e:	4605      	mov	r5, r0
 8005d90:	2800      	cmp	r0, #0
 8005d92:	f47f af73 	bne.w	8005c7c <oslib_test_002_002_execute+0x3c>
  test_set_step(4);
 8005d96:	f04f 0804 	mov.w	r8, #4
 8005d9a:	f8c7 8000 	str.w	r8, [r7]
 8005d9e:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 8005da2:	6922      	ldr	r2, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8005da4:	e9d4 1300 	ldrd	r1, r3, [r4]
 8005da8:	1a5b      	subs	r3, r3, r1
 8005daa:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 8005dae:	bf0c      	ite	eq
 8005db0:	2001      	moveq	r0, #1
 8005db2:	2000      	movne	r0, #0
 8005db4:	495a      	ldr	r1, [pc, #360]	; (8005f20 <oslib_test_002_002_execute+0x2e0>)
 8005db6:	f7fa ffeb 	bl	8000d90 <_test_assert>
 8005dba:	4681      	mov	r9, r0
 8005dbc:	2800      	cmp	r0, #0
 8005dbe:	d189      	bne.n	8005cd4 <oslib_test_002_002_execute+0x94>
 8005dc0:	f380 8811 	msr	BASEPRI, r0
 8005dc4:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8005dc8:	6920      	ldr	r0, [r4, #16]
 8005dca:	4956      	ldr	r1, [pc, #344]	; (8005f24 <oslib_test_002_002_execute+0x2e4>)
 8005dcc:	f1a0 0004 	sub.w	r0, r0, #4
 8005dd0:	fab0 f080 	clz	r0, r0
 8005dd4:	0940      	lsrs	r0, r0, #5
 8005dd6:	f7fa ffdb 	bl	8000d90 <_test_assert>
 8005dda:	4605      	mov	r5, r0
 8005ddc:	b110      	cbz	r0, 8005de4 <oslib_test_002_002_execute+0x1a4>
 8005dde:	f389 8811 	msr	BASEPRI, r9
 8005de2:	e74b      	b.n	8005c7c <oslib_test_002_002_execute+0x3c>
 8005de4:	f380 8811 	msr	BASEPRI, r0
 8005de8:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8005dec:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
 8005df0:	1ac6      	subs	r6, r0, r3
 8005df2:	4270      	negs	r0, r6
 8005df4:	4170      	adcs	r0, r6
 8005df6:	494c      	ldr	r1, [pc, #304]	; (8005f28 <oslib_test_002_002_execute+0x2e8>)
 8005df8:	f7fa ffca 	bl	8000d90 <_test_assert>
 8005dfc:	2800      	cmp	r0, #0
 8005dfe:	f47f af69 	bne.w	8005cd4 <oslib_test_002_002_execute+0x94>
 8005e02:	f380 8811 	msr	BASEPRI, r0
  test_set_step(5);
 8005e06:	2305      	movs	r3, #5
 8005e08:	4645      	mov	r5, r8
 8005e0a:	4606      	mov	r6, r0
 8005e0c:	f04f 0820 	mov.w	r8, #32
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005e10:	f8df 9108 	ldr.w	r9, [pc, #264]	; 8005f1c <oslib_test_002_002_execute+0x2dc>
  test_set_step(5);
 8005e14:	603b      	str	r3, [r7, #0]
 8005e16:	f388 8811 	msr	BASEPRI, r8
      msg1 = chMBFetchI(&mb1, &msg2);
 8005e1a:	a801      	add	r0, sp, #4
 8005e1c:	f7fb fc78 	bl	8001710 <chMBFetchI.constprop.33>
 8005e20:	f386 8811 	msr	BASEPRI, r6
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005e24:	fab0 f080 	clz	r0, r0
 8005e28:	4649      	mov	r1, r9
 8005e2a:	0940      	lsrs	r0, r0, #5
 8005e2c:	f7fa ffb0 	bl	8000d90 <_test_assert>
 8005e30:	2800      	cmp	r0, #0
 8005e32:	f47f af23 	bne.w	8005c7c <oslib_test_002_002_execute+0x3c>
      test_emit_token(msg2);
 8005e36:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8005e3a:	f7fb f851 	bl	8000ee0 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 8005e3e:	3d01      	subs	r5, #1
 8005e40:	d1e9      	bne.n	8005e16 <oslib_test_002_002_execute+0x1d6>
    test_assert_sequence("ABCD", "wrong get sequence");
 8005e42:	493a      	ldr	r1, [pc, #232]	; (8005f2c <oslib_test_002_002_execute+0x2ec>)
 8005e44:	483a      	ldr	r0, [pc, #232]	; (8005f30 <oslib_test_002_002_execute+0x2f0>)
 8005e46:	f7fb f923 	bl	8001090 <_test_assert_sequence>
 8005e4a:	2800      	cmp	r0, #0
 8005e4c:	f47f af16 	bne.w	8005c7c <oslib_test_002_002_execute+0x3c>
  test_set_step(6);
 8005e50:	2306      	movs	r3, #6
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8005e52:	2146      	movs	r1, #70	; 0x46
 8005e54:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005e58:	482a      	ldr	r0, [pc, #168]	; (8005f04 <oslib_test_002_002_execute+0x2c4>)
  test_set_step(6);
 8005e5a:	603b      	str	r3, [r7, #0]
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8005e5c:	f7ff fe20 	bl	8005aa0 <chMBPostTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005e60:	fab0 f080 	clz	r0, r0
 8005e64:	492d      	ldr	r1, [pc, #180]	; (8005f1c <oslib_test_002_002_execute+0x2dc>)
 8005e66:	0940      	lsrs	r0, r0, #5
 8005e68:	f7fa ff92 	bl	8000d90 <_test_assert>
 8005e6c:	2800      	cmp	r0, #0
 8005e6e:	f47f af05 	bne.w	8005c7c <oslib_test_002_002_execute+0x3c>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8005e72:	a901      	add	r1, sp, #4
 8005e74:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005e78:	4822      	ldr	r0, [pc, #136]	; (8005f04 <oslib_test_002_002_execute+0x2c4>)
 8005e7a:	f7ff fdb1 	bl	80059e0 <chMBFetchTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005e7e:	fab0 f080 	clz	r0, r0
 8005e82:	4926      	ldr	r1, [pc, #152]	; (8005f1c <oslib_test_002_002_execute+0x2dc>)
 8005e84:	0940      	lsrs	r0, r0, #5
 8005e86:	f7fa ff83 	bl	8000d90 <_test_assert>
 8005e8a:	2800      	cmp	r0, #0
 8005e8c:	f47f aef6 	bne.w	8005c7c <oslib_test_002_002_execute+0x3c>
  test_set_step(7);
 8005e90:	2307      	movs	r3, #7
 8005e92:	603b      	str	r3, [r7, #0]
 8005e94:	f388 8811 	msr	BASEPRI, r8
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005e98:	6923      	ldr	r3, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8005e9a:	e9d4 1200 	ldrd	r1, r2, [r4]
 8005e9e:	1a52      	subs	r2, r2, r1
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005ea0:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8005ea4:	1f19      	subs	r1, r3, #4
 8005ea6:	4248      	negs	r0, r1
 8005ea8:	4148      	adcs	r0, r1
 8005eaa:	4918      	ldr	r1, [pc, #96]	; (8005f0c <oslib_test_002_002_execute+0x2cc>)
 8005eac:	f7fa ff70 	bl	8000d90 <_test_assert>
 8005eb0:	2800      	cmp	r0, #0
 8005eb2:	f47f af0f 	bne.w	8005cd4 <oslib_test_002_002_execute+0x94>
 8005eb6:	f385 8811 	msr	BASEPRI, r5
 8005eba:	f388 8811 	msr	BASEPRI, r8
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8005ebe:	6920      	ldr	r0, [r4, #16]
 8005ec0:	4913      	ldr	r1, [pc, #76]	; (8005f10 <oslib_test_002_002_execute+0x2d0>)
 8005ec2:	fab0 f080 	clz	r0, r0
 8005ec6:	0940      	lsrs	r0, r0, #5
 8005ec8:	f7fa ff62 	bl	8000d90 <_test_assert>
 8005ecc:	2800      	cmp	r0, #0
 8005ece:	f47f af01 	bne.w	8005cd4 <oslib_test_002_002_execute+0x94>
 8005ed2:	f385 8811 	msr	BASEPRI, r5
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8005ed6:	6820      	ldr	r0, [r4, #0]
 8005ed8:	68a3      	ldr	r3, [r4, #8]
 8005eda:	490e      	ldr	r1, [pc, #56]	; (8005f14 <oslib_test_002_002_execute+0x2d4>)
 8005edc:	1ac2      	subs	r2, r0, r3
 8005ede:	4250      	negs	r0, r2
 8005ee0:	4150      	adcs	r0, r2
 8005ee2:	f7fa ff55 	bl	8000d90 <_test_assert>
 8005ee6:	2800      	cmp	r0, #0
 8005ee8:	f47f aec8 	bne.w	8005c7c <oslib_test_002_002_execute+0x3c>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8005eec:	6820      	ldr	r0, [r4, #0]
 8005eee:	68e3      	ldr	r3, [r4, #12]
 8005ef0:	4909      	ldr	r1, [pc, #36]	; (8005f18 <oslib_test_002_002_execute+0x2d8>)
 8005ef2:	1ac3      	subs	r3, r0, r3
 8005ef4:	4258      	negs	r0, r3
 8005ef6:	4158      	adcs	r0, r3
 8005ef8:	f7fa ff4a 	bl	8000d90 <_test_assert>
 8005efc:	e6be      	b.n	8005c7c <oslib_test_002_002_execute+0x3c>
 8005efe:	bf00      	nop
 8005f00:	20001d94 	.word	0x20001d94
 8005f04:	20000c58 	.word	0x20000c58
 8005f08:	0800b170 	.word	0x0800b170
 8005f0c:	0800b17c 	.word	0x0800b17c
 8005f10:	0800b188 	.word	0x0800b188
 8005f14:	0800b194 	.word	0x0800b194
 8005f18:	0800b1b8 	.word	0x0800b1b8
 8005f1c:	0800b238 	.word	0x0800b238
 8005f20:	0800b1dc 	.word	0x0800b1dc
 8005f24:	0800b1e8 	.word	0x0800b1e8
 8005f28:	0800b1f4 	.word	0x0800b1f4
 8005f2c:	0800b20c 	.word	0x0800b20c
 8005f30:	0800b220 	.word	0x0800b220
	...

08005f40 <oslib_test_002_001_execute>:
  test_set_step(1);
 8005f40:	2301      	movs	r3, #1
static void oslib_test_002_001_execute(void) {
 8005f42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8005f46:	4fb8      	ldr	r7, [pc, #736]	; (8006228 <oslib_test_002_001_execute+0x2e8>)
static void oslib_test_002_001_execute(void) {
 8005f48:	b082      	sub	sp, #8
 8005f4a:	2620      	movs	r6, #32
  test_set_step(1);
 8005f4c:	603b      	str	r3, [r7, #0]
 8005f4e:	f386 8811 	msr	BASEPRI, r6
 8005f52:	4cb6      	ldr	r4, [pc, #728]	; (800622c <oslib_test_002_001_execute+0x2ec>)
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8005f54:	49b6      	ldr	r1, [pc, #728]	; (8006230 <oslib_test_002_001_execute+0x2f0>)
 8005f56:	6920      	ldr	r0, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8005f58:	e9d4 2300 	ldrd	r2, r3, [r4]
 8005f5c:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005f5e:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
 8005f62:	f1a0 0004 	sub.w	r0, r0, #4
 8005f66:	fab0 f080 	clz	r0, r0
 8005f6a:	0940      	lsrs	r0, r0, #5
 8005f6c:	f7fa ff10 	bl	8000d90 <_test_assert>
 8005f70:	b128      	cbz	r0, 8005f7e <oslib_test_002_001_execute+0x3e>
 8005f72:	2300      	movs	r3, #0
 8005f74:	f383 8811 	msr	BASEPRI, r3
}
 8005f78:	b002      	add	sp, #8
 8005f7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005f7e:	4605      	mov	r5, r0
 8005f80:	f380 8811 	msr	BASEPRI, r0
  test_set_step(2);
 8005f84:	2302      	movs	r3, #2
 8005f86:	603b      	str	r3, [r7, #0]
    chMBReset(&mb1);
 8005f88:	f7ff f8d2 	bl	8005130 <chMBReset.constprop.38>
 8005f8c:	f386 8811 	msr	BASEPRI, r6
  return (size_t)(mbp->top - mbp->buffer);
 8005f90:	e9d4 2300 	ldrd	r2, r3, [r4]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005f94:	6920      	ldr	r0, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8005f96:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005f98:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8005f9c:	f1a0 0004 	sub.w	r0, r0, #4
 8005fa0:	fab0 f080 	clz	r0, r0
 8005fa4:	49a3      	ldr	r1, [pc, #652]	; (8006234 <oslib_test_002_001_execute+0x2f4>)
 8005fa6:	0940      	lsrs	r0, r0, #5
 8005fa8:	f7fa fef2 	bl	8000d90 <_test_assert>
 8005fac:	4680      	mov	r8, r0
 8005fae:	b120      	cbz	r0, 8005fba <oslib_test_002_001_execute+0x7a>
 8005fb0:	f385 8811 	msr	BASEPRI, r5
}
 8005fb4:	b002      	add	sp, #8
 8005fb6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005fba:	f380 8811 	msr	BASEPRI, r0
 8005fbe:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8005fc2:	6920      	ldr	r0, [r4, #16]
 8005fc4:	499c      	ldr	r1, [pc, #624]	; (8006238 <oslib_test_002_001_execute+0x2f8>)
 8005fc6:	fab0 f080 	clz	r0, r0
 8005fca:	0940      	lsrs	r0, r0, #5
 8005fcc:	f7fa fee0 	bl	8000d90 <_test_assert>
 8005fd0:	4605      	mov	r5, r0
 8005fd2:	b110      	cbz	r0, 8005fda <oslib_test_002_001_execute+0x9a>
 8005fd4:	f388 8811 	msr	BASEPRI, r8
 8005fd8:	e7ce      	b.n	8005f78 <oslib_test_002_001_execute+0x38>
 8005fda:	f380 8811 	msr	BASEPRI, r0
 8005fde:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8005fe2:	6820      	ldr	r0, [r4, #0]
 8005fe4:	68a3      	ldr	r3, [r4, #8]
 8005fe6:	4995      	ldr	r1, [pc, #596]	; (800623c <oslib_test_002_001_execute+0x2fc>)
 8005fe8:	1ac0      	subs	r0, r0, r3
 8005fea:	fab0 f080 	clz	r0, r0
 8005fee:	0940      	lsrs	r0, r0, #5
 8005ff0:	f7fa fece 	bl	8000d90 <_test_assert>
 8005ff4:	4680      	mov	r8, r0
 8005ff6:	2800      	cmp	r0, #0
 8005ff8:	d1da      	bne.n	8005fb0 <oslib_test_002_001_execute+0x70>
 8005ffa:	f380 8811 	msr	BASEPRI, r0
 8005ffe:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8006002:	6820      	ldr	r0, [r4, #0]
 8006004:	68e3      	ldr	r3, [r4, #12]
 8006006:	498e      	ldr	r1, [pc, #568]	; (8006240 <oslib_test_002_001_execute+0x300>)
 8006008:	1ac0      	subs	r0, r0, r3
 800600a:	fab0 f080 	clz	r0, r0
 800600e:	0940      	lsrs	r0, r0, #5
 8006010:	f7fa febe 	bl	8000d90 <_test_assert>
 8006014:	2800      	cmp	r0, #0
 8006016:	d1dd      	bne.n	8005fd4 <oslib_test_002_001_execute+0x94>
 8006018:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 800601c:	2303      	movs	r3, #3
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 800601e:	4601      	mov	r1, r0
 8006020:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006024:	4620      	mov	r0, r4
  test_set_step(3);
 8006026:	603b      	str	r3, [r7, #0]
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 8006028:	f7ff fd3a 	bl	8005aa0 <chMBPostTimeout>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 800602c:	1c85      	adds	r5, r0, #2
 800602e:	bf14      	ite	ne
 8006030:	2000      	movne	r0, #0
 8006032:	2001      	moveq	r0, #1
 8006034:	4983      	ldr	r1, [pc, #524]	; (8006244 <oslib_test_002_001_execute+0x304>)
 8006036:	f7fa feab 	bl	8000d90 <_test_assert>
 800603a:	2800      	cmp	r0, #0
 800603c:	d19c      	bne.n	8005f78 <oslib_test_002_001_execute+0x38>
    msg1 = chMBPostAheadTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 800603e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8006042:	f7ff f8ad 	bl	80051a0 <chMBPostAheadTimeout.constprop.35>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8006046:	1c82      	adds	r2, r0, #2
 8006048:	bf14      	ite	ne
 800604a:	2000      	movne	r0, #0
 800604c:	2001      	moveq	r0, #1
 800604e:	497d      	ldr	r1, [pc, #500]	; (8006244 <oslib_test_002_001_execute+0x304>)
 8006050:	f7fa fe9e 	bl	8000d90 <_test_assert>
 8006054:	2800      	cmp	r0, #0
 8006056:	d18f      	bne.n	8005f78 <oslib_test_002_001_execute+0x38>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8006058:	a901      	add	r1, sp, #4
 800605a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800605e:	4620      	mov	r0, r4
 8006060:	f7ff fcbe 	bl	80059e0 <chMBFetchTimeout>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8006064:	1c83      	adds	r3, r0, #2
 8006066:	bf14      	ite	ne
 8006068:	2000      	movne	r0, #0
 800606a:	2001      	moveq	r0, #1
 800606c:	4975      	ldr	r1, [pc, #468]	; (8006244 <oslib_test_002_001_execute+0x304>)
 800606e:	f7fa fe8f 	bl	8000d90 <_test_assert>
 8006072:	2800      	cmp	r0, #0
 8006074:	d180      	bne.n	8005f78 <oslib_test_002_001_execute+0x38>
  test_set_step(4);
 8006076:	2304      	movs	r3, #4
 8006078:	2542      	movs	r5, #66	; 0x42
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 800607a:	46a0      	mov	r8, r4
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800607c:	4e72      	ldr	r6, [pc, #456]	; (8006248 <oslib_test_002_001_execute+0x308>)
  mbp->reset = false;
 800607e:	7520      	strb	r0, [r4, #20]
  test_set_step(4);
 8006080:	603b      	str	r3, [r7, #0]
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8006082:	4629      	mov	r1, r5
 8006084:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006088:	4640      	mov	r0, r8
 800608a:	f7ff fd09 	bl	8005aa0 <chMBPostTimeout>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800608e:	fab0 f080 	clz	r0, r0
 8006092:	4631      	mov	r1, r6
 8006094:	0940      	lsrs	r0, r0, #5
 8006096:	f7fa fe7b 	bl	8000d90 <_test_assert>
 800609a:	3501      	adds	r5, #1
 800609c:	2800      	cmp	r0, #0
 800609e:	f47f af6b 	bne.w	8005f78 <oslib_test_002_001_execute+0x38>
    for (i = 0; i < MB_SIZE - 1; i++) {
 80060a2:	2d45      	cmp	r5, #69	; 0x45
 80060a4:	d1ed      	bne.n	8006082 <oslib_test_002_001_execute+0x142>
    msg1 = chMBPostAheadTimeout(&mb1, 'A', TIME_INFINITE);
 80060a6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80060aa:	2041      	movs	r0, #65	; 0x41
 80060ac:	f7ff f878 	bl	80051a0 <chMBPostAheadTimeout.constprop.35>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80060b0:	fab0 f080 	clz	r0, r0
 80060b4:	4964      	ldr	r1, [pc, #400]	; (8006248 <oslib_test_002_001_execute+0x308>)
 80060b6:	0940      	lsrs	r0, r0, #5
 80060b8:	f7fa fe6a 	bl	8000d90 <_test_assert>
 80060bc:	4605      	mov	r5, r0
 80060be:	2800      	cmp	r0, #0
 80060c0:	f47f af5a 	bne.w	8005f78 <oslib_test_002_001_execute+0x38>
  test_set_step(5);
 80060c4:	2305      	movs	r3, #5
 80060c6:	2620      	movs	r6, #32
 80060c8:	603b      	str	r3, [r7, #0]
 80060ca:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 80060ce:	6922      	ldr	r2, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 80060d0:	e9d4 1300 	ldrd	r1, r3, [r4]
 80060d4:	1a5b      	subs	r3, r3, r1
 80060d6:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 80060da:	bf0c      	ite	eq
 80060dc:	2001      	moveq	r0, #1
 80060de:	2000      	movne	r0, #0
 80060e0:	495a      	ldr	r1, [pc, #360]	; (800624c <oslib_test_002_001_execute+0x30c>)
 80060e2:	f7fa fe55 	bl	8000d90 <_test_assert>
 80060e6:	4680      	mov	r8, r0
 80060e8:	2800      	cmp	r0, #0
 80060ea:	f47f af61 	bne.w	8005fb0 <oslib_test_002_001_execute+0x70>
 80060ee:	f380 8811 	msr	BASEPRI, r0
 80060f2:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 80060f6:	6920      	ldr	r0, [r4, #16]
 80060f8:	4955      	ldr	r1, [pc, #340]	; (8006250 <oslib_test_002_001_execute+0x310>)
 80060fa:	f1a0 0c04 	sub.w	ip, r0, #4
 80060fe:	f1dc 0000 	rsbs	r0, ip, #0
 8006102:	eb40 000c 	adc.w	r0, r0, ip
 8006106:	f7fa fe43 	bl	8000d90 <_test_assert>
 800610a:	4605      	mov	r5, r0
 800610c:	2800      	cmp	r0, #0
 800610e:	f47f af61 	bne.w	8005fd4 <oslib_test_002_001_execute+0x94>
 8006112:	f380 8811 	msr	BASEPRI, r0
 8006116:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 800611a:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
 800611e:	1ac6      	subs	r6, r0, r3
 8006120:	4270      	negs	r0, r6
 8006122:	4170      	adcs	r0, r6
 8006124:	494b      	ldr	r1, [pc, #300]	; (8006254 <oslib_test_002_001_execute+0x314>)
 8006126:	f7fa fe33 	bl	8000d90 <_test_assert>
 800612a:	2800      	cmp	r0, #0
 800612c:	f47f af40 	bne.w	8005fb0 <oslib_test_002_001_execute+0x70>
 8006130:	f380 8811 	msr	BASEPRI, r0
  test_set_step(6);
 8006134:	2306      	movs	r3, #6
 8006136:	2504      	movs	r5, #4
      msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8006138:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 800622c <oslib_test_002_001_execute+0x2ec>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800613c:	4e42      	ldr	r6, [pc, #264]	; (8006248 <oslib_test_002_001_execute+0x308>)
  test_set_step(6);
 800613e:	603b      	str	r3, [r7, #0]
      msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8006140:	a901      	add	r1, sp, #4
 8006142:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006146:	4640      	mov	r0, r8
 8006148:	f7ff fc4a 	bl	80059e0 <chMBFetchTimeout>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800614c:	fab0 f080 	clz	r0, r0
 8006150:	4631      	mov	r1, r6
 8006152:	0940      	lsrs	r0, r0, #5
 8006154:	f7fa fe1c 	bl	8000d90 <_test_assert>
 8006158:	2800      	cmp	r0, #0
 800615a:	f47f af0d 	bne.w	8005f78 <oslib_test_002_001_execute+0x38>
      test_emit_token(msg2);
 800615e:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8006162:	f7fa febd 	bl	8000ee0 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 8006166:	3d01      	subs	r5, #1
 8006168:	d1ea      	bne.n	8006140 <oslib_test_002_001_execute+0x200>
    test_assert_sequence("ABCD", "wrong get sequence");
 800616a:	493b      	ldr	r1, [pc, #236]	; (8006258 <oslib_test_002_001_execute+0x318>)
 800616c:	483b      	ldr	r0, [pc, #236]	; (800625c <oslib_test_002_001_execute+0x31c>)
 800616e:	f7fa ff8f 	bl	8001090 <_test_assert_sequence>
 8006172:	2800      	cmp	r0, #0
 8006174:	f47f af00 	bne.w	8005f78 <oslib_test_002_001_execute+0x38>
  test_set_step(7);
 8006178:	2307      	movs	r3, #7
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 800617a:	2146      	movs	r1, #70	; 0x46
 800617c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006180:	482a      	ldr	r0, [pc, #168]	; (800622c <oslib_test_002_001_execute+0x2ec>)
  test_set_step(7);
 8006182:	603b      	str	r3, [r7, #0]
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8006184:	f7ff fc8c 	bl	8005aa0 <chMBPostTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8006188:	fab0 f080 	clz	r0, r0
 800618c:	492e      	ldr	r1, [pc, #184]	; (8006248 <oslib_test_002_001_execute+0x308>)
 800618e:	0940      	lsrs	r0, r0, #5
 8006190:	f7fa fdfe 	bl	8000d90 <_test_assert>
 8006194:	2800      	cmp	r0, #0
 8006196:	f47f aeef 	bne.w	8005f78 <oslib_test_002_001_execute+0x38>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 800619a:	a901      	add	r1, sp, #4
 800619c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80061a0:	4822      	ldr	r0, [pc, #136]	; (800622c <oslib_test_002_001_execute+0x2ec>)
 80061a2:	f7ff fc1d 	bl	80059e0 <chMBFetchTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80061a6:	fab0 f080 	clz	r0, r0
 80061aa:	4927      	ldr	r1, [pc, #156]	; (8006248 <oslib_test_002_001_execute+0x308>)
 80061ac:	0940      	lsrs	r0, r0, #5
 80061ae:	f7fa fdef 	bl	8000d90 <_test_assert>
 80061b2:	2800      	cmp	r0, #0
 80061b4:	f47f aee0 	bne.w	8005f78 <oslib_test_002_001_execute+0x38>
  test_set_step(8);
 80061b8:	2308      	movs	r3, #8
 80061ba:	2620      	movs	r6, #32
 80061bc:	603b      	str	r3, [r7, #0]
 80061be:	f386 8811 	msr	BASEPRI, r6
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80061c2:	6923      	ldr	r3, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 80061c4:	e9d4 1200 	ldrd	r1, r2, [r4]
 80061c8:	1a52      	subs	r2, r2, r1
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80061ca:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80061ce:	1f19      	subs	r1, r3, #4
 80061d0:	4248      	negs	r0, r1
 80061d2:	4148      	adcs	r0, r1
 80061d4:	4917      	ldr	r1, [pc, #92]	; (8006234 <oslib_test_002_001_execute+0x2f4>)
 80061d6:	f7fa fddb 	bl	8000d90 <_test_assert>
 80061da:	2800      	cmp	r0, #0
 80061dc:	f47f aee8 	bne.w	8005fb0 <oslib_test_002_001_execute+0x70>
 80061e0:	f385 8811 	msr	BASEPRI, r5
 80061e4:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 80061e8:	6920      	ldr	r0, [r4, #16]
 80061ea:	4913      	ldr	r1, [pc, #76]	; (8006238 <oslib_test_002_001_execute+0x2f8>)
 80061ec:	fab0 f080 	clz	r0, r0
 80061f0:	0940      	lsrs	r0, r0, #5
 80061f2:	f7fa fdcd 	bl	8000d90 <_test_assert>
 80061f6:	2800      	cmp	r0, #0
 80061f8:	f47f aeda 	bne.w	8005fb0 <oslib_test_002_001_execute+0x70>
 80061fc:	f385 8811 	msr	BASEPRI, r5
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8006200:	6820      	ldr	r0, [r4, #0]
 8006202:	68a3      	ldr	r3, [r4, #8]
 8006204:	490d      	ldr	r1, [pc, #52]	; (800623c <oslib_test_002_001_execute+0x2fc>)
 8006206:	1ac2      	subs	r2, r0, r3
 8006208:	4250      	negs	r0, r2
 800620a:	4150      	adcs	r0, r2
 800620c:	f7fa fdc0 	bl	8000d90 <_test_assert>
 8006210:	2800      	cmp	r0, #0
 8006212:	f47f aeb1 	bne.w	8005f78 <oslib_test_002_001_execute+0x38>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8006216:	6820      	ldr	r0, [r4, #0]
 8006218:	68e3      	ldr	r3, [r4, #12]
 800621a:	4909      	ldr	r1, [pc, #36]	; (8006240 <oslib_test_002_001_execute+0x300>)
 800621c:	1ac3      	subs	r3, r0, r3
 800621e:	4258      	negs	r0, r3
 8006220:	4158      	adcs	r0, r3
 8006222:	f7fa fdb5 	bl	8000d90 <_test_assert>
 8006226:	e6a7      	b.n	8005f78 <oslib_test_002_001_execute+0x38>
 8006228:	20001d94 	.word	0x20001d94
 800622c:	20000c58 	.word	0x20000c58
 8006230:	0800b170 	.word	0x0800b170
 8006234:	0800b17c 	.word	0x0800b17c
 8006238:	0800b188 	.word	0x0800b188
 800623c:	0800b194 	.word	0x0800b194
 8006240:	0800b1b8 	.word	0x0800b1b8
 8006244:	0800b14c 	.word	0x0800b14c
 8006248:	0800b238 	.word	0x0800b238
 800624c:	0800b1dc 	.word	0x0800b1dc
 8006250:	0800b1e8 	.word	0x0800b1e8
 8006254:	0800b1f4 	.word	0x0800b1f4
 8006258:	0800b20c 	.word	0x0800b20c
 800625c:	0800b220 	.word	0x0800b220

08006260 <chMtxUnlock>:
  thread_t *ctp = currp;
 8006260:	4b17      	ldr	r3, [pc, #92]	; (80062c0 <chMtxUnlock+0x60>)
void chMtxUnlock(mutex_t *mp) {
 8006262:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8006264:	699d      	ldr	r5, [r3, #24]
 8006266:	2320      	movs	r3, #32
 8006268:	f383 8811 	msr	BASEPRI, r3
  return (bool)(tqp->next != (const thread_t *)tqp);
 800626c:	6804      	ldr	r4, [r0, #0]
    ctp->mtxlist = mp->next;
 800626e:	68c3      	ldr	r3, [r0, #12]
    if (chMtxQueueNotEmptyS(mp)) {
 8006270:	4284      	cmp	r4, r0
    ctp->mtxlist = mp->next;
 8006272:	63ab      	str	r3, [r5, #56]	; 0x38
    if (chMtxQueueNotEmptyS(mp)) {
 8006274:	d01d      	beq.n	80062b2 <chMtxUnlock+0x52>
      tprio_t newprio = ctp->realprio;
 8006276:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      while (lmp != NULL) {
 8006278:	b14b      	cbz	r3, 800628e <chMtxUnlock+0x2e>
 800627a:	681a      	ldr	r2, [r3, #0]
        if (chMtxQueueNotEmptyS(lmp) &&
 800627c:	4293      	cmp	r3, r2
 800627e:	d003      	beq.n	8006288 <chMtxUnlock+0x28>
 8006280:	6892      	ldr	r2, [r2, #8]
 8006282:	4291      	cmp	r1, r2
 8006284:	bf38      	it	cc
 8006286:	4611      	movcc	r1, r2
        lmp = lmp->next;
 8006288:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 800628a:	2b00      	cmp	r3, #0
 800628c:	d1f5      	bne.n	800627a <chMtxUnlock+0x1a>
 800628e:	4603      	mov	r3, r0
  tqp->next             = tp->queue.next;
 8006290:	6822      	ldr	r2, [r4, #0]
      mp->next = tp->mtxlist;
 8006292:	6ba6      	ldr	r6, [r4, #56]	; 0x38
      (void) chSchReadyI(tp);
 8006294:	4620      	mov	r0, r4
      ctp->prio = newprio;
 8006296:	60a9      	str	r1, [r5, #8]
 8006298:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800629a:	6053      	str	r3, [r2, #4]
      mp->next = tp->mtxlist;
 800629c:	e9c3 4602 	strd	r4, r6, [r3, #8]
      tp->mtxlist = mp;
 80062a0:	63a3      	str	r3, [r4, #56]	; 0x38
      (void) chSchReadyI(tp);
 80062a2:	f7fb f9a5 	bl	80015f0 <chSchReadyI>
      chSchRescheduleS();
 80062a6:	f7fe fe23 	bl	8004ef0 <chSchRescheduleS>
 80062aa:	2300      	movs	r3, #0
 80062ac:	f383 8811 	msr	BASEPRI, r3
}
 80062b0:	bd70      	pop	{r4, r5, r6, pc}
      mp->owner = NULL;
 80062b2:	2300      	movs	r3, #0
 80062b4:	60a3      	str	r3, [r4, #8]
 80062b6:	2300      	movs	r3, #0
 80062b8:	f383 8811 	msr	BASEPRI, r3
}
 80062bc:	bd70      	pop	{r4, r5, r6, pc}
 80062be:	bf00      	nop
 80062c0:	20001254 	.word	0x20001254
	...

080062d0 <chHeapAllocAligned.constprop.41>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 80062d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
    heapp = &default_heap;
 80062d4:	4d37      	ldr	r5, [pc, #220]	; (80063b4 <chHeapAllocAligned.constprop.41+0xe4>)
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80062d6:	f101 0807 	add.w	r8, r1, #7
    heapp = &default_heap;
 80062da:	2800      	cmp	r0, #0
 80062dc:	bf18      	it	ne
 80062de:	4605      	movne	r5, r0

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80062e0:	f105 070c 	add.w	r7, r5, #12
 80062e4:	4638      	mov	r0, r7
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 80062e6:	460e      	mov	r6, r1
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80062e8:	ea4f 08d8 	mov.w	r8, r8, lsr #3
  H_LOCK(heapp);
 80062ec:	f7fe fae8 	bl	80048c0 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 80062f0:	f105 0c04 	add.w	ip, r5, #4
  while (H_NEXT(qp) != NULL) {
 80062f4:	f8dc 3000 	ldr.w	r3, [ip]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 80062f8:	f103 000f 	add.w	r0, r3, #15
 80062fc:	f020 0007 	bic.w	r0, r0, #7
 8006300:	f1a0 0e08 	sub.w	lr, r0, #8
 8006304:	f103 0a08 	add.w	sl, r3, #8
  while (H_NEXT(qp) != NULL) {
 8006308:	b173      	cbz	r3, 8006328 <chHeapAllocAligned.constprop.41+0x58>

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800630a:	f8d3 9004 	ldr.w	r9, [r3, #4]
 800630e:	f109 0201 	add.w	r2, r9, #1
 8006312:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8006316:	4596      	cmp	lr, r2
 8006318:	d204      	bcs.n	8006324 <chHeapAllocAligned.constprop.41+0x54>
 800631a:	1a11      	subs	r1, r2, r0
 800631c:	10c9      	asrs	r1, r1, #3
 800631e:	4588      	cmp	r8, r1
 8006320:	4604      	mov	r4, r0
 8006322:	d912      	bls.n	800634a <chHeapAllocAligned.constprop.41+0x7a>
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 8006324:	469c      	mov	ip, r3
 8006326:	e7e5      	b.n	80062f4 <chHeapAllocAligned.constprop.41+0x24>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8006328:	4638      	mov	r0, r7
 800632a:	f7ff ff99 	bl	8006260 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 800632e:	682c      	ldr	r4, [r5, #0]
 8006330:	b144      	cbz	r4, 8006344 <chHeapAllocAligned.constprop.41+0x74>
    ahp = heapp->provider(pages * CH_HEAP_ALIGNMENT,
 8006332:	2208      	movs	r2, #8
 8006334:	ea4f 00c8 	mov.w	r0, r8, lsl #3
 8006338:	4611      	mov	r1, r2
 800633a:	47a0      	blx	r4
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
 800633c:	4604      	mov	r4, r0
 800633e:	b108      	cbz	r0, 8006344 <chHeapAllocAligned.constprop.41+0x74>
      hp = ahp - 1U;
      H_HEAP(hp) = heapp;
      H_SIZE(hp) = size;
 8006340:	e940 5602 	strd	r5, r6, [r0, #-8]
      /*lint -restore*/
    }
  }

  return NULL;
}
 8006344:	4620      	mov	r0, r4
 8006346:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if (ahp > hp) {
 800634a:	4573      	cmp	r3, lr
 800634c:	d319      	bcc.n	8006382 <chHeapAllocAligned.constprop.41+0xb2>
        if (H_PAGES(hp) == pages) {
 800634e:	45c8      	cmp	r8, r9
 8006350:	6818      	ldr	r0, [r3, #0]
 8006352:	d02a      	beq.n	80063aa <chHeapAllocAligned.constprop.41+0xda>
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8006354:	4654      	mov	r4, sl
          fp = H_BLOCK(hp) + pages;
 8006356:	f108 0801 	add.w	r8, r8, #1
 800635a:	eb03 01c8 	add.w	r1, r3, r8, lsl #3
          H_NEXT(fp) = H_NEXT(hp);
 800635e:	f843 0038 	str.w	r0, [r3, r8, lsl #3]
          H_NEXT(qp) = fp;
 8006362:	469e      	mov	lr, r3
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8006364:	f101 0308 	add.w	r3, r1, #8
 8006368:	1ad3      	subs	r3, r2, r3
 800636a:	10db      	asrs	r3, r3, #3
 800636c:	604b      	str	r3, [r1, #4]
          H_NEXT(qp) = fp;
 800636e:	f8cc 1000 	str.w	r1, [ip]
      H_UNLOCK(heapp);
 8006372:	4638      	mov	r0, r7
      H_HEAP(hp) = heapp;
 8006374:	e9ce 5600 	strd	r5, r6, [lr]
      H_UNLOCK(heapp);
 8006378:	f7ff ff72 	bl	8006260 <chMtxUnlock>
}
 800637c:	4620      	mov	r0, r4
 800637e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8006382:	ebae 0a0a 	sub.w	sl, lr, sl
 8006386:	ea4f 02ea 	mov.w	r2, sl, asr #3
        if (bpages > pages) {
 800638a:	4588      	cmp	r8, r1
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 800638c:	605a      	str	r2, [r3, #4]
        if (bpages > pages) {
 800638e:	d2f0      	bcs.n	8006372 <chHeapAllocAligned.constprop.41+0xa2>
          H_PAGES(fp) = (bpages - pages) - 1U;
 8006390:	ea6f 0208 	mvn.w	r2, r8
          H_NEXT(fp) = H_NEXT(hp);
 8006394:	6818      	ldr	r0, [r3, #0]
          fp = H_BLOCK(ahp) + pages;
 8006396:	f108 0801 	add.w	r8, r8, #1
          H_PAGES(fp) = (bpages - pages) - 1U;
 800639a:	4411      	add	r1, r2
          fp = H_BLOCK(ahp) + pages;
 800639c:	eb0e 02c8 	add.w	r2, lr, r8, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 80063a0:	6051      	str	r1, [r2, #4]
          H_NEXT(fp) = H_NEXT(hp);
 80063a2:	f84e 0038 	str.w	r0, [lr, r8, lsl #3]
          H_NEXT(hp) = fp;
 80063a6:	601a      	str	r2, [r3, #0]
 80063a8:	e7e3      	b.n	8006372 <chHeapAllocAligned.constprop.41+0xa2>
          H_NEXT(qp) = H_NEXT(hp);
 80063aa:	f8cc 0000 	str.w	r0, [ip]
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 80063ae:	4654      	mov	r4, sl
          H_NEXT(qp) = H_NEXT(hp);
 80063b0:	469e      	mov	lr, r3
 80063b2:	e7de      	b.n	8006372 <chHeapAllocAligned.constprop.41+0xa2>
 80063b4:	200013f8 	.word	0x200013f8
	...

080063c0 <dyn_create_object_heap>:
                                             size_t size) {
 80063c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_element_t *p = dlp->next;
 80063c2:	680c      	ldr	r4, [r1, #0]
                                             size_t size) {
 80063c4:	460d      	mov	r5, r1
  while (p != (dyn_element_t *)dlp) {
 80063c6:	42a1      	cmp	r1, r4
                                             size_t size) {
 80063c8:	4606      	mov	r6, r0
 80063ca:	4617      	mov	r7, r2
  while (p != (dyn_element_t *)dlp) {
 80063cc:	d103      	bne.n	80063d6 <dyn_create_object_heap+0x16>
 80063ce:	e00d      	b.n	80063ec <dyn_create_object_heap+0x2c>
    p = p->next;
 80063d0:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 80063d2:	42a5      	cmp	r5, r4
 80063d4:	d00a      	beq.n	80063ec <dyn_create_object_heap+0x2c>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 80063d6:	2208      	movs	r2, #8
 80063d8:	4631      	mov	r1, r6
 80063da:	18a0      	adds	r0, r4, r2
 80063dc:	f7fa f98a 	bl	80006f4 <strncmp>
 80063e0:	2800      	cmp	r0, #0
 80063e2:	d1f5      	bne.n	80063d0 <dyn_create_object_heap+0x10>
  if (dep != NULL) {
 80063e4:	b114      	cbz	r4, 80063ec <dyn_create_object_heap+0x2c>
    return NULL;
 80063e6:	4604      	mov	r4, r0
}
 80063e8:	4620      	mov	r0, r4
 80063ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 80063ec:	4639      	mov	r1, r7
 80063ee:	2000      	movs	r0, #0
 80063f0:	f7ff ff6e 	bl	80062d0 <chHeapAllocAligned.constprop.41>
  if (dep == NULL) {
 80063f4:	4604      	mov	r4, r0
 80063f6:	b148      	cbz	r0, 800640c <dyn_create_object_heap+0x4c>
  strncpy(dep->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 80063f8:	2208      	movs	r2, #8
 80063fa:	4631      	mov	r1, r6
 80063fc:	4410      	add	r0, r2
 80063fe:	f7fa f9c3 	bl	8000788 <strncpy>
  dep->refs = (ucnt_t)1;
 8006402:	2201      	movs	r2, #1
  dep->next = dlp->next;
 8006404:	682b      	ldr	r3, [r5, #0]
 8006406:	e9c4 3200 	strd	r3, r2, [r4]
  dlp->next = dep;
 800640a:	602c      	str	r4, [r5, #0]
}
 800640c:	4620      	mov	r0, r4
 800640e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006410 <chThdCreateFromHeap>:
                              tfunc_t pf, void *arg) {
 8006410:	b570      	push	{r4, r5, r6, lr}
 8006412:	b086      	sub	sp, #24
 8006414:	4616      	mov	r6, r2
 8006416:	461d      	mov	r5, r3
 8006418:	460c      	mov	r4, r1
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 800641a:	f7ff ff59 	bl	80062d0 <chHeapAllocAligned.constprop.41>
  if (wsp == NULL) {
 800641e:	b1d8      	cbz	r0, 8006458 <chThdCreateFromHeap+0x48>
  thread_descriptor_t td = {
 8006420:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    (stkalign_t *)((uint8_t *)wsp + size),
 8006422:	4404      	add	r4, r0
  thread_descriptor_t td = {
 8006424:	9304      	str	r3, [sp, #16]
 8006426:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8006428:	9402      	str	r4, [sp, #8]
 800642a:	9305      	str	r3, [sp, #20]
 800642c:	e9cd 6000 	strd	r6, r0, [sp]
 8006430:	9503      	str	r5, [sp, #12]
 8006432:	2320      	movs	r3, #32
 8006434:	f383 8811 	msr	BASEPRI, r3
  tp = chThdCreateSuspendedI(&td);
 8006438:	4668      	mov	r0, sp
 800643a:	f7fb f861 	bl	8001500 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 800643e:	2301      	movs	r3, #1
  chSchWakeupS(tp, MSG_OK);
 8006440:	2100      	movs	r1, #0
  tp->flags = CH_FLAG_MODE_HEAP;
 8006442:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  tp = chThdCreateSuspendedI(&td);
 8006446:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 8006448:	f7fd f94a 	bl	80036e0 <chSchWakeupS>
 800644c:	2300      	movs	r3, #0
 800644e:	f383 8811 	msr	BASEPRI, r3
}
 8006452:	4620      	mov	r0, r4
 8006454:	b006      	add	sp, #24
 8006456:	bd70      	pop	{r4, r5, r6, pc}
    return NULL;
 8006458:	4604      	mov	r4, r0
 800645a:	e7fa      	b.n	8006452 <chThdCreateFromHeap+0x42>
 800645c:	0000      	movs	r0, r0
	...

08006460 <chPipeWriteTimeout.constprop.24>:
 *                      lower than @p n means that a timeout occurred or the
 *                      pipe went in reset state.
 *
 * @api
 */
size_t chPipeWriteTimeout(pipe_t *pp, const uint8_t *bp,
 8006460:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t max = n;

  chDbgCheck(n > 0U);

  /* If the pipe is in reset state then returns immediately.*/
  if (pp->reset) {
 8006464:	4d36      	ldr	r5, [pc, #216]	; (8006540 <chPipeWriteTimeout.constprop.24+0xe0>)
size_t chPipeWriteTimeout(pipe_t *pp, const uint8_t *bp,
 8006466:	b083      	sub	sp, #12
  if (pp->reset) {
 8006468:	7d2b      	ldrb	r3, [r5, #20]
 800646a:	b11b      	cbz	r3, 8006474 <chPipeWriteTimeout.constprop.24+0x14>
    return (size_t)0;
 800646c:	2000      	movs	r0, #0
  }

  PW_UNLOCK(pp);

  return max - n;
}
 800646e:	b003      	add	sp, #12
 8006470:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006474:	4681      	mov	r9, r0
  PW_LOCK(pp);
 8006476:	464f      	mov	r7, r9
 8006478:	f105 0030 	add.w	r0, r5, #48	; 0x30
 800647c:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 8006548 <chPipeWriteTimeout.constprop.24+0xe8>
    *trp = NULL;
 8006480:	469a      	mov	sl, r3
  PC_LOCK(pp);
 8006482:	f105 0b20 	add.w	fp, r5, #32
  PW_LOCK(pp);
 8006486:	f7fe fa1b 	bl	80048c0 <chMtxLock>
  PC_LOCK(pp);
 800648a:	f8cd 9004 	str.w	r9, [sp, #4]
 800648e:	4658      	mov	r0, fp
 8006490:	f7fe fa16 	bl	80048c0 <chMtxLock>
 */
static inline size_t chPipeGetSize(const pipe_t *pp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (size_t)(pp->top - pp->buffer);
 8006494:	e9d5 4600 	ldrd	r4, r6, [r5]
 *
 * @api
 */
static inline size_t chPipeGetFreeCount(const pipe_t *pp) {

  return chPipeGetSize(pp) - chPipeGetUsedCount(pp);
 8006498:	692b      	ldr	r3, [r5, #16]
  return (size_t)(pp->top - pp->buffer);
 800649a:	1b34      	subs	r4, r6, r4
  return chPipeGetSize(pp) - chPipeGetUsedCount(pp);
 800649c:	1ae4      	subs	r4, r4, r3
 800649e:	42bc      	cmp	r4, r7
 80064a0:	bf28      	it	cs
 80064a2:	463c      	movcs	r4, r7
  s1 = (size_t)(pp->top - pp->wrptr);
 80064a4:	68a8      	ldr	r0, [r5, #8]
  pp->cnt += n;
 80064a6:	4423      	add	r3, r4
  s1 = (size_t)(pp->top - pp->wrptr);
 80064a8:	1a36      	subs	r6, r6, r0
  if (n < s1) {
 80064aa:	42a6      	cmp	r6, r4
  pp->cnt += n;
 80064ac:	612b      	str	r3, [r5, #16]
  if (n < s1) {
 80064ae:	d83e      	bhi.n	800652e <chPipeWriteTimeout.constprop.24+0xce>
    s2 = n - s1;
 80064b0:	eba4 0906 	sub.w	r9, r4, r6
  else if (n > s1) {
 80064b4:	d32c      	bcc.n	8006510 <chPipeWriteTimeout.constprop.24+0xb0>
    memcpy((void *)pp->wrptr, (const void *)bp, n);
 80064b6:	4622      	mov	r2, r4
 80064b8:	4641      	mov	r1, r8
 80064ba:	f7f9 ff09 	bl	80002d0 <memcpy>
    pp->wrptr = pp->buffer;
 80064be:	682b      	ldr	r3, [r5, #0]
 80064c0:	60ab      	str	r3, [r5, #8]
  PC_UNLOCK(pp);
 80064c2:	4658      	mov	r0, fp
      bp += done;
 80064c4:	44a0      	add	r8, r4
  PC_UNLOCK(pp);
 80064c6:	f7ff fecb 	bl	8006260 <chMtxUnlock>
    if (done == (size_t)0) {
 80064ca:	b97c      	cbnz	r4, 80064ec <chPipeWriteTimeout.constprop.24+0x8c>
 80064cc:	f8dd 9004 	ldr.w	r9, [sp, #4]
 80064d0:	2320      	movs	r3, #32
 80064d2:	f383 8811 	msr	BASEPRI, r3
 80064d6:	f384 8811 	msr	BASEPRI, r4
 80064da:	eba9 0907 	sub.w	r9, r9, r7
  PW_UNLOCK(pp);
 80064de:	4819      	ldr	r0, [pc, #100]	; (8006544 <chPipeWriteTimeout.constprop.24+0xe4>)
 80064e0:	f7ff febe 	bl	8006260 <chMtxUnlock>
 80064e4:	4648      	mov	r0, r9
}
 80064e6:	b003      	add	sp, #12
 80064e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      n  -= done;
 80064ec:	1b3f      	subs	r7, r7, r4
 80064ee:	2320      	movs	r3, #32
 80064f0:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 80064f4:	69e8      	ldr	r0, [r5, #28]
 80064f6:	b120      	cbz	r0, 8006502 <chPipeWriteTimeout.constprop.24+0xa2>
    chSchWakeupS(tp, msg);
 80064f8:	2100      	movs	r1, #0
    *trp = NULL;
 80064fa:	f8c5 a01c 	str.w	sl, [r5, #28]
    chSchWakeupS(tp, msg);
 80064fe:	f7fd f8ef 	bl	80036e0 <chSchWakeupS>
 8006502:	f38a 8811 	msr	BASEPRI, sl
  while (n > 0U) {
 8006506:	2f00      	cmp	r7, #0
 8006508:	d1c1      	bne.n	800648e <chPipeWriteTimeout.constprop.24+0x2e>
 800650a:	f8dd 9004 	ldr.w	r9, [sp, #4]
 800650e:	e7e6      	b.n	80064de <chPipeWriteTimeout.constprop.24+0x7e>
    memcpy((void *)pp->wrptr, (const void *)bp, s1);
 8006510:	4632      	mov	r2, r6
 8006512:	4641      	mov	r1, r8
 8006514:	f7f9 fedc 	bl	80002d0 <memcpy>
    memcpy((void *)pp->buffer, (const void *)bp, s2);
 8006518:	464a      	mov	r2, r9
 800651a:	eb08 0106 	add.w	r1, r8, r6
 800651e:	6828      	ldr	r0, [r5, #0]
 8006520:	f7f9 fed6 	bl	80002d0 <memcpy>
    pp->wrptr = pp->buffer + s2;
 8006524:	682a      	ldr	r2, [r5, #0]
 8006526:	eb02 0309 	add.w	r3, r2, r9
 800652a:	60ab      	str	r3, [r5, #8]
 800652c:	e7c9      	b.n	80064c2 <chPipeWriteTimeout.constprop.24+0x62>
    memcpy((void *)pp->wrptr, (const void *)bp, n);
 800652e:	4622      	mov	r2, r4
 8006530:	4641      	mov	r1, r8
 8006532:	f7f9 fecd 	bl	80002d0 <memcpy>
    pp->wrptr += n;
 8006536:	68ab      	ldr	r3, [r5, #8]
 8006538:	4423      	add	r3, r4
 800653a:	60ab      	str	r3, [r5, #8]
 800653c:	e7c1      	b.n	80064c2 <chPipeWriteTimeout.constprop.24+0x62>
 800653e:	bf00      	nop
 8006540:	20000c98 	.word	0x20000c98
 8006544:	20000cc8 	.word	0x20000cc8
 8006548:	0800b684 	.word	0x0800b684
 800654c:	00000000 	.word	0x00000000

08006550 <chPipeReadTimeout.constprop.23>:
 *                      lower than @p n means that a timeout occurred or the
 *                      pipe went in reset state.
 *
 * @api
 */
size_t chPipeReadTimeout(pipe_t *pp, uint8_t *bp,
 8006550:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t max = n;

  chDbgCheck(n > 0U);

  /* If the pipe is in reset state then returns immediately.*/
  if (pp->reset) {
 8006554:	4c35      	ldr	r4, [pc, #212]	; (800662c <chPipeReadTimeout.constprop.23+0xdc>)
size_t chPipeReadTimeout(pipe_t *pp, uint8_t *bp,
 8006556:	b083      	sub	sp, #12
  if (pp->reset) {
 8006558:	7d23      	ldrb	r3, [r4, #20]
 800655a:	b11b      	cbz	r3, 8006564 <chPipeReadTimeout.constprop.23+0x14>
    return (size_t)0;
 800655c:	2000      	movs	r0, #0
  }

  PR_UNLOCK(pp);

  return max - n;
}
 800655e:	b003      	add	sp, #12
 8006560:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006564:	4689      	mov	r9, r1
  PR_LOCK(pp);
 8006566:	46c8      	mov	r8, r9
 8006568:	4607      	mov	r7, r0
 800656a:	f104 0040 	add.w	r0, r4, #64	; 0x40
    *trp = NULL;
 800656e:	469a      	mov	sl, r3
  PC_LOCK(pp);
 8006570:	f104 0b20 	add.w	fp, r4, #32
  PR_LOCK(pp);
 8006574:	f7fe f9a4 	bl	80048c0 <chMtxLock>
  PC_LOCK(pp);
 8006578:	f8cd 9004 	str.w	r9, [sp, #4]
 800657c:	4658      	mov	r0, fp
 800657e:	f7fe f99f 	bl	80048c0 <chMtxLock>
  s1 = (size_t)(pp->top - pp->rdptr);
 8006582:	e9d4 1303 	ldrd	r1, r3, [r4, #12]
 8006586:	4543      	cmp	r3, r8
 8006588:	461d      	mov	r5, r3
 800658a:	bf28      	it	cs
 800658c:	4645      	movcs	r5, r8
 800658e:	6866      	ldr	r6, [r4, #4]
  pp->cnt -= n;
 8006590:	1b5b      	subs	r3, r3, r5
  s1 = (size_t)(pp->top - pp->rdptr);
 8006592:	1a76      	subs	r6, r6, r1
  if (n < s1) {
 8006594:	42ae      	cmp	r6, r5
  pp->cnt -= n;
 8006596:	6123      	str	r3, [r4, #16]
  if (n < s1) {
 8006598:	d83f      	bhi.n	800661a <chPipeReadTimeout.constprop.23+0xca>
    s2 = n - s1;
 800659a:	eba5 0906 	sub.w	r9, r5, r6
  else if (n > s1) {
 800659e:	d32e      	bcc.n	80065fe <chPipeReadTimeout.constprop.23+0xae>
    memcpy((void *)bp, (void *)pp->rdptr, n);
 80065a0:	462a      	mov	r2, r5
 80065a2:	4638      	mov	r0, r7
 80065a4:	f7f9 fe94 	bl	80002d0 <memcpy>
    pp->rdptr = pp->buffer;
 80065a8:	6823      	ldr	r3, [r4, #0]
 80065aa:	60e3      	str	r3, [r4, #12]
  PC_UNLOCK(pp);
 80065ac:	4658      	mov	r0, fp
      bp += done;
 80065ae:	442f      	add	r7, r5
  PC_UNLOCK(pp);
 80065b0:	f7ff fe56 	bl	8006260 <chMtxUnlock>
    if (done == (size_t)0) {
 80065b4:	b97d      	cbnz	r5, 80065d6 <chPipeReadTimeout.constprop.23+0x86>
 80065b6:	f8dd 9004 	ldr.w	r9, [sp, #4]
 80065ba:	2320      	movs	r3, #32
 80065bc:	f383 8811 	msr	BASEPRI, r3
 80065c0:	f385 8811 	msr	BASEPRI, r5
 80065c4:	eba9 0908 	sub.w	r9, r9, r8
  PR_UNLOCK(pp);
 80065c8:	4819      	ldr	r0, [pc, #100]	; (8006630 <chPipeReadTimeout.constprop.23+0xe0>)
 80065ca:	f7ff fe49 	bl	8006260 <chMtxUnlock>
 80065ce:	4648      	mov	r0, r9
}
 80065d0:	b003      	add	sp, #12
 80065d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      n  -= done;
 80065d6:	eba8 0805 	sub.w	r8, r8, r5
 80065da:	2320      	movs	r3, #32
 80065dc:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 80065e0:	69a0      	ldr	r0, [r4, #24]
 80065e2:	b120      	cbz	r0, 80065ee <chPipeReadTimeout.constprop.23+0x9e>
    chSchWakeupS(tp, msg);
 80065e4:	2100      	movs	r1, #0
    *trp = NULL;
 80065e6:	f8c4 a018 	str.w	sl, [r4, #24]
    chSchWakeupS(tp, msg);
 80065ea:	f7fd f879 	bl	80036e0 <chSchWakeupS>
 80065ee:	f38a 8811 	msr	BASEPRI, sl
  while (n > 0U) {
 80065f2:	f1b8 0f00 	cmp.w	r8, #0
 80065f6:	d1c1      	bne.n	800657c <chPipeReadTimeout.constprop.23+0x2c>
 80065f8:	f8dd 9004 	ldr.w	r9, [sp, #4]
 80065fc:	e7e4      	b.n	80065c8 <chPipeReadTimeout.constprop.23+0x78>
    memcpy((void *)bp, (void *)pp->rdptr, s1);
 80065fe:	4632      	mov	r2, r6
 8006600:	4638      	mov	r0, r7
 8006602:	f7f9 fe65 	bl	80002d0 <memcpy>
    memcpy((void *)bp, (void *)pp->buffer, s2);
 8006606:	464a      	mov	r2, r9
 8006608:	19b8      	adds	r0, r7, r6
 800660a:	6821      	ldr	r1, [r4, #0]
 800660c:	f7f9 fe60 	bl	80002d0 <memcpy>
    pp->rdptr = pp->buffer + s2;
 8006610:	6822      	ldr	r2, [r4, #0]
 8006612:	eb02 0309 	add.w	r3, r2, r9
 8006616:	60e3      	str	r3, [r4, #12]
 8006618:	e7c8      	b.n	80065ac <chPipeReadTimeout.constprop.23+0x5c>
    memcpy((void *)bp, (void *)pp->rdptr, n);
 800661a:	462a      	mov	r2, r5
 800661c:	4638      	mov	r0, r7
 800661e:	f7f9 fe57 	bl	80002d0 <memcpy>
    pp->rdptr += n;
 8006622:	68e3      	ldr	r3, [r4, #12]
 8006624:	442b      	add	r3, r5
 8006626:	60e3      	str	r3, [r4, #12]
 8006628:	e7c0      	b.n	80065ac <chPipeReadTimeout.constprop.23+0x5c>
 800662a:	bf00      	nop
 800662c:	20000c98 	.word	0x20000c98
 8006630:	20000cd8 	.word	0x20000cd8
	...

08006640 <oslib_test_003_002_execute>:

static void oslib_test_003_002_execute(void) {

  /* [3.2.1] Reading while pipe is empty.*/
  test_set_step(1);
 8006640:	2301      	movs	r3, #1
static void oslib_test_003_002_execute(void) {
 8006642:	b530      	push	{r4, r5, lr}
  test_set_step(1);
 8006644:	4c21      	ldr	r4, [pc, #132]	; (80066cc <oslib_test_003_002_execute+0x8c>)
static void oslib_test_003_002_execute(void) {
 8006646:	b085      	sub	sp, #20
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8006648:	2110      	movs	r1, #16
 800664a:	4668      	mov	r0, sp
  test_set_step(1);
 800664c:	6023      	str	r3, [r4, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 800664e:	f7ff ff7f 	bl	8006550 <chPipeReadTimeout.constprop.23>
    test_assert(n == 0, "wrong size");
 8006652:	fab0 f080 	clz	r0, r0
 8006656:	491e      	ldr	r1, [pc, #120]	; (80066d0 <oslib_test_003_002_execute+0x90>)
 8006658:	0940      	lsrs	r0, r0, #5
 800665a:	f7fa fb99 	bl	8000d90 <_test_assert>
 800665e:	b940      	cbnz	r0, 8006672 <oslib_test_003_002_execute+0x32>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006660:	4d1c      	ldr	r5, [pc, #112]	; (80066d4 <oslib_test_003_002_execute+0x94>)
 8006662:	68eb      	ldr	r3, [r5, #12]
 8006664:	682a      	ldr	r2, [r5, #0]
 8006666:	4293      	cmp	r3, r2
 8006668:	d01d      	beq.n	80066a6 <oslib_test_003_002_execute+0x66>
 800666a:	491b      	ldr	r1, [pc, #108]	; (80066d8 <oslib_test_003_002_execute+0x98>)
 800666c:	f7fa fb90 	bl	8000d90 <_test_assert>
 8006670:	b108      	cbz	r0, 8006676 <oslib_test_003_002_execute+0x36>
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == PIPE_SIZE / 2),
                "invalid pipe state");
  }
  test_end_step(2);
}
 8006672:	b005      	add	sp, #20
 8006674:	bd30      	pop	{r4, r5, pc}
  test_set_step(2);
 8006676:	2302      	movs	r3, #2
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8006678:	2010      	movs	r0, #16
  test_set_step(2);
 800667a:	6023      	str	r3, [r4, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 800667c:	f7ff fef0 	bl	8006460 <chPipeWriteTimeout.constprop.24>
    test_assert(n == PIPE_SIZE / 2, "wrong size");
 8006680:	f1a0 0008 	sub.w	r0, r0, #8
 8006684:	fab0 f080 	clz	r0, r0
 8006688:	4911      	ldr	r1, [pc, #68]	; (80066d0 <oslib_test_003_002_execute+0x90>)
 800668a:	0940      	lsrs	r0, r0, #5
 800668c:	f7fa fb80 	bl	8000d90 <_test_assert>
 8006690:	2800      	cmp	r0, #0
 8006692:	d1ee      	bne.n	8006672 <oslib_test_003_002_execute+0x32>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8006694:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 8006698:	4293      	cmp	r3, r2
 800669a:	d00c      	beq.n	80066b6 <oslib_test_003_002_execute+0x76>
 800669c:	490e      	ldr	r1, [pc, #56]	; (80066d8 <oslib_test_003_002_execute+0x98>)
 800669e:	f7fa fb77 	bl	8000d90 <_test_assert>
}
 80066a2:	b005      	add	sp, #20
 80066a4:	bd30      	pop	{r4, r5, pc}
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 80066a6:	68aa      	ldr	r2, [r5, #8]
 80066a8:	4293      	cmp	r3, r2
 80066aa:	d1de      	bne.n	800666a <oslib_test_003_002_execute+0x2a>
 80066ac:	6928      	ldr	r0, [r5, #16]
 80066ae:	fab0 f080 	clz	r0, r0
 80066b2:	0940      	lsrs	r0, r0, #5
 80066b4:	e7d9      	b.n	800666a <oslib_test_003_002_execute+0x2a>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 80066b6:	682a      	ldr	r2, [r5, #0]
 80066b8:	4293      	cmp	r3, r2
 80066ba:	d1ef      	bne.n	800669c <oslib_test_003_002_execute+0x5c>
 80066bc:	6928      	ldr	r0, [r5, #16]
 80066be:	f1a0 0008 	sub.w	r0, r0, #8
 80066c2:	fab0 f080 	clz	r0, r0
 80066c6:	0940      	lsrs	r0, r0, #5
 80066c8:	e7e8      	b.n	800669c <oslib_test_003_002_execute+0x5c>
 80066ca:	bf00      	nop
 80066cc:	20001d94 	.word	0x20001d94
 80066d0:	0800b170 	.word	0x0800b170
 80066d4:	20000c98 	.word	0x20000c98
 80066d8:	0800b290 	.word	0x0800b290
 80066dc:	00000000 	.word	0x00000000

080066e0 <chFactoryRegisterObject.constprop.17>:
 * @retval NULL         if the object to be registered cannot be allocated or
 *                      a registered object with the same name exists.
 *
 * @api
 */
registered_object_t *chFactoryRegisterObject(const char *name,
 80066e0:	b538      	push	{r3, r4, r5, lr}
 80066e2:	4605      	mov	r5, r0
                                             void *objp) {
  registered_object_t *rop;

  F_LOCK();
 80066e4:	4807      	ldr	r0, [pc, #28]	; (8006704 <chFactoryRegisterObject.constprop.17+0x24>)
 80066e6:	f7fe f8eb 	bl	80048c0 <chMtxLock>

  rop = (registered_object_t *)dyn_create_object_pool(name,
 80066ea:	4a07      	ldr	r2, [pc, #28]	; (8006708 <chFactoryRegisterObject.constprop.17+0x28>)
 80066ec:	4807      	ldr	r0, [pc, #28]	; (800670c <chFactoryRegisterObject.constprop.17+0x2c>)
 80066ee:	1f11      	subs	r1, r2, #4
 80066f0:	f7fc ff86 	bl	8003600 <dyn_create_object_pool>
                                                      &ch_factory.obj_list,
                                                      &ch_factory.obj_pool);
  if (rop != NULL) {
 80066f4:	4604      	mov	r4, r0
 80066f6:	b100      	cbz	r0, 80066fa <chFactoryRegisterObject.constprop.17+0x1a>
    /* Initializing registered object data.*/
    rop->objp = objp;
 80066f8:	6105      	str	r5, [r0, #16]
  }

  F_UNLOCK();
 80066fa:	4802      	ldr	r0, [pc, #8]	; (8006704 <chFactoryRegisterObject.constprop.17+0x24>)
 80066fc:	f7ff fdb0 	bl	8006260 <chMtxUnlock>

  return rop;
}
 8006700:	4620      	mov	r0, r4
 8006702:	bd38      	pop	{r3, r4, r5, pc}
 8006704:	200012cc 	.word	0x200012cc
 8006708:	200012e0 	.word	0x200012e0
 800670c:	0800a9fc 	.word	0x0800a9fc

08006710 <chFactoryFindObject.constprop.16>:
 * @retval NULL         if a registered object with the specified name
 *                      does not exist.
 *
 * @api
 */
registered_object_t *chFactoryFindObject(const char *name) {
 8006710:	b538      	push	{r3, r4, r5, lr}
  registered_object_t *rop;

  F_LOCK();
 8006712:	4c07      	ldr	r4, [pc, #28]	; (8006730 <chFactoryFindObject.constprop.16+0x20>)
 8006714:	4620      	mov	r0, r4
 8006716:	f7fe f8d3 	bl	80048c0 <chMtxLock>

  rop = (registered_object_t *)dyn_find_object(name, &ch_factory.obj_list);
 800671a:	f104 0110 	add.w	r1, r4, #16
 800671e:	4805      	ldr	r0, [pc, #20]	; (8006734 <chFactoryFindObject.constprop.16+0x24>)
 8006720:	f7fc ff4e 	bl	80035c0 <dyn_find_object>
 8006724:	4605      	mov	r5, r0

  F_UNLOCK();
 8006726:	4620      	mov	r0, r4
 8006728:	f7ff fd9a 	bl	8006260 <chMtxUnlock>

  return rop;
}
 800672c:	4628      	mov	r0, r5
 800672e:	bd38      	pop	{r3, r4, r5, pc}
 8006730:	200012cc 	.word	0x200012cc
 8006734:	0800a9fc 	.word	0x0800a9fc
	...

08006740 <chFactoryCreateBuffer.constprop.15>:
 * @retval NULL         if the dynamic buffer object cannot be allocated or
 *                      a dynamic buffer object with the same name exists.
 *
 * @api
 */
dyn_buffer_t *chFactoryCreateBuffer(const char *name, size_t size) {
 8006740:	b510      	push	{r4, lr}
  dyn_buffer_t *dbp;

  F_LOCK();
 8006742:	480a      	ldr	r0, [pc, #40]	; (800676c <chFactoryCreateBuffer.constprop.15+0x2c>)
 8006744:	f7fe f8bc 	bl	80048c0 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_create_object_heap(name,
 8006748:	2280      	movs	r2, #128	; 0x80
 800674a:	4909      	ldr	r1, [pc, #36]	; (8006770 <chFactoryCreateBuffer.constprop.15+0x30>)
 800674c:	4809      	ldr	r0, [pc, #36]	; (8006774 <chFactoryCreateBuffer.constprop.15+0x34>)
 800674e:	f7ff fe37 	bl	80063c0 <dyn_create_object_heap>
                                               &ch_factory.buf_list,
                                               size);
  if (dbp != NULL) {
 8006752:	4604      	mov	r4, r0
 8006754:	b120      	cbz	r0, 8006760 <chFactoryCreateBuffer.constprop.15+0x20>
    /* Initializing buffer object data.*/
    memset((void *)(dbp + 1), 0, size);
 8006756:	2280      	movs	r2, #128	; 0x80
 8006758:	2100      	movs	r1, #0
 800675a:	3010      	adds	r0, #16
 800675c:	f7f9 fe2e 	bl	80003bc <memset>
  }

  F_UNLOCK();
 8006760:	4802      	ldr	r0, [pc, #8]	; (800676c <chFactoryCreateBuffer.constprop.15+0x2c>)
 8006762:	f7ff fd7d 	bl	8006260 <chMtxUnlock>

  return dbp;
}
 8006766:	4620      	mov	r0, r4
 8006768:	bd10      	pop	{r4, pc}
 800676a:	bf00      	nop
 800676c:	200012cc 	.word	0x200012cc
 8006770:	200012f0 	.word	0x200012f0
 8006774:	0800a9d4 	.word	0x0800a9d4
	...

08006780 <chFactoryFindBuffer.constprop.14>:
 * @retval NULL         if a dynamic buffer object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_buffer_t *chFactoryFindBuffer(const char *name) {
 8006780:	b538      	push	{r3, r4, r5, lr}
  dyn_buffer_t *dbp;

  F_LOCK();
 8006782:	4c07      	ldr	r4, [pc, #28]	; (80067a0 <chFactoryFindBuffer.constprop.14+0x20>)
 8006784:	4620      	mov	r0, r4
 8006786:	f7fe f89b 	bl	80048c0 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_find_object(name, &ch_factory.buf_list);
 800678a:	f104 0124 	add.w	r1, r4, #36	; 0x24
 800678e:	4805      	ldr	r0, [pc, #20]	; (80067a4 <chFactoryFindBuffer.constprop.14+0x24>)
 8006790:	f7fc ff16 	bl	80035c0 <dyn_find_object>
 8006794:	4605      	mov	r5, r0

  F_UNLOCK();
 8006796:	4620      	mov	r0, r4
 8006798:	f7ff fd62 	bl	8006260 <chMtxUnlock>

  return dbp;
}
 800679c:	4628      	mov	r0, r5
 800679e:	bd38      	pop	{r3, r4, r5, pc}
 80067a0:	200012cc 	.word	0x200012cc
 80067a4:	0800a9d4 	.word	0x0800a9d4
	...

080067b0 <chFactoryCreateSemaphore.constprop.13>:
 * @retval NULL         if the dynamic semaphore object cannot be allocated or
 *                      a dynamic semaphore with the same name exists.
 *
 * @api
 */
dyn_semaphore_t *chFactoryCreateSemaphore(const char *name, cnt_t n) {
 80067b0:	b510      	push	{r4, lr}
  dyn_semaphore_t *dsp;

  F_LOCK();
 80067b2:	480a      	ldr	r0, [pc, #40]	; (80067dc <chFactoryCreateSemaphore.constprop.13+0x2c>)
 80067b4:	f7fe f884 	bl	80048c0 <chMtxLock>

  dsp = (dyn_semaphore_t *)dyn_create_object_pool(name,
 80067b8:	4a09      	ldr	r2, [pc, #36]	; (80067e0 <chFactoryCreateSemaphore.constprop.13+0x30>)
 80067ba:	480a      	ldr	r0, [pc, #40]	; (80067e4 <chFactoryCreateSemaphore.constprop.13+0x34>)
 80067bc:	1f11      	subs	r1, r2, #4
 80067be:	f7fc ff1f 	bl	8003600 <dyn_create_object_pool>
                                                  &ch_factory.sem_list,
                                                  &ch_factory.sem_pool);
  if (dsp != NULL) {
 80067c2:	4604      	mov	r4, r0
 80067c4:	b128      	cbz	r0, 80067d2 <chFactoryCreateSemaphore.constprop.13+0x22>
 80067c6:	2200      	movs	r2, #0
    /* Initializing semaphore object dataa.*/
    chSemObjectInit(&dsp->sem, n);
 80067c8:	f100 0310 	add.w	r3, r0, #16
  tqp->prev = (thread_t *)tqp;
 80067cc:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80067d0:	6182      	str	r2, [r0, #24]
  }

  F_UNLOCK();
 80067d2:	4802      	ldr	r0, [pc, #8]	; (80067dc <chFactoryCreateSemaphore.constprop.13+0x2c>)
 80067d4:	f7ff fd44 	bl	8006260 <chMtxUnlock>

  return dsp;
}
 80067d8:	4620      	mov	r0, r4
 80067da:	bd10      	pop	{r4, pc}
 80067dc:	200012cc 	.word	0x200012cc
 80067e0:	200012f8 	.word	0x200012f8
 80067e4:	0800a9f4 	.word	0x0800a9f4
	...

080067f0 <chFactoryFindSemaphore.constprop.12>:
 * @retval NULL         if a dynamic semaphore object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_semaphore_t *chFactoryFindSemaphore(const char *name) {
 80067f0:	b538      	push	{r3, r4, r5, lr}
  dyn_semaphore_t *dsp;

  F_LOCK();
 80067f2:	4c07      	ldr	r4, [pc, #28]	; (8006810 <chFactoryFindSemaphore.constprop.12+0x20>)
 80067f4:	4620      	mov	r0, r4
 80067f6:	f7fe f863 	bl	80048c0 <chMtxLock>

  dsp = (dyn_semaphore_t *)dyn_find_object(name, &ch_factory.sem_list);
 80067fa:	f104 0128 	add.w	r1, r4, #40	; 0x28
 80067fe:	4805      	ldr	r0, [pc, #20]	; (8006814 <chFactoryFindSemaphore.constprop.12+0x24>)
 8006800:	f7fc fede 	bl	80035c0 <dyn_find_object>
 8006804:	4605      	mov	r5, r0

  F_UNLOCK();
 8006806:	4620      	mov	r0, r4
 8006808:	f7ff fd2a 	bl	8006260 <chMtxUnlock>

  return dsp;
}
 800680c:	4628      	mov	r0, r5
 800680e:	bd38      	pop	{r3, r4, r5, pc}
 8006810:	200012cc 	.word	0x200012cc
 8006814:	0800a9f4 	.word	0x0800a9f4
	...

08006820 <chFactoryCreateMailbox.constprop.11>:
 * @retval NULL         if the dynamic mailbox object cannot be allocated or
 *                      a dynamic mailbox object with the same name exists.
 *
 * @api
 */
dyn_mailbox_t *chFactoryCreateMailbox(const char *name, size_t n) {
 8006820:	b538      	push	{r3, r4, r5, lr}
  dyn_mailbox_t *dmp;

  F_LOCK();
 8006822:	4811      	ldr	r0, [pc, #68]	; (8006868 <chFactoryCreateMailbox.constprop.11+0x48>)
 8006824:	f7fe f84c 	bl	80048c0 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_create_object_heap(name,
 8006828:	2278      	movs	r2, #120	; 0x78
 800682a:	4910      	ldr	r1, [pc, #64]	; (800686c <chFactoryCreateMailbox.constprop.11+0x4c>)
 800682c:	4810      	ldr	r0, [pc, #64]	; (8006870 <chFactoryCreateMailbox.constprop.11+0x50>)
 800682e:	f7ff fdc7 	bl	80063c0 <dyn_create_object_heap>
                                                &ch_factory.mbx_list,
                                                sizeof (dyn_mailbox_t) +
                                                (n * sizeof (msg_t)));
  if (dmp != NULL) {
 8006832:	4604      	mov	r4, r0
 8006834:	b198      	cbz	r0, 800685e <chFactoryCreateMailbox.constprop.11+0x3e>
  mbp->cnt    = (size_t)0;
 8006836:	2000      	movs	r0, #0
    /* Initializing mailbox object data.*/
    chMBObjectInit(&dmp->mbx, (msg_t *)(dmp + 1), n);
 8006838:	f104 0338 	add.w	r3, r4, #56	; 0x38
  chThdQueueObjectInit(&mbp->qw);
 800683c:	f104 0128 	add.w	r1, r4, #40	; 0x28
  chThdQueueObjectInit(&mbp->qr);
 8006840:	f104 0230 	add.w	r2, r4, #48	; 0x30
  mbp->wrptr  = buf;
 8006844:	e9c4 3306 	strd	r3, r3, [r4, #24]
 8006848:	e9c4 110a 	strd	r1, r1, [r4, #40]	; 0x28
 800684c:	e9c4 220c 	strd	r2, r2, [r4, #48]	; 0x30
  mbp->top    = &buf[n];
 8006850:	f104 0578 	add.w	r5, r4, #120	; 0x78
  mbp->cnt    = (size_t)0;
 8006854:	6220      	str	r0, [r4, #32]
  mbp->reset  = false;
 8006856:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
  mbp->buffer = buf;
 800685a:	6123      	str	r3, [r4, #16]
  mbp->top    = &buf[n];
 800685c:	6165      	str	r5, [r4, #20]
  }

  F_UNLOCK();
 800685e:	4802      	ldr	r0, [pc, #8]	; (8006868 <chFactoryCreateMailbox.constprop.11+0x48>)
 8006860:	f7ff fcfe 	bl	8006260 <chMtxUnlock>

  return dmp;
}
 8006864:	4620      	mov	r0, r4
 8006866:	bd38      	pop	{r3, r4, r5, pc}
 8006868:	200012cc 	.word	0x200012cc
 800686c:	20001308 	.word	0x20001308
 8006870:	0800a9dc 	.word	0x0800a9dc
	...

08006880 <chFactoryFindMailbox.constprop.10>:
 * @retval NULL         if a dynamic mailbox object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_mailbox_t *chFactoryFindMailbox(const char *name) {
 8006880:	b538      	push	{r3, r4, r5, lr}
  dyn_mailbox_t *dmp;

  F_LOCK();
 8006882:	4c07      	ldr	r4, [pc, #28]	; (80068a0 <chFactoryFindMailbox.constprop.10+0x20>)
 8006884:	4620      	mov	r0, r4
 8006886:	f7fe f81b 	bl	80048c0 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_find_object(name, &ch_factory.mbx_list);
 800688a:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 800688e:	4805      	ldr	r0, [pc, #20]	; (80068a4 <chFactoryFindMailbox.constprop.10+0x24>)
 8006890:	f7fc fe96 	bl	80035c0 <dyn_find_object>
 8006894:	4605      	mov	r5, r0

  F_UNLOCK();
 8006896:	4620      	mov	r0, r4
 8006898:	f7ff fce2 	bl	8006260 <chMtxUnlock>

  return dmp;
}
 800689c:	4628      	mov	r0, r5
 800689e:	bd38      	pop	{r3, r4, r5, pc}
 80068a0:	200012cc 	.word	0x200012cc
 80068a4:	0800a9dc 	.word	0x0800a9dc
	...

080068b0 <chFactoryCreateObjectsFIFO.constprop.9>:
 *                      allocated or a dynamic "objects FIFO" object with
 *                      the same name exists.
 *
 * @api
 */
dyn_objects_fifo_t *chFactoryCreateObjectsFIFO(const char *name,
 80068b0:	b570      	push	{r4, r5, r6, lr}
                                               size_t objsize,
                                               size_t objn,
                                               unsigned objalign) {
  dyn_objects_fifo_t *dofp;

  F_LOCK();
 80068b2:	4818      	ldr	r0, [pc, #96]	; (8006914 <chFactoryCreateObjectsFIFO.constprop.9+0x64>)
 80068b4:	f7fe f804 	bl	80048c0 <chMtxLock>

  dofp = (dyn_objects_fifo_t *)dyn_create_object_heap(name,
 80068b8:	f44f 72ca 	mov.w	r2, #404	; 0x194
 80068bc:	4916      	ldr	r1, [pc, #88]	; (8006918 <chFactoryCreateObjectsFIFO.constprop.9+0x68>)
 80068be:	4817      	ldr	r0, [pc, #92]	; (800691c <chFactoryCreateObjectsFIFO.constprop.9+0x6c>)
 80068c0:	f7ff fd7e 	bl	80063c0 <dyn_create_object_heap>
                                                      &ch_factory.fifo_list,
                                                      sizeof (dyn_objects_fifo_t) +
                                                      (objn * sizeof (msg_t)) +
                                                      (objn * objsize));
  if (dofp != NULL) {
 80068c4:	4604      	mov	r4, r0
 80068c6:	b300      	cbz	r0, 800690a <chFactoryCreateObjectsFIFO.constprop.9+0x5a>
  mp->object_size = size;
 80068c8:	2210      	movs	r2, #16
  mp->next = NULL;
 80068ca:	2500      	movs	r5, #0
  mp->align = align;
 80068cc:	2304      	movs	r3, #4
    msg_t *msgbuf = (msg_t *)(dofp + 1);

    /* Initializing mailbox object data.*/
    chFifoObjectInitAligned(&dofp->fifo, objsize, objn, objalign,
                            (void *)&msgbuf[objn], msgbuf);
 80068ce:	f100 0694 	add.w	r6, r0, #148	; 0x94
                                           size_t objn, unsigned objalign,
                                           void *objbuf, msg_t *msgbuf) {

  chDbgCheck((objsize >= objalign) && ((objsize % objalign) == 0U));

  chGuardedPoolObjectInitAligned(&ofp->free, objsize, objalign);
 80068d2:	4410      	add	r0, r2
 80068d4:	e9c4 2308 	strd	r2, r3, [r4, #32]
  chGuardedPoolLoadArray(&ofp->free, objbuf, objn);
 80068d8:	4631      	mov	r1, r6
  mp->next = NULL;
 80068da:	61e5      	str	r5, [r4, #28]
  mp->provider = provider;
 80068dc:	62a5      	str	r5, [r4, #40]	; 0x28
 80068de:	61a5      	str	r5, [r4, #24]
 80068e0:	e9c4 0004 	strd	r0, r0, [r4, #16]
 80068e4:	f7fe ffe4 	bl	80058b0 <chGuardedPoolLoadArray>
    msg_t *msgbuf = (msg_t *)(dofp + 1);
 80068e8:	f104 0354 	add.w	r3, r4, #84	; 0x54
  chThdQueueObjectInit(&mbp->qw);
 80068ec:	f104 0144 	add.w	r1, r4, #68	; 0x44
  chThdQueueObjectInit(&mbp->qr);
 80068f0:	f104 024c 	add.w	r2, r4, #76	; 0x4c
  mbp->wrptr  = buf;
 80068f4:	e9c4 330d 	strd	r3, r3, [r4, #52]	; 0x34
 80068f8:	e9c4 1111 	strd	r1, r1, [r4, #68]	; 0x44
 80068fc:	e9c4 2213 	strd	r2, r2, [r4, #76]	; 0x4c
  mbp->top    = &buf[n];
 8006900:	6326      	str	r6, [r4, #48]	; 0x30
  mbp->cnt    = (size_t)0;
 8006902:	63e5      	str	r5, [r4, #60]	; 0x3c
  mbp->reset  = false;
 8006904:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
  mbp->buffer = buf;
 8006908:	62e3      	str	r3, [r4, #44]	; 0x2c
  }

  F_UNLOCK();
 800690a:	4802      	ldr	r0, [pc, #8]	; (8006914 <chFactoryCreateObjectsFIFO.constprop.9+0x64>)
 800690c:	f7ff fca8 	bl	8006260 <chMtxUnlock>

  return dofp;
}
 8006910:	4620      	mov	r0, r4
 8006912:	bd70      	pop	{r4, r5, r6, pc}
 8006914:	200012cc 	.word	0x200012cc
 8006918:	2000130c 	.word	0x2000130c
 800691c:	0800a9e4 	.word	0x0800a9e4

08006920 <chFactoryFindObjectsFIFO.constprop.8>:
 * @retval NULL         if a dynamic "objects FIFO" object with the specified
 *                      name does not exist.
 *
 * @api
 */
dyn_objects_fifo_t *chFactoryFindObjectsFIFO(const char *name) {
 8006920:	b538      	push	{r3, r4, r5, lr}
  dyn_objects_fifo_t *dofp;

  F_LOCK();
 8006922:	4c07      	ldr	r4, [pc, #28]	; (8006940 <chFactoryFindObjectsFIFO.constprop.8+0x20>)
 8006924:	4620      	mov	r0, r4
 8006926:	f7fd ffcb 	bl	80048c0 <chMtxLock>

  dofp = (dyn_objects_fifo_t *)dyn_find_object(name, &ch_factory.fifo_list);
 800692a:	f104 0140 	add.w	r1, r4, #64	; 0x40
 800692e:	4805      	ldr	r0, [pc, #20]	; (8006944 <chFactoryFindObjectsFIFO.constprop.8+0x24>)
 8006930:	f7fc fe46 	bl	80035c0 <dyn_find_object>
 8006934:	4605      	mov	r5, r0

  F_UNLOCK();
 8006936:	4620      	mov	r0, r4
 8006938:	f7ff fc92 	bl	8006260 <chMtxUnlock>

  return dofp;
}
 800693c:	4628      	mov	r0, r5
 800693e:	bd38      	pop	{r3, r4, r5, pc}
 8006940:	200012cc 	.word	0x200012cc
 8006944:	0800a9e4 	.word	0x0800a9e4
	...

08006950 <chFactoryCreatePipe.constprop.7>:
 *                      allocated or a dynamic pipe object with
 *                      the same name exists.
 *
 * @api
 */
dyn_pipe_t *chFactoryCreatePipe(const char *name, size_t size) {
 8006950:	b538      	push	{r3, r4, r5, lr}
  dyn_pipe_t *dpp;

  F_LOCK();
 8006952:	4815      	ldr	r0, [pc, #84]	; (80069a8 <chFactoryCreatePipe.constprop.7+0x58>)
 8006954:	f7fd ffb4 	bl	80048c0 <chMtxLock>

  dpp = (dyn_pipe_t *)dyn_create_object_heap(name,
 8006958:	2270      	movs	r2, #112	; 0x70
 800695a:	4914      	ldr	r1, [pc, #80]	; (80069ac <chFactoryCreatePipe.constprop.7+0x5c>)
 800695c:	4814      	ldr	r0, [pc, #80]	; (80069b0 <chFactoryCreatePipe.constprop.7+0x60>)
 800695e:	f7ff fd2f 	bl	80063c0 <dyn_create_object_heap>
                                             &ch_factory.pipe_list,
                                             sizeof (dyn_pipe_t) + size);
  if (dpp != NULL) {
 8006962:	4604      	mov	r4, r0
 8006964:	b1d8      	cbz	r0, 800699e <chFactoryCreatePipe.constprop.7+0x4e>
  pp->cnt    = (size_t)0;
 8006966:	2300      	movs	r3, #0
    /* Initializing mailbox object data.*/
    chPipeObjectInit(&dpp->pipe, (uint8_t *)(dpp + 1), size);
 8006968:	f100 0260 	add.w	r2, r0, #96	; 0x60
  pp->top    = &buf[n];
 800696c:	f100 0570 	add.w	r5, r0, #112	; 0x70
  PW_INIT(pp);
 8006970:	f104 0140 	add.w	r1, r4, #64	; 0x40
  PC_INIT(pp);
 8006974:	3030      	adds	r0, #48	; 0x30
  pp->cnt    = (size_t)0;
 8006976:	6223      	str	r3, [r4, #32]
  pp->reset  = false;
 8006978:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  pp->rtr    = NULL;
 800697c:	e9c4 330a 	strd	r3, r3, [r4, #40]	; 0x28
  mp->owner = NULL;
 8006980:	63a3      	str	r3, [r4, #56]	; 0x38
 8006982:	64a3      	str	r3, [r4, #72]	; 0x48
 8006984:	65a3      	str	r3, [r4, #88]	; 0x58
  PR_INIT(pp);
 8006986:	f104 0350 	add.w	r3, r4, #80	; 0x50
  pp->wrptr  = buf;
 800698a:	e9c4 2206 	strd	r2, r2, [r4, #24]
 800698e:	e9c4 000c 	strd	r0, r0, [r4, #48]	; 0x30
 8006992:	e9c4 1110 	strd	r1, r1, [r4, #64]	; 0x40
 8006996:	e9c4 3314 	strd	r3, r3, [r4, #80]	; 0x50
  pp->buffer = buf;
 800699a:	6122      	str	r2, [r4, #16]
  pp->top    = &buf[n];
 800699c:	6165      	str	r5, [r4, #20]
  }

  F_UNLOCK();
 800699e:	4802      	ldr	r0, [pc, #8]	; (80069a8 <chFactoryCreatePipe.constprop.7+0x58>)
 80069a0:	f7ff fc5e 	bl	8006260 <chMtxUnlock>

  return dpp;
}
 80069a4:	4620      	mov	r0, r4
 80069a6:	bd38      	pop	{r3, r4, r5, pc}
 80069a8:	200012cc 	.word	0x200012cc
 80069ac:	20001310 	.word	0x20001310
 80069b0:	0800a9ec 	.word	0x0800a9ec
	...

080069c0 <chFactoryFindPipe.constprop.6>:
 * @retval NULL         if a dynamic pipe object with the specified
 *                      name does not exist.
 *
 * @api
 */
dyn_pipe_t *chFactoryFindPipe(const char *name) {
 80069c0:	b538      	push	{r3, r4, r5, lr}
  dyn_pipe_t *dpp;

  F_LOCK();
 80069c2:	4c07      	ldr	r4, [pc, #28]	; (80069e0 <chFactoryFindPipe.constprop.6+0x20>)
 80069c4:	4620      	mov	r0, r4
 80069c6:	f7fd ff7b 	bl	80048c0 <chMtxLock>

  dpp = (dyn_pipe_t *)dyn_find_object(name, &ch_factory.pipe_list);
 80069ca:	f104 0144 	add.w	r1, r4, #68	; 0x44
 80069ce:	4805      	ldr	r0, [pc, #20]	; (80069e4 <chFactoryFindPipe.constprop.6+0x24>)
 80069d0:	f7fc fdf6 	bl	80035c0 <dyn_find_object>
 80069d4:	4605      	mov	r5, r0

  F_UNLOCK();
 80069d6:	4620      	mov	r0, r4
 80069d8:	f7ff fc42 	bl	8006260 <chMtxUnlock>

  return dpp;
}
 80069dc:	4628      	mov	r0, r5
 80069de:	bd38      	pop	{r3, r4, r5, pc}
 80069e0:	200012cc 	.word	0x200012cc
 80069e4:	0800a9ec 	.word	0x0800a9ec
	...

080069f0 <oslib_test_003_001_execute>:
static void oslib_test_003_001_execute(void) {
 80069f0:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 80069f2:	2501      	movs	r5, #1
  PC_LOCK(pp);
 80069f4:	4c1e      	ldr	r4, [pc, #120]	; (8006a70 <oslib_test_003_001_execute+0x80>)
 80069f6:	4e1f      	ldr	r6, [pc, #124]	; (8006a74 <oslib_test_003_001_execute+0x84>)
static void oslib_test_003_001_execute(void) {
 80069f8:	b084      	sub	sp, #16
 80069fa:	f104 0020 	add.w	r0, r4, #32
  test_set_step(1);
 80069fe:	6035      	str	r5, [r6, #0]
 8006a00:	f7fd ff5e 	bl	80048c0 <chMtxLock>
  pp->cnt   = (size_t)0;
 8006a04:	2200      	movs	r2, #0
  pp->wrptr = pp->buffer;
 8006a06:	6823      	ldr	r3, [r4, #0]
  pp->reset = true;
 8006a08:	7525      	strb	r5, [r4, #20]
  pp->rdptr = pp->buffer;
 8006a0a:	e9c4 3302 	strd	r3, r3, [r4, #8]
  pp->cnt   = (size_t)0;
 8006a0e:	6122      	str	r2, [r4, #16]
 8006a10:	2320      	movs	r3, #32
 8006a12:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 8006a16:	69a0      	ldr	r0, [r4, #24]
 8006a18:	b128      	cbz	r0, 8006a26 <oslib_test_003_001_execute+0x36>
    tp->u.rdymsg = msg;
 8006a1a:	f06f 0301 	mvn.w	r3, #1
 8006a1e:	6243      	str	r3, [r0, #36]	; 0x24
    *trp = NULL;
 8006a20:	61a2      	str	r2, [r4, #24]
    (void) chSchReadyI(tp);
 8006a22:	f7fa fde5 	bl	80015f0 <chSchReadyI>
  if (*trp != NULL) {
 8006a26:	69e0      	ldr	r0, [r4, #28]
 8006a28:	b130      	cbz	r0, 8006a38 <oslib_test_003_001_execute+0x48>
    tp->u.rdymsg = msg;
 8006a2a:	f06f 0201 	mvn.w	r2, #1
    *trp = NULL;
 8006a2e:	2300      	movs	r3, #0
    tp->u.rdymsg = msg;
 8006a30:	6242      	str	r2, [r0, #36]	; 0x24
    *trp = NULL;
 8006a32:	61e3      	str	r3, [r4, #28]
    (void) chSchReadyI(tp);
 8006a34:	f7fa fddc 	bl	80015f0 <chSchReadyI>
  chSchRescheduleS();
 8006a38:	f7fe fa5a 	bl	8004ef0 <chSchRescheduleS>
 8006a3c:	2500      	movs	r5, #0
 8006a3e:	f385 8811 	msr	BASEPRI, r5
  PC_UNLOCK(pp);
 8006a42:	480d      	ldr	r0, [pc, #52]	; (8006a78 <oslib_test_003_001_execute+0x88>)
 8006a44:	f7ff fc0c 	bl	8006260 <chMtxUnlock>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006a48:	68e3      	ldr	r3, [r4, #12]
 8006a4a:	6822      	ldr	r2, [r4, #0]
 8006a4c:	4293      	cmp	r3, r2
 8006a4e:	d006      	beq.n	8006a5e <oslib_test_003_001_execute+0x6e>
 8006a50:	4628      	mov	r0, r5
 8006a52:	490a      	ldr	r1, [pc, #40]	; (8006a7c <oslib_test_003_001_execute+0x8c>)
 8006a54:	f7fa f99c 	bl	8000d90 <_test_assert>
 8006a58:	b190      	cbz	r0, 8006a80 <oslib_test_003_001_execute+0x90>
}
 8006a5a:	b004      	add	sp, #16
 8006a5c:	bd70      	pop	{r4, r5, r6, pc}
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006a5e:	68a2      	ldr	r2, [r4, #8]
 8006a60:	4293      	cmp	r3, r2
 8006a62:	d1f5      	bne.n	8006a50 <oslib_test_003_001_execute+0x60>
 8006a64:	6925      	ldr	r5, [r4, #16]
 8006a66:	fab5 f085 	clz	r0, r5
 8006a6a:	0940      	lsrs	r0, r0, #5
 8006a6c:	e7f1      	b.n	8006a52 <oslib_test_003_001_execute+0x62>
 8006a6e:	bf00      	nop
 8006a70:	20000c98 	.word	0x20000c98
 8006a74:	20001d94 	.word	0x20001d94
 8006a78:	20000cb8 	.word	0x20000cb8
 8006a7c:	0800b290 	.word	0x0800b290
  test_set_step(2);
 8006a80:	2302      	movs	r3, #2
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8006a82:	2010      	movs	r0, #16
  test_set_step(2);
 8006a84:	6033      	str	r3, [r6, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8006a86:	f7ff fceb 	bl	8006460 <chPipeWriteTimeout.constprop.24>
    test_assert(n == 0, "not reset");
 8006a8a:	fab0 f080 	clz	r0, r0
 8006a8e:	49bf      	ldr	r1, [pc, #764]	; (8006d8c <oslib_test_003_001_execute+0x39c>)
 8006a90:	0940      	lsrs	r0, r0, #5
 8006a92:	f7fa f97d 	bl	8000d90 <_test_assert>
 8006a96:	2800      	cmp	r0, #0
 8006a98:	d1df      	bne.n	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006a9a:	68e3      	ldr	r3, [r4, #12]
 8006a9c:	6822      	ldr	r2, [r4, #0]
 8006a9e:	4293      	cmp	r3, r2
 8006aa0:	f000 8199 	beq.w	8006dd6 <oslib_test_003_001_execute+0x3e6>
 8006aa4:	49ba      	ldr	r1, [pc, #744]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006aa6:	f7fa f973 	bl	8000d90 <_test_assert>
 8006aaa:	2800      	cmp	r0, #0
 8006aac:	d1d5      	bne.n	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(3);
 8006aae:	2303      	movs	r3, #3
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8006ab0:	2110      	movs	r1, #16
 8006ab2:	4668      	mov	r0, sp
  test_set_step(3);
 8006ab4:	6033      	str	r3, [r6, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8006ab6:	f7ff fd4b 	bl	8006550 <chPipeReadTimeout.constprop.23>
    test_assert(n == 0, "not reset");
 8006aba:	fab0 f080 	clz	r0, r0
 8006abe:	49b3      	ldr	r1, [pc, #716]	; (8006d8c <oslib_test_003_001_execute+0x39c>)
 8006ac0:	0940      	lsrs	r0, r0, #5
 8006ac2:	f7fa f965 	bl	8000d90 <_test_assert>
 8006ac6:	2800      	cmp	r0, #0
 8006ac8:	d1c7      	bne.n	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006aca:	68e3      	ldr	r3, [r4, #12]
 8006acc:	6822      	ldr	r2, [r4, #0]
 8006ace:	4293      	cmp	r3, r2
 8006ad0:	f000 818a 	beq.w	8006de8 <oslib_test_003_001_execute+0x3f8>
 8006ad4:	49ae      	ldr	r1, [pc, #696]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006ad6:	f7fa f95b 	bl	8000d90 <_test_assert>
 8006ada:	2800      	cmp	r0, #0
 8006adc:	d1bd      	bne.n	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(4);
 8006ade:	2104      	movs	r1, #4
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006ae0:	68e3      	ldr	r3, [r4, #12]
 8006ae2:	6822      	ldr	r2, [r4, #0]
 *
 * @api
 */
static inline void chPipeResume(pipe_t *pp) {

  pp->reset = false;
 8006ae4:	7520      	strb	r0, [r4, #20]
 8006ae6:	4293      	cmp	r3, r2
  test_set_step(4);
 8006ae8:	6031      	str	r1, [r6, #0]
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006aea:	f000 8186 	beq.w	8006dfa <oslib_test_003_001_execute+0x40a>
 8006aee:	49a8      	ldr	r1, [pc, #672]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006af0:	f7fa f94e 	bl	8000d90 <_test_assert>
 8006af4:	2800      	cmp	r0, #0
 8006af6:	d1b0      	bne.n	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(5);
 8006af8:	2305      	movs	r3, #5
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8006afa:	2010      	movs	r0, #16
  test_set_step(5);
 8006afc:	6033      	str	r3, [r6, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8006afe:	f7ff fcaf 	bl	8006460 <chPipeWriteTimeout.constprop.24>
    test_assert(n == PIPE_SIZE, "wrong size");
 8006b02:	f1a0 0010 	sub.w	r0, r0, #16
 8006b06:	fab0 f080 	clz	r0, r0
 8006b0a:	49a2      	ldr	r1, [pc, #648]	; (8006d94 <oslib_test_003_001_execute+0x3a4>)
 8006b0c:	0940      	lsrs	r0, r0, #5
 8006b0e:	f7fa f93f 	bl	8000d90 <_test_assert>
 8006b12:	2800      	cmp	r0, #0
 8006b14:	d1a1      	bne.n	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006b16:	68e3      	ldr	r3, [r4, #12]
 8006b18:	6822      	ldr	r2, [r4, #0]
 8006b1a:	4293      	cmp	r3, r2
 8006b1c:	f000 8176 	beq.w	8006e0c <oslib_test_003_001_execute+0x41c>
 8006b20:	499b      	ldr	r1, [pc, #620]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006b22:	f7fa f935 	bl	8000d90 <_test_assert>
 8006b26:	2800      	cmp	r0, #0
 8006b28:	d197      	bne.n	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(6);
 8006b2a:	2306      	movs	r3, #6
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8006b2c:	2110      	movs	r1, #16
 8006b2e:	4668      	mov	r0, sp
  test_set_step(6);
 8006b30:	6033      	str	r3, [r6, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8006b32:	f7ff fd0d 	bl	8006550 <chPipeReadTimeout.constprop.23>
    test_assert(n == PIPE_SIZE, "wrong size");
 8006b36:	f1a0 0010 	sub.w	r0, r0, #16
 8006b3a:	fab0 f080 	clz	r0, r0
 8006b3e:	4995      	ldr	r1, [pc, #596]	; (8006d94 <oslib_test_003_001_execute+0x3a4>)
 8006b40:	0940      	lsrs	r0, r0, #5
 8006b42:	f7fa f925 	bl	8000d90 <_test_assert>
 8006b46:	2800      	cmp	r0, #0
 8006b48:	d187      	bne.n	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006b4a:	68e3      	ldr	r3, [r4, #12]
 8006b4c:	6822      	ldr	r2, [r4, #0]
 8006b4e:	4293      	cmp	r3, r2
 8006b50:	f000 8168 	beq.w	8006e24 <oslib_test_003_001_execute+0x434>
 8006b54:	498e      	ldr	r1, [pc, #568]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006b56:	f7fa f91b 	bl	8000d90 <_test_assert>
 8006b5a:	2800      	cmp	r0, #0
 8006b5c:	f47f af7d 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
 8006b60:	4669      	mov	r1, sp
 8006b62:	2210      	movs	r2, #16
 8006b64:	488c      	ldr	r0, [pc, #560]	; (8006d98 <oslib_test_003_001_execute+0x3a8>)
 8006b66:	f7f9 fb81 	bl	800026c <memcmp>
 8006b6a:	fab0 f080 	clz	r0, r0
 8006b6e:	498b      	ldr	r1, [pc, #556]	; (8006d9c <oslib_test_003_001_execute+0x3ac>)
 8006b70:	0940      	lsrs	r0, r0, #5
 8006b72:	f7fa f90d 	bl	8000d90 <_test_assert>
 8006b76:	2800      	cmp	r0, #0
 8006b78:	f47f af6f 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(7);
 8006b7c:	2307      	movs	r3, #7
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 4, TIME_IMMEDIATE);
 8006b7e:	2004      	movs	r0, #4
  test_set_step(7);
 8006b80:	6033      	str	r3, [r6, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 4, TIME_IMMEDIATE);
 8006b82:	f7ff fc6d 	bl	8006460 <chPipeWriteTimeout.constprop.24>
    test_assert(n == 4, "wrong size");
 8006b86:	1f05      	subs	r5, r0, #4
 8006b88:	4268      	negs	r0, r5
 8006b8a:	4168      	adcs	r0, r5
 8006b8c:	4981      	ldr	r1, [pc, #516]	; (8006d94 <oslib_test_003_001_execute+0x3a4>)
 8006b8e:	f7fa f8ff 	bl	8000d90 <_test_assert>
 8006b92:	2800      	cmp	r0, #0
 8006b94:	f47f af61 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
 8006b98:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8006b9c:	4293      	cmp	r3, r2
 8006b9e:	d006      	beq.n	8006bae <oslib_test_003_001_execute+0x1be>
 8006ba0:	6822      	ldr	r2, [r4, #0]
 8006ba2:	4293      	cmp	r3, r2
 8006ba4:	d103      	bne.n	8006bae <oslib_test_003_001_execute+0x1be>
 8006ba6:	6920      	ldr	r0, [r4, #16]
 8006ba8:	1f01      	subs	r1, r0, #4
 8006baa:	4248      	negs	r0, r1
 8006bac:	4148      	adcs	r0, r1
 8006bae:	4978      	ldr	r1, [pc, #480]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006bb0:	f7fa f8ee 	bl	8000d90 <_test_assert>
 8006bb4:	2800      	cmp	r0, #0
 8006bb6:	f47f af50 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(8);
 8006bba:	2308      	movs	r3, #8
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE - 4, TIME_IMMEDIATE);
 8006bbc:	200c      	movs	r0, #12
  test_set_step(8);
 8006bbe:	6033      	str	r3, [r6, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE - 4, TIME_IMMEDIATE);
 8006bc0:	f7ff fc4e 	bl	8006460 <chPipeWriteTimeout.constprop.24>
    test_assert(n == PIPE_SIZE - 4, "wrong size");
 8006bc4:	f1a0 020c 	sub.w	r2, r0, #12
 8006bc8:	4250      	negs	r0, r2
 8006bca:	4150      	adcs	r0, r2
 8006bcc:	4971      	ldr	r1, [pc, #452]	; (8006d94 <oslib_test_003_001_execute+0x3a4>)
 8006bce:	f7fa f8df 	bl	8000d90 <_test_assert>
 8006bd2:	2800      	cmp	r0, #0
 8006bd4:	f47f af41 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006bd8:	68e3      	ldr	r3, [r4, #12]
 8006bda:	6822      	ldr	r2, [r4, #0]
 8006bdc:	4293      	cmp	r3, r2
 8006bde:	f000 812a 	beq.w	8006e36 <oslib_test_003_001_execute+0x446>
 8006be2:	496b      	ldr	r1, [pc, #428]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006be4:	f7fa f8d4 	bl	8000d90 <_test_assert>
 8006be8:	2800      	cmp	r0, #0
 8006bea:	f47f af36 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(9);
 8006bee:	2309      	movs	r3, #9
    n = chPipeReadTimeout(&pipe1, buf, 4, TIME_IMMEDIATE);
 8006bf0:	2104      	movs	r1, #4
 8006bf2:	4668      	mov	r0, sp
  test_set_step(9);
 8006bf4:	6033      	str	r3, [r6, #0]
    n = chPipeReadTimeout(&pipe1, buf, 4, TIME_IMMEDIATE);
 8006bf6:	f7ff fcab 	bl	8006550 <chPipeReadTimeout.constprop.23>
    test_assert(n == 4, "wrong size");
 8006bfa:	f1a0 0e04 	sub.w	lr, r0, #4
 8006bfe:	f1de 0000 	rsbs	r0, lr, #0
 8006c02:	eb40 000e 	adc.w	r0, r0, lr
 8006c06:	4963      	ldr	r1, [pc, #396]	; (8006d94 <oslib_test_003_001_execute+0x3a4>)
 8006c08:	f7fa f8c2 	bl	8000d90 <_test_assert>
 8006c0c:	2800      	cmp	r0, #0
 8006c0e:	f47f af24 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr != pipe1.buffer) &&
 8006c12:	6823      	ldr	r3, [r4, #0]
 8006c14:	68e2      	ldr	r2, [r4, #12]
 8006c16:	429a      	cmp	r2, r3
 8006c18:	d009      	beq.n	8006c2e <oslib_test_003_001_execute+0x23e>
 8006c1a:	68a2      	ldr	r2, [r4, #8]
 8006c1c:	4293      	cmp	r3, r2
 8006c1e:	d106      	bne.n	8006c2e <oslib_test_003_001_execute+0x23e>
 8006c20:	6920      	ldr	r0, [r4, #16]
 8006c22:	f1a0 0c0c 	sub.w	ip, r0, #12
 8006c26:	f1dc 0000 	rsbs	r0, ip, #0
 8006c2a:	eb40 000c 	adc.w	r0, r0, ip
 8006c2e:	4958      	ldr	r1, [pc, #352]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006c30:	f7fa f8ae 	bl	8000d90 <_test_assert>
 8006c34:	2800      	cmp	r0, #0
 8006c36:	f47f af10 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert(memcmp(pipe_pattern, buf, 4) == 0, "content mismatch");
 8006c3a:	9800      	ldr	r0, [sp, #0]
 8006c3c:	4b58      	ldr	r3, [pc, #352]	; (8006da0 <oslib_test_003_001_execute+0x3b0>)
 8006c3e:	4957      	ldr	r1, [pc, #348]	; (8006d9c <oslib_test_003_001_execute+0x3ac>)
 8006c40:	1ac5      	subs	r5, r0, r3
 8006c42:	4268      	negs	r0, r5
 8006c44:	4168      	adcs	r0, r5
 8006c46:	f7fa f8a3 	bl	8000d90 <_test_assert>
 8006c4a:	2800      	cmp	r0, #0
 8006c4c:	f47f af05 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(10);
 8006c50:	230a      	movs	r3, #10
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE - 4, TIME_IMMEDIATE);
 8006c52:	210c      	movs	r1, #12
 8006c54:	4668      	mov	r0, sp
  test_set_step(10);
 8006c56:	6033      	str	r3, [r6, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE - 4, TIME_IMMEDIATE);
 8006c58:	f7ff fc7a 	bl	8006550 <chPipeReadTimeout.constprop.23>
    test_assert(n == PIPE_SIZE - 4, "wrong size");
 8006c5c:	f1a0 020c 	sub.w	r2, r0, #12
 8006c60:	4250      	negs	r0, r2
 8006c62:	4150      	adcs	r0, r2
 8006c64:	494b      	ldr	r1, [pc, #300]	; (8006d94 <oslib_test_003_001_execute+0x3a4>)
 8006c66:	f7fa f893 	bl	8000d90 <_test_assert>
 8006c6a:	2800      	cmp	r0, #0
 8006c6c:	f47f aef5 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006c70:	68e3      	ldr	r3, [r4, #12]
 8006c72:	6822      	ldr	r2, [r4, #0]
 8006c74:	4293      	cmp	r3, r2
 8006c76:	f000 80e8 	beq.w	8006e4a <oslib_test_003_001_execute+0x45a>
 8006c7a:	4945      	ldr	r1, [pc, #276]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006c7c:	f7fa f888 	bl	8000d90 <_test_assert>
 8006c80:	2800      	cmp	r0, #0
 8006c82:	f47f aeea 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE - 4) == 0, "content mismatch");
 8006c86:	4669      	mov	r1, sp
 8006c88:	220c      	movs	r2, #12
 8006c8a:	4843      	ldr	r0, [pc, #268]	; (8006d98 <oslib_test_003_001_execute+0x3a8>)
 8006c8c:	f7f9 faee 	bl	800026c <memcmp>
 8006c90:	fab0 f080 	clz	r0, r0
 8006c94:	4941      	ldr	r1, [pc, #260]	; (8006d9c <oslib_test_003_001_execute+0x3ac>)
 8006c96:	0940      	lsrs	r0, r0, #5
 8006c98:	f7fa f87a 	bl	8000d90 <_test_assert>
 8006c9c:	2800      	cmp	r0, #0
 8006c9e:	f47f aedc 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(11);
 8006ca2:	230b      	movs	r3, #11
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 5, TIME_IMMEDIATE);
 8006ca4:	2005      	movs	r0, #5
  test_set_step(11);
 8006ca6:	6033      	str	r3, [r6, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 5, TIME_IMMEDIATE);
 8006ca8:	f7ff fbda 	bl	8006460 <chPipeWriteTimeout.constprop.24>
    test_assert(n == 5, "wrong size");
 8006cac:	1f43      	subs	r3, r0, #5
 8006cae:	4258      	negs	r0, r3
 8006cb0:	4158      	adcs	r0, r3
 8006cb2:	4938      	ldr	r1, [pc, #224]	; (8006d94 <oslib_test_003_001_execute+0x3a4>)
 8006cb4:	f7fa f86c 	bl	8000d90 <_test_assert>
 8006cb8:	2800      	cmp	r0, #0
 8006cba:	f47f aece 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
 8006cbe:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8006cc2:	4293      	cmp	r3, r2
 8006cc4:	d009      	beq.n	8006cda <oslib_test_003_001_execute+0x2ea>
 8006cc6:	6822      	ldr	r2, [r4, #0]
 8006cc8:	4293      	cmp	r3, r2
 8006cca:	d106      	bne.n	8006cda <oslib_test_003_001_execute+0x2ea>
 8006ccc:	6920      	ldr	r0, [r4, #16]
 8006cce:	f1a0 0e05 	sub.w	lr, r0, #5
 8006cd2:	f1de 0000 	rsbs	r0, lr, #0
 8006cd6:	eb40 000e 	adc.w	r0, r0, lr
 8006cda:	492d      	ldr	r1, [pc, #180]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006cdc:	f7fa f858 	bl	8000d90 <_test_assert>
 8006ce0:	2800      	cmp	r0, #0
 8006ce2:	f47f aeba 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(12);
 8006ce6:	230c      	movs	r3, #12
    n = chPipeReadTimeout(&pipe1, buf, 5, TIME_IMMEDIATE);
 8006ce8:	2105      	movs	r1, #5
 8006cea:	4668      	mov	r0, sp
  test_set_step(12);
 8006cec:	6033      	str	r3, [r6, #0]
    n = chPipeReadTimeout(&pipe1, buf, 5, TIME_IMMEDIATE);
 8006cee:	f7ff fc2f 	bl	8006550 <chPipeReadTimeout.constprop.23>
    test_assert(n == 5, "wrong size");
 8006cf2:	f1a0 0c05 	sub.w	ip, r0, #5
 8006cf6:	f1dc 0000 	rsbs	r0, ip, #0
 8006cfa:	eb40 000c 	adc.w	r0, r0, ip
 8006cfe:	4925      	ldr	r1, [pc, #148]	; (8006d94 <oslib_test_003_001_execute+0x3a4>)
 8006d00:	f7fa f846 	bl	8000d90 <_test_assert>
 8006d04:	2800      	cmp	r0, #0
 8006d06:	f47f aea8 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8006d0a:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8006d0e:	4293      	cmp	r3, r2
 8006d10:	f000 80b6 	beq.w	8006e80 <oslib_test_003_001_execute+0x490>
 8006d14:	491e      	ldr	r1, [pc, #120]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006d16:	f7fa f83b 	bl	8000d90 <_test_assert>
 8006d1a:	2800      	cmp	r0, #0
 8006d1c:	f47f ae9d 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert(memcmp(pipe_pattern, buf, 5) == 0, "content mismatch");
 8006d20:	4669      	mov	r1, sp
 8006d22:	2205      	movs	r2, #5
 8006d24:	481c      	ldr	r0, [pc, #112]	; (8006d98 <oslib_test_003_001_execute+0x3a8>)
 8006d26:	f7f9 faa1 	bl	800026c <memcmp>
 8006d2a:	fab0 f080 	clz	r0, r0
 8006d2e:	491b      	ldr	r1, [pc, #108]	; (8006d9c <oslib_test_003_001_execute+0x3ac>)
 8006d30:	0940      	lsrs	r0, r0, #5
 8006d32:	f7fa f82d 	bl	8000d90 <_test_assert>
 8006d36:	2800      	cmp	r0, #0
 8006d38:	f47f ae8f 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(13);
 8006d3c:	230d      	movs	r3, #13
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8006d3e:	2010      	movs	r0, #16
  test_set_step(13);
 8006d40:	6033      	str	r3, [r6, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8006d42:	f7ff fb8d 	bl	8006460 <chPipeWriteTimeout.constprop.24>
    test_assert(n == PIPE_SIZE, "wrong size");
 8006d46:	f1a0 0510 	sub.w	r5, r0, #16
 8006d4a:	4268      	negs	r0, r5
 8006d4c:	4168      	adcs	r0, r5
 8006d4e:	4911      	ldr	r1, [pc, #68]	; (8006d94 <oslib_test_003_001_execute+0x3a4>)
 8006d50:	f7fa f81e 	bl	8000d90 <_test_assert>
 8006d54:	2800      	cmp	r0, #0
 8006d56:	f47f ae80 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8006d5a:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8006d5e:	4293      	cmp	r3, r2
 8006d60:	f000 8084 	beq.w	8006e6c <oslib_test_003_001_execute+0x47c>
 8006d64:	490a      	ldr	r1, [pc, #40]	; (8006d90 <oslib_test_003_001_execute+0x3a0>)
 8006d66:	f7fa f813 	bl	8000d90 <_test_assert>
 8006d6a:	2800      	cmp	r0, #0
 8006d6c:	f47f ae75 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
  test_set_step(14);
 8006d70:	230e      	movs	r3, #14
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8006d72:	2110      	movs	r1, #16
 8006d74:	4668      	mov	r0, sp
  test_set_step(14);
 8006d76:	6033      	str	r3, [r6, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8006d78:	f7ff fbea 	bl	8006550 <chPipeReadTimeout.constprop.23>
    test_assert(n == PIPE_SIZE, "wrong size");
 8006d7c:	f1a0 0310 	sub.w	r3, r0, #16
 8006d80:	4258      	negs	r0, r3
 8006d82:	4158      	adcs	r0, r3
 8006d84:	4903      	ldr	r1, [pc, #12]	; (8006d94 <oslib_test_003_001_execute+0x3a4>)
 8006d86:	f7fa f803 	bl	8000d90 <_test_assert>
 8006d8a:	e00b      	b.n	8006da4 <oslib_test_003_001_execute+0x3b4>
 8006d8c:	0800b260 	.word	0x0800b260
 8006d90:	0800b290 	.word	0x0800b290
 8006d94:	0800b170 	.word	0x0800b170
 8006d98:	0800b684 	.word	0x0800b684
 8006d9c:	0800b26c 	.word	0x0800b26c
 8006da0:	33323130 	.word	0x33323130
 8006da4:	2800      	cmp	r0, #0
 8006da6:	f47f ae58 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8006daa:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8006dae:	4293      	cmp	r3, r2
 8006db0:	d054      	beq.n	8006e5c <oslib_test_003_001_execute+0x46c>
 8006db2:	4938      	ldr	r1, [pc, #224]	; (8006e94 <oslib_test_003_001_execute+0x4a4>)
 8006db4:	f7f9 ffec 	bl	8000d90 <_test_assert>
 8006db8:	2800      	cmp	r0, #0
 8006dba:	f47f ae4e 	bne.w	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
 8006dbe:	4669      	mov	r1, sp
 8006dc0:	2210      	movs	r2, #16
 8006dc2:	4835      	ldr	r0, [pc, #212]	; (8006e98 <oslib_test_003_001_execute+0x4a8>)
 8006dc4:	f7f9 fa52 	bl	800026c <memcmp>
 8006dc8:	fab0 f080 	clz	r0, r0
 8006dcc:	4933      	ldr	r1, [pc, #204]	; (8006e9c <oslib_test_003_001_execute+0x4ac>)
 8006dce:	0940      	lsrs	r0, r0, #5
 8006dd0:	f7f9 ffde 	bl	8000d90 <_test_assert>
 8006dd4:	e641      	b.n	8006a5a <oslib_test_003_001_execute+0x6a>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006dd6:	68a2      	ldr	r2, [r4, #8]
 8006dd8:	4293      	cmp	r3, r2
 8006dda:	f47f ae63 	bne.w	8006aa4 <oslib_test_003_001_execute+0xb4>
 8006dde:	6920      	ldr	r0, [r4, #16]
 8006de0:	fab0 f080 	clz	r0, r0
 8006de4:	0940      	lsrs	r0, r0, #5
 8006de6:	e65d      	b.n	8006aa4 <oslib_test_003_001_execute+0xb4>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006de8:	68a2      	ldr	r2, [r4, #8]
 8006dea:	4293      	cmp	r3, r2
 8006dec:	f47f ae72 	bne.w	8006ad4 <oslib_test_003_001_execute+0xe4>
 8006df0:	6920      	ldr	r0, [r4, #16]
 8006df2:	fab0 f080 	clz	r0, r0
 8006df6:	0940      	lsrs	r0, r0, #5
 8006df8:	e66c      	b.n	8006ad4 <oslib_test_003_001_execute+0xe4>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006dfa:	68a2      	ldr	r2, [r4, #8]
 8006dfc:	4293      	cmp	r3, r2
 8006dfe:	f47f ae76 	bne.w	8006aee <oslib_test_003_001_execute+0xfe>
 8006e02:	6920      	ldr	r0, [r4, #16]
 8006e04:	fab0 f080 	clz	r0, r0
 8006e08:	0940      	lsrs	r0, r0, #5
 8006e0a:	e670      	b.n	8006aee <oslib_test_003_001_execute+0xfe>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006e0c:	68a2      	ldr	r2, [r4, #8]
 8006e0e:	4293      	cmp	r3, r2
 8006e10:	f47f ae86 	bne.w	8006b20 <oslib_test_003_001_execute+0x130>
 8006e14:	6920      	ldr	r0, [r4, #16]
 8006e16:	f1a0 0c10 	sub.w	ip, r0, #16
 8006e1a:	f1dc 0000 	rsbs	r0, ip, #0
 8006e1e:	eb40 000c 	adc.w	r0, r0, ip
 8006e22:	e67d      	b.n	8006b20 <oslib_test_003_001_execute+0x130>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006e24:	68a2      	ldr	r2, [r4, #8]
 8006e26:	4293      	cmp	r3, r2
 8006e28:	f47f ae94 	bne.w	8006b54 <oslib_test_003_001_execute+0x164>
 8006e2c:	6920      	ldr	r0, [r4, #16]
 8006e2e:	fab0 f080 	clz	r0, r0
 8006e32:	0940      	lsrs	r0, r0, #5
 8006e34:	e68e      	b.n	8006b54 <oslib_test_003_001_execute+0x164>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006e36:	68a2      	ldr	r2, [r4, #8]
 8006e38:	4293      	cmp	r3, r2
 8006e3a:	f47f aed2 	bne.w	8006be2 <oslib_test_003_001_execute+0x1f2>
 8006e3e:	6920      	ldr	r0, [r4, #16]
 8006e40:	f1a0 0310 	sub.w	r3, r0, #16
 8006e44:	4258      	negs	r0, r3
 8006e46:	4158      	adcs	r0, r3
 8006e48:	e6cb      	b.n	8006be2 <oslib_test_003_001_execute+0x1f2>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006e4a:	68a2      	ldr	r2, [r4, #8]
 8006e4c:	4293      	cmp	r3, r2
 8006e4e:	f47f af14 	bne.w	8006c7a <oslib_test_003_001_execute+0x28a>
 8006e52:	6920      	ldr	r0, [r4, #16]
 8006e54:	fab0 f080 	clz	r0, r0
 8006e58:	0940      	lsrs	r0, r0, #5
 8006e5a:	e70e      	b.n	8006c7a <oslib_test_003_001_execute+0x28a>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8006e5c:	6822      	ldr	r2, [r4, #0]
 8006e5e:	4293      	cmp	r3, r2
 8006e60:	d0a7      	beq.n	8006db2 <oslib_test_003_001_execute+0x3c2>
 8006e62:	6920      	ldr	r0, [r4, #16]
 8006e64:	fab0 f080 	clz	r0, r0
 8006e68:	0940      	lsrs	r0, r0, #5
 8006e6a:	e7a2      	b.n	8006db2 <oslib_test_003_001_execute+0x3c2>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8006e6c:	6822      	ldr	r2, [r4, #0]
 8006e6e:	4293      	cmp	r3, r2
 8006e70:	f43f af78 	beq.w	8006d64 <oslib_test_003_001_execute+0x374>
 8006e74:	6920      	ldr	r0, [r4, #16]
 8006e76:	f1a0 0210 	sub.w	r2, r0, #16
 8006e7a:	4250      	negs	r0, r2
 8006e7c:	4150      	adcs	r0, r2
 8006e7e:	e771      	b.n	8006d64 <oslib_test_003_001_execute+0x374>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8006e80:	6822      	ldr	r2, [r4, #0]
 8006e82:	4293      	cmp	r3, r2
 8006e84:	f43f af46 	beq.w	8006d14 <oslib_test_003_001_execute+0x324>
 8006e88:	6920      	ldr	r0, [r4, #16]
 8006e8a:	fab0 f080 	clz	r0, r0
 8006e8e:	0940      	lsrs	r0, r0, #5
 8006e90:	e740      	b.n	8006d14 <oslib_test_003_001_execute+0x324>
 8006e92:	bf00      	nop
 8006e94:	0800b290 	.word	0x0800b290
 8006e98:	0800b684 	.word	0x0800b684
 8006e9c:	0800b26c 	.word	0x0800b26c

08006ea0 <rt_test_011_011_execute>:
  test_set_step(1);
 8006ea0:	2301      	movs	r3, #1
static void rt_test_011_011_execute(void) {
 8006ea2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8006ea6:	f8df 807c 	ldr.w	r8, [pc, #124]	; 8006f24 <rt_test_011_011_execute+0x84>
    n = 0;
 8006eaa:	2500      	movs	r5, #0
  test_set_step(1);
 8006eac:	f8c8 3000 	str.w	r3, [r8]
    start = test_wait_tick();
 8006eb0:	f7fd f966 	bl	8004180 <test_wait_tick>
 8006eb4:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 8006eb8:	4606      	mov	r6, r0
      chMtxLock(&mtx1);
 8006eba:	4c17      	ldr	r4, [pc, #92]	; (8006f18 <rt_test_011_011_execute+0x78>)
 8006ebc:	4620      	mov	r0, r4
 8006ebe:	f7fd fcff 	bl	80048c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8006ec2:	4620      	mov	r0, r4
 8006ec4:	f7ff f9cc 	bl	8006260 <chMtxUnlock>
      chMtxLock(&mtx1);
 8006ec8:	4620      	mov	r0, r4
 8006eca:	f7fd fcf9 	bl	80048c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8006ece:	4620      	mov	r0, r4
 8006ed0:	f7ff f9c6 	bl	8006260 <chMtxUnlock>
      chMtxLock(&mtx1);
 8006ed4:	4620      	mov	r0, r4
 8006ed6:	f7fd fcf3 	bl	80048c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8006eda:	4620      	mov	r0, r4
 8006edc:	f7ff f9c0 	bl	8006260 <chMtxUnlock>
      chMtxLock(&mtx1);
 8006ee0:	4620      	mov	r0, r4
 8006ee2:	f7fd fced 	bl	80048c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8006ee6:	4620      	mov	r0, r4
 8006ee8:	f7ff f9ba 	bl	8006260 <chMtxUnlock>
 8006eec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      n++;
 8006eee:	3501      	adds	r5, #1
 8006ef0:	1b9b      	subs	r3, r3, r6
    } while (chVTIsSystemTimeWithinX(start, end));
 8006ef2:	b29b      	uxth	r3, r3
 8006ef4:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8006ef8:	d3e0      	bcc.n	8006ebc <rt_test_011_011_execute+0x1c>
  test_set_step(2);
 8006efa:	2302      	movs	r3, #2
    test_print("--- Score : ");
 8006efc:	4807      	ldr	r0, [pc, #28]	; (8006f1c <rt_test_011_011_execute+0x7c>)
  test_set_step(2);
 8006efe:	f8c8 3000 	str.w	r3, [r8]
    test_print("--- Score : ");
 8006f02:	f7fa f8ad 	bl	8001060 <test_print>
    test_printn(n * 4);
 8006f06:	00a8      	lsls	r0, r5, #2
 8006f08:	f7f9 ffda 	bl	8000ec0 <test_printn>
}
 8006f0c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_println(" lock+unlock/S");
 8006f10:	4803      	ldr	r0, [pc, #12]	; (8006f20 <rt_test_011_011_execute+0x80>)
 8006f12:	f7fa b885 	b.w	8001020 <test_println>
 8006f16:	bf00      	nop
 8006f18:	20001550 	.word	0x20001550
 8006f1c:	0800c4fc 	.word	0x0800c4fc
 8006f20:	0800c548 	.word	0x0800c548
 8006f24:	20001d94 	.word	0x20001d94
	...

08006f30 <thread8>:
static THD_FUNCTION(thread8, p) {
 8006f30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006f32:	4607      	mov	r7, r0
  chMtxLock(&m2);
 8006f34:	481c      	ldr	r0, [pc, #112]	; (8006fa8 <thread8+0x78>)
 8006f36:	f7fd fcc3 	bl	80048c0 <chMtxLock>
  chMtxLock(&m1);
 8006f3a:	481c      	ldr	r0, [pc, #112]	; (8006fac <thread8+0x7c>)
 8006f3c:	f7fd fcc0 	bl	80048c0 <chMtxLock>
 8006f40:	2320      	movs	r3, #32
 8006f42:	f383 8811 	msr	BASEPRI, r3
  return ch.rlist.current;
 8006f46:	4d1a      	ldr	r5, [pc, #104]	; (8006fb0 <thread8+0x80>)
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
 8006f48:	69ab      	ldr	r3, [r5, #24]
 8006f4a:	6b9e      	ldr	r6, [r3, #56]	; 0x38
  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (timeout != TIME_IMMEDIATE));
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
 8006f4c:	4630      	mov	r0, r6
 8006f4e:	f7fa fc4f 	bl	80017f0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 8006f52:	4a18      	ldr	r2, [pc, #96]	; (8006fb4 <thread8+0x84>)
 8006f54:	69ac      	ldr	r4, [r5, #24]
  thread_t *cp = (thread_t *)tqp;
 8006f56:	4610      	mov	r0, r2
 8006f58:	4613      	mov	r3, r2
 8006f5a:	6262      	str	r2, [r4, #36]	; 0x24
 8006f5c:	e003      	b.n	8006f66 <thread8+0x36>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006f5e:	6899      	ldr	r1, [r3, #8]
 8006f60:	68a2      	ldr	r2, [r4, #8]
 8006f62:	4291      	cmp	r1, r2
 8006f64:	d302      	bcc.n	8006f6c <thread8+0x3c>
    cp = cp->queue.next;
 8006f66:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006f68:	4283      	cmp	r3, r0
 8006f6a:	d1f8      	bne.n	8006f5e <thread8+0x2e>
  tp->queue.prev             = cp->queue.prev;
 8006f6c:	685a      	ldr	r2, [r3, #4]
    chSchGoSleepS(newstate);
 8006f6e:	2007      	movs	r0, #7
 8006f70:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8006f74:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8006f76:	605c      	str	r4, [r3, #4]
 8006f78:	f7fc fca2 	bl	80038c0 <chSchGoSleepS>
  return currp->u.rdymsg;
 8006f7c:	69ab      	ldr	r3, [r5, #24]
  queue_prio_insert(currp, &cp->queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, timeout);
  if (msg != MSG_TIMEOUT) {
 8006f7e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006f80:	3301      	adds	r3, #1
 8006f82:	d002      	beq.n	8006f8a <thread8+0x5a>
    chMtxLockS(mp);
 8006f84:	4630      	mov	r0, r6
 8006f86:	f7fd fc23 	bl	80047d0 <chMtxLockS>
 8006f8a:	2300      	movs	r3, #0
 8006f8c:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
 8006f90:	7838      	ldrb	r0, [r7, #0]
 8006f92:	f7f9 ffa5 	bl	8000ee0 <test_emit_token>
  chMtxUnlock(&m1);
 8006f96:	4805      	ldr	r0, [pc, #20]	; (8006fac <thread8+0x7c>)
 8006f98:	f7ff f962 	bl	8006260 <chMtxUnlock>
}
 8006f9c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chMtxUnlock(&m2);
 8006fa0:	4801      	ldr	r0, [pc, #4]	; (8006fa8 <thread8+0x78>)
 8006fa2:	f7ff b95d 	b.w	8006260 <chMtxUnlock>
 8006fa6:	bf00      	nop
 8006fa8:	20000c48 	.word	0x20000c48
 8006fac:	20000c38 	.word	0x20000c38
 8006fb0:	20001254 	.word	0x20001254
 8006fb4:	20000c04 	.word	0x20000c04
	...

08006fc0 <thread6>:
static THD_FUNCTION(thread6, p) {
 8006fc0:	b570      	push	{r4, r5, r6, lr}
 8006fc2:	4606      	mov	r6, r0
  chMtxLock(&m1);
 8006fc4:	4816      	ldr	r0, [pc, #88]	; (8007020 <thread6+0x60>)
 8006fc6:	f7fd fc7b 	bl	80048c0 <chMtxLock>
 8006fca:	2320      	movs	r3, #32
 8006fcc:	f383 8811 	msr	BASEPRI, r3
  thread_t *ctp = currp;
 8006fd0:	4b14      	ldr	r3, [pc, #80]	; (8007024 <thread6+0x64>)
 8006fd2:	699c      	ldr	r4, [r3, #24]
 8006fd4:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  chMtxUnlockS(mp);
 8006fd6:	4628      	mov	r0, r5
 8006fd8:	f7fa fc0a 	bl	80017f0 <chMtxUnlockS>
  ctp->u.wtobjp = cp;
 8006fdc:	4a12      	ldr	r2, [pc, #72]	; (8007028 <thread6+0x68>)
  thread_t *cp = (thread_t *)tqp;
 8006fde:	4610      	mov	r0, r2
 8006fe0:	4613      	mov	r3, r2
 8006fe2:	6262      	str	r2, [r4, #36]	; 0x24
 8006fe4:	e003      	b.n	8006fee <thread6+0x2e>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006fe6:	6899      	ldr	r1, [r3, #8]
 8006fe8:	68a2      	ldr	r2, [r4, #8]
 8006fea:	4291      	cmp	r1, r2
 8006fec:	d302      	bcc.n	8006ff4 <thread6+0x34>
    cp = cp->queue.next;
 8006fee:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006ff0:	4283      	cmp	r3, r0
 8006ff2:	d1f8      	bne.n	8006fe6 <thread6+0x26>
  tp->queue.prev             = cp->queue.prev;
 8006ff4:	685a      	ldr	r2, [r3, #4]
  chSchGoSleepS(CH_STATE_WTCOND);
 8006ff6:	2007      	movs	r0, #7
 8006ff8:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8006ffc:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8006ffe:	605c      	str	r4, [r3, #4]
 8007000:	f7fc fc5e 	bl	80038c0 <chSchGoSleepS>
  chMtxLockS(mp);
 8007004:	4628      	mov	r0, r5
 8007006:	f7fd fbe3 	bl	80047d0 <chMtxLockS>
 800700a:	2300      	movs	r3, #0
 800700c:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
 8007010:	7830      	ldrb	r0, [r6, #0]
 8007012:	f7f9 ff65 	bl	8000ee0 <test_emit_token>
}
 8007016:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chMtxUnlock(&m1);
 800701a:	4801      	ldr	r0, [pc, #4]	; (8007020 <thread6+0x60>)
 800701c:	f7ff b920 	b.w	8006260 <chMtxUnlock>
 8007020:	20000c38 	.word	0x20000c38
 8007024:	20001254 	.word	0x20001254
 8007028:	20000c04 	.word	0x20000c04
 800702c:	00000000 	.word	0x00000000

08007030 <thread9>:
static THD_FUNCTION(thread9, p) {
 8007030:	b538      	push	{r3, r4, r5, lr}
 8007032:	4605      	mov	r5, r0
  chMtxLock(&m2);
 8007034:	4c05      	ldr	r4, [pc, #20]	; (800704c <thread9+0x1c>)
 8007036:	4620      	mov	r0, r4
 8007038:	f7fd fc42 	bl	80048c0 <chMtxLock>
  test_emit_token(*(char *)p);
 800703c:	7828      	ldrb	r0, [r5, #0]
 800703e:	f7f9 ff4f 	bl	8000ee0 <test_emit_token>
  chMtxUnlock(&m2);
 8007042:	4620      	mov	r0, r4
}
 8007044:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m2);
 8007048:	f7ff b90a 	b.w	8006260 <chMtxUnlock>
 800704c:	20000c48 	.word	0x20000c48

08007050 <rt_test_007_005_execute>:
  test_set_step(2);
 8007050:	2202      	movs	r2, #2
static void rt_test_007_005_execute(void) {
 8007052:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8007056:	4d4d      	ldr	r5, [pc, #308]	; (800718c <rt_test_007_005_execute+0x13c>)
  test_set_step(2);
 8007058:	4c4d      	ldr	r4, [pc, #308]	; (8007190 <rt_test_007_005_execute+0x140>)
  return chThdGetSelfX()->prio;
 800705a:	69ab      	ldr	r3, [r5, #24]
 800705c:	6022      	str	r2, [r4, #0]
 800705e:	689e      	ldr	r6, [r3, #8]
    b = chMtxTryLock(&m1);
 8007060:	f7f9 fc06 	bl	8000870 <chMtxTryLock.constprop.61>
    test_assert(b, "already locked");
 8007064:	494b      	ldr	r1, [pc, #300]	; (8007194 <rt_test_007_005_execute+0x144>)
 8007066:	f7f9 fe93 	bl	8000d90 <_test_assert>
 800706a:	b108      	cbz	r0, 8007070 <rt_test_007_005_execute+0x20>
}
 800706c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  test_set_step(3);
 8007070:	2303      	movs	r3, #3
 8007072:	6023      	str	r3, [r4, #0]
    b = chMtxTryLock(&m1);
 8007074:	f7f9 fbfc 	bl	8000870 <chMtxTryLock.constprop.61>
    test_assert(!b, "not locked");
 8007078:	f080 0001 	eor.w	r0, r0, #1
 800707c:	b2c0      	uxtb	r0, r0
 800707e:	4946      	ldr	r1, [pc, #280]	; (8007198 <rt_test_007_005_execute+0x148>)
 8007080:	f7f9 fe86 	bl	8000d90 <_test_assert>
 8007084:	2800      	cmp	r0, #0
 8007086:	d1f1      	bne.n	800706c <rt_test_007_005_execute+0x1c>
  test_set_step(4);
 8007088:	2304      	movs	r3, #4
    chMtxUnlock(&m1);
 800708a:	4f44      	ldr	r7, [pc, #272]	; (800719c <rt_test_007_005_execute+0x14c>)
  test_set_step(4);
 800708c:	6023      	str	r3, [r4, #0]
    chMtxUnlock(&m1);
 800708e:	4638      	mov	r0, r7
 8007090:	f7ff f8e6 	bl	8006260 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 8007094:	68b8      	ldr	r0, [r7, #8]
 8007096:	4942      	ldr	r1, [pc, #264]	; (80071a0 <rt_test_007_005_execute+0x150>)
 8007098:	fab0 f080 	clz	r0, r0
 800709c:	0940      	lsrs	r0, r0, #5
 800709e:	f7f9 fe77 	bl	8000d90 <_test_assert>
 80070a2:	2800      	cmp	r0, #0
 80070a4:	d1e2      	bne.n	800706c <rt_test_007_005_execute+0x1c>
  return (bool)(tqp->next == (const thread_t *)tqp);
 80070a6:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 80070a8:	493e      	ldr	r1, [pc, #248]	; (80071a4 <rt_test_007_005_execute+0x154>)
 80070aa:	1bc0      	subs	r0, r0, r7
 80070ac:	fab0 f080 	clz	r0, r0
 80070b0:	0940      	lsrs	r0, r0, #5
 80070b2:	f7f9 fe6d 	bl	8000d90 <_test_assert>
 80070b6:	2800      	cmp	r0, #0
 80070b8:	d1d8      	bne.n	800706c <rt_test_007_005_execute+0x1c>
 80070ba:	69ab      	ldr	r3, [r5, #24]
  test_set_step(5);
 80070bc:	2205      	movs	r2, #5
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80070be:	6898      	ldr	r0, [r3, #8]
 80070c0:	4939      	ldr	r1, [pc, #228]	; (80071a8 <rt_test_007_005_execute+0x158>)
 80070c2:	1b80      	subs	r0, r0, r6
 80070c4:	fab0 f080 	clz	r0, r0
 80070c8:	0940      	lsrs	r0, r0, #5
  test_set_step(5);
 80070ca:	6022      	str	r2, [r4, #0]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80070cc:	f7f9 fe60 	bl	8000d90 <_test_assert>
 80070d0:	2800      	cmp	r0, #0
 80070d2:	d1cb      	bne.n	800706c <rt_test_007_005_execute+0x1c>
  test_set_step(6);
 80070d4:	2306      	movs	r3, #6
 80070d6:	6023      	str	r3, [r4, #0]
    b = chMtxTryLock(&m1);
 80070d8:	f7f9 fbca 	bl	8000870 <chMtxTryLock.constprop.61>
    test_assert(b, "already locked");
 80070dc:	492d      	ldr	r1, [pc, #180]	; (8007194 <rt_test_007_005_execute+0x144>)
 80070de:	f7f9 fe57 	bl	8000d90 <_test_assert>
 80070e2:	2800      	cmp	r0, #0
 80070e4:	d1c2      	bne.n	800706c <rt_test_007_005_execute+0x1c>
    b = chMtxTryLock(&m1);
 80070e6:	f7f9 fbc3 	bl	8000870 <chMtxTryLock.constprop.61>
    test_assert(!b, "not locked");
 80070ea:	f080 0001 	eor.w	r0, r0, #1
 80070ee:	b2c0      	uxtb	r0, r0
 80070f0:	4929      	ldr	r1, [pc, #164]	; (8007198 <rt_test_007_005_execute+0x148>)
 80070f2:	f7f9 fe4d 	bl	8000d90 <_test_assert>
 80070f6:	2800      	cmp	r0, #0
 80070f8:	d1b8      	bne.n	800706c <rt_test_007_005_execute+0x1c>
 80070fa:	2320      	movs	r3, #32
 80070fc:	f383 8811 	msr	BASEPRI, r3
 *          inheritance mechanism.
 *
 * @sclass
 */
void chMtxUnlockAllS(void) {
  thread_t *ctp = currp;
 8007100:	f8d5 8018 	ldr.w	r8, [r5, #24]

  if (ctp->mtxlist != NULL) {
 8007104:	f8d8 3038 	ldr.w	r3, [r8, #56]	; 0x38
 8007108:	b1d3      	cbz	r3, 8007140 <rt_test_007_005_execute+0xf0>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 800710a:	4681      	mov	r9, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 800710c:	681a      	ldr	r2, [r3, #0]
      ctp->mtxlist = mp->next;
 800710e:	68d9      	ldr	r1, [r3, #12]
      if (chMtxQueueNotEmptyS(mp)) {
 8007110:	4293      	cmp	r3, r2
      ctp->mtxlist = mp->next;
 8007112:	f8c8 1038 	str.w	r1, [r8, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 8007116:	d034      	beq.n	8007182 <rt_test_007_005_execute+0x132>
        mp->next    = tp->mtxlist;
 8007118:	6b90      	ldr	r0, [r2, #56]	; 0x38
  tqp->next             = tp->queue.next;
 800711a:	6811      	ldr	r1, [r2, #0]
 800711c:	6019      	str	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800711e:	604b      	str	r3, [r1, #4]
 8007120:	e9c3 2002 	strd	r2, r0, [r3, #8]
        tp->mtxlist = mp;
 8007124:	6393      	str	r3, [r2, #56]	; 0x38
        (void) chSchReadyI(tp);
 8007126:	4610      	mov	r0, r2
 8007128:	f7fa fa62 	bl	80015f0 <chSchReadyI>
 800712c:	f8d8 3038 	ldr.w	r3, [r8, #56]	; 0x38
      }
    } while (ctp->mtxlist != NULL);
 8007130:	2b00      	cmp	r3, #0
 8007132:	d1eb      	bne.n	800710c <rt_test_007_005_execute+0xbc>
    ctp->prio = ctp->realprio;
 8007134:	f8d8 303c 	ldr.w	r3, [r8, #60]	; 0x3c
 8007138:	f8c8 3008 	str.w	r3, [r8, #8]
    chSchRescheduleS();
 800713c:	f7fd fed8 	bl	8004ef0 <chSchRescheduleS>
 8007140:	2300      	movs	r3, #0
 8007142:	f383 8811 	msr	BASEPRI, r3
    test_assert(m1.owner == NULL, "still owned");
 8007146:	68b8      	ldr	r0, [r7, #8]
 8007148:	4915      	ldr	r1, [pc, #84]	; (80071a0 <rt_test_007_005_execute+0x150>)
 800714a:	fab0 f080 	clz	r0, r0
 800714e:	0940      	lsrs	r0, r0, #5
 8007150:	f7f9 fe1e 	bl	8000d90 <_test_assert>
 8007154:	2800      	cmp	r0, #0
 8007156:	d189      	bne.n	800706c <rt_test_007_005_execute+0x1c>
  return (bool)(tqp->next == (const thread_t *)tqp);
 8007158:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 800715a:	4912      	ldr	r1, [pc, #72]	; (80071a4 <rt_test_007_005_execute+0x154>)
 800715c:	1bc2      	subs	r2, r0, r7
 800715e:	4250      	negs	r0, r2
 8007160:	4150      	adcs	r0, r2
 8007162:	f7f9 fe15 	bl	8000d90 <_test_assert>
 8007166:	2800      	cmp	r0, #0
 8007168:	d180      	bne.n	800706c <rt_test_007_005_execute+0x1c>
  test_set_step(7);
 800716a:	2307      	movs	r3, #7
 800716c:	69aa      	ldr	r2, [r5, #24]
 800716e:	6023      	str	r3, [r4, #0]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8007170:	6890      	ldr	r0, [r2, #8]
 8007172:	490d      	ldr	r1, [pc, #52]	; (80071a8 <rt_test_007_005_execute+0x158>)
 8007174:	1b83      	subs	r3, r0, r6
 8007176:	4258      	negs	r0, r3
 8007178:	4158      	adcs	r0, r3
}
 800717a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 800717e:	f7f9 be07 	b.w	8000d90 <_test_assert>
        mp->owner = NULL;
 8007182:	f8c3 9008 	str.w	r9, [r3, #8]
 8007186:	460b      	mov	r3, r1
 8007188:	e7d2      	b.n	8007130 <rt_test_007_005_execute+0xe0>
 800718a:	bf00      	nop
 800718c:	20001254 	.word	0x20001254
 8007190:	20001d94 	.word	0x20001d94
 8007194:	0800c19c 	.word	0x0800c19c
 8007198:	0800c1ac 	.word	0x0800c1ac
 800719c:	20000c38 	.word	0x20000c38
 80071a0:	0800c1b8 	.word	0x0800c1b8
 80071a4:	0800c0f0 	.word	0x0800c0f0
 80071a8:	0800c1c4 	.word	0x0800c1c4
 80071ac:	00000000 	.word	0x00000000

080071b0 <rt_test_007_004_execute>:
static void rt_test_007_004_execute(void) {
 80071b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_set_step(2);
 80071b4:	2702      	movs	r7, #2
  return ch.rlist.current;
 80071b6:	4d3e      	ldr	r5, [pc, #248]	; (80072b0 <rt_test_007_004_execute+0x100>)
 80071b8:	4e3e      	ldr	r6, [pc, #248]	; (80072b4 <rt_test_007_004_execute+0x104>)
  return chThdGetSelfX()->prio;
 80071ba:	69aa      	ldr	r2, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80071bc:	4b3e      	ldr	r3, [pc, #248]	; (80072b8 <rt_test_007_004_execute+0x108>)
 80071be:	6894      	ldr	r4, [r2, #8]
 80071c0:	483e      	ldr	r0, [pc, #248]	; (80072bc <rt_test_007_004_execute+0x10c>)
    pa = p + 1;
 80071c2:	f104 0801 	add.w	r8, r4, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80071c6:	4a3e      	ldr	r2, [pc, #248]	; (80072c0 <rt_test_007_004_execute+0x110>)
 80071c8:	4641      	mov	r1, r8
  test_set_step(2);
 80071ca:	6037      	str	r7, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80071cc:	f7fc fab8 	bl	8003740 <chThdCreateStatic.constprop.68>
 80071d0:	4f3c      	ldr	r7, [pc, #240]	; (80072c4 <rt_test_007_004_execute+0x114>)
    pb = p + 2;
 80071d2:	f104 0902 	add.w	r9, r4, #2
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 80071d6:	4649      	mov	r1, r9
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80071d8:	6038      	str	r0, [r7, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 80071da:	4b3b      	ldr	r3, [pc, #236]	; (80072c8 <rt_test_007_004_execute+0x118>)
 80071dc:	4a3b      	ldr	r2, [pc, #236]	; (80072cc <rt_test_007_004_execute+0x11c>)
 80071de:	483c      	ldr	r0, [pc, #240]	; (80072d0 <rt_test_007_004_execute+0x120>)
 80071e0:	f7fc faae 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(3);
 80071e4:	2303      	movs	r3, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 80071e6:	6078      	str	r0, [r7, #4]
    chMtxLock(&m1);
 80071e8:	483a      	ldr	r0, [pc, #232]	; (80072d4 <rt_test_007_004_execute+0x124>)
  test_set_step(3);
 80071ea:	6033      	str	r3, [r6, #0]
    chMtxLock(&m1);
 80071ec:	f7fd fb68 	bl	80048c0 <chMtxLock>
 80071f0:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 80071f2:	4939      	ldr	r1, [pc, #228]	; (80072d8 <rt_test_007_004_execute+0x128>)
 80071f4:	6898      	ldr	r0, [r3, #8]
 80071f6:	1b00      	subs	r0, r0, r4
 80071f8:	fab0 f080 	clz	r0, r0
 80071fc:	0940      	lsrs	r0, r0, #5
 80071fe:	f7f9 fdc7 	bl	8000d90 <_test_assert>
 8007202:	b108      	cbz	r0, 8007208 <rt_test_007_004_execute+0x58>
}
 8007204:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  test_set_step(4);
 8007208:	2304      	movs	r3, #4
    chThdSleepMilliseconds(100);
 800720a:	20c8      	movs	r0, #200	; 0xc8
  test_set_step(4);
 800720c:	6033      	str	r3, [r6, #0]
    chThdSleepMilliseconds(100);
 800720e:	f7fc ff17 	bl	8004040 <chThdSleep>
 8007212:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8007214:	4930      	ldr	r1, [pc, #192]	; (80072d8 <rt_test_007_004_execute+0x128>)
 8007216:	6898      	ldr	r0, [r3, #8]
 8007218:	eba0 0008 	sub.w	r0, r0, r8
 800721c:	fab0 f080 	clz	r0, r0
 8007220:	0940      	lsrs	r0, r0, #5
 8007222:	f7f9 fdb5 	bl	8000d90 <_test_assert>
 8007226:	2800      	cmp	r0, #0
 8007228:	d1ec      	bne.n	8007204 <rt_test_007_004_execute+0x54>
  test_set_step(5);
 800722a:	2305      	movs	r3, #5
    chMtxLock(&m2);
 800722c:	482b      	ldr	r0, [pc, #172]	; (80072dc <rt_test_007_004_execute+0x12c>)
  test_set_step(5);
 800722e:	6033      	str	r3, [r6, #0]
    chMtxLock(&m2);
 8007230:	f7fd fb46 	bl	80048c0 <chMtxLock>
 8007234:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8007236:	4928      	ldr	r1, [pc, #160]	; (80072d8 <rt_test_007_004_execute+0x128>)
 8007238:	6898      	ldr	r0, [r3, #8]
 800723a:	eba0 0008 	sub.w	r0, r0, r8
 800723e:	fab0 f080 	clz	r0, r0
 8007242:	0940      	lsrs	r0, r0, #5
 8007244:	f7f9 fda4 	bl	8000d90 <_test_assert>
 8007248:	2800      	cmp	r0, #0
 800724a:	d1db      	bne.n	8007204 <rt_test_007_004_execute+0x54>
  test_set_step(6);
 800724c:	2306      	movs	r3, #6
    chThdSleepMilliseconds(100);
 800724e:	20c8      	movs	r0, #200	; 0xc8
  test_set_step(6);
 8007250:	6033      	str	r3, [r6, #0]
    chThdSleepMilliseconds(100);
 8007252:	f7fc fef5 	bl	8004040 <chThdSleep>
 8007256:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 8007258:	491f      	ldr	r1, [pc, #124]	; (80072d8 <rt_test_007_004_execute+0x128>)
 800725a:	6898      	ldr	r0, [r3, #8]
 800725c:	eba0 0009 	sub.w	r0, r0, r9
 8007260:	fab0 f080 	clz	r0, r0
 8007264:	0940      	lsrs	r0, r0, #5
 8007266:	f7f9 fd93 	bl	8000d90 <_test_assert>
 800726a:	2800      	cmp	r0, #0
 800726c:	d1ca      	bne.n	8007204 <rt_test_007_004_execute+0x54>
  test_set_step(7);
 800726e:	2307      	movs	r3, #7
    chMtxUnlock(&m2);
 8007270:	481a      	ldr	r0, [pc, #104]	; (80072dc <rt_test_007_004_execute+0x12c>)
  test_set_step(7);
 8007272:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m2);
 8007274:	f7fe fff4 	bl	8006260 <chMtxUnlock>
 8007278:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 800727a:	4917      	ldr	r1, [pc, #92]	; (80072d8 <rt_test_007_004_execute+0x128>)
 800727c:	6898      	ldr	r0, [r3, #8]
 800727e:	eba0 0008 	sub.w	r0, r0, r8
 8007282:	fab0 f080 	clz	r0, r0
 8007286:	0940      	lsrs	r0, r0, #5
 8007288:	f7f9 fd82 	bl	8000d90 <_test_assert>
 800728c:	2800      	cmp	r0, #0
 800728e:	d1b9      	bne.n	8007204 <rt_test_007_004_execute+0x54>
  test_set_step(8);
 8007290:	2308      	movs	r3, #8
    chMtxUnlock(&m1);
 8007292:	4810      	ldr	r0, [pc, #64]	; (80072d4 <rt_test_007_004_execute+0x124>)
  test_set_step(8);
 8007294:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m1);
 8007296:	f7fe ffe3 	bl	8006260 <chMtxUnlock>
 800729a:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 800729c:	490e      	ldr	r1, [pc, #56]	; (80072d8 <rt_test_007_004_execute+0x128>)
 800729e:	6898      	ldr	r0, [r3, #8]
 80072a0:	1b00      	subs	r0, r0, r4
 80072a2:	fab0 f080 	clz	r0, r0
}
 80072a6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 80072aa:	0940      	lsrs	r0, r0, #5
 80072ac:	f7f9 bd70 	b.w	8000d90 <_test_assert>
 80072b0:	20001254 	.word	0x20001254
 80072b4:	20001d94 	.word	0x20001d94
 80072b8:	0800c184 	.word	0x0800c184
 80072bc:	20001680 	.word	0x20001680
 80072c0:	080072e1 	.word	0x080072e1
 80072c4:	20001dac 	.word	0x20001dac
 80072c8:	0800c188 	.word	0x0800c188
 80072cc:	08005631 	.word	0x08005631
 80072d0:	200017c8 	.word	0x200017c8
 80072d4:	20000c38 	.word	0x20000c38
 80072d8:	0800c1c4 	.word	0x0800c1c4
 80072dc:	20000c48 	.word	0x20000c48

080072e0 <thread4A>:
static THD_FUNCTION(thread4A, p) {
 80072e0:	b510      	push	{r4, lr}
  chMtxLock(&m1);
 80072e2:	4c06      	ldr	r4, [pc, #24]	; (80072fc <thread4A+0x1c>)
  chThdSleepMilliseconds(50);
 80072e4:	2064      	movs	r0, #100	; 0x64
 80072e6:	f7fc feab 	bl	8004040 <chThdSleep>
  chMtxLock(&m1);
 80072ea:	4620      	mov	r0, r4
 80072ec:	f7fd fae8 	bl	80048c0 <chMtxLock>
  chMtxUnlock(&m1);
 80072f0:	4620      	mov	r0, r4
}
 80072f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMtxUnlock(&m1);
 80072f6:	f7fe bfb3 	b.w	8006260 <chMtxUnlock>
 80072fa:	bf00      	nop
 80072fc:	20000c38 	.word	0x20000c38

08007300 <thread1.lto_priv.114>:
static THD_FUNCTION(thread1, p) {
 8007300:	b538      	push	{r3, r4, r5, lr}
 8007302:	4605      	mov	r5, r0
  chMtxLock(&m1);
 8007304:	4c05      	ldr	r4, [pc, #20]	; (800731c <thread1.lto_priv.114+0x1c>)
 8007306:	4620      	mov	r0, r4
 8007308:	f7fd fada 	bl	80048c0 <chMtxLock>
  test_emit_token(*(char *)p);
 800730c:	7828      	ldrb	r0, [r5, #0]
 800730e:	f7f9 fde7 	bl	8000ee0 <test_emit_token>
  chMtxUnlock(&m1);
 8007312:	4620      	mov	r0, r4
}
 8007314:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m1);
 8007318:	f7fe bfa2 	b.w	8006260 <chMtxUnlock>
 800731c:	20000c38 	.word	0x20000c38

08007320 <chFactoryReleaseSemaphore>:
void chFactoryReleaseSemaphore(dyn_semaphore_t *dsp) {
 8007320:	b538      	push	{r3, r4, r5, lr}
 8007322:	4604      	mov	r4, r0
  F_LOCK();
 8007324:	4d16      	ldr	r5, [pc, #88]	; (8007380 <chFactoryReleaseSemaphore+0x60>)
 8007326:	4628      	mov	r0, r5
 8007328:	f7fd faca 	bl	80048c0 <chMtxLock>
  dep->refs--;
 800732c:	6863      	ldr	r3, [r4, #4]
 800732e:	3b01      	subs	r3, #1
 8007330:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 8007332:	b123      	cbz	r3, 800733e <chFactoryReleaseSemaphore+0x1e>
}
 8007334:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
 8007338:	4811      	ldr	r0, [pc, #68]	; (8007380 <chFactoryReleaseSemaphore+0x60>)
 800733a:	f7fe bf91 	b.w	8006260 <chMtxUnlock>
  dyn_element_t *prev = (dyn_element_t *)dlp;
 800733e:	f105 0128 	add.w	r1, r5, #40	; 0x28
 8007342:	460a      	mov	r2, r1
 8007344:	e002      	b.n	800734c <chFactoryReleaseSemaphore+0x2c>
    if (prev->next == element) {
 8007346:	429c      	cmp	r4, r3
 8007348:	d00a      	beq.n	8007360 <chFactoryReleaseSemaphore+0x40>
 800734a:	461a      	mov	r2, r3
  while (prev->next != (dyn_element_t *)dlp) {
 800734c:	6813      	ldr	r3, [r2, #0]
 800734e:	428b      	cmp	r3, r1
 8007350:	d1f9      	bne.n	8007346 <chFactoryReleaseSemaphore+0x26>
 8007352:	2320      	movs	r3, #32
 8007354:	f383 8811 	msr	BASEPRI, r3
  php->next = mp->next;
 8007358:	2300      	movs	r3, #0
 800735a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800735c:	601a      	str	r2, [r3, #0]
 800735e:	deff      	udf	#255	; 0xff
      prev->next = element->next;
 8007360:	6821      	ldr	r1, [r4, #0]
 8007362:	2320      	movs	r3, #32
 8007364:	6011      	str	r1, [r2, #0]
 8007366:	f383 8811 	msr	BASEPRI, r3
 800736a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800736c:	2300      	movs	r3, #0
 800736e:	6022      	str	r2, [r4, #0]
  mp->next = php;
 8007370:	62ec      	str	r4, [r5, #44]	; 0x2c
 8007372:	f383 8811 	msr	BASEPRI, r3
  F_UNLOCK();
 8007376:	4802      	ldr	r0, [pc, #8]	; (8007380 <chFactoryReleaseSemaphore+0x60>)
}
 8007378:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
 800737c:	f7fe bf70 	b.w	8006260 <chMtxUnlock>
 8007380:	200012cc 	.word	0x200012cc
	...

08007390 <oslib_test_009_003_execute>:
      chFactoryReleaseSemaphore(dsp);
    }
  }
}

static void oslib_test_009_003_execute(void) {
 8007390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_semaphore_t *dsp;

  /* [9.3.1] Retrieving a dynamic semaphore by name, must not exist.*/
  test_set_step(1);
 8007392:	2501      	movs	r5, #1
 8007394:	4c41      	ldr	r4, [pc, #260]	; (800749c <oslib_test_009_003_execute+0x10c>)
 8007396:	6025      	str	r5, [r4, #0]
  {
    dsp = chFactoryFindSemaphore("mysem");
 8007398:	f7ff fa2a 	bl	80067f0 <chFactoryFindSemaphore.constprop.12>
    test_assert(dsp == NULL, "found");
 800739c:	fab0 f080 	clz	r0, r0
 80073a0:	493f      	ldr	r1, [pc, #252]	; (80074a0 <oslib_test_009_003_execute+0x110>)
 80073a2:	0940      	lsrs	r0, r0, #5
 80073a4:	f7f9 fcf4 	bl	8000d90 <_test_assert>
 80073a8:	b100      	cbz	r0, 80073ac <oslib_test_009_003_execute+0x1c>
  {
    dsp = chFactoryFindSemaphore("mysem");
    test_assert(dsp == NULL, "found");
  }
  test_end_step(6);
}
 80073aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 80073ac:	2302      	movs	r3, #2
 80073ae:	6023      	str	r3, [r4, #0]
    dsp = chFactoryCreateSemaphore("mysem", 0);
 80073b0:	f7ff f9fe 	bl	80067b0 <chFactoryCreateSemaphore.constprop.13>
    test_assert(dsp != NULL, "cannot create");
 80073b4:	4606      	mov	r6, r0
 80073b6:	3000      	adds	r0, #0
 80073b8:	bf18      	it	ne
 80073ba:	2001      	movne	r0, #1
 80073bc:	4939      	ldr	r1, [pc, #228]	; (80074a4 <oslib_test_009_003_execute+0x114>)
 80073be:	f7f9 fce7 	bl	8000d90 <_test_assert>
 80073c2:	2800      	cmp	r0, #0
 80073c4:	d1f1      	bne.n	80073aa <oslib_test_009_003_execute+0x1a>
  test_set_step(3);
 80073c6:	2303      	movs	r3, #3
 80073c8:	6023      	str	r3, [r4, #0]
    dsp1 = chFactoryCreateSemaphore("mysem", 0);
 80073ca:	f7ff f9f1 	bl	80067b0 <chFactoryCreateSemaphore.constprop.13>
    test_assert(dsp1 == NULL, "can create");
 80073ce:	fab0 f080 	clz	r0, r0
 80073d2:	4935      	ldr	r1, [pc, #212]	; (80074a8 <oslib_test_009_003_execute+0x118>)
 80073d4:	0940      	lsrs	r0, r0, #5
 80073d6:	f7f9 fcdb 	bl	8000d90 <_test_assert>
 80073da:	2800      	cmp	r0, #0
 80073dc:	d1e5      	bne.n	80073aa <oslib_test_009_003_execute+0x1a>
  test_set_step(4);
 80073de:	2304      	movs	r3, #4
 80073e0:	6023      	str	r3, [r4, #0]
    dsp1 = chFactoryFindSemaphore("mysem");
 80073e2:	f7ff fa05 	bl	80067f0 <chFactoryFindSemaphore.constprop.12>
    test_assert(dsp1 != NULL, "not found");
 80073e6:	4607      	mov	r7, r0
 80073e8:	3000      	adds	r0, #0
 80073ea:	bf18      	it	ne
 80073ec:	2001      	movne	r0, #1
 80073ee:	492f      	ldr	r1, [pc, #188]	; (80074ac <oslib_test_009_003_execute+0x11c>)
 80073f0:	f7f9 fcce 	bl	8000d90 <_test_assert>
 80073f4:	2800      	cmp	r0, #0
 80073f6:	d1d8      	bne.n	80073aa <oslib_test_009_003_execute+0x1a>
    test_assert(dsp == dsp1, "object reference mismatch");
 80073f8:	1bf0      	subs	r0, r6, r7
 80073fa:	fab0 f080 	clz	r0, r0
 80073fe:	492c      	ldr	r1, [pc, #176]	; (80074b0 <oslib_test_009_003_execute+0x120>)
 8007400:	0940      	lsrs	r0, r0, #5
 8007402:	f7f9 fcc5 	bl	8000d90 <_test_assert>
 8007406:	2800      	cmp	r0, #0
 8007408:	d1cf      	bne.n	80073aa <oslib_test_009_003_execute+0x1a>
    test_assert(dsp1->element.refs == 2, "object reference mismatch");
 800740a:	6878      	ldr	r0, [r7, #4]
 800740c:	4928      	ldr	r1, [pc, #160]	; (80074b0 <oslib_test_009_003_execute+0x120>)
 800740e:	f1a0 0002 	sub.w	r0, r0, #2
 8007412:	fab0 f080 	clz	r0, r0
 8007416:	0940      	lsrs	r0, r0, #5
 8007418:	f7f9 fcba 	bl	8000d90 <_test_assert>
 800741c:	2800      	cmp	r0, #0
 800741e:	d1c4      	bne.n	80073aa <oslib_test_009_003_execute+0x1a>
 *
 * @api
 */
static inline dyn_element_t *chFactoryDuplicateReference(dyn_element_t *dep) {

  dep->refs++;
 8007420:	687b      	ldr	r3, [r7, #4]
    test_assert(dsp1 == dsp2, "object reference mismatch");
 8007422:	4628      	mov	r0, r5
 8007424:	442b      	add	r3, r5
 8007426:	607b      	str	r3, [r7, #4]
 8007428:	4921      	ldr	r1, [pc, #132]	; (80074b0 <oslib_test_009_003_execute+0x120>)
 800742a:	f7f9 fcb1 	bl	8000d90 <_test_assert>
 800742e:	2800      	cmp	r0, #0
 8007430:	d1bb      	bne.n	80073aa <oslib_test_009_003_execute+0x1a>
    test_assert(dsp2->element.refs == 3, "object reference mismatch");
 8007432:	6878      	ldr	r0, [r7, #4]
 8007434:	491e      	ldr	r1, [pc, #120]	; (80074b0 <oslib_test_009_003_execute+0x120>)
 8007436:	f1a0 0c03 	sub.w	ip, r0, #3
 800743a:	f1dc 0000 	rsbs	r0, ip, #0
 800743e:	eb40 000c 	adc.w	r0, r0, ip
 8007442:	f7f9 fca5 	bl	8000d90 <_test_assert>
 8007446:	2800      	cmp	r0, #0
 8007448:	d1af      	bne.n	80073aa <oslib_test_009_003_execute+0x1a>
    chFactoryReleaseSemaphore(dsp2);
 800744a:	4638      	mov	r0, r7
 800744c:	f7ff ff68 	bl	8007320 <chFactoryReleaseSemaphore>
    test_assert(dsp1->element.refs == 2, "references mismatch");
 8007450:	6878      	ldr	r0, [r7, #4]
 8007452:	4918      	ldr	r1, [pc, #96]	; (80074b4 <oslib_test_009_003_execute+0x124>)
 8007454:	1e82      	subs	r2, r0, #2
 8007456:	4250      	negs	r0, r2
 8007458:	4150      	adcs	r0, r2
 800745a:	f7f9 fc99 	bl	8000d90 <_test_assert>
 800745e:	2800      	cmp	r0, #0
 8007460:	d1a3      	bne.n	80073aa <oslib_test_009_003_execute+0x1a>
    chFactoryReleaseSemaphore(dsp1);
 8007462:	4638      	mov	r0, r7
 8007464:	f7ff ff5c 	bl	8007320 <chFactoryReleaseSemaphore>
    test_assert(dsp->element.refs == 1, "references mismatch");
 8007468:	6870      	ldr	r0, [r6, #4]
 800746a:	4912      	ldr	r1, [pc, #72]	; (80074b4 <oslib_test_009_003_execute+0x124>)
 800746c:	1b43      	subs	r3, r0, r5
 800746e:	4258      	negs	r0, r3
 8007470:	4158      	adcs	r0, r3
 8007472:	f7f9 fc8d 	bl	8000d90 <_test_assert>
 8007476:	2800      	cmp	r0, #0
 8007478:	d197      	bne.n	80073aa <oslib_test_009_003_execute+0x1a>
  test_set_step(5);
 800747a:	2305      	movs	r3, #5
    chFactoryReleaseSemaphore(dsp);
 800747c:	4630      	mov	r0, r6
  test_set_step(5);
 800747e:	6023      	str	r3, [r4, #0]
    chFactoryReleaseSemaphore(dsp);
 8007480:	f7ff ff4e 	bl	8007320 <chFactoryReleaseSemaphore>
  test_set_step(6);
 8007484:	2306      	movs	r3, #6
 8007486:	6023      	str	r3, [r4, #0]
    dsp = chFactoryFindSemaphore("mysem");
 8007488:	f7ff f9b2 	bl	80067f0 <chFactoryFindSemaphore.constprop.12>
}
 800748c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dsp == NULL, "found");
 8007490:	fab0 f080 	clz	r0, r0
 8007494:	4902      	ldr	r1, [pc, #8]	; (80074a0 <oslib_test_009_003_execute+0x110>)
 8007496:	0940      	lsrs	r0, r0, #5
 8007498:	f7f9 bc7a 	b.w	8000d90 <_test_assert>
 800749c:	20001d94 	.word	0x20001d94
 80074a0:	0800b524 	.word	0x0800b524
 80074a4:	0800b504 	.word	0x0800b504
 80074a8:	0800b514 	.word	0x0800b514
 80074ac:	0800b520 	.word	0x0800b520
 80074b0:	0800b52c 	.word	0x0800b52c
 80074b4:	0800b548 	.word	0x0800b548
	...

080074c0 <oslib_test_009_003_teardown>:
static void oslib_test_009_003_teardown(void) {
 80074c0:	b510      	push	{r4, lr}
  dsp = chFactoryFindSemaphore("mysem");
 80074c2:	f7ff f995 	bl	80067f0 <chFactoryFindSemaphore.constprop.12>
  if (dsp != NULL) {
 80074c6:	b140      	cbz	r0, 80074da <oslib_test_009_003_teardown+0x1a>
    while (dsp->element.refs > 0U) {
 80074c8:	6843      	ldr	r3, [r0, #4]
 80074ca:	4604      	mov	r4, r0
 80074cc:	b12b      	cbz	r3, 80074da <oslib_test_009_003_teardown+0x1a>
      chFactoryReleaseSemaphore(dsp);
 80074ce:	4620      	mov	r0, r4
 80074d0:	f7ff ff26 	bl	8007320 <chFactoryReleaseSemaphore>
    while (dsp->element.refs > 0U) {
 80074d4:	6863      	ldr	r3, [r4, #4]
 80074d6:	2b00      	cmp	r3, #0
 80074d8:	d1f9      	bne.n	80074ce <oslib_test_009_003_teardown+0xe>
}
 80074da:	bd10      	pop	{r4, pc}
 80074dc:	0000      	movs	r0, r0
	...

080074e0 <chFactoryReleaseObject>:
void chFactoryReleaseObject(registered_object_t *rop) {
 80074e0:	b538      	push	{r3, r4, r5, lr}
 80074e2:	4604      	mov	r4, r0
  F_LOCK();
 80074e4:	4d16      	ldr	r5, [pc, #88]	; (8007540 <chFactoryReleaseObject+0x60>)
 80074e6:	4628      	mov	r0, r5
 80074e8:	f7fd f9ea 	bl	80048c0 <chMtxLock>
  dep->refs--;
 80074ec:	6863      	ldr	r3, [r4, #4]
 80074ee:	3b01      	subs	r3, #1
 80074f0:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 80074f2:	b123      	cbz	r3, 80074fe <chFactoryReleaseObject+0x1e>
}
 80074f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
 80074f8:	4811      	ldr	r0, [pc, #68]	; (8007540 <chFactoryReleaseObject+0x60>)
 80074fa:	f7fe beb1 	b.w	8006260 <chMtxUnlock>
  dyn_element_t *prev = (dyn_element_t *)dlp;
 80074fe:	f105 0110 	add.w	r1, r5, #16
 8007502:	460a      	mov	r2, r1
 8007504:	e002      	b.n	800750c <chFactoryReleaseObject+0x2c>
    if (prev->next == element) {
 8007506:	429c      	cmp	r4, r3
 8007508:	d00a      	beq.n	8007520 <chFactoryReleaseObject+0x40>
 800750a:	461a      	mov	r2, r3
  while (prev->next != (dyn_element_t *)dlp) {
 800750c:	6813      	ldr	r3, [r2, #0]
 800750e:	428b      	cmp	r3, r1
 8007510:	d1f9      	bne.n	8007506 <chFactoryReleaseObject+0x26>
 8007512:	2320      	movs	r3, #32
 8007514:	f383 8811 	msr	BASEPRI, r3
  php->next = mp->next;
 8007518:	2300      	movs	r3, #0
 800751a:	696a      	ldr	r2, [r5, #20]
 800751c:	601a      	str	r2, [r3, #0]
 800751e:	deff      	udf	#255	; 0xff
      prev->next = element->next;
 8007520:	6821      	ldr	r1, [r4, #0]
 8007522:	2320      	movs	r3, #32
 8007524:	6011      	str	r1, [r2, #0]
 8007526:	f383 8811 	msr	BASEPRI, r3
 800752a:	696a      	ldr	r2, [r5, #20]
 800752c:	2300      	movs	r3, #0
 800752e:	6022      	str	r2, [r4, #0]
  mp->next = php;
 8007530:	616c      	str	r4, [r5, #20]
 8007532:	f383 8811 	msr	BASEPRI, r3
  F_UNLOCK();
 8007536:	4802      	ldr	r0, [pc, #8]	; (8007540 <chFactoryReleaseObject+0x60>)
}
 8007538:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
 800753c:	f7fe be90 	b.w	8006260 <chMtxUnlock>
 8007540:	200012cc 	.word	0x200012cc
	...

08007550 <oslib_test_009_001_execute>:
static void oslib_test_009_001_execute(void) {
 8007550:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8007554:	2501      	movs	r5, #1
 8007556:	4c51      	ldr	r4, [pc, #324]	; (800769c <oslib_test_009_001_execute+0x14c>)
 8007558:	6025      	str	r5, [r4, #0]
    rop = chFactoryFindObject("myobj");
 800755a:	f7ff f8d9 	bl	8006710 <chFactoryFindObject.constprop.16>
    test_assert(rop == NULL, "found");
 800755e:	fab0 f080 	clz	r0, r0
 8007562:	494f      	ldr	r1, [pc, #316]	; (80076a0 <oslib_test_009_001_execute+0x150>)
 8007564:	0940      	lsrs	r0, r0, #5
 8007566:	f7f9 fc13 	bl	8000d90 <_test_assert>
 800756a:	b108      	cbz	r0, 8007570 <oslib_test_009_001_execute+0x20>
}
 800756c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(2);
 8007570:	2302      	movs	r3, #2
    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
 8007572:	484c      	ldr	r0, [pc, #304]	; (80076a4 <oslib_test_009_001_execute+0x154>)
  test_set_step(2);
 8007574:	6023      	str	r3, [r4, #0]
    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
 8007576:	f7ff f8b3 	bl	80066e0 <chFactoryRegisterObject.constprop.17>
    test_assert(rop != NULL, "cannot register");
 800757a:	4606      	mov	r6, r0
 800757c:	3000      	adds	r0, #0
 800757e:	bf18      	it	ne
 8007580:	2001      	movne	r0, #1
 8007582:	4949      	ldr	r1, [pc, #292]	; (80076a8 <oslib_test_009_001_execute+0x158>)
 8007584:	f7f9 fc04 	bl	8000d90 <_test_assert>
 8007588:	2800      	cmp	r0, #0
 800758a:	d1ef      	bne.n	800756c <oslib_test_009_001_execute+0x1c>
  test_set_step(3);
 800758c:	2303      	movs	r3, #3
    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
 800758e:	4847      	ldr	r0, [pc, #284]	; (80076ac <oslib_test_009_001_execute+0x15c>)
  test_set_step(3);
 8007590:	6023      	str	r3, [r4, #0]
    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
 8007592:	f7ff f8a5 	bl	80066e0 <chFactoryRegisterObject.constprop.17>
    test_assert(rop1 == NULL, "can register");
 8007596:	fab0 f080 	clz	r0, r0
 800759a:	4945      	ldr	r1, [pc, #276]	; (80076b0 <oslib_test_009_001_execute+0x160>)
 800759c:	0940      	lsrs	r0, r0, #5
 800759e:	f7f9 fbf7 	bl	8000d90 <_test_assert>
 80075a2:	2800      	cmp	r0, #0
 80075a4:	d1e2      	bne.n	800756c <oslib_test_009_001_execute+0x1c>
  test_set_step(4);
 80075a6:	2304      	movs	r3, #4
 80075a8:	6023      	str	r3, [r4, #0]
    rop1 = chFactoryFindObject("myobj");
 80075aa:	f7ff f8b1 	bl	8006710 <chFactoryFindObject.constprop.16>
    test_assert(rop1 != NULL, "not found");
 80075ae:	4607      	mov	r7, r0
 80075b0:	3000      	adds	r0, #0
 80075b2:	bf18      	it	ne
 80075b4:	2001      	movne	r0, #1
 80075b6:	493f      	ldr	r1, [pc, #252]	; (80076b4 <oslib_test_009_001_execute+0x164>)
 80075b8:	f7f9 fbea 	bl	8000d90 <_test_assert>
 80075bc:	2800      	cmp	r0, #0
 80075be:	d1d5      	bne.n	800756c <oslib_test_009_001_execute+0x1c>
    test_assert(*(uint32_t *)(rop1->objp) == 0x55aa, "object mismatch");
 80075c0:	f245 58aa 	movw	r8, #21930	; 0x55aa
 80075c4:	693b      	ldr	r3, [r7, #16]
 80075c6:	493c      	ldr	r1, [pc, #240]	; (80076b8 <oslib_test_009_001_execute+0x168>)
 80075c8:	6818      	ldr	r0, [r3, #0]
 80075ca:	eba0 0008 	sub.w	r0, r0, r8
 80075ce:	fab0 f080 	clz	r0, r0
 80075d2:	0940      	lsrs	r0, r0, #5
 80075d4:	f7f9 fbdc 	bl	8000d90 <_test_assert>
 80075d8:	2800      	cmp	r0, #0
 80075da:	d1c7      	bne.n	800756c <oslib_test_009_001_execute+0x1c>
    test_assert(rop == rop1, "object reference mismatch");
 80075dc:	1bf0      	subs	r0, r6, r7
 80075de:	fab0 f080 	clz	r0, r0
 80075e2:	4936      	ldr	r1, [pc, #216]	; (80076bc <oslib_test_009_001_execute+0x16c>)
 80075e4:	0940      	lsrs	r0, r0, #5
 80075e6:	f7f9 fbd3 	bl	8000d90 <_test_assert>
 80075ea:	2800      	cmp	r0, #0
 80075ec:	d1be      	bne.n	800756c <oslib_test_009_001_execute+0x1c>
    test_assert(rop1->element.refs == 2, "object reference mismatch");
 80075ee:	6878      	ldr	r0, [r7, #4]
 80075f0:	4932      	ldr	r1, [pc, #200]	; (80076bc <oslib_test_009_001_execute+0x16c>)
 80075f2:	f1a0 0002 	sub.w	r0, r0, #2
 80075f6:	fab0 f080 	clz	r0, r0
 80075fa:	0940      	lsrs	r0, r0, #5
 80075fc:	f7f9 fbc8 	bl	8000d90 <_test_assert>
 8007600:	2800      	cmp	r0, #0
 8007602:	d1b3      	bne.n	800756c <oslib_test_009_001_execute+0x1c>
 8007604:	687b      	ldr	r3, [r7, #4]
    test_assert(rop1 == rop2, "object reference mismatch");
 8007606:	4628      	mov	r0, r5
 8007608:	442b      	add	r3, r5
 800760a:	607b      	str	r3, [r7, #4]
 800760c:	492b      	ldr	r1, [pc, #172]	; (80076bc <oslib_test_009_001_execute+0x16c>)
 800760e:	f7f9 fbbf 	bl	8000d90 <_test_assert>
 8007612:	2800      	cmp	r0, #0
 8007614:	d1aa      	bne.n	800756c <oslib_test_009_001_execute+0x1c>
    test_assert(*(uint32_t *)(rop2->objp) == 0x55aa, "object mismatch");
 8007616:	693b      	ldr	r3, [r7, #16]
 8007618:	4927      	ldr	r1, [pc, #156]	; (80076b8 <oslib_test_009_001_execute+0x168>)
 800761a:	6818      	ldr	r0, [r3, #0]
 800761c:	eba0 0e08 	sub.w	lr, r0, r8
 8007620:	f1de 0000 	rsbs	r0, lr, #0
 8007624:	eb40 000e 	adc.w	r0, r0, lr
 8007628:	f7f9 fbb2 	bl	8000d90 <_test_assert>
 800762c:	2800      	cmp	r0, #0
 800762e:	d19d      	bne.n	800756c <oslib_test_009_001_execute+0x1c>
    test_assert(rop2->element.refs == 3, "object reference mismatch");
 8007630:	6878      	ldr	r0, [r7, #4]
 8007632:	4922      	ldr	r1, [pc, #136]	; (80076bc <oslib_test_009_001_execute+0x16c>)
 8007634:	f1a0 0c03 	sub.w	ip, r0, #3
 8007638:	f1dc 0000 	rsbs	r0, ip, #0
 800763c:	eb40 000c 	adc.w	r0, r0, ip
 8007640:	f7f9 fba6 	bl	8000d90 <_test_assert>
 8007644:	2800      	cmp	r0, #0
 8007646:	d191      	bne.n	800756c <oslib_test_009_001_execute+0x1c>
    chFactoryReleaseObject(rop2);
 8007648:	4638      	mov	r0, r7
 800764a:	f7ff ff49 	bl	80074e0 <chFactoryReleaseObject>
    test_assert(rop1->element.refs == 2, "references mismatch");
 800764e:	6878      	ldr	r0, [r7, #4]
 8007650:	491b      	ldr	r1, [pc, #108]	; (80076c0 <oslib_test_009_001_execute+0x170>)
 8007652:	1e82      	subs	r2, r0, #2
 8007654:	4250      	negs	r0, r2
 8007656:	4150      	adcs	r0, r2
 8007658:	f7f9 fb9a 	bl	8000d90 <_test_assert>
 800765c:	2800      	cmp	r0, #0
 800765e:	d185      	bne.n	800756c <oslib_test_009_001_execute+0x1c>
    chFactoryReleaseObject(rop1);
 8007660:	4638      	mov	r0, r7
 8007662:	f7ff ff3d 	bl	80074e0 <chFactoryReleaseObject>
    test_assert(rop->element.refs == 1, "references mismatch");
 8007666:	6870      	ldr	r0, [r6, #4]
 8007668:	4915      	ldr	r1, [pc, #84]	; (80076c0 <oslib_test_009_001_execute+0x170>)
 800766a:	1b43      	subs	r3, r0, r5
 800766c:	4258      	negs	r0, r3
 800766e:	4158      	adcs	r0, r3
 8007670:	f7f9 fb8e 	bl	8000d90 <_test_assert>
 8007674:	2800      	cmp	r0, #0
 8007676:	f47f af79 	bne.w	800756c <oslib_test_009_001_execute+0x1c>
  test_set_step(5);
 800767a:	2305      	movs	r3, #5
    chFactoryReleaseObject(rop);
 800767c:	4630      	mov	r0, r6
  test_set_step(5);
 800767e:	6023      	str	r3, [r4, #0]
    chFactoryReleaseObject(rop);
 8007680:	f7ff ff2e 	bl	80074e0 <chFactoryReleaseObject>
  test_set_step(6);
 8007684:	2306      	movs	r3, #6
 8007686:	6023      	str	r3, [r4, #0]
    rop = chFactoryFindObject("myobj");
 8007688:	f7ff f842 	bl	8006710 <chFactoryFindObject.constprop.16>
}
 800768c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(rop == NULL, "found");
 8007690:	fab0 f080 	clz	r0, r0
 8007694:	4902      	ldr	r1, [pc, #8]	; (80076a0 <oslib_test_009_001_execute+0x150>)
 8007696:	0940      	lsrs	r0, r0, #5
 8007698:	f7f9 bb7a 	b.w	8000d90 <_test_assert>
 800769c:	20001d94 	.word	0x20001d94
 80076a0:	0800b524 	.word	0x0800b524
 80076a4:	20000c90 	.word	0x20000c90
 80076a8:	0800b4b4 	.word	0x0800b4b4
 80076ac:	20000c94 	.word	0x20000c94
 80076b0:	0800b4c4 	.word	0x0800b4c4
 80076b4:	0800b520 	.word	0x0800b520
 80076b8:	0800b4d4 	.word	0x0800b4d4
 80076bc:	0800b52c 	.word	0x0800b52c
 80076c0:	0800b548 	.word	0x0800b548
	...

080076d0 <oslib_test_009_001_teardown>:
static void oslib_test_009_001_teardown(void) {
 80076d0:	b510      	push	{r4, lr}
  rop = chFactoryFindObject("myobj");
 80076d2:	f7ff f81d 	bl	8006710 <chFactoryFindObject.constprop.16>
  if (rop != NULL) {
 80076d6:	b140      	cbz	r0, 80076ea <oslib_test_009_001_teardown+0x1a>
    while (rop->element.refs > 0U) {
 80076d8:	6843      	ldr	r3, [r0, #4]
 80076da:	4604      	mov	r4, r0
 80076dc:	b12b      	cbz	r3, 80076ea <oslib_test_009_001_teardown+0x1a>
      chFactoryReleaseObject(rop);
 80076de:	4620      	mov	r0, r4
 80076e0:	f7ff fefe 	bl	80074e0 <chFactoryReleaseObject>
    while (rop->element.refs > 0U) {
 80076e4:	6863      	ldr	r3, [r4, #4]
 80076e6:	2b00      	cmp	r3, #0
 80076e8:	d1f9      	bne.n	80076de <oslib_test_009_001_teardown+0xe>
}
 80076ea:	bd10      	pop	{r4, pc}
 80076ec:	0000      	movs	r0, r0
	...

080076f0 <chHeapStatus>:
 *                      free free block found space or @p NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 80076f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
 80076f4:	4c17      	ldr	r4, [pc, #92]	; (8007754 <chHeapStatus+0x64>)
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 80076f6:	4688      	mov	r8, r1
    heapp = &default_heap;
 80076f8:	2800      	cmp	r0, #0
 80076fa:	bf18      	it	ne
 80076fc:	4604      	movne	r4, r0
  }

  H_LOCK(heapp);
 80076fe:	f104 070c 	add.w	r7, r4, #12
 8007702:	4638      	mov	r0, r7
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 8007704:	4691      	mov	r9, r2
  H_LOCK(heapp);
 8007706:	f7fd f8db 	bl	80048c0 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 800770a:	6863      	ldr	r3, [r4, #4]
 800770c:	b1f3      	cbz	r3, 800774c <chHeapStatus+0x5c>
  lpages = 0U;
 800770e:	2400      	movs	r4, #0
  tpages = 0U;
 8007710:	4625      	mov	r5, r4
  n = 0U;
 8007712:	4626      	mov	r6, r4
    size_t pages = H_PAGES(H_NEXT(qp));
 8007714:	6858      	ldr	r0, [r3, #4]
  while (H_NEXT(qp) != NULL) {
 8007716:	681b      	ldr	r3, [r3, #0]
 8007718:	4284      	cmp	r4, r0

    /* Updating counters.*/
    n++;
 800771a:	f106 0601 	add.w	r6, r6, #1
    tpages += pages;
 800771e:	4405      	add	r5, r0
 8007720:	bf38      	it	cc
 8007722:	4604      	movcc	r4, r0
  while (H_NEXT(qp) != NULL) {
 8007724:	2b00      	cmp	r3, #0
 8007726:	d1f5      	bne.n	8007714 <chHeapStatus+0x24>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 8007728:	f1b8 0f00 	cmp.w	r8, #0
 800772c:	d002      	beq.n	8007734 <chHeapStatus+0x44>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 800772e:	00ed      	lsls	r5, r5, #3
 8007730:	f8c8 5000 	str.w	r5, [r8]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 8007734:	f1b9 0f00 	cmp.w	r9, #0
 8007738:	d002      	beq.n	8007740 <chHeapStatus+0x50>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 800773a:	00e4      	lsls	r4, r4, #3
 800773c:	f8c9 4000 	str.w	r4, [r9]
  }
  H_UNLOCK(heapp);
 8007740:	4638      	mov	r0, r7
 8007742:	f7fe fd8d 	bl	8006260 <chMtxUnlock>

  return n;
}
 8007746:	4630      	mov	r0, r6
 8007748:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  lpages = 0U;
 800774c:	461c      	mov	r4, r3
  tpages = 0U;
 800774e:	461d      	mov	r5, r3
  n = 0U;
 8007750:	461e      	mov	r6, r3
 8007752:	e7e9      	b.n	8007728 <chHeapStatus+0x38>
 8007754:	200013f8 	.word	0x200013f8
	...

08007760 <cmd_mem>:
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8007760:	b530      	push	{r4, r5, lr}
  if (argc > 0) {
 8007762:	2900      	cmp	r1, #0
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8007764:	b083      	sub	sp, #12
  if (argc > 0) {
 8007766:	dd05      	ble.n	8007774 <cmd_mem+0x14>
    shellUsage(chp, "mem");
 8007768:	4a12      	ldr	r2, [pc, #72]	; (80077b4 <cmd_mem+0x54>)
 800776a:	4913      	ldr	r1, [pc, #76]	; (80077b8 <cmd_mem+0x58>)
 800776c:	f7fb fc38 	bl	8002fe0 <chprintf>
}
 8007770:	b003      	add	sp, #12
 8007772:	bd30      	pop	{r4, r5, pc}
 8007774:	4604      	mov	r4, r0
  n = chHeapStatus(NULL, &total, &largest);
 8007776:	aa01      	add	r2, sp, #4
 8007778:	4669      	mov	r1, sp
 800777a:	2000      	movs	r0, #0
 800777c:	f7ff ffb8 	bl	80076f0 <chHeapStatus>
 8007780:	4605      	mov	r5, r0
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.topmem - ch_memcore.basemem);
 8007782:	4b0e      	ldr	r3, [pc, #56]	; (80077bc <cmd_mem+0x5c>)
  chprintf(chp, "core free memory : %u bytes" SHELL_NEWLINE_STR, chCoreGetStatusX());
 8007784:	490e      	ldr	r1, [pc, #56]	; (80077c0 <cmd_mem+0x60>)
 8007786:	685a      	ldr	r2, [r3, #4]
 8007788:	681b      	ldr	r3, [r3, #0]
 800778a:	4620      	mov	r0, r4
 800778c:	1ad2      	subs	r2, r2, r3
 800778e:	f7fb fc27 	bl	8002fe0 <chprintf>
  chprintf(chp, "heap fragments   : %u" SHELL_NEWLINE_STR, n);
 8007792:	462a      	mov	r2, r5
 8007794:	490b      	ldr	r1, [pc, #44]	; (80077c4 <cmd_mem+0x64>)
 8007796:	4620      	mov	r0, r4
 8007798:	f7fb fc22 	bl	8002fe0 <chprintf>
  chprintf(chp, "heap free total  : %u bytes" SHELL_NEWLINE_STR, total);
 800779c:	9a00      	ldr	r2, [sp, #0]
 800779e:	490a      	ldr	r1, [pc, #40]	; (80077c8 <cmd_mem+0x68>)
 80077a0:	4620      	mov	r0, r4
 80077a2:	f7fb fc1d 	bl	8002fe0 <chprintf>
  chprintf(chp, "heap free largest: %u bytes" SHELL_NEWLINE_STR, largest);
 80077a6:	4620      	mov	r0, r4
 80077a8:	9a01      	ldr	r2, [sp, #4]
 80077aa:	4908      	ldr	r1, [pc, #32]	; (80077cc <cmd_mem+0x6c>)
 80077ac:	f7fb fc18 	bl	8002fe0 <chprintf>
}
 80077b0:	b003      	add	sp, #12
 80077b2:	bd30      	pop	{r4, r5, pc}
 80077b4:	0800ab4c 	.word	0x0800ab4c
 80077b8:	0800abd0 	.word	0x0800abd0
 80077bc:	200013f0 	.word	0x200013f0
 80077c0:	0800ab50 	.word	0x0800ab50
 80077c4:	0800ab70 	.word	0x0800ab70
 80077c8:	0800ab88 	.word	0x0800ab88
 80077cc:	0800aba8 	.word	0x0800aba8

080077d0 <chHeapFree>:
void chHeapFree(void *p) {
 80077d0:	b570      	push	{r4, r5, r6, lr}
  heapp = H_HEAP(hp);
 80077d2:	e950 4302 	ldrd	r4, r3, [r0, #-8]
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80077d6:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80077d8:	08db      	lsrs	r3, r3, #3
  H_LOCK(heapp);
 80077da:	f104 060c 	add.w	r6, r4, #12
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80077de:	f840 3c04 	str.w	r3, [r0, #-4]
void chHeapFree(void *p) {
 80077e2:	4605      	mov	r5, r0
  qp = &heapp->header;
 80077e4:	3404      	adds	r4, #4
  H_LOCK(heapp);
 80077e6:	4630      	mov	r0, r6
 80077e8:	f7fd f86a 	bl	80048c0 <chMtxLock>
  qp = &heapp->header;
 80077ec:	4623      	mov	r3, r4
  hp = (heap_header_t *)p - 1U;
 80077ee:	f1a5 0108 	sub.w	r1, r5, #8
    if (((qp == &heapp->header) || (hp > qp)) &&
 80077f2:	42a3      	cmp	r3, r4
 80077f4:	681a      	ldr	r2, [r3, #0]
 80077f6:	d001      	beq.n	80077fc <chHeapFree+0x2c>
 80077f8:	4299      	cmp	r1, r3
 80077fa:	d902      	bls.n	8007802 <chHeapFree+0x32>
 80077fc:	b11a      	cbz	r2, 8007806 <chHeapFree+0x36>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80077fe:	4291      	cmp	r1, r2
 8007800:	d301      	bcc.n	8007806 <chHeapFree+0x36>
void chHeapFree(void *p) {
 8007802:	4613      	mov	r3, r2
 8007804:	e7f5      	b.n	80077f2 <chHeapFree+0x22>
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8007806:	f855 0c04 	ldr.w	r0, [r5, #-4]
      H_NEXT(hp) = H_NEXT(qp);
 800780a:	f845 2c08 	str.w	r2, [r5, #-8]
      H_NEXT(qp) = hp;
 800780e:	6019      	str	r1, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8007810:	1c42      	adds	r2, r0, #1
 8007812:	f855 4c08 	ldr.w	r4, [r5, #-8]
 8007816:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
 800781a:	42a0      	cmp	r0, r4
 800781c:	d00a      	beq.n	8007834 <chHeapFree+0x64>
      if ((H_LIMIT(qp) == hp)) {
 800781e:	6858      	ldr	r0, [r3, #4]
 8007820:	1c42      	adds	r2, r0, #1
 8007822:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8007826:	4291      	cmp	r1, r2
 8007828:	d010      	beq.n	800784c <chHeapFree+0x7c>
  H_UNLOCK(heapp);
 800782a:	4630      	mov	r0, r6
}
 800782c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  H_UNLOCK(heapp);
 8007830:	f7fe bd16 	b.w	8006260 <chMtxUnlock>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8007834:	6840      	ldr	r0, [r0, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8007836:	f851 4032 	ldr.w	r4, [r1, r2, lsl #3]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 800783a:	4402      	add	r2, r0
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800783c:	e945 4202 	strd	r4, r2, [r5, #-8]
      if ((H_LIMIT(qp) == hp)) {
 8007840:	6858      	ldr	r0, [r3, #4]
 8007842:	1c42      	adds	r2, r0, #1
 8007844:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8007848:	4291      	cmp	r1, r2
 800784a:	d1ee      	bne.n	800782a <chHeapFree+0x5a>
        H_NEXT(qp) = H_NEXT(hp);
 800784c:	e955 1202 	ldrd	r1, r2, [r5, #-8]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8007850:	3201      	adds	r2, #1
 8007852:	4410      	add	r0, r2
        H_NEXT(qp) = H_NEXT(hp);
 8007854:	e9c3 1000 	strd	r1, r0, [r3]
  H_UNLOCK(heapp);
 8007858:	4630      	mov	r0, r6
}
 800785a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  H_UNLOCK(heapp);
 800785e:	f7fe bcff 	b.w	8006260 <chMtxUnlock>
 8007862:	bf00      	nop
	...

08007870 <oslib_test_008_002_execute>:
  void *p1;
  size_t total_size, largest_size;

  /* [8.2.1] Single block allocation using chHeapAlloc() then the block
     is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8007870:	2301      	movs	r3, #1
static void oslib_test_008_002_execute(void) {
 8007872:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 8007874:	4c13      	ldr	r4, [pc, #76]	; (80078c4 <oslib_test_008_002_execute+0x54>)
static void oslib_test_008_002_execute(void) {
 8007876:	b082      	sub	sp, #8
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8007878:	466a      	mov	r2, sp
 800787a:	a901      	add	r1, sp, #4
 800787c:	2000      	movs	r0, #0
  test_set_step(1);
 800787e:	6023      	str	r3, [r4, #0]
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8007880:	f7ff ff36 	bl	80076f0 <chHeapStatus>
 8007884:	2110      	movs	r1, #16
 8007886:	4810      	ldr	r0, [pc, #64]	; (80078c8 <oslib_test_008_002_execute+0x58>)
 8007888:	f7fe fd22 	bl	80062d0 <chHeapAllocAligned.constprop.41>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 800788c:	4606      	mov	r6, r0
 800788e:	3000      	adds	r0, #0
 8007890:	bf18      	it	ne
 8007892:	2001      	movne	r0, #1
 8007894:	490d      	ldr	r1, [pc, #52]	; (80078cc <oslib_test_008_002_execute+0x5c>)
 8007896:	f7f9 fa7b 	bl	8000d90 <_test_assert>
 800789a:	b980      	cbnz	r0, 80078be <oslib_test_008_002_execute+0x4e>
 800789c:	4605      	mov	r5, r0
    chHeapFree(p1);
 800789e:	4630      	mov	r0, r6
 80078a0:	f7ff ff96 	bl	80077d0 <chHeapFree>
  }
  test_end_step(1);

  /* [8.2.2] Testing allocation failure.*/
  test_set_step(2);
 80078a4:	2302      	movs	r3, #2
 80078a6:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 80078aa:	4628      	mov	r0, r5
 80078ac:	6023      	str	r3, [r4, #0]
 80078ae:	f7fe fd0f 	bl	80062d0 <chHeapAllocAligned.constprop.41>
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
 80078b2:	fab0 f080 	clz	r0, r0
 80078b6:	4906      	ldr	r1, [pc, #24]	; (80078d0 <oslib_test_008_002_execute+0x60>)
 80078b8:	0940      	lsrs	r0, r0, #5
 80078ba:	f7f9 fa69 	bl	8000d90 <_test_assert>
  }
  test_end_step(2);
}
 80078be:	b002      	add	sp, #8
 80078c0:	bd70      	pop	{r4, r5, r6, pc}
 80078c2:	bf00      	nop
 80078c4:	20001d94 	.word	0x20001d94
 80078c8:	20001cf4 	.word	0x20001cf4
 80078cc:	0800b478 	.word	0x0800b478
 80078d0:	0800b48c 	.word	0x0800b48c
	...

080078e0 <oslib_test_008_001_execute>:
  test_set_step(1);
 80078e0:	2301      	movs	r3, #1
static void oslib_test_008_001_execute(void) {
 80078e2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 80078e6:	4cbf      	ldr	r4, [pc, #764]	; (8007be4 <oslib_test_008_001_execute+0x304>)
static void oslib_test_008_001_execute(void) {
 80078e8:	b084      	sub	sp, #16
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 80078ea:	4669      	mov	r1, sp
 80078ec:	2200      	movs	r2, #0
 80078ee:	48be      	ldr	r0, [pc, #760]	; (8007be8 <oslib_test_008_001_execute+0x308>)
  test_set_step(1);
 80078f0:	6023      	str	r3, [r4, #0]
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 80078f2:	f7ff fefd 	bl	80076f0 <chHeapStatus>
 80078f6:	f1a0 0001 	sub.w	r0, r0, #1
 80078fa:	fab0 f080 	clz	r0, r0
 80078fe:	49bb      	ldr	r1, [pc, #748]	; (8007bec <oslib_test_008_001_execute+0x30c>)
 8007900:	0940      	lsrs	r0, r0, #5
 8007902:	f7f9 fa45 	bl	8000d90 <_test_assert>
 8007906:	b110      	cbz	r0, 800790e <oslib_test_008_001_execute+0x2e>
}
 8007908:	b004      	add	sp, #16
 800790a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(2);
 800790e:	2302      	movs	r3, #2
 8007910:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007914:	48b4      	ldr	r0, [pc, #720]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007916:	6023      	str	r3, [r4, #0]
 8007918:	f7fe fcda 	bl	80062d0 <chHeapAllocAligned.constprop.41>
    test_assert(p1 == NULL, "allocation not failed");
 800791c:	fab0 f080 	clz	r0, r0
 8007920:	49b3      	ldr	r1, [pc, #716]	; (8007bf0 <oslib_test_008_001_execute+0x310>)
 8007922:	0940      	lsrs	r0, r0, #5
 8007924:	f7f9 fa34 	bl	8000d90 <_test_assert>
 8007928:	2800      	cmp	r0, #0
 800792a:	d1ed      	bne.n	8007908 <oslib_test_008_001_execute+0x28>
  test_set_step(3);
 800792c:	2303      	movs	r3, #3
 800792e:	2110      	movs	r1, #16
 8007930:	48ad      	ldr	r0, [pc, #692]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007932:	6023      	str	r3, [r4, #0]
 8007934:	f7fe fccc 	bl	80062d0 <chHeapAllocAligned.constprop.41>
    test_assert(p1 != NULL, "allocation failed");
 8007938:	4605      	mov	r5, r0
 800793a:	3000      	adds	r0, #0
 800793c:	bf18      	it	ne
 800793e:	2001      	movne	r0, #1
 8007940:	49ac      	ldr	r1, [pc, #688]	; (8007bf4 <oslib_test_008_001_execute+0x314>)
 8007942:	f7f9 fa25 	bl	8000d90 <_test_assert>
 8007946:	2800      	cmp	r0, #0
 8007948:	d1de      	bne.n	8007908 <oslib_test_008_001_execute+0x28>
    chHeapFree(p1);
 800794a:	4628      	mov	r0, r5
 800794c:	f7ff ff40 	bl	80077d0 <chHeapFree>
  test_set_step(4);
 8007950:	2304      	movs	r3, #4
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8007952:	a903      	add	r1, sp, #12
 8007954:	aa02      	add	r2, sp, #8
 8007956:	48a4      	ldr	r0, [pc, #656]	; (8007be8 <oslib_test_008_001_execute+0x308>)
  test_set_step(4);
 8007958:	6023      	str	r3, [r4, #0]
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 800795a:	f7ff fec9 	bl	80076f0 <chHeapStatus>
 800795e:	4603      	mov	r3, r0
    test_assert(n == 1, "missing free block");
 8007960:	f1a0 0001 	sub.w	r0, r0, #1
 8007964:	fab0 f080 	clz	r0, r0
 8007968:	49a3      	ldr	r1, [pc, #652]	; (8007bf8 <oslib_test_008_001_execute+0x318>)
 800796a:	0940      	lsrs	r0, r0, #5
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 800796c:	9301      	str	r3, [sp, #4]
    test_assert(n == 1, "missing free block");
 800796e:	f7f9 fa0f 	bl	8000d90 <_test_assert>
 8007972:	2800      	cmp	r0, #0
 8007974:	d1c8      	bne.n	8007908 <oslib_test_008_001_execute+0x28>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 8007976:	9803      	ldr	r0, [sp, #12]
 8007978:	49a0      	ldr	r1, [pc, #640]	; (8007bfc <oslib_test_008_001_execute+0x31c>)
 800797a:	280f      	cmp	r0, #15
 800797c:	bf94      	ite	ls
 800797e:	2000      	movls	r0, #0
 8007980:	2001      	movhi	r0, #1
 8007982:	f7f9 fa05 	bl	8000d90 <_test_assert>
 8007986:	2800      	cmp	r0, #0
 8007988:	d1be      	bne.n	8007908 <oslib_test_008_001_execute+0x28>
    test_assert(total_size == largest_size, "unexpected heap state");
 800798a:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
 800798e:	1ac0      	subs	r0, r0, r3
 8007990:	fab0 f080 	clz	r0, r0
 8007994:	4999      	ldr	r1, [pc, #612]	; (8007bfc <oslib_test_008_001_execute+0x31c>)
 8007996:	0940      	lsrs	r0, r0, #5
 8007998:	f7f9 f9fa 	bl	8000d90 <_test_assert>
 800799c:	4605      	mov	r5, r0
 800799e:	2800      	cmp	r0, #0
 80079a0:	d1b2      	bne.n	8007908 <oslib_test_008_001_execute+0x28>
  test_set_step(5);
 80079a2:	2305      	movs	r3, #5
 80079a4:	2110      	movs	r1, #16
 80079a6:	4890      	ldr	r0, [pc, #576]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 80079a8:	6023      	str	r3, [r4, #0]
 80079aa:	f7fe fc91 	bl	80062d0 <chHeapAllocAligned.constprop.41>
 80079ae:	2110      	movs	r1, #16
 80079b0:	4680      	mov	r8, r0
 80079b2:	488d      	ldr	r0, [pc, #564]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 80079b4:	f7fe fc8c 	bl	80062d0 <chHeapAllocAligned.constprop.41>
 80079b8:	2110      	movs	r1, #16
 80079ba:	4607      	mov	r7, r0
 80079bc:	488a      	ldr	r0, [pc, #552]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 80079be:	f7fe fc87 	bl	80062d0 <chHeapAllocAligned.constprop.41>
 80079c2:	4606      	mov	r6, r0
    chHeapFree(p1);                                 /* Does not merge.*/
 80079c4:	4640      	mov	r0, r8
 80079c6:	f7ff ff03 	bl	80077d0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 80079ca:	4638      	mov	r0, r7
 80079cc:	f7ff ff00 	bl	80077d0 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 80079d0:	4630      	mov	r0, r6
 80079d2:	f7ff fefd 	bl	80077d0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80079d6:	462a      	mov	r2, r5
 80079d8:	a901      	add	r1, sp, #4
 80079da:	4883      	ldr	r0, [pc, #524]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 80079dc:	f7ff fe88 	bl	80076f0 <chHeapStatus>
 80079e0:	f1a0 0001 	sub.w	r0, r0, #1
 80079e4:	fab0 f080 	clz	r0, r0
 80079e8:	4980      	ldr	r1, [pc, #512]	; (8007bec <oslib_test_008_001_execute+0x30c>)
 80079ea:	0940      	lsrs	r0, r0, #5
 80079ec:	f7f9 f9d0 	bl	8000d90 <_test_assert>
 80079f0:	4605      	mov	r5, r0
 80079f2:	2800      	cmp	r0, #0
 80079f4:	d188      	bne.n	8007908 <oslib_test_008_001_execute+0x28>
  test_set_step(6);
 80079f6:	2306      	movs	r3, #6
 80079f8:	2110      	movs	r1, #16
 80079fa:	487b      	ldr	r0, [pc, #492]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 80079fc:	6023      	str	r3, [r4, #0]
 80079fe:	f7fe fc67 	bl	80062d0 <chHeapAllocAligned.constprop.41>
 8007a02:	2110      	movs	r1, #16
 8007a04:	4606      	mov	r6, r0
 8007a06:	4878      	ldr	r0, [pc, #480]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007a08:	f7fe fc62 	bl	80062d0 <chHeapAllocAligned.constprop.41>
 8007a0c:	4607      	mov	r7, r0
 8007a0e:	2110      	movs	r1, #16
 8007a10:	4875      	ldr	r0, [pc, #468]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007a12:	f7fe fc5d 	bl	80062d0 <chHeapAllocAligned.constprop.41>
    chHeapFree(p3);                                 /* Merges forward.*/
 8007a16:	f7ff fedb 	bl	80077d0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 8007a1a:	4638      	mov	r0, r7
 8007a1c:	f7ff fed8 	bl	80077d0 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 8007a20:	4630      	mov	r0, r6
 8007a22:	f7ff fed5 	bl	80077d0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8007a26:	462a      	mov	r2, r5
 8007a28:	a901      	add	r1, sp, #4
 8007a2a:	486f      	ldr	r0, [pc, #444]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007a2c:	f7ff fe60 	bl	80076f0 <chHeapStatus>
 8007a30:	1e43      	subs	r3, r0, #1
 8007a32:	4258      	negs	r0, r3
 8007a34:	496d      	ldr	r1, [pc, #436]	; (8007bec <oslib_test_008_001_execute+0x30c>)
 8007a36:	4158      	adcs	r0, r3
 8007a38:	f7f9 f9aa 	bl	8000d90 <_test_assert>
 8007a3c:	4605      	mov	r5, r0
 8007a3e:	2800      	cmp	r0, #0
 8007a40:	f47f af62 	bne.w	8007908 <oslib_test_008_001_execute+0x28>
  test_set_step(7);
 8007a44:	2307      	movs	r3, #7
 8007a46:	2111      	movs	r1, #17
 8007a48:	4867      	ldr	r0, [pc, #412]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007a4a:	6023      	str	r3, [r4, #0]
 8007a4c:	f7fe fc40 	bl	80062d0 <chHeapAllocAligned.constprop.41>
 8007a50:	2110      	movs	r1, #16
 8007a52:	4606      	mov	r6, r0
 8007a54:	4864      	ldr	r0, [pc, #400]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007a56:	f7fe fc3b 	bl	80062d0 <chHeapAllocAligned.constprop.41>
 8007a5a:	4607      	mov	r7, r0
    chHeapFree(p1);
 8007a5c:	4630      	mov	r0, r6
 8007a5e:	f7ff feb7 	bl	80077d0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8007a62:	462a      	mov	r2, r5
 8007a64:	a901      	add	r1, sp, #4
 8007a66:	4860      	ldr	r0, [pc, #384]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007a68:	f7ff fe42 	bl	80076f0 <chHeapStatus>
 8007a6c:	f1a0 0802 	sub.w	r8, r0, #2
 8007a70:	f1d8 0000 	rsbs	r0, r8, #0
 8007a74:	4962      	ldr	r1, [pc, #392]	; (8007c00 <oslib_test_008_001_execute+0x320>)
 8007a76:	eb40 0008 	adc.w	r0, r0, r8
 8007a7a:	f7f9 f989 	bl	8000d90 <_test_assert>
 8007a7e:	4605      	mov	r5, r0
 8007a80:	2800      	cmp	r0, #0
 8007a82:	f47f af41 	bne.w	8007908 <oslib_test_008_001_execute+0x28>
 8007a86:	2110      	movs	r1, #16
 8007a88:	4857      	ldr	r0, [pc, #348]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007a8a:	f7fe fc21 	bl	80062d0 <chHeapAllocAligned.constprop.41>
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8007a8e:	462a      	mov	r2, r5
 8007a90:	4606      	mov	r6, r0
 8007a92:	a901      	add	r1, sp, #4
 8007a94:	4854      	ldr	r0, [pc, #336]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007a96:	f7ff fe2b 	bl	80076f0 <chHeapStatus>
 8007a9a:	2801      	cmp	r0, #1
 8007a9c:	f000 809f 	beq.w	8007bde <oslib_test_008_001_execute+0x2fe>
 8007aa0:	2200      	movs	r2, #0
 8007aa2:	a901      	add	r1, sp, #4
 8007aa4:	4850      	ldr	r0, [pc, #320]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007aa6:	f7ff fe23 	bl	80076f0 <chHeapStatus>
 8007aaa:	f1a0 0e02 	sub.w	lr, r0, #2
 8007aae:	f1de 0000 	rsbs	r0, lr, #0
 8007ab2:	eb40 000e 	adc.w	r0, r0, lr
 8007ab6:	494d      	ldr	r1, [pc, #308]	; (8007bec <oslib_test_008_001_execute+0x30c>)
 8007ab8:	f7f9 f96a 	bl	8000d90 <_test_assert>
 8007abc:	4605      	mov	r5, r0
 8007abe:	2800      	cmp	r0, #0
 8007ac0:	f47f af22 	bne.w	8007908 <oslib_test_008_001_execute+0x28>
    chHeapFree(p2);
 8007ac4:	4638      	mov	r0, r7
 8007ac6:	f7ff fe83 	bl	80077d0 <chHeapFree>
    chHeapFree(p1);
 8007aca:	4630      	mov	r0, r6
 8007acc:	f7ff fe80 	bl	80077d0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8007ad0:	462a      	mov	r2, r5
 8007ad2:	a901      	add	r1, sp, #4
 8007ad4:	4844      	ldr	r0, [pc, #272]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007ad6:	f7ff fe0b 	bl	80076f0 <chHeapStatus>
 8007ada:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 8007ade:	f1dc 0000 	rsbs	r0, ip, #0
 8007ae2:	4942      	ldr	r1, [pc, #264]	; (8007bec <oslib_test_008_001_execute+0x30c>)
 8007ae4:	eb40 000c 	adc.w	r0, r0, ip
 8007ae8:	f7f9 f952 	bl	8000d90 <_test_assert>
 8007aec:	4605      	mov	r5, r0
 8007aee:	2800      	cmp	r0, #0
 8007af0:	f47f af0a 	bne.w	8007908 <oslib_test_008_001_execute+0x28>
  test_set_step(8);
 8007af4:	2308      	movs	r3, #8
 8007af6:	2110      	movs	r1, #16
 8007af8:	483b      	ldr	r0, [pc, #236]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007afa:	6023      	str	r3, [r4, #0]
 8007afc:	f7fe fbe8 	bl	80062d0 <chHeapAllocAligned.constprop.41>
 8007b00:	2110      	movs	r1, #16
 8007b02:	4607      	mov	r7, r0
 8007b04:	4838      	ldr	r0, [pc, #224]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007b06:	f7fe fbe3 	bl	80062d0 <chHeapAllocAligned.constprop.41>
 8007b0a:	4606      	mov	r6, r0
    chHeapFree(p1);
 8007b0c:	4638      	mov	r0, r7
 8007b0e:	f7ff fe5f 	bl	80077d0 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8007b12:	462a      	mov	r2, r5
 8007b14:	a901      	add	r1, sp, #4
 8007b16:	4834      	ldr	r0, [pc, #208]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007b18:	f7ff fdea 	bl	80076f0 <chHeapStatus>
 8007b1c:	1e87      	subs	r7, r0, #2
 8007b1e:	4278      	negs	r0, r7
 8007b20:	4937      	ldr	r1, [pc, #220]	; (8007c00 <oslib_test_008_001_execute+0x320>)
 8007b22:	4178      	adcs	r0, r7
 8007b24:	f7f9 f934 	bl	8000d90 <_test_assert>
 8007b28:	4605      	mov	r5, r0
 8007b2a:	2800      	cmp	r0, #0
 8007b2c:	f47f aeec 	bne.w	8007908 <oslib_test_008_001_execute+0x28>
 8007b30:	2120      	movs	r1, #32
 8007b32:	482d      	ldr	r0, [pc, #180]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007b34:	f7fe fbcc 	bl	80062d0 <chHeapAllocAligned.constprop.41>
    chHeapFree(p1);
 8007b38:	f7ff fe4a 	bl	80077d0 <chHeapFree>
    chHeapFree(p2);
 8007b3c:	4630      	mov	r0, r6
 8007b3e:	f7ff fe47 	bl	80077d0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8007b42:	462a      	mov	r2, r5
 8007b44:	a901      	add	r1, sp, #4
 8007b46:	4828      	ldr	r0, [pc, #160]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007b48:	f7ff fdd2 	bl	80076f0 <chHeapStatus>
 8007b4c:	1e45      	subs	r5, r0, #1
 8007b4e:	4268      	negs	r0, r5
 8007b50:	4926      	ldr	r1, [pc, #152]	; (8007bec <oslib_test_008_001_execute+0x30c>)
 8007b52:	4168      	adcs	r0, r5
 8007b54:	f7f9 f91c 	bl	8000d90 <_test_assert>
 8007b58:	4602      	mov	r2, r0
 8007b5a:	2800      	cmp	r0, #0
 8007b5c:	f47f aed4 	bne.w	8007908 <oslib_test_008_001_execute+0x28>
  test_set_step(9);
 8007b60:	2309      	movs	r3, #9
    (void)chHeapStatus(&test_heap, &n, NULL);
 8007b62:	a901      	add	r1, sp, #4
 8007b64:	4820      	ldr	r0, [pc, #128]	; (8007be8 <oslib_test_008_001_execute+0x308>)
  test_set_step(9);
 8007b66:	6023      	str	r3, [r4, #0]
    (void)chHeapStatus(&test_heap, &n, NULL);
 8007b68:	f7ff fdc2 	bl	80076f0 <chHeapStatus>
 8007b6c:	9901      	ldr	r1, [sp, #4]
 8007b6e:	481e      	ldr	r0, [pc, #120]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007b70:	f7fe fbae 	bl	80062d0 <chHeapAllocAligned.constprop.41>
    test_assert(p1 != NULL, "allocation failed");
 8007b74:	4606      	mov	r6, r0
 8007b76:	3000      	adds	r0, #0
 8007b78:	491e      	ldr	r1, [pc, #120]	; (8007bf4 <oslib_test_008_001_execute+0x314>)
 8007b7a:	bf18      	it	ne
 8007b7c:	2001      	movne	r0, #1
 8007b7e:	f7f9 f907 	bl	8000d90 <_test_assert>
 8007b82:	4602      	mov	r2, r0
 8007b84:	2800      	cmp	r0, #0
 8007b86:	f47f aebf 	bne.w	8007908 <oslib_test_008_001_execute+0x28>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 8007b8a:	4601      	mov	r1, r0
 8007b8c:	4816      	ldr	r0, [pc, #88]	; (8007be8 <oslib_test_008_001_execute+0x308>)
 8007b8e:	f7ff fdaf 	bl	80076f0 <chHeapStatus>
 8007b92:	fab0 f080 	clz	r0, r0
 8007b96:	491b      	ldr	r1, [pc, #108]	; (8007c04 <oslib_test_008_001_execute+0x324>)
 8007b98:	0940      	lsrs	r0, r0, #5
 8007b9a:	f7f9 f8f9 	bl	8000d90 <_test_assert>
 8007b9e:	4605      	mov	r5, r0
 8007ba0:	2800      	cmp	r0, #0
 8007ba2:	f47f aeb1 	bne.w	8007908 <oslib_test_008_001_execute+0x28>
    chHeapFree(p1);
 8007ba6:	4630      	mov	r0, r6
 8007ba8:	f7ff fe12 	bl	80077d0 <chHeapFree>
  test_set_step(10);
 8007bac:	230a      	movs	r3, #10
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8007bae:	462a      	mov	r2, r5
 8007bb0:	a901      	add	r1, sp, #4
 8007bb2:	480d      	ldr	r0, [pc, #52]	; (8007be8 <oslib_test_008_001_execute+0x308>)
  test_set_step(10);
 8007bb4:	6023      	str	r3, [r4, #0]
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8007bb6:	f7ff fd9b 	bl	80076f0 <chHeapStatus>
 8007bba:	1e42      	subs	r2, r0, #1
 8007bbc:	4250      	negs	r0, r2
 8007bbe:	4150      	adcs	r0, r2
 8007bc0:	490a      	ldr	r1, [pc, #40]	; (8007bec <oslib_test_008_001_execute+0x30c>)
 8007bc2:	f7f9 f8e5 	bl	8000d90 <_test_assert>
 8007bc6:	2800      	cmp	r0, #0
 8007bc8:	f47f ae9e 	bne.w	8007908 <oslib_test_008_001_execute+0x28>
    test_assert(n == sz, "size changed");
 8007bcc:	e9dd 3000 	ldrd	r3, r0, [sp]
 8007bd0:	1ac3      	subs	r3, r0, r3
 8007bd2:	4258      	negs	r0, r3
 8007bd4:	490c      	ldr	r1, [pc, #48]	; (8007c08 <oslib_test_008_001_execute+0x328>)
 8007bd6:	4158      	adcs	r0, r3
 8007bd8:	f7f9 f8da 	bl	8000d90 <_test_assert>
 8007bdc:	e694      	b.n	8007908 <oslib_test_008_001_execute+0x28>
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8007bde:	2001      	movs	r0, #1
 8007be0:	e769      	b.n	8007ab6 <oslib_test_008_001_execute+0x1d6>
 8007be2:	bf00      	nop
 8007be4:	20001d94 	.word	0x20001d94
 8007be8:	20001cf4 	.word	0x20001cf4
 8007bec:	0800b40c 	.word	0x0800b40c
 8007bf0:	0800b48c 	.word	0x0800b48c
 8007bf4:	0800b478 	.word	0x0800b478
 8007bf8:	0800b41c 	.word	0x0800b41c
 8007bfc:	0800b430 	.word	0x0800b430
 8007c00:	0800b448 	.word	0x0800b448
 8007c04:	0800b17c 	.word	0x0800b17c
 8007c08:	0800b458 	.word	0x0800b458
 8007c0c:	00000000 	.word	0x00000000

08007c10 <dyn_release_object_heap.part.3>:
  dyn_element_t *prev = (dyn_element_t *)dlp;
 8007c10:	460a      	mov	r2, r1
 8007c12:	e002      	b.n	8007c1a <dyn_release_object_heap.part.3+0xa>
    if (prev->next == element) {
 8007c14:	4298      	cmp	r0, r3
 8007c16:	d006      	beq.n	8007c26 <dyn_release_object_heap.part.3+0x16>
 8007c18:	461a      	mov	r2, r3
  while (prev->next != (dyn_element_t *)dlp) {
 8007c1a:	6813      	ldr	r3, [r2, #0]
 8007c1c:	428b      	cmp	r3, r1
 8007c1e:	d1f9      	bne.n	8007c14 <dyn_release_object_heap.part.3+0x4>
  return NULL;
 8007c20:	2000      	movs	r0, #0
    chHeapFree((void *)dep);
 8007c22:	f7ff bdd5 	b.w	80077d0 <chHeapFree>
      prev->next = element->next;
 8007c26:	6803      	ldr	r3, [r0, #0]
 8007c28:	6013      	str	r3, [r2, #0]
    chHeapFree((void *)dep);
 8007c2a:	f7ff bdd1 	b.w	80077d0 <chHeapFree>
 8007c2e:	bf00      	nop

08007c30 <chFactoryReleasePipe>:
 *
 * @param[in] dpp       dynamic pipe object reference
 *
 * @api
 */
void chFactoryReleasePipe(dyn_pipe_t *dpp) {
 8007c30:	b510      	push	{r4, lr}
 8007c32:	4604      	mov	r4, r0

  F_LOCK();
 8007c34:	4807      	ldr	r0, [pc, #28]	; (8007c54 <chFactoryReleasePipe+0x24>)
 8007c36:	f7fc fe43 	bl	80048c0 <chMtxLock>
  dep->refs--;
 8007c3a:	6863      	ldr	r3, [r4, #4]
 8007c3c:	3b01      	subs	r3, #1
 8007c3e:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 8007c40:	b91b      	cbnz	r3, 8007c4a <chFactoryReleasePipe+0x1a>
 8007c42:	4620      	mov	r0, r4
 8007c44:	4904      	ldr	r1, [pc, #16]	; (8007c58 <chFactoryReleasePipe+0x28>)
 8007c46:	f7ff ffe3 	bl	8007c10 <dyn_release_object_heap.part.3>

  dyn_release_object_heap(&dpp->element, &ch_factory.pipe_list);

  F_UNLOCK();
}
 8007c4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  F_UNLOCK();
 8007c4e:	4801      	ldr	r0, [pc, #4]	; (8007c54 <chFactoryReleasePipe+0x24>)
 8007c50:	f7fe bb06 	b.w	8006260 <chMtxUnlock>
 8007c54:	200012cc 	.word	0x200012cc
 8007c58:	20001310 	.word	0x20001310
 8007c5c:	00000000 	.word	0x00000000

08007c60 <oslib_test_009_006_execute>:
      chFactoryReleasePipe(dpp);
    }
  }
}

static void oslib_test_009_006_execute(void) {
 8007c60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_pipe_t *dpp;

  /* [9.6.1] Retrieving a dynamic pipe by name, must not exist.*/
  test_set_step(1);
 8007c62:	2501      	movs	r5, #1
 8007c64:	4c41      	ldr	r4, [pc, #260]	; (8007d6c <oslib_test_009_006_execute+0x10c>)
 8007c66:	6025      	str	r5, [r4, #0]
  {
    dpp = chFactoryFindPipe("mypipe");
 8007c68:	f7fe feaa 	bl	80069c0 <chFactoryFindPipe.constprop.6>
    test_assert(dpp == NULL, "found");
 8007c6c:	fab0 f080 	clz	r0, r0
 8007c70:	493f      	ldr	r1, [pc, #252]	; (8007d70 <oslib_test_009_006_execute+0x110>)
 8007c72:	0940      	lsrs	r0, r0, #5
 8007c74:	f7f9 f88c 	bl	8000d90 <_test_assert>
 8007c78:	b100      	cbz	r0, 8007c7c <oslib_test_009_006_execute+0x1c>
  {
    dpp = chFactoryFindPipe("mypipe");
    test_assert(dpp == NULL, "found");
  }
  test_end_step(6);
}
 8007c7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 8007c7c:	2302      	movs	r3, #2
 8007c7e:	6023      	str	r3, [r4, #0]
    dpp = chFactoryCreatePipe("mypipe", 16U);
 8007c80:	f7fe fe66 	bl	8006950 <chFactoryCreatePipe.constprop.7>
    test_assert(dpp != NULL, "cannot create");
 8007c84:	4606      	mov	r6, r0
 8007c86:	3000      	adds	r0, #0
 8007c88:	bf18      	it	ne
 8007c8a:	2001      	movne	r0, #1
 8007c8c:	4939      	ldr	r1, [pc, #228]	; (8007d74 <oslib_test_009_006_execute+0x114>)
 8007c8e:	f7f9 f87f 	bl	8000d90 <_test_assert>
 8007c92:	2800      	cmp	r0, #0
 8007c94:	d1f1      	bne.n	8007c7a <oslib_test_009_006_execute+0x1a>
  test_set_step(3);
 8007c96:	2303      	movs	r3, #3
 8007c98:	6023      	str	r3, [r4, #0]
    dpp1 = chFactoryCreatePipe("mypipe", 16U);
 8007c9a:	f7fe fe59 	bl	8006950 <chFactoryCreatePipe.constprop.7>
    test_assert(dpp1 == NULL, "can create");
 8007c9e:	fab0 f080 	clz	r0, r0
 8007ca2:	4935      	ldr	r1, [pc, #212]	; (8007d78 <oslib_test_009_006_execute+0x118>)
 8007ca4:	0940      	lsrs	r0, r0, #5
 8007ca6:	f7f9 f873 	bl	8000d90 <_test_assert>
 8007caa:	2800      	cmp	r0, #0
 8007cac:	d1e5      	bne.n	8007c7a <oslib_test_009_006_execute+0x1a>
  test_set_step(4);
 8007cae:	2304      	movs	r3, #4
 8007cb0:	6023      	str	r3, [r4, #0]
    dpp1 = chFactoryFindPipe("mypipe");
 8007cb2:	f7fe fe85 	bl	80069c0 <chFactoryFindPipe.constprop.6>
    test_assert(dpp1 != NULL, "not found");
 8007cb6:	4607      	mov	r7, r0
 8007cb8:	3000      	adds	r0, #0
 8007cba:	bf18      	it	ne
 8007cbc:	2001      	movne	r0, #1
 8007cbe:	492f      	ldr	r1, [pc, #188]	; (8007d7c <oslib_test_009_006_execute+0x11c>)
 8007cc0:	f7f9 f866 	bl	8000d90 <_test_assert>
 8007cc4:	2800      	cmp	r0, #0
 8007cc6:	d1d8      	bne.n	8007c7a <oslib_test_009_006_execute+0x1a>
    test_assert(dpp == dpp1, "object reference mismatch");
 8007cc8:	1bf0      	subs	r0, r6, r7
 8007cca:	fab0 f080 	clz	r0, r0
 8007cce:	492c      	ldr	r1, [pc, #176]	; (8007d80 <oslib_test_009_006_execute+0x120>)
 8007cd0:	0940      	lsrs	r0, r0, #5
 8007cd2:	f7f9 f85d 	bl	8000d90 <_test_assert>
 8007cd6:	2800      	cmp	r0, #0
 8007cd8:	d1cf      	bne.n	8007c7a <oslib_test_009_006_execute+0x1a>
    test_assert(dpp1->element.refs == 2, "object reference mismatch");
 8007cda:	6878      	ldr	r0, [r7, #4]
 8007cdc:	4928      	ldr	r1, [pc, #160]	; (8007d80 <oslib_test_009_006_execute+0x120>)
 8007cde:	f1a0 0002 	sub.w	r0, r0, #2
 8007ce2:	fab0 f080 	clz	r0, r0
 8007ce6:	0940      	lsrs	r0, r0, #5
 8007ce8:	f7f9 f852 	bl	8000d90 <_test_assert>
 8007cec:	2800      	cmp	r0, #0
 8007cee:	d1c4      	bne.n	8007c7a <oslib_test_009_006_execute+0x1a>
 8007cf0:	687b      	ldr	r3, [r7, #4]
    test_assert(dpp1 == dpp2, "object reference mismatch");
 8007cf2:	4628      	mov	r0, r5
 8007cf4:	442b      	add	r3, r5
 8007cf6:	607b      	str	r3, [r7, #4]
 8007cf8:	4921      	ldr	r1, [pc, #132]	; (8007d80 <oslib_test_009_006_execute+0x120>)
 8007cfa:	f7f9 f849 	bl	8000d90 <_test_assert>
 8007cfe:	2800      	cmp	r0, #0
 8007d00:	d1bb      	bne.n	8007c7a <oslib_test_009_006_execute+0x1a>
    test_assert(dpp2->element.refs == 3, "object reference mismatch");
 8007d02:	6878      	ldr	r0, [r7, #4]
 8007d04:	491e      	ldr	r1, [pc, #120]	; (8007d80 <oslib_test_009_006_execute+0x120>)
 8007d06:	f1a0 0c03 	sub.w	ip, r0, #3
 8007d0a:	f1dc 0000 	rsbs	r0, ip, #0
 8007d0e:	eb40 000c 	adc.w	r0, r0, ip
 8007d12:	f7f9 f83d 	bl	8000d90 <_test_assert>
 8007d16:	2800      	cmp	r0, #0
 8007d18:	d1af      	bne.n	8007c7a <oslib_test_009_006_execute+0x1a>
    chFactoryReleasePipe(dpp2);
 8007d1a:	4638      	mov	r0, r7
 8007d1c:	f7ff ff88 	bl	8007c30 <chFactoryReleasePipe>
    test_assert(dpp1->element.refs == 2, "references mismatch");
 8007d20:	6878      	ldr	r0, [r7, #4]
 8007d22:	4918      	ldr	r1, [pc, #96]	; (8007d84 <oslib_test_009_006_execute+0x124>)
 8007d24:	1e82      	subs	r2, r0, #2
 8007d26:	4250      	negs	r0, r2
 8007d28:	4150      	adcs	r0, r2
 8007d2a:	f7f9 f831 	bl	8000d90 <_test_assert>
 8007d2e:	2800      	cmp	r0, #0
 8007d30:	d1a3      	bne.n	8007c7a <oslib_test_009_006_execute+0x1a>
    chFactoryReleasePipe(dpp1);
 8007d32:	4638      	mov	r0, r7
 8007d34:	f7ff ff7c 	bl	8007c30 <chFactoryReleasePipe>
    test_assert(dpp->element.refs == 1, "references mismatch");
 8007d38:	6870      	ldr	r0, [r6, #4]
 8007d3a:	4912      	ldr	r1, [pc, #72]	; (8007d84 <oslib_test_009_006_execute+0x124>)
 8007d3c:	1b43      	subs	r3, r0, r5
 8007d3e:	4258      	negs	r0, r3
 8007d40:	4158      	adcs	r0, r3
 8007d42:	f7f9 f825 	bl	8000d90 <_test_assert>
 8007d46:	2800      	cmp	r0, #0
 8007d48:	d197      	bne.n	8007c7a <oslib_test_009_006_execute+0x1a>
  test_set_step(5);
 8007d4a:	2305      	movs	r3, #5
    chFactoryReleasePipe(dpp);
 8007d4c:	4630      	mov	r0, r6
  test_set_step(5);
 8007d4e:	6023      	str	r3, [r4, #0]
    chFactoryReleasePipe(dpp);
 8007d50:	f7ff ff6e 	bl	8007c30 <chFactoryReleasePipe>
  test_set_step(6);
 8007d54:	2306      	movs	r3, #6
 8007d56:	6023      	str	r3, [r4, #0]
    dpp = chFactoryFindPipe("mypipe");
 8007d58:	f7fe fe32 	bl	80069c0 <chFactoryFindPipe.constprop.6>
}
 8007d5c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dpp == NULL, "found");
 8007d60:	fab0 f080 	clz	r0, r0
 8007d64:	4902      	ldr	r1, [pc, #8]	; (8007d70 <oslib_test_009_006_execute+0x110>)
 8007d66:	0940      	lsrs	r0, r0, #5
 8007d68:	f7f9 b812 	b.w	8000d90 <_test_assert>
 8007d6c:	20001d94 	.word	0x20001d94
 8007d70:	0800b524 	.word	0x0800b524
 8007d74:	0800b504 	.word	0x0800b504
 8007d78:	0800b514 	.word	0x0800b514
 8007d7c:	0800b520 	.word	0x0800b520
 8007d80:	0800b52c 	.word	0x0800b52c
 8007d84:	0800b548 	.word	0x0800b548
	...

08007d90 <oslib_test_009_006_teardown>:
static void oslib_test_009_006_teardown(void) {
 8007d90:	b510      	push	{r4, lr}
  dpp = chFactoryFindPipe("mypipe");
 8007d92:	f7fe fe15 	bl	80069c0 <chFactoryFindPipe.constprop.6>
  if (dpp != NULL) {
 8007d96:	b140      	cbz	r0, 8007daa <oslib_test_009_006_teardown+0x1a>
    while (dpp->element.refs > 0U) {
 8007d98:	6843      	ldr	r3, [r0, #4]
 8007d9a:	4604      	mov	r4, r0
 8007d9c:	b12b      	cbz	r3, 8007daa <oslib_test_009_006_teardown+0x1a>
      chFactoryReleasePipe(dpp);
 8007d9e:	4620      	mov	r0, r4
 8007da0:	f7ff ff46 	bl	8007c30 <chFactoryReleasePipe>
    while (dpp->element.refs > 0U) {
 8007da4:	6863      	ldr	r3, [r4, #4]
 8007da6:	2b00      	cmp	r3, #0
 8007da8:	d1f9      	bne.n	8007d9e <oslib_test_009_006_teardown+0xe>
}
 8007daa:	bd10      	pop	{r4, pc}
 8007dac:	0000      	movs	r0, r0
	...

08007db0 <chFactoryReleaseObjectsFIFO>:
void chFactoryReleaseObjectsFIFO(dyn_objects_fifo_t *dofp) {
 8007db0:	b510      	push	{r4, lr}
 8007db2:	4604      	mov	r4, r0
  F_LOCK();
 8007db4:	4807      	ldr	r0, [pc, #28]	; (8007dd4 <chFactoryReleaseObjectsFIFO+0x24>)
 8007db6:	f7fc fd83 	bl	80048c0 <chMtxLock>
  dep->refs--;
 8007dba:	6863      	ldr	r3, [r4, #4]
 8007dbc:	3b01      	subs	r3, #1
 8007dbe:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 8007dc0:	b91b      	cbnz	r3, 8007dca <chFactoryReleaseObjectsFIFO+0x1a>
 8007dc2:	4620      	mov	r0, r4
 8007dc4:	4904      	ldr	r1, [pc, #16]	; (8007dd8 <chFactoryReleaseObjectsFIFO+0x28>)
 8007dc6:	f7ff ff23 	bl	8007c10 <dyn_release_object_heap.part.3>
}
 8007dca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  F_UNLOCK();
 8007dce:	4801      	ldr	r0, [pc, #4]	; (8007dd4 <chFactoryReleaseObjectsFIFO+0x24>)
 8007dd0:	f7fe ba46 	b.w	8006260 <chMtxUnlock>
 8007dd4:	200012cc 	.word	0x200012cc
 8007dd8:	2000130c 	.word	0x2000130c
 8007ddc:	00000000 	.word	0x00000000

08007de0 <oslib_test_009_005_execute>:
static void oslib_test_009_005_execute(void) {
 8007de0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 8007de2:	2501      	movs	r5, #1
 8007de4:	4c41      	ldr	r4, [pc, #260]	; (8007eec <oslib_test_009_005_execute+0x10c>)
 8007de6:	6025      	str	r5, [r4, #0]
    dofp = chFactoryFindObjectsFIFO("myfifo");
 8007de8:	f7fe fd9a 	bl	8006920 <chFactoryFindObjectsFIFO.constprop.8>
    test_assert(dofp == NULL, "found");
 8007dec:	fab0 f080 	clz	r0, r0
 8007df0:	493f      	ldr	r1, [pc, #252]	; (8007ef0 <oslib_test_009_005_execute+0x110>)
 8007df2:	0940      	lsrs	r0, r0, #5
 8007df4:	f7f8 ffcc 	bl	8000d90 <_test_assert>
 8007df8:	b100      	cbz	r0, 8007dfc <oslib_test_009_005_execute+0x1c>
}
 8007dfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 8007dfc:	2302      	movs	r3, #2
 8007dfe:	6023      	str	r3, [r4, #0]
    dofp = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 8007e00:	f7fe fd56 	bl	80068b0 <chFactoryCreateObjectsFIFO.constprop.9>
    test_assert(dofp != NULL, "cannot create");
 8007e04:	4606      	mov	r6, r0
 8007e06:	3000      	adds	r0, #0
 8007e08:	bf18      	it	ne
 8007e0a:	2001      	movne	r0, #1
 8007e0c:	4939      	ldr	r1, [pc, #228]	; (8007ef4 <oslib_test_009_005_execute+0x114>)
 8007e0e:	f7f8 ffbf 	bl	8000d90 <_test_assert>
 8007e12:	2800      	cmp	r0, #0
 8007e14:	d1f1      	bne.n	8007dfa <oslib_test_009_005_execute+0x1a>
  test_set_step(3);
 8007e16:	2303      	movs	r3, #3
 8007e18:	6023      	str	r3, [r4, #0]
    dofp1 = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 8007e1a:	f7fe fd49 	bl	80068b0 <chFactoryCreateObjectsFIFO.constprop.9>
    test_assert(dofp1 == NULL, "can create");
 8007e1e:	fab0 f080 	clz	r0, r0
 8007e22:	4935      	ldr	r1, [pc, #212]	; (8007ef8 <oslib_test_009_005_execute+0x118>)
 8007e24:	0940      	lsrs	r0, r0, #5
 8007e26:	f7f8 ffb3 	bl	8000d90 <_test_assert>
 8007e2a:	2800      	cmp	r0, #0
 8007e2c:	d1e5      	bne.n	8007dfa <oslib_test_009_005_execute+0x1a>
  test_set_step(4);
 8007e2e:	2304      	movs	r3, #4
 8007e30:	6023      	str	r3, [r4, #0]
    dofp1 = chFactoryFindObjectsFIFO("myfifo");
 8007e32:	f7fe fd75 	bl	8006920 <chFactoryFindObjectsFIFO.constprop.8>
    test_assert(dofp1 != NULL, "not found");
 8007e36:	4607      	mov	r7, r0
 8007e38:	3000      	adds	r0, #0
 8007e3a:	bf18      	it	ne
 8007e3c:	2001      	movne	r0, #1
 8007e3e:	492f      	ldr	r1, [pc, #188]	; (8007efc <oslib_test_009_005_execute+0x11c>)
 8007e40:	f7f8 ffa6 	bl	8000d90 <_test_assert>
 8007e44:	2800      	cmp	r0, #0
 8007e46:	d1d8      	bne.n	8007dfa <oslib_test_009_005_execute+0x1a>
    test_assert(dofp == dofp1, "object reference mismatch");
 8007e48:	1bf0      	subs	r0, r6, r7
 8007e4a:	fab0 f080 	clz	r0, r0
 8007e4e:	492c      	ldr	r1, [pc, #176]	; (8007f00 <oslib_test_009_005_execute+0x120>)
 8007e50:	0940      	lsrs	r0, r0, #5
 8007e52:	f7f8 ff9d 	bl	8000d90 <_test_assert>
 8007e56:	2800      	cmp	r0, #0
 8007e58:	d1cf      	bne.n	8007dfa <oslib_test_009_005_execute+0x1a>
    test_assert(dofp1->element.refs == 2, "object reference mismatch");
 8007e5a:	6878      	ldr	r0, [r7, #4]
 8007e5c:	4928      	ldr	r1, [pc, #160]	; (8007f00 <oslib_test_009_005_execute+0x120>)
 8007e5e:	f1a0 0002 	sub.w	r0, r0, #2
 8007e62:	fab0 f080 	clz	r0, r0
 8007e66:	0940      	lsrs	r0, r0, #5
 8007e68:	f7f8 ff92 	bl	8000d90 <_test_assert>
 8007e6c:	2800      	cmp	r0, #0
 8007e6e:	d1c4      	bne.n	8007dfa <oslib_test_009_005_execute+0x1a>
 8007e70:	687b      	ldr	r3, [r7, #4]
    test_assert(dofp1 == dofp2, "object reference mismatch");
 8007e72:	4628      	mov	r0, r5
 8007e74:	442b      	add	r3, r5
 8007e76:	607b      	str	r3, [r7, #4]
 8007e78:	4921      	ldr	r1, [pc, #132]	; (8007f00 <oslib_test_009_005_execute+0x120>)
 8007e7a:	f7f8 ff89 	bl	8000d90 <_test_assert>
 8007e7e:	2800      	cmp	r0, #0
 8007e80:	d1bb      	bne.n	8007dfa <oslib_test_009_005_execute+0x1a>
    test_assert(dofp2->element.refs == 3, "object reference mismatch");
 8007e82:	6878      	ldr	r0, [r7, #4]
 8007e84:	491e      	ldr	r1, [pc, #120]	; (8007f00 <oslib_test_009_005_execute+0x120>)
 8007e86:	f1a0 0c03 	sub.w	ip, r0, #3
 8007e8a:	f1dc 0000 	rsbs	r0, ip, #0
 8007e8e:	eb40 000c 	adc.w	r0, r0, ip
 8007e92:	f7f8 ff7d 	bl	8000d90 <_test_assert>
 8007e96:	2800      	cmp	r0, #0
 8007e98:	d1af      	bne.n	8007dfa <oslib_test_009_005_execute+0x1a>
    chFactoryReleaseObjectsFIFO(dofp2);
 8007e9a:	4638      	mov	r0, r7
 8007e9c:	f7ff ff88 	bl	8007db0 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp1->element.refs == 2, "references mismatch");
 8007ea0:	6878      	ldr	r0, [r7, #4]
 8007ea2:	4918      	ldr	r1, [pc, #96]	; (8007f04 <oslib_test_009_005_execute+0x124>)
 8007ea4:	1e82      	subs	r2, r0, #2
 8007ea6:	4250      	negs	r0, r2
 8007ea8:	4150      	adcs	r0, r2
 8007eaa:	f7f8 ff71 	bl	8000d90 <_test_assert>
 8007eae:	2800      	cmp	r0, #0
 8007eb0:	d1a3      	bne.n	8007dfa <oslib_test_009_005_execute+0x1a>
    chFactoryReleaseObjectsFIFO(dofp1);
 8007eb2:	4638      	mov	r0, r7
 8007eb4:	f7ff ff7c 	bl	8007db0 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp->element.refs == 1, "references mismatch");
 8007eb8:	6870      	ldr	r0, [r6, #4]
 8007eba:	4912      	ldr	r1, [pc, #72]	; (8007f04 <oslib_test_009_005_execute+0x124>)
 8007ebc:	1b43      	subs	r3, r0, r5
 8007ebe:	4258      	negs	r0, r3
 8007ec0:	4158      	adcs	r0, r3
 8007ec2:	f7f8 ff65 	bl	8000d90 <_test_assert>
 8007ec6:	2800      	cmp	r0, #0
 8007ec8:	d197      	bne.n	8007dfa <oslib_test_009_005_execute+0x1a>
  test_set_step(5);
 8007eca:	2305      	movs	r3, #5
    chFactoryReleaseObjectsFIFO(dofp);
 8007ecc:	4630      	mov	r0, r6
  test_set_step(5);
 8007ece:	6023      	str	r3, [r4, #0]
    chFactoryReleaseObjectsFIFO(dofp);
 8007ed0:	f7ff ff6e 	bl	8007db0 <chFactoryReleaseObjectsFIFO>
  test_set_step(6);
 8007ed4:	2306      	movs	r3, #6
 8007ed6:	6023      	str	r3, [r4, #0]
    dofp = chFactoryFindObjectsFIFO("myfifo");
 8007ed8:	f7fe fd22 	bl	8006920 <chFactoryFindObjectsFIFO.constprop.8>
}
 8007edc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dofp == NULL, "found");
 8007ee0:	fab0 f080 	clz	r0, r0
 8007ee4:	4902      	ldr	r1, [pc, #8]	; (8007ef0 <oslib_test_009_005_execute+0x110>)
 8007ee6:	0940      	lsrs	r0, r0, #5
 8007ee8:	f7f8 bf52 	b.w	8000d90 <_test_assert>
 8007eec:	20001d94 	.word	0x20001d94
 8007ef0:	0800b524 	.word	0x0800b524
 8007ef4:	0800b504 	.word	0x0800b504
 8007ef8:	0800b514 	.word	0x0800b514
 8007efc:	0800b520 	.word	0x0800b520
 8007f00:	0800b52c 	.word	0x0800b52c
 8007f04:	0800b548 	.word	0x0800b548
	...

08007f10 <oslib_test_009_005_teardown>:
static void oslib_test_009_005_teardown(void) {
 8007f10:	b510      	push	{r4, lr}
  dofp = chFactoryFindObjectsFIFO("myfifo");
 8007f12:	f7fe fd05 	bl	8006920 <chFactoryFindObjectsFIFO.constprop.8>
  if (dofp != NULL) {
 8007f16:	b140      	cbz	r0, 8007f2a <oslib_test_009_005_teardown+0x1a>
    while (dofp->element.refs > 0U) {
 8007f18:	6843      	ldr	r3, [r0, #4]
 8007f1a:	4604      	mov	r4, r0
 8007f1c:	b12b      	cbz	r3, 8007f2a <oslib_test_009_005_teardown+0x1a>
      chFactoryReleaseObjectsFIFO(dofp);
 8007f1e:	4620      	mov	r0, r4
 8007f20:	f7ff ff46 	bl	8007db0 <chFactoryReleaseObjectsFIFO>
    while (dofp->element.refs > 0U) {
 8007f24:	6863      	ldr	r3, [r4, #4]
 8007f26:	2b00      	cmp	r3, #0
 8007f28:	d1f9      	bne.n	8007f1e <oslib_test_009_005_teardown+0xe>
}
 8007f2a:	bd10      	pop	{r4, pc}
 8007f2c:	0000      	movs	r0, r0
	...

08007f30 <chFactoryReleaseMailbox>:
void chFactoryReleaseMailbox(dyn_mailbox_t *dmp) {
 8007f30:	b510      	push	{r4, lr}
 8007f32:	4604      	mov	r4, r0
  F_LOCK();
 8007f34:	4807      	ldr	r0, [pc, #28]	; (8007f54 <chFactoryReleaseMailbox+0x24>)
 8007f36:	f7fc fcc3 	bl	80048c0 <chMtxLock>
  dep->refs--;
 8007f3a:	6863      	ldr	r3, [r4, #4]
 8007f3c:	3b01      	subs	r3, #1
 8007f3e:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 8007f40:	b91b      	cbnz	r3, 8007f4a <chFactoryReleaseMailbox+0x1a>
 8007f42:	4620      	mov	r0, r4
 8007f44:	4904      	ldr	r1, [pc, #16]	; (8007f58 <chFactoryReleaseMailbox+0x28>)
 8007f46:	f7ff fe63 	bl	8007c10 <dyn_release_object_heap.part.3>
}
 8007f4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  F_UNLOCK();
 8007f4e:	4801      	ldr	r0, [pc, #4]	; (8007f54 <chFactoryReleaseMailbox+0x24>)
 8007f50:	f7fe b986 	b.w	8006260 <chMtxUnlock>
 8007f54:	200012cc 	.word	0x200012cc
 8007f58:	20001308 	.word	0x20001308
 8007f5c:	00000000 	.word	0x00000000

08007f60 <oslib_test_009_004_execute>:
static void oslib_test_009_004_execute(void) {
 8007f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 8007f62:	2501      	movs	r5, #1
 8007f64:	4c41      	ldr	r4, [pc, #260]	; (800806c <oslib_test_009_004_execute+0x10c>)
 8007f66:	6025      	str	r5, [r4, #0]
    dmp = chFactoryFindMailbox("mymbx");
 8007f68:	f7fe fc8a 	bl	8006880 <chFactoryFindMailbox.constprop.10>
    test_assert(dmp == NULL, "found");
 8007f6c:	fab0 f080 	clz	r0, r0
 8007f70:	493f      	ldr	r1, [pc, #252]	; (8008070 <oslib_test_009_004_execute+0x110>)
 8007f72:	0940      	lsrs	r0, r0, #5
 8007f74:	f7f8 ff0c 	bl	8000d90 <_test_assert>
 8007f78:	b100      	cbz	r0, 8007f7c <oslib_test_009_004_execute+0x1c>
}
 8007f7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 8007f7c:	2302      	movs	r3, #2
 8007f7e:	6023      	str	r3, [r4, #0]
    dmp = chFactoryCreateMailbox("mymbx", 16U);
 8007f80:	f7fe fc4e 	bl	8006820 <chFactoryCreateMailbox.constprop.11>
    test_assert(dmp != NULL, "cannot create");
 8007f84:	4606      	mov	r6, r0
 8007f86:	3000      	adds	r0, #0
 8007f88:	bf18      	it	ne
 8007f8a:	2001      	movne	r0, #1
 8007f8c:	4939      	ldr	r1, [pc, #228]	; (8008074 <oslib_test_009_004_execute+0x114>)
 8007f8e:	f7f8 feff 	bl	8000d90 <_test_assert>
 8007f92:	2800      	cmp	r0, #0
 8007f94:	d1f1      	bne.n	8007f7a <oslib_test_009_004_execute+0x1a>
  test_set_step(3);
 8007f96:	2303      	movs	r3, #3
 8007f98:	6023      	str	r3, [r4, #0]
    dmp1 = chFactoryCreateMailbox("mymbx", 16U);
 8007f9a:	f7fe fc41 	bl	8006820 <chFactoryCreateMailbox.constprop.11>
    test_assert(dmp1 == NULL, "can create");
 8007f9e:	fab0 f080 	clz	r0, r0
 8007fa2:	4935      	ldr	r1, [pc, #212]	; (8008078 <oslib_test_009_004_execute+0x118>)
 8007fa4:	0940      	lsrs	r0, r0, #5
 8007fa6:	f7f8 fef3 	bl	8000d90 <_test_assert>
 8007faa:	2800      	cmp	r0, #0
 8007fac:	d1e5      	bne.n	8007f7a <oslib_test_009_004_execute+0x1a>
  test_set_step(4);
 8007fae:	2304      	movs	r3, #4
 8007fb0:	6023      	str	r3, [r4, #0]
    dmp1 = chFactoryFindMailbox("mymbx");
 8007fb2:	f7fe fc65 	bl	8006880 <chFactoryFindMailbox.constprop.10>
    test_assert(dmp1 != NULL, "not found");
 8007fb6:	4607      	mov	r7, r0
 8007fb8:	3000      	adds	r0, #0
 8007fba:	bf18      	it	ne
 8007fbc:	2001      	movne	r0, #1
 8007fbe:	492f      	ldr	r1, [pc, #188]	; (800807c <oslib_test_009_004_execute+0x11c>)
 8007fc0:	f7f8 fee6 	bl	8000d90 <_test_assert>
 8007fc4:	2800      	cmp	r0, #0
 8007fc6:	d1d8      	bne.n	8007f7a <oslib_test_009_004_execute+0x1a>
    test_assert(dmp == dmp1, "object reference mismatch");
 8007fc8:	1bf0      	subs	r0, r6, r7
 8007fca:	fab0 f080 	clz	r0, r0
 8007fce:	492c      	ldr	r1, [pc, #176]	; (8008080 <oslib_test_009_004_execute+0x120>)
 8007fd0:	0940      	lsrs	r0, r0, #5
 8007fd2:	f7f8 fedd 	bl	8000d90 <_test_assert>
 8007fd6:	2800      	cmp	r0, #0
 8007fd8:	d1cf      	bne.n	8007f7a <oslib_test_009_004_execute+0x1a>
    test_assert(dmp1->element.refs == 2, "object reference mismatch");
 8007fda:	6878      	ldr	r0, [r7, #4]
 8007fdc:	4928      	ldr	r1, [pc, #160]	; (8008080 <oslib_test_009_004_execute+0x120>)
 8007fde:	f1a0 0002 	sub.w	r0, r0, #2
 8007fe2:	fab0 f080 	clz	r0, r0
 8007fe6:	0940      	lsrs	r0, r0, #5
 8007fe8:	f7f8 fed2 	bl	8000d90 <_test_assert>
 8007fec:	2800      	cmp	r0, #0
 8007fee:	d1c4      	bne.n	8007f7a <oslib_test_009_004_execute+0x1a>
 8007ff0:	687b      	ldr	r3, [r7, #4]
    test_assert(dmp1 == dmp2, "object reference mismatch");
 8007ff2:	4628      	mov	r0, r5
 8007ff4:	442b      	add	r3, r5
 8007ff6:	607b      	str	r3, [r7, #4]
 8007ff8:	4921      	ldr	r1, [pc, #132]	; (8008080 <oslib_test_009_004_execute+0x120>)
 8007ffa:	f7f8 fec9 	bl	8000d90 <_test_assert>
 8007ffe:	2800      	cmp	r0, #0
 8008000:	d1bb      	bne.n	8007f7a <oslib_test_009_004_execute+0x1a>
    test_assert(dmp2->element.refs == 3, "object reference mismatch");
 8008002:	6878      	ldr	r0, [r7, #4]
 8008004:	491e      	ldr	r1, [pc, #120]	; (8008080 <oslib_test_009_004_execute+0x120>)
 8008006:	f1a0 0c03 	sub.w	ip, r0, #3
 800800a:	f1dc 0000 	rsbs	r0, ip, #0
 800800e:	eb40 000c 	adc.w	r0, r0, ip
 8008012:	f7f8 febd 	bl	8000d90 <_test_assert>
 8008016:	2800      	cmp	r0, #0
 8008018:	d1af      	bne.n	8007f7a <oslib_test_009_004_execute+0x1a>
    chFactoryReleaseMailbox(dmp2);
 800801a:	4638      	mov	r0, r7
 800801c:	f7ff ff88 	bl	8007f30 <chFactoryReleaseMailbox>
    test_assert(dmp1->element.refs == 2, "references mismatch");
 8008020:	6878      	ldr	r0, [r7, #4]
 8008022:	4918      	ldr	r1, [pc, #96]	; (8008084 <oslib_test_009_004_execute+0x124>)
 8008024:	1e82      	subs	r2, r0, #2
 8008026:	4250      	negs	r0, r2
 8008028:	4150      	adcs	r0, r2
 800802a:	f7f8 feb1 	bl	8000d90 <_test_assert>
 800802e:	2800      	cmp	r0, #0
 8008030:	d1a3      	bne.n	8007f7a <oslib_test_009_004_execute+0x1a>
    chFactoryReleaseMailbox(dmp1);
 8008032:	4638      	mov	r0, r7
 8008034:	f7ff ff7c 	bl	8007f30 <chFactoryReleaseMailbox>
    test_assert(dmp->element.refs == 1, "references mismatch");
 8008038:	6870      	ldr	r0, [r6, #4]
 800803a:	4912      	ldr	r1, [pc, #72]	; (8008084 <oslib_test_009_004_execute+0x124>)
 800803c:	1b43      	subs	r3, r0, r5
 800803e:	4258      	negs	r0, r3
 8008040:	4158      	adcs	r0, r3
 8008042:	f7f8 fea5 	bl	8000d90 <_test_assert>
 8008046:	2800      	cmp	r0, #0
 8008048:	d197      	bne.n	8007f7a <oslib_test_009_004_execute+0x1a>
  test_set_step(5);
 800804a:	2305      	movs	r3, #5
    chFactoryReleaseMailbox(dmp);
 800804c:	4630      	mov	r0, r6
  test_set_step(5);
 800804e:	6023      	str	r3, [r4, #0]
    chFactoryReleaseMailbox(dmp);
 8008050:	f7ff ff6e 	bl	8007f30 <chFactoryReleaseMailbox>
  test_set_step(6);
 8008054:	2306      	movs	r3, #6
 8008056:	6023      	str	r3, [r4, #0]
    dmp = chFactoryFindMailbox("mymbx");
 8008058:	f7fe fc12 	bl	8006880 <chFactoryFindMailbox.constprop.10>
}
 800805c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dmp == NULL, "found");
 8008060:	fab0 f080 	clz	r0, r0
 8008064:	4902      	ldr	r1, [pc, #8]	; (8008070 <oslib_test_009_004_execute+0x110>)
 8008066:	0940      	lsrs	r0, r0, #5
 8008068:	f7f8 be92 	b.w	8000d90 <_test_assert>
 800806c:	20001d94 	.word	0x20001d94
 8008070:	0800b524 	.word	0x0800b524
 8008074:	0800b504 	.word	0x0800b504
 8008078:	0800b514 	.word	0x0800b514
 800807c:	0800b520 	.word	0x0800b520
 8008080:	0800b52c 	.word	0x0800b52c
 8008084:	0800b548 	.word	0x0800b548
	...

08008090 <oslib_test_009_004_teardown>:
static void oslib_test_009_004_teardown(void) {
 8008090:	b510      	push	{r4, lr}
  dmp = chFactoryFindMailbox("mymbx");
 8008092:	f7fe fbf5 	bl	8006880 <chFactoryFindMailbox.constprop.10>
  if (dmp != NULL) {
 8008096:	b140      	cbz	r0, 80080aa <oslib_test_009_004_teardown+0x1a>
    while (dmp->element.refs > 0U) {
 8008098:	6843      	ldr	r3, [r0, #4]
 800809a:	4604      	mov	r4, r0
 800809c:	b12b      	cbz	r3, 80080aa <oslib_test_009_004_teardown+0x1a>
      chFactoryReleaseMailbox(dmp);
 800809e:	4620      	mov	r0, r4
 80080a0:	f7ff ff46 	bl	8007f30 <chFactoryReleaseMailbox>
    while (dmp->element.refs > 0U) {
 80080a4:	6863      	ldr	r3, [r4, #4]
 80080a6:	2b00      	cmp	r3, #0
 80080a8:	d1f9      	bne.n	800809e <oslib_test_009_004_teardown+0xe>
}
 80080aa:	bd10      	pop	{r4, pc}
 80080ac:	0000      	movs	r0, r0
	...

080080b0 <chFactoryReleaseBuffer>:
void chFactoryReleaseBuffer(dyn_buffer_t *dbp) {
 80080b0:	b510      	push	{r4, lr}
 80080b2:	4604      	mov	r4, r0
  F_LOCK();
 80080b4:	4807      	ldr	r0, [pc, #28]	; (80080d4 <chFactoryReleaseBuffer+0x24>)
 80080b6:	f7fc fc03 	bl	80048c0 <chMtxLock>
  dep->refs--;
 80080ba:	6863      	ldr	r3, [r4, #4]
 80080bc:	3b01      	subs	r3, #1
 80080be:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 80080c0:	b91b      	cbnz	r3, 80080ca <chFactoryReleaseBuffer+0x1a>
 80080c2:	4620      	mov	r0, r4
 80080c4:	4904      	ldr	r1, [pc, #16]	; (80080d8 <chFactoryReleaseBuffer+0x28>)
 80080c6:	f7ff fda3 	bl	8007c10 <dyn_release_object_heap.part.3>
}
 80080ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  F_UNLOCK();
 80080ce:	4801      	ldr	r0, [pc, #4]	; (80080d4 <chFactoryReleaseBuffer+0x24>)
 80080d0:	f7fe b8c6 	b.w	8006260 <chMtxUnlock>
 80080d4:	200012cc 	.word	0x200012cc
 80080d8:	200012f0 	.word	0x200012f0
 80080dc:	00000000 	.word	0x00000000

080080e0 <oslib_test_009_002_execute>:
static void oslib_test_009_002_execute(void) {
 80080e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 80080e2:	2501      	movs	r5, #1
 80080e4:	4c41      	ldr	r4, [pc, #260]	; (80081ec <oslib_test_009_002_execute+0x10c>)
 80080e6:	6025      	str	r5, [r4, #0]
    dbp = chFactoryFindBuffer("mybuf");
 80080e8:	f7fe fb4a 	bl	8006780 <chFactoryFindBuffer.constprop.14>
    test_assert(dbp == NULL, "found");
 80080ec:	fab0 f080 	clz	r0, r0
 80080f0:	493f      	ldr	r1, [pc, #252]	; (80081f0 <oslib_test_009_002_execute+0x110>)
 80080f2:	0940      	lsrs	r0, r0, #5
 80080f4:	f7f8 fe4c 	bl	8000d90 <_test_assert>
 80080f8:	b100      	cbz	r0, 80080fc <oslib_test_009_002_execute+0x1c>
}
 80080fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 80080fc:	2302      	movs	r3, #2
 80080fe:	6023      	str	r3, [r4, #0]
    dbp = chFactoryCreateBuffer("mybuf", 128U);
 8008100:	f7fe fb1e 	bl	8006740 <chFactoryCreateBuffer.constprop.15>
    test_assert(dbp != NULL, "cannot create");
 8008104:	4606      	mov	r6, r0
 8008106:	3000      	adds	r0, #0
 8008108:	bf18      	it	ne
 800810a:	2001      	movne	r0, #1
 800810c:	4939      	ldr	r1, [pc, #228]	; (80081f4 <oslib_test_009_002_execute+0x114>)
 800810e:	f7f8 fe3f 	bl	8000d90 <_test_assert>
 8008112:	2800      	cmp	r0, #0
 8008114:	d1f1      	bne.n	80080fa <oslib_test_009_002_execute+0x1a>
  test_set_step(3);
 8008116:	2303      	movs	r3, #3
 8008118:	6023      	str	r3, [r4, #0]
    dbp1 = chFactoryCreateBuffer("mybuf", 128U);
 800811a:	f7fe fb11 	bl	8006740 <chFactoryCreateBuffer.constprop.15>
    test_assert(dbp1 == NULL, "can create");
 800811e:	fab0 f080 	clz	r0, r0
 8008122:	4935      	ldr	r1, [pc, #212]	; (80081f8 <oslib_test_009_002_execute+0x118>)
 8008124:	0940      	lsrs	r0, r0, #5
 8008126:	f7f8 fe33 	bl	8000d90 <_test_assert>
 800812a:	2800      	cmp	r0, #0
 800812c:	d1e5      	bne.n	80080fa <oslib_test_009_002_execute+0x1a>
  test_set_step(4);
 800812e:	2304      	movs	r3, #4
 8008130:	6023      	str	r3, [r4, #0]
    dbp1 = chFactoryFindBuffer("mybuf");
 8008132:	f7fe fb25 	bl	8006780 <chFactoryFindBuffer.constprop.14>
    test_assert(dbp1 != NULL, "not found");
 8008136:	4607      	mov	r7, r0
 8008138:	3000      	adds	r0, #0
 800813a:	bf18      	it	ne
 800813c:	2001      	movne	r0, #1
 800813e:	492f      	ldr	r1, [pc, #188]	; (80081fc <oslib_test_009_002_execute+0x11c>)
 8008140:	f7f8 fe26 	bl	8000d90 <_test_assert>
 8008144:	2800      	cmp	r0, #0
 8008146:	d1d8      	bne.n	80080fa <oslib_test_009_002_execute+0x1a>
    test_assert(dbp == dbp1, "object reference mismatch");
 8008148:	1bf0      	subs	r0, r6, r7
 800814a:	fab0 f080 	clz	r0, r0
 800814e:	492c      	ldr	r1, [pc, #176]	; (8008200 <oslib_test_009_002_execute+0x120>)
 8008150:	0940      	lsrs	r0, r0, #5
 8008152:	f7f8 fe1d 	bl	8000d90 <_test_assert>
 8008156:	2800      	cmp	r0, #0
 8008158:	d1cf      	bne.n	80080fa <oslib_test_009_002_execute+0x1a>
    test_assert(dbp1->element.refs == 2, "object reference mismatch");
 800815a:	6878      	ldr	r0, [r7, #4]
 800815c:	4928      	ldr	r1, [pc, #160]	; (8008200 <oslib_test_009_002_execute+0x120>)
 800815e:	f1a0 0002 	sub.w	r0, r0, #2
 8008162:	fab0 f080 	clz	r0, r0
 8008166:	0940      	lsrs	r0, r0, #5
 8008168:	f7f8 fe12 	bl	8000d90 <_test_assert>
 800816c:	2800      	cmp	r0, #0
 800816e:	d1c4      	bne.n	80080fa <oslib_test_009_002_execute+0x1a>
 8008170:	687b      	ldr	r3, [r7, #4]
    test_assert(dbp1 == dbp2, "object reference mismatch");
 8008172:	4628      	mov	r0, r5
 8008174:	442b      	add	r3, r5
 8008176:	607b      	str	r3, [r7, #4]
 8008178:	4921      	ldr	r1, [pc, #132]	; (8008200 <oslib_test_009_002_execute+0x120>)
 800817a:	f7f8 fe09 	bl	8000d90 <_test_assert>
 800817e:	2800      	cmp	r0, #0
 8008180:	d1bb      	bne.n	80080fa <oslib_test_009_002_execute+0x1a>
    test_assert(dbp2->element.refs == 3, "object reference mismatch");
 8008182:	6878      	ldr	r0, [r7, #4]
 8008184:	491e      	ldr	r1, [pc, #120]	; (8008200 <oslib_test_009_002_execute+0x120>)
 8008186:	f1a0 0c03 	sub.w	ip, r0, #3
 800818a:	f1dc 0000 	rsbs	r0, ip, #0
 800818e:	eb40 000c 	adc.w	r0, r0, ip
 8008192:	f7f8 fdfd 	bl	8000d90 <_test_assert>
 8008196:	2800      	cmp	r0, #0
 8008198:	d1af      	bne.n	80080fa <oslib_test_009_002_execute+0x1a>
    chFactoryReleaseBuffer(dbp2);
 800819a:	4638      	mov	r0, r7
 800819c:	f7ff ff88 	bl	80080b0 <chFactoryReleaseBuffer>
    test_assert(dbp1->element.refs == 2, "references mismatch");
 80081a0:	6878      	ldr	r0, [r7, #4]
 80081a2:	4918      	ldr	r1, [pc, #96]	; (8008204 <oslib_test_009_002_execute+0x124>)
 80081a4:	1e82      	subs	r2, r0, #2
 80081a6:	4250      	negs	r0, r2
 80081a8:	4150      	adcs	r0, r2
 80081aa:	f7f8 fdf1 	bl	8000d90 <_test_assert>
 80081ae:	2800      	cmp	r0, #0
 80081b0:	d1a3      	bne.n	80080fa <oslib_test_009_002_execute+0x1a>
    chFactoryReleaseBuffer(dbp1);
 80081b2:	4638      	mov	r0, r7
 80081b4:	f7ff ff7c 	bl	80080b0 <chFactoryReleaseBuffer>
    test_assert(dbp->element.refs == 1, "references mismatch");
 80081b8:	6870      	ldr	r0, [r6, #4]
 80081ba:	4912      	ldr	r1, [pc, #72]	; (8008204 <oslib_test_009_002_execute+0x124>)
 80081bc:	1b43      	subs	r3, r0, r5
 80081be:	4258      	negs	r0, r3
 80081c0:	4158      	adcs	r0, r3
 80081c2:	f7f8 fde5 	bl	8000d90 <_test_assert>
 80081c6:	2800      	cmp	r0, #0
 80081c8:	d197      	bne.n	80080fa <oslib_test_009_002_execute+0x1a>
  test_set_step(5);
 80081ca:	2305      	movs	r3, #5
    chFactoryReleaseBuffer(dbp);
 80081cc:	4630      	mov	r0, r6
  test_set_step(5);
 80081ce:	6023      	str	r3, [r4, #0]
    chFactoryReleaseBuffer(dbp);
 80081d0:	f7ff ff6e 	bl	80080b0 <chFactoryReleaseBuffer>
  test_set_step(6);
 80081d4:	2306      	movs	r3, #6
 80081d6:	6023      	str	r3, [r4, #0]
    dbp = chFactoryFindBuffer("mybuf");
 80081d8:	f7fe fad2 	bl	8006780 <chFactoryFindBuffer.constprop.14>
}
 80081dc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dbp == NULL, "found");
 80081e0:	fab0 f080 	clz	r0, r0
 80081e4:	4902      	ldr	r1, [pc, #8]	; (80081f0 <oslib_test_009_002_execute+0x110>)
 80081e6:	0940      	lsrs	r0, r0, #5
 80081e8:	f7f8 bdd2 	b.w	8000d90 <_test_assert>
 80081ec:	20001d94 	.word	0x20001d94
 80081f0:	0800b524 	.word	0x0800b524
 80081f4:	0800b504 	.word	0x0800b504
 80081f8:	0800b514 	.word	0x0800b514
 80081fc:	0800b520 	.word	0x0800b520
 8008200:	0800b52c 	.word	0x0800b52c
 8008204:	0800b548 	.word	0x0800b548
	...

08008210 <oslib_test_009_002_teardown>:
static void oslib_test_009_002_teardown(void) {
 8008210:	b510      	push	{r4, lr}
  dbp = chFactoryFindBuffer("mybuf");
 8008212:	f7fe fab5 	bl	8006780 <chFactoryFindBuffer.constprop.14>
  if (dbp != NULL) {
 8008216:	b140      	cbz	r0, 800822a <oslib_test_009_002_teardown+0x1a>
    while (dbp->element.refs > 0U) {
 8008218:	6843      	ldr	r3, [r0, #4]
 800821a:	4604      	mov	r4, r0
 800821c:	b12b      	cbz	r3, 800822a <oslib_test_009_002_teardown+0x1a>
      chFactoryReleaseBuffer(dbp);
 800821e:	4620      	mov	r0, r4
 8008220:	f7ff ff46 	bl	80080b0 <chFactoryReleaseBuffer>
    while (dbp->element.refs > 0U) {
 8008224:	6863      	ldr	r3, [r4, #4]
 8008226:	2b00      	cmp	r3, #0
 8008228:	d1f9      	bne.n	800821e <oslib_test_009_002_teardown+0xe>
}
 800822a:	bd10      	pop	{r4, pc}
 800822c:	0000      	movs	r0, r0
	...

08008230 <chThdRelease>:
 8008230:	2220      	movs	r2, #32
 8008232:	f382 8811 	msr	BASEPRI, r2
  tp->refs--;
 8008236:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 800823a:	3b01      	subs	r3, #1
 800823c:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8008240:	6a03      	ldr	r3, [r0, #32]
 8008242:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8008246:	2b0f      	cmp	r3, #15
 8008248:	d003      	beq.n	8008252 <chThdRelease+0x22>
 800824a:	2300      	movs	r3, #0
 800824c:	f383 8811 	msr	BASEPRI, r3
 8008250:	4770      	bx	lr
void chThdRelease(thread_t *tp) {
 8008252:	b410      	push	{r4}
    REG_REMOVE(tp);
 8008254:	e9d0 4304 	ldrd	r4, r3, [r0, #16]
 8008258:	611c      	str	r4, [r3, #16]
 800825a:	6904      	ldr	r4, [r0, #16]
 800825c:	2100      	movs	r1, #0
 800825e:	6163      	str	r3, [r4, #20]
 8008260:	f381 8811 	msr	BASEPRI, r1
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8008264:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8008268:	f003 0303 	and.w	r3, r3, #3
 800826c:	2b01      	cmp	r3, #1
 800826e:	d00c      	beq.n	800828a <chThdRelease+0x5a>
 8008270:	2b02      	cmp	r3, #2
 8008272:	d108      	bne.n	8008286 <chThdRelease+0x56>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8008274:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8008276:	69c0      	ldr	r0, [r0, #28]
 8008278:	f382 8811 	msr	BASEPRI, r2
  php->next = mp->next;
 800827c:	681a      	ldr	r2, [r3, #0]
 800827e:	6002      	str	r2, [r0, #0]
  mp->next = php;
 8008280:	6018      	str	r0, [r3, #0]
 8008282:	f381 8811 	msr	BASEPRI, r1
}
 8008286:	bc10      	pop	{r4}
 8008288:	4770      	bx	lr
      chHeapFree(chThdGetWorkingAreaX(tp));
 800828a:	69c0      	ldr	r0, [r0, #28]
}
 800828c:	bc10      	pop	{r4}
      chHeapFree(chThdGetWorkingAreaX(tp));
 800828e:	f7ff ba9f 	b.w	80077d0 <chHeapFree>
 8008292:	bf00      	nop
	...

080082a0 <rt_test_011_006_execute>:
  test_set_step(1);
 80082a0:	2201      	movs	r2, #1
static void rt_test_011_006_execute(void) {
 80082a2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 80082a6:	4b17      	ldr	r3, [pc, #92]	; (8008304 <rt_test_011_006_execute+0x64>)
  test_set_step(1);
 80082a8:	f8df 906c 	ldr.w	r9, [pc, #108]	; 8008318 <rt_test_011_006_execute+0x78>
  return chThdGetSelfX()->prio;
 80082ac:	699b      	ldr	r3, [r3, #24]
 80082ae:	f8c9 2000 	str.w	r2, [r9]
  tprio_t prio = chThdGetPriorityX() + 1;
 80082b2:	689d      	ldr	r5, [r3, #8]
    n = 0;
 80082b4:	2400      	movs	r4, #0
  tprio_t prio = chThdGetPriorityX() + 1;
 80082b6:	4415      	add	r5, r2
    start = test_wait_tick();
 80082b8:	f7fb ff62 	bl	8004180 <test_wait_tick>
 80082bc:	4680      	mov	r8, r0
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80082be:	4f12      	ldr	r7, [pc, #72]	; (8008308 <rt_test_011_006_execute+0x68>)
 80082c0:	4e12      	ldr	r6, [pc, #72]	; (800830c <rt_test_011_006_execute+0x6c>)
 80082c2:	2300      	movs	r3, #0
 80082c4:	463a      	mov	r2, r7
 80082c6:	4629      	mov	r1, r5
 80082c8:	4630      	mov	r0, r6
 80082ca:	f7fb fa39 	bl	8003740 <chThdCreateStatic.constprop.68>
 80082ce:	f7ff ffaf 	bl	8008230 <chThdRelease>
 80082d2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80082d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      n++;
 80082d8:	3401      	adds	r4, #1
 80082da:	eba3 0308 	sub.w	r3, r3, r8
    } while (chVTIsSystemTimeWithinX(start, end));
 80082de:	b29b      	uxth	r3, r3
 80082e0:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 80082e4:	d3ed      	bcc.n	80082c2 <rt_test_011_006_execute+0x22>
  test_set_step(2);
 80082e6:	2302      	movs	r3, #2
    test_print("--- Score : ");
 80082e8:	4809      	ldr	r0, [pc, #36]	; (8008310 <rt_test_011_006_execute+0x70>)
  test_set_step(2);
 80082ea:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 80082ee:	f7f8 feb7 	bl	8001060 <test_print>
    test_printn(n);
 80082f2:	4620      	mov	r0, r4
 80082f4:	f7f8 fde4 	bl	8000ec0 <test_printn>
}
 80082f8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" threads/S");
 80082fc:	4805      	ldr	r0, [pc, #20]	; (8008314 <rt_test_011_006_execute+0x74>)
 80082fe:	f7f8 be8f 	b.w	8001020 <test_println>
 8008302:	bf00      	nop
 8008304:	20001254 	.word	0x20001254
 8008308:	08004ea1 	.word	0x08004ea1
 800830c:	20001680 	.word	0x20001680
 8008310:	0800c4fc 	.word	0x0800c4fc
 8008314:	0800c4a0 	.word	0x0800c4a0
 8008318:	20001d94 	.word	0x20001d94
 800831c:	00000000 	.word	0x00000000

08008320 <cmd_threads>:
  if (argc > 0) {
 8008320:	2900      	cmp	r1, #0
 8008322:	dd03      	ble.n	800832c <cmd_threads+0xc>
    shellUsage(chp, "threads");
 8008324:	4a28      	ldr	r2, [pc, #160]	; (80083c8 <cmd_threads+0xa8>)
 8008326:	4929      	ldr	r1, [pc, #164]	; (80083cc <cmd_threads+0xac>)
 8008328:	f7fa be5a 	b.w	8002fe0 <chprintf>
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 800832c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
 8008330:	4927      	ldr	r1, [pc, #156]	; (80083d0 <cmd_threads+0xb0>)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8008332:	b087      	sub	sp, #28
 8008334:	4605      	mov	r5, r0
 8008336:	2620      	movs	r6, #32
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
 8008338:	f7fa fe52 	bl	8002fe0 <chprintf>
 800833c:	f386 8811 	msr	BASEPRI, r6
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 8008340:	4f24      	ldr	r7, [pc, #144]	; (80083d4 <cmd_threads+0xb4>)
 8008342:	2200      	movs	r2, #0
 8008344:	693c      	ldr	r4, [r7, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8008346:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 800834a:	3301      	adds	r3, #1
 800834c:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
 8008350:	f382 8811 	msr	BASEPRI, r2
 8008354:	f8df a080 	ldr.w	sl, [pc, #128]	; 80083d8 <cmd_threads+0xb8>
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8008358:	f8df 9080 	ldr.w	r9, [pc, #128]	; 80083dc <cmd_threads+0xbc>
 800835c:	f8df 8080 	ldr.w	r8, [pc, #128]	; 80083e0 <cmd_threads+0xc0>
 8008360:	e00b      	b.n	800837a <cmd_threads+0x5a>
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    ntp->refs++;
 8008362:	f89b 3022 	ldrb.w	r3, [fp, #34]	; 0x22
 8008366:	2200      	movs	r2, #0
 8008368:	3301      	adds	r3, #1
 800836a:	f88b 3022 	strb.w	r3, [fp, #34]	; 0x22
 800836e:	f382 8811 	msr	BASEPRI, r2
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8008372:	4620      	mov	r0, r4
 8008374:	f7ff ff5c 	bl	8008230 <chThdRelease>
 8008378:	465c      	mov	r4, fp
             tp->name == NULL ? "" : tp->name);
 800837a:	69a1      	ldr	r1, [r4, #24]
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 800837c:	f894 3020 	ldrb.w	r3, [r4, #32]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8008380:	2900      	cmp	r1, #0
 8008382:	bf08      	it	eq
 8008384:	4649      	moveq	r1, r9
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8008386:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 800838a:	f85a e023 	ldr.w	lr, [sl, r3, lsl #2]
 800838e:	3801      	subs	r0, #1
    uint32_t stklimit = (uint32_t)tp->wabase;
 8008390:	69e2      	ldr	r2, [r4, #28]
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8008392:	e9d4 c302 	ldrd	ip, r3, [r4, #8]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8008396:	e9cd e103 	strd	lr, r1, [sp, #12]
 800839a:	e9cd 0c01 	strd	r0, ip, [sp, #4]
 800839e:	9400      	str	r4, [sp, #0]
 80083a0:	4641      	mov	r1, r8
 80083a2:	4628      	mov	r0, r5
 80083a4:	f7fa fe1c 	bl	8002fe0 <chprintf>
 80083a8:	f386 8811 	msr	BASEPRI, r6
  ntp = tp->newer;
 80083ac:	f8d4 b010 	ldr.w	fp, [r4, #16]
  if (ntp == (thread_t *)&ch.rlist) {
 80083b0:	45bb      	cmp	fp, r7
 80083b2:	d1d6      	bne.n	8008362 <cmd_threads+0x42>
 80083b4:	2300      	movs	r3, #0
 80083b6:	f383 8811 	msr	BASEPRI, r3
  chThdRelease(tp);
 80083ba:	4620      	mov	r0, r4
}
 80083bc:	b007      	add	sp, #28
 80083be:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80083c2:	f7ff bf35 	b.w	8008230 <chThdRelease>
 80083c6:	bf00      	nop
 80083c8:	0800ce6c 	.word	0x0800ce6c
 80083cc:	0800abd0 	.word	0x0800abd0
 80083d0:	0800ac08 	.word	0x0800ac08
 80083d4:	20001254 	.word	0x20001254
 80083d8:	0800c840 	.word	0x0800c840
 80083dc:	0800c7f4 	.word	0x0800c7f4
 80083e0:	0800ac48 	.word	0x0800ac48
	...

080083f0 <chThdWait>:
msg_t chThdWait(thread_t *tp) {
 80083f0:	b538      	push	{r3, r4, r5, lr}
 80083f2:	4604      	mov	r4, r0
 80083f4:	2320      	movs	r3, #32
 80083f6:	f383 8811 	msr	BASEPRI, r3
  if (tp->state != CH_STATE_FINAL) {
 80083fa:	f890 3020 	ldrb.w	r3, [r0, #32]
 80083fe:	2b0f      	cmp	r3, #15
 8008400:	d007      	beq.n	8008412 <chThdWait+0x22>
    list_insert(currp, &tp->waiting);
 8008402:	4b08      	ldr	r3, [pc, #32]	; (8008424 <chThdWait+0x34>)
  tp->queue.next = tlp->next;
 8008404:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8008406:	699b      	ldr	r3, [r3, #24]
    chSchGoSleepS(CH_STATE_WTEXIT);
 8008408:	2009      	movs	r0, #9
 800840a:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
 800840c:	62a3      	str	r3, [r4, #40]	; 0x28
 800840e:	f7fb fa57 	bl	80038c0 <chSchGoSleepS>
  msg = tp->u.exitcode;
 8008412:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8008414:	2300      	movs	r3, #0
 8008416:	f383 8811 	msr	BASEPRI, r3
  chThdRelease(tp);
 800841a:	4620      	mov	r0, r4
 800841c:	f7ff ff08 	bl	8008230 <chThdRelease>
}
 8008420:	4628      	mov	r0, r5
 8008422:	bd38      	pop	{r3, r4, r5, pc}
 8008424:	20001254 	.word	0x20001254
	...

08008430 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 8008430:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008434:	2500      	movs	r5, #0
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008436:	f44f 7680 	mov.w	r6, #256	; 0x100

/*
 * Application entry point.
 */
int main(void) 
{
 800843a:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800843e:	2060      	movs	r0, #96	; 0x60
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008440:	f04f 0a40 	mov.w	sl, #64	; 0x40
 8008444:	f04f 0980 	mov.w	r9, #128	; 0x80
 8008448:	f44f 7800 	mov.w	r8, #512	; 0x200
 800844c:	f44f 6e80 	mov.w	lr, #1024	; 0x400
 8008450:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
 8008454:	f04f 3488 	mov.w	r4, #2290649224	; 0x88888888
 8008458:	4abc      	ldr	r2, [pc, #752]	; (800874c <main+0x31c>)
  PWR->CR |= PWR_CR_DBP;
 800845a:	f8df b34c 	ldr.w	fp, [pc, #844]	; 80087a8 <main+0x378>
  rccResetAPB1(0xFFFFFFFF);
 800845e:	6917      	ldr	r7, [r2, #16]
 8008460:	6111      	str	r1, [r2, #16]
 8008462:	6917      	ldr	r7, [r2, #16]
 8008464:	6115      	str	r5, [r2, #16]
 8008466:	6917      	ldr	r7, [r2, #16]
  rccResetAPB2(0xFFFFFFFF);
 8008468:	68d7      	ldr	r7, [r2, #12]
 800846a:	60d1      	str	r1, [r2, #12]
 800846c:	68d7      	ldr	r7, [r2, #12]
 800846e:	60d5      	str	r5, [r2, #12]
 8008470:	68d7      	ldr	r7, [r2, #12]

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(true);
 8008472:	69d7      	ldr	r7, [r2, #28]
    usbp->in_params[i]  = NULL;
 8008474:	462b      	mov	r3, r5
 8008476:	f047 5780 	orr.w	r7, r7, #268435456	; 0x10000000
 800847a:	61d7      	str	r7, [r2, #28]
 800847c:	69d7      	ldr	r7, [r2, #28]
  rccEnableBKPInterface(true);
 800847e:	69d7      	ldr	r7, [r2, #28]
 8008480:	b089      	sub	sp, #36	; 0x24
 8008482:	f047 6700 	orr.w	r7, r7, #134217728	; 0x8000000
 8008486:	61d7      	str	r7, [r2, #28]
 8008488:	69d7      	ldr	r7, [r2, #28]
  PWR->CR |= PWR_CR_DBP;
 800848a:	f8db 7000 	ldr.w	r7, [fp]
 800848e:	4337      	orrs	r7, r6
 8008490:	f8cb 7000 	str.w	r7, [fp]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008494:	4fae      	ldr	r7, [pc, #696]	; (8008750 <main+0x320>)
 8008496:	f887 0306 	strb.w	r0, [r7, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800849a:	f8c7 a180 	str.w	sl, [r7, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800849e:	f8c7 a000 	str.w	sl, [r7]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80084a2:	f887 0307 	strb.w	r0, [r7, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80084a6:	f8c7 9180 	str.w	r9, [r7, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80084aa:	f8c7 9000 	str.w	r9, [r7]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80084ae:	f887 0308 	strb.w	r0, [r7, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80084b2:	f8c7 6180 	str.w	r6, [r7, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80084b6:	603e      	str	r6, [r7, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80084b8:	f887 0309 	strb.w	r0, [r7, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80084bc:	f8c7 8180 	str.w	r8, [r7, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80084c0:	f8c7 8000 	str.w	r8, [r7]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80084c4:	f887 030a 	strb.w	r0, [r7, #778]	; 0x30a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80084c8:	f8c7 e180 	str.w	lr, [r7, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80084cc:	f8c7 e000 	str.w	lr, [r7]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80084d0:	f887 0317 	strb.w	r0, [r7, #791]	; 0x317
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80084d4:	f8c7 c180 	str.w	ip, [r7, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80084d8:	f8c7 c000 	str.w	ip, [r7]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80084dc:	f887 0328 	strb.w	r0, [r7, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80084e0:	f8c7 6184 	str.w	r6, [r7, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80084e4:	607e      	str	r6, [r7, #4]
  rccEnableAPB2(APB2_EN_MASK, true);
 80084e6:	6990      	ldr	r0, [r2, #24]
  GPIOA->ODR = config->PAData.odr;
 80084e8:	4e9a      	ldr	r6, [pc, #616]	; (8008754 <main+0x324>)
  rccEnableAPB2(APB2_EN_MASK, true);
 80084ea:	f040 007d 	orr.w	r0, r0, #125	; 0x7d
 80084ee:	6190      	str	r0, [r2, #24]
  GPIOA->CRH = config->PAData.crh;
 80084f0:	4f99      	ldr	r7, [pc, #612]	; (8008758 <main+0x328>)
  rccEnableAPB2(APB2_EN_MASK, true);
 80084f2:	6992      	ldr	r2, [r2, #24]
  GPIOB->ODR = config->PBData.odr;
 80084f4:	4899      	ldr	r0, [pc, #612]	; (800875c <main+0x32c>)
  GPIOA->CRL = config->PAData.crl;
 80084f6:	4a9a      	ldr	r2, [pc, #616]	; (8008760 <main+0x330>)
  GPIOA->ODR = config->PAData.odr;
 80084f8:	60f1      	str	r1, [r6, #12]
  GPIOA->CRH = config->PAData.crh;
 80084fa:	6077      	str	r7, [r6, #4]
  GPIOB->CRH = config->PBData.crh;
 80084fc:	f507 7760 	add.w	r7, r7, #896	; 0x380
  GPIOA->CRL = config->PAData.crl;
 8008500:	6032      	str	r2, [r6, #0]
  GPIOB->ODR = config->PBData.odr;
 8008502:	60c1      	str	r1, [r0, #12]
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 8008504:	4a97      	ldr	r2, [pc, #604]	; (8008764 <main+0x334>)
  GPIOB->CRH = config->PBData.crh;
 8008506:	6047      	str	r7, [r0, #4]
  GPIOB->CRL = config->PBData.crl;
 8008508:	6007      	str	r7, [r0, #0]
  GPIOC->ODR = config->PCData.odr;
 800850a:	f8c6 180c 	str.w	r1, [r6, #2060]	; 0x80c
  GPIOC->CRH = config->PCData.crh;
 800850e:	f8c6 4804 	str.w	r4, [r6, #2052]	; 0x804
  GPIOC->CRL = config->PCData.crl;
 8008512:	f8c6 4800 	str.w	r4, [r6, #2048]	; 0x800
  usbp->state        = USB_STOP;
 8008516:	4e94      	ldr	r6, [pc, #592]	; (8008768 <main+0x338>)
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
 8008518:	370c      	adds	r7, #12
  GPIOD->ODR = config->PDData.odr;
 800851a:	60d1      	str	r1, [r2, #12]
  usbp->config       = NULL;
 800851c:	6075      	str	r5, [r6, #4]
  GPIOD->CRH = config->PDData.crh;
 800851e:	6054      	str	r4, [r2, #4]
  GPIOD->CRL = config->PDData.crl;
 8008520:	6017      	str	r7, [r2, #0]
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8008522:	f8c0 1c0c 	str.w	r1, [r0, #3084]	; 0xc0c
  GPIOE->CRH = config->PEData.crh;
 8008526:	f8c0 4c04 	str.w	r4, [r0, #3076]	; 0xc04
  GPIOE->CRL = config->PEData.crl;
 800852a:	f8c0 4c00 	str.w	r4, [r0, #3072]	; 0xc00
  usbp->state        = USB_STOP;
 800852e:	f04f 0001 	mov.w	r0, #1
 8008532:	f106 022c 	add.w	r2, r6, #44	; 0x2c
 8008536:	f106 0148 	add.w	r1, r6, #72	; 0x48
 800853a:	7030      	strb	r0, [r6, #0]
    usbp->in_params[i]  = NULL;
 800853c:	f842 3b04 	str.w	r3, [r2], #4
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8008540:	4291      	cmp	r1, r2
    usbp->out_params[i] = NULL;
 8008542:	6193      	str	r3, [r2, #24]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8008544:	d1fa      	bne.n	800853c <main+0x10c>
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8008546:	f04f 0e01 	mov.w	lr, #1
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800854a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800854e:	f64f 79ff 	movw	r9, #65535	; 0xffff
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8008552:	f648 4a9f 	movw	sl, #35999	; 0x8c9f
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008556:	f04f 5c80 	mov.w	ip, #268435456	; 0x10000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800855a:	f04f 0880 	mov.w	r8, #128	; 0x80
  ch.vtlist.delta = (sysinterval_t)-1;
 800855e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
  mp->align = align;
 8008562:	2104      	movs	r1, #4
  ST_ENABLE_CLOCK();
 8008564:	4879      	ldr	r0, [pc, #484]	; (800874c <main+0x31c>)
  usbp->transmitting = 0;
 8008566:	60b3      	str	r3, [r6, #8]
 8008568:	69c4      	ldr	r4, [r0, #28]
  mp->object_size = size;
 800856a:	f04f 0b14 	mov.w	fp, #20
 800856e:	ea44 040e 	orr.w	r4, r4, lr
 8008572:	61c4      	str	r4, [r0, #28]
  ST_ENABLE_STOP();
 8008574:	4c7d      	ldr	r4, [pc, #500]	; (800876c <main+0x33c>)
  ST_ENABLE_CLOCK();
 8008576:	69c0      	ldr	r0, [r0, #28]
  ST_ENABLE_STOP();
 8008578:	6860      	ldr	r0, [r4, #4]
  tmp->cumulative = (rttime_t)0;
 800857a:	460d      	mov	r5, r1
 800857c:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 8008580:	6060      	str	r0, [r4, #4]
  tqp->next = (thread_t *)tqp;
 8008582:	4c7b      	ldr	r4, [pc, #492]	; (8008770 <main+0x340>)
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8008584:	f8c2 a028 	str.w	sl, [r2, #40]	; 0x28
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8008588:	487a      	ldr	r0, [pc, #488]	; (8008774 <main+0x344>)
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800858a:	f8c2 902c 	str.w	r9, [r2, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800858e:	6193      	str	r3, [r2, #24]
  tqp->prev = (thread_t *)tqp;
 8008590:	6064      	str	r4, [r4, #4]
  STM32_ST_TIM->CCR[0] = 0;
 8008592:	6353      	str	r3, [r2, #52]	; 0x34
  ch.rlist.prio = NOPRIO;
 8008594:	60a3      	str	r3, [r4, #8]
  STM32_ST_TIM->DIER   = 0;
 8008596:	60d3      	str	r3, [r2, #12]
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8008598:	6124      	str	r4, [r4, #16]
  STM32_ST_TIM->CR2    = 0;
 800859a:	6053      	str	r3, [r2, #4]
  ch.rlist.older = (thread_t *)&ch.rlist;
 800859c:	6164      	str	r4, [r4, #20]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800859e:	f8c2 e014 	str.w	lr, [r2, #20]
  ch.vtlist.lasttime = (systime_t)0;
 80085a2:	8523      	strh	r3, [r4, #40]	; 0x28
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80085a4:	f8c2 e000 	str.w	lr, [r2]
 80085a8:	4a69      	ldr	r2, [pc, #420]	; (8008750 <main+0x320>)
  H_NEXT(&default_heap.header) = NULL;
 80085aa:	6043      	str	r3, [r0, #4]
 80085ac:	f882 831c 	strb.w	r8, [r2, #796]	; 0x31c
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80085b0:	f8c2 c180 	str.w	ip, [r2, #384]	; 0x180
  H_PAGES(&default_heap.header) = 0;
 80085b4:	6083      	str	r3, [r0, #8]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80085b6:	f8c2 c000 	str.w	ip, [r2]
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 80085ba:	f104 0c1c 	add.w	ip, r4, #28
  ch_memcore.basemem = __heap_base__;
 80085be:	4a6e      	ldr	r2, [pc, #440]	; (8008778 <main+0x348>)
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 80085c0:	e9c4 cc07 	strd	ip, ip, [r4, #28]
 80085c4:	f8df c1e4 	ldr.w	ip, [pc, #484]	; 80087ac <main+0x37c>
  default_heap.provider = chCoreAllocAlignedWithOffset;
 80085c8:	f8df e1e4 	ldr.w	lr, [pc, #484]	; 80087b0 <main+0x380>
 80085cc:	f8c2 c000 	str.w	ip, [r2]
  ch_memcore.topmem  = __heap_end__;
 80085d0:	f8df c1e0 	ldr.w	ip, [pc, #480]	; 80087b4 <main+0x384>
 80085d4:	f8c0 e000 	str.w	lr, [r0]
 80085d8:	f8c2 c004 	str.w	ip, [r2, #4]
  tqp->next = (thread_t *)tqp;
 80085dc:	4a67      	ldr	r2, [pc, #412]	; (800877c <main+0x34c>)
 80085de:	f100 0e0c 	add.w	lr, r0, #12
 80085e2:	f8c0 e00c 	str.w	lr, [r0, #12]
  ch.vtlist.delta = (sysinterval_t)-1;
 80085e6:	6267      	str	r7, [r4, #36]	; 0x24
 80085e8:	6024      	str	r4, [r4, #0]
  tqp->prev = (thread_t *)tqp;
 80085ea:	f8c0 e010 	str.w	lr, [r0, #16]
  mp->owner = NULL;
 80085ee:	6143      	str	r3, [r0, #20]
  ch.tm.offset = (rtcnt_t)0;
 80085f0:	6763      	str	r3, [r4, #116]	; 0x74
  tmp->last       = (rtcnt_t)0;
 80085f2:	e9cd 3303 	strd	r3, r3, [sp, #12]
  tmp->n          = (ucnt_t)0;
 80085f6:	9305      	str	r3, [sp, #20]
 80085f8:	6093      	str	r3, [r2, #8]
  mp->next = NULL;
 80085fa:	6153      	str	r3, [r2, #20]
 80085fc:	62d3      	str	r3, [r2, #44]	; 0x2c
  dlp->next = (dyn_element_t *)dlp;
 80085fe:	f102 0310 	add.w	r3, r2, #16
  tmp->cumulative = (rttime_t)0;
 8008602:	f04f 0800 	mov.w	r8, #0
 8008606:	f04f 0900 	mov.w	r9, #0
 800860a:	6113      	str	r3, [r2, #16]
 800860c:	f102 0328 	add.w	r3, r2, #40	; 0x28
 8008610:	6293      	str	r3, [r2, #40]	; 0x28
  mp->object_size = size;
 8008612:	231c      	movs	r3, #28
  tmp->best       = (rtcnt_t)-1;
 8008614:	9702      	str	r7, [sp, #8]
 8008616:	f102 0724 	add.w	r7, r2, #36	; 0x24
 800861a:	6257      	str	r7, [r2, #36]	; 0x24
 800861c:	f102 0c3c 	add.w	ip, r2, #60	; 0x3c
 8008620:	f102 0740 	add.w	r7, r2, #64	; 0x40
  mp->provider = provider;
 8008624:	4856      	ldr	r0, [pc, #344]	; (8008780 <main+0x350>)
  tmp->cumulative = (rttime_t)0;
 8008626:	e9cd 8906 	strd	r8, r9, [sp, #24]
 800862a:	e9c2 2200 	strd	r2, r2, [r2]
 800862e:	e9c2 c70f 	strd	ip, r7, [r2, #60]	; 0x3c
  mp->object_size = size;
 8008632:	6313      	str	r3, [r2, #48]	; 0x30
 8008634:	f102 0344 	add.w	r3, r2, #68	; 0x44
 8008638:	f8c2 b018 	str.w	fp, [r2, #24]
 800863c:	6453      	str	r3, [r2, #68]	; 0x44
  mp->align = align;
 800863e:	61d1      	str	r1, [r2, #28]
 8008640:	6351      	str	r1, [r2, #52]	; 0x34
  mp->provider = provider;
 8008642:	6210      	str	r0, [r2, #32]
 8008644:	6390      	str	r0, [r2, #56]	; 0x38
    chTMStartMeasurementX(&tm);
 8008646:	a802      	add	r0, sp, #8
 8008648:	f7f8 ff52 	bl	80014f0 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 800864c:	a802      	add	r0, sp, #8
 800864e:	f7f8 ff27 	bl	80014a0 <chTMStopMeasurementX>
  } while (i > 0U);
 8008652:	3d01      	subs	r5, #1
 8008654:	d1f7      	bne.n	8008646 <main+0x216>
  tp->prio      = prio;
 8008656:	2280      	movs	r2, #128	; 0x80
  tp->refs      = (trefs_t)1;
 8008658:	2701      	movs	r7, #1
  REG_INSERT(tp);
 800865a:	4b4a      	ldr	r3, [pc, #296]	; (8008784 <main+0x354>)
  ch.tm.offset = tm.best;
 800865c:	9802      	ldr	r0, [sp, #8]
 800865e:	6961      	ldr	r1, [r4, #20]
  tp->name      = name;
 8008660:	f8df c154 	ldr.w	ip, [pc, #340]	; 80087b8 <main+0x388>
  tp->prio      = prio;
 8008664:	63a2      	str	r2, [r4, #56]	; 0x38
  tp->realprio  = prio;
 8008666:	66e2      	str	r2, [r4, #108]	; 0x6c
 8008668:	6760      	str	r0, [r4, #116]	; 0x74
  tqp->next = (thread_t *)tqp;
 800866a:	f103 022c 	add.w	r2, r3, #44	; 0x2c
  tlp->next = (thread_t *)tlp;
 800866e:	f103 0028 	add.w	r0, r3, #40	; 0x28
  tp->flags     = CH_FLAG_MODE_STATIC;
 8008672:	f884 5051 	strb.w	r5, [r4, #81]	; 0x51
  tp->epending  = (eventmask_t)0;
 8008676:	e9c4 5519 	strd	r5, r5, [r4, #100]	; 0x64
  REG_INSERT(tp);
 800867a:	6424      	str	r4, [r4, #64]	; 0x40
  tp->refs      = (trefs_t)1;
 800867c:	f884 7052 	strb.w	r7, [r4, #82]	; 0x52
  tp->name      = name;
 8008680:	f8c4 c048 	str.w	ip, [r4, #72]	; 0x48
  REG_INSERT(tp);
 8008684:	6461      	str	r1, [r4, #68]	; 0x44
 8008686:	f04f 0820 	mov.w	r8, #32
 800868a:	610b      	str	r3, [r1, #16]
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 800868c:	e9c4 3305 	strd	r3, r3, [r4, #20]
  currp->state = CH_STATE_CURRENT;
 8008690:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
  currp->wabase = NULL;
 8008694:	64e5      	str	r5, [r4, #76]	; 0x4c
  tqp->next = (thread_t *)tqp;
 8008696:	e9c4 0216 	strd	r0, r2, [r4, #88]	; 0x58
  tqp->prev = (thread_t *)tqp;
 800869a:	6622      	str	r2, [r4, #96]	; 0x60
 800869c:	f388 8811 	msr	BASEPRI, r8
  __ASM volatile ("cpsie i" : : : "memory");
 80086a0:	b662      	cpsie	i
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80086a2:	f64f 04ff 	movw	r4, #63743	; 0xf8ff
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80086a6:	2010      	movs	r0, #16
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80086a8:	4b37      	ldr	r3, [pc, #220]	; (8008788 <main+0x358>)
  reg_value  =  (reg_value                                   |
 80086aa:	4a38      	ldr	r2, [pc, #224]	; (800878c <main+0x35c>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80086ac:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80086ae:	4021      	ands	r1, r4
  reg_value  =  (reg_value                                   |
 80086b0:	430a      	orrs	r2, r1
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80086b2:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  SCB->AIRCR =  reg_value;
 80086b6:	60da      	str	r2, [r3, #12]
 80086b8:	f6a4 340f 	subw	r4, r4, #2831	; 0xb0f
 80086bc:	68e2      	ldr	r2, [r4, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80086be:	4934      	ldr	r1, [pc, #208]	; (8008790 <main+0x360>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80086c0:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80086c4:	60e2      	str	r2, [r4, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80086c6:	680a      	ldr	r2, [r1, #0]
 80086c8:	433a      	orrs	r2, r7
 80086ca:	600a      	str	r2, [r1, #0]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80086cc:	77d8      	strb	r0, [r3, #31]
 80086ce:	f883 8022 	strb.w	r8, [r3, #34]	; 0x22
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80086d2:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
 80086d6:	b662      	cpsie	i
  sdup->vmt = &vmt;
 80086d8:	4c2e      	ldr	r4, [pc, #184]	; (8008794 <main+0x364>)
    (void) chThdCreate(&idle_descriptor);
 80086da:	482f      	ldr	r0, [pc, #188]	; (8008798 <main+0x368>)
 80086dc:	f7fb f8e0 	bl	80038a0 <chThdCreate>
 80086e0:	4622      	mov	r2, r4
  ibqp->bn        = n;
 80086e2:	2302      	movs	r3, #2
  ibqp->bsize     = size + sizeof (size_t);
 80086e4:	f44f 7082 	mov.w	r0, #260	; 0x104
 80086e8:	492c      	ldr	r1, [pc, #176]	; (800879c <main+0x36c>)
  ibqp->bcounter  = 0;
 80086ea:	61a5      	str	r5, [r4, #24]
 80086ec:	f842 1b04 	str.w	r1, [r2], #4
  ibqp->notify    = infy;
 80086f0:	492b      	ldr	r1, [pc, #172]	; (80087a0 <main+0x370>)
  esp->next = (event_listener_t *)esp;
 80086f2:	6062      	str	r2, [r4, #4]
 80086f4:	63e1      	str	r1, [r4, #60]	; 0x3c
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 80086f6:	f204 418c 	addw	r1, r4, #1164	; 0x48c
 80086fa:	65e1      	str	r1, [r4, #92]	; 0x5c
  obqp->notify    = onfy;
 80086fc:	4929      	ldr	r1, [pc, #164]	; (80087a4 <main+0x374>)
  tqp->next = (thread_t *)tqp;
 80086fe:	f104 020c 	add.w	r2, r4, #12
 8008702:	6761      	str	r1, [r4, #116]	; 0x74
  ibqp->brdptr    = bp;
 8008704:	f104 017c 	add.w	r1, r4, #124	; 0x7c
  tqp->prev = (thread_t *)tqp;
 8008708:	e9c4 2203 	strd	r2, r2, [r4, #12]
  ibqp->bwrptr    = bp;
 800870c:	e9c4 1107 	strd	r1, r1, [r4, #28]
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8008710:	f504 7221 	add.w	r2, r4, #644	; 0x284
  ibqp->buffers   = bp;
 8008714:	6321      	str	r1, [r4, #48]	; 0x30
  tqp->next = (thread_t *)tqp;
 8008716:	f104 0144 	add.w	r1, r4, #68	; 0x44
  sdup->state = SDU_STOP;
 800871a:	7227      	strb	r7, [r4, #8]
  ibqp->suspended = suspended;
 800871c:	7527      	strb	r7, [r4, #20]
  ibqp->top       = NULL;
 800871e:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
  obqp->suspended = suspended;
 8008722:	f884 704c 	strb.w	r7, [r4, #76]	; 0x4c
  obqp->top       = NULL;
 8008726:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
  ibqp->link      = link;
 800872a:	6424      	str	r4, [r4, #64]	; 0x40
  obqp->link      = link;
 800872c:	67a4      	str	r4, [r4, #120]	; 0x78
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800872e:	6262      	str	r2, [r4, #36]	; 0x24
  obqp->bwrptr    = bp;
 8008730:	e9c4 2215 	strd	r2, r2, [r4, #84]	; 0x54
  obqp->buffers   = bp;
 8008734:	66a2      	str	r2, [r4, #104]	; 0x68
  tqp->prev = (thread_t *)tqp;
 8008736:	e9c4 1111 	strd	r1, r1, [r4, #68]	; 0x44
  ibqp->bsize     = size + sizeof (size_t);
 800873a:	62a0      	str	r0, [r4, #40]	; 0x28
  obqp->bsize     = size + sizeof (size_t);
 800873c:	6620      	str	r0, [r4, #96]	; 0x60
  ibqp->bn        = n;
 800873e:	62e3      	str	r3, [r4, #44]	; 0x2c
  obqp->bcounter  = n;
 8008740:	6523      	str	r3, [r4, #80]	; 0x50
  obqp->bn        = n;
 8008742:	6663      	str	r3, [r4, #100]	; 0x64
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008744:	f388 8811 	msr	BASEPRI, r8
 8008748:	e038      	b.n	80087bc <main+0x38c>
 800874a:	bf00      	nop
 800874c:	40021000 	.word	0x40021000
 8008750:	e000e100 	.word	0xe000e100
 8008754:	40010800 	.word	0x40010800
 8008758:	888884b8 	.word	0x888884b8
 800875c:	40010c00 	.word	0x40010c00
 8008760:	88884388 	.word	0x88884388
 8008764:	40011400 	.word	0x40011400
 8008768:	20001178 	.word	0x20001178
 800876c:	e0042000 	.word	0xe0042000
 8008770:	20001254 	.word	0x20001254
 8008774:	200013f8 	.word	0x200013f8
 8008778:	200013f0 	.word	0x200013f0
 800877c:	200012cc 	.word	0x200012cc
 8008780:	080011e1 	.word	0x080011e1
 8008784:	20001284 	.word	0x20001284
 8008788:	e000ed00 	.word	0xe000ed00
 800878c:	05fa0300 	.word	0x05fa0300
 8008790:	e0001000 	.word	0xe0001000
 8008794:	20000ce8 	.word	0x20000ce8
 8008798:	0800ad1c 	.word	0x0800ad1c
 800879c:	0800d534 	.word	0x0800d534
 80087a0:	08002501 	.word	0x08002501
 80087a4:	080025a1 	.word	0x080025a1
 80087a8:	40007000 	.word	0x40007000
 80087ac:	20002490 	.word	0x20002490
 80087b0:	08000911 	.word	0x08000911
 80087b4:	20005000 	.word	0x20005000
 80087b8:	0800aa0c 	.word	0x0800aa0c
  sdup->config = config;
 80087bc:	4a34      	ldr	r2, [pc, #208]	; (8008890 <main+0x460>)
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 80087be:	62f4      	str	r4, [r6, #44]	; 0x2c
  usbp->out_params[config->bulk_out - 1U] = sdup;
 80087c0:	64b4      	str	r4, [r6, #72]	; 0x48
    usbp->in_params[config->int_in - 1U]  = sdup;
 80087c2:	6334      	str	r4, [r6, #48]	; 0x30
  sdup->state = SDU_READY;
 80087c4:	7223      	strb	r3, [r4, #8]
  sdup->config = config;
 80087c6:	f8c4 248c 	str.w	r2, [r4, #1164]	; 0x48c
 80087ca:	f385 8811 	msr	BASEPRI, r5
        /*
         * Activates the USB driver and then the USB bus pull-up on D+.
         * Note, a delay is inserted in order to not have to disconnect the cable
         * after a reset.
         */
        usbDisconnectBus(serusbcfg.usbp);
 80087ce:	f44f 7200 	mov.w	r2, #512	; 0x200
 80087d2:	4b30      	ldr	r3, [pc, #192]	; (8008894 <main+0x464>)
        chThdSleepMilliseconds(1500);
 80087d4:	f640 30b8 	movw	r0, #3000	; 0xbb8
        usbDisconnectBus(serusbcfg.usbp);
 80087d8:	611a      	str	r2, [r3, #16]
        chThdSleepMilliseconds(1500);
 80087da:	f7fb fc31 	bl	8004040 <chThdSleep>
 80087de:	f388 8811 	msr	BASEPRI, r8
  if (usbp->state == USB_STOP) {
 80087e2:	7837      	ldrb	r7, [r6, #0]
  usbp->config = config;
 80087e4:	4b2c      	ldr	r3, [pc, #176]	; (8008898 <main+0x468>)
 80087e6:	2f01      	cmp	r7, #1
    usbp->epc[i] = NULL;
 80087e8:	e9c6 5503 	strd	r5, r5, [r6, #12]
 80087ec:	e9c6 5505 	strd	r5, r5, [r6, #20]
 80087f0:	e9c6 5507 	strd	r5, r5, [r6, #28]
 80087f4:	e9c6 5509 	strd	r5, r5, [r6, #36]	; 0x24
  usbp->config = config;
 80087f8:	6073      	str	r3, [r6, #4]
 80087fa:	d029      	beq.n	8008850 <main+0x420>
  usbp->state = USB_READY;
 80087fc:	2202      	movs	r2, #2
 80087fe:	2300      	movs	r3, #0
 8008800:	7032      	strb	r2, [r6, #0]
 8008802:	f383 8811 	msr	BASEPRI, r3
        usbStart(serusbcfg.usbp, &usbcfg);
        usbConnectBus(serusbcfg.usbp);
 8008806:	f44f 7100 	mov.w	r1, #512	; 0x200
 800880a:	4a22      	ldr	r2, [pc, #136]	; (8008894 <main+0x464>)
 800880c:	4d23      	ldr	r5, [pc, #140]	; (800889c <main+0x46c>)
 800880e:	6151      	str	r1, [r2, #20]
        shellInit();

        /*
         * Creates the blinker thread.
         */
        chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8008810:	4823      	ldr	r0, [pc, #140]	; (80088a0 <main+0x470>)
 8008812:	4a24      	ldr	r2, [pc, #144]	; (80088a4 <main+0x474>)
 8008814:	2180      	movs	r1, #128	; 0x80
 8008816:	602d      	str	r5, [r5, #0]
 8008818:	4f23      	ldr	r7, [pc, #140]	; (80088a8 <main+0x478>)
 800881a:	f7fa ff91 	bl	8003740 <chThdCreateStatic.constprop.68>
 800881e:	4e23      	ldr	r6, [pc, #140]	; (80088ac <main+0x47c>)
        /*
         * Normal main() thread activity, spawning shells.
         */
        while (true) {
                if (SDU1.config->usbp->state == USB_ACTIVE) {
                        thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
 8008820:	4d23      	ldr	r5, [pc, #140]	; (80088b0 <main+0x480>)
 8008822:	e003      	b.n	800882c <main+0x3fc>
                                              "shell", NORMALPRIO + 1,
                                              shellThread, (void *)&shell_cfg1);
                        chThdWait(shelltp);     /* Waiting termination.             */
                }
                chThdSleepMilliseconds(1000);
 8008824:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8008828:	f7fb fc0a 	bl	8004040 <chThdSleep>
                if (SDU1.config->usbp->state == USB_ACTIVE) {
 800882c:	f8d4 348c 	ldr.w	r3, [r4, #1164]	; 0x48c
 8008830:	681b      	ldr	r3, [r3, #0]
 8008832:	781b      	ldrb	r3, [r3, #0]
 8008834:	2b04      	cmp	r3, #4
 8008836:	d1f5      	bne.n	8008824 <main+0x3f4>
                        thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
 8008838:	2381      	movs	r3, #129	; 0x81
 800883a:	462a      	mov	r2, r5
 800883c:	f640 01c8 	movw	r1, #2248	; 0x8c8
 8008840:	e9cd 6700 	strd	r6, r7, [sp]
 8008844:	2000      	movs	r0, #0
 8008846:	f7fd fde3 	bl	8006410 <chThdCreateFromHeap>
                        chThdWait(shelltp);     /* Waiting termination.             */
 800884a:	f7ff fdd1 	bl	80083f0 <chThdWait>
 800884e:	e7e9      	b.n	8008824 <main+0x3f4>
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008850:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8008854:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008858:	f04f 0ed0 	mov.w	lr, #208	; 0xd0
 800885c:	f04f 0ce0 	mov.w	ip, #224	; 0xe0
      rccEnableUSB(true);
 8008860:	4b14      	ldr	r3, [pc, #80]	; (80088b4 <main+0x484>)
 8008862:	69da      	ldr	r2, [r3, #28]
 8008864:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8008868:	61da      	str	r2, [r3, #28]
 800886a:	69db      	ldr	r3, [r3, #28]
      STM32_USB->CNTR = CNTR_FRES;
 800886c:	4a12      	ldr	r2, [pc, #72]	; (80088b8 <main+0x488>)
 800886e:	4b13      	ldr	r3, [pc, #76]	; (80088bc <main+0x48c>)
 8008870:	6417      	str	r7, [r2, #64]	; 0x40
 8008872:	f883 e313 	strb.w	lr, [r3, #787]	; 0x313
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008876:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800887a:	6018      	str	r0, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800887c:	f883 c314 	strb.w	ip, [r3, #788]	; 0x314
    usb_lld_reset(usbp);
 8008880:	480f      	ldr	r0, [pc, #60]	; (80088c0 <main+0x490>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008882:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008886:	6019      	str	r1, [r3, #0]
      STM32_USB->CNTR = 0;
 8008888:	6415      	str	r5, [r2, #64]	; 0x40
    usb_lld_reset(usbp);
 800888a:	f7f9 fa81 	bl	8001d90 <usb_lld_reset>
 800888e:	e7b5      	b.n	80087fc <main+0x3cc>
 8008890:	0800c778 	.word	0x0800c778
 8008894:	40010c00 	.word	0x40010c00
 8008898:	0800d430 	.word	0x0800d430
 800889c:	20001678 	.word	0x20001678
 80088a0:	20002348 	.word	0x20002348
 80088a4:	08004061 	.word	0x08004061
 80088a8:	0800c7f8 	.word	0x0800c7f8
 80088ac:	08004ba1 	.word	0x08004ba1
 80088b0:	0800c788 	.word	0x0800c788
 80088b4:	40021000 	.word	0x40021000
 80088b8:	40005c00 	.word	0x40005c00
 80088bc:	e000e100 	.word	0xe000e100
 80088c0:	20001178 	.word	0x20001178
	...

080088d0 <oslib_test_005_001_execute>:
 *   emitted tokens.
 * - [5.1.3] Waiting for the thread to terminate-.
 * .
 */

static void oslib_test_005_001_execute(void) {
 80088d0:	b570      	push	{r4, r5, r6, lr}
  thread_t *tp;

  /* [5.1.1] Starting the dispatcher thread.*/
  test_set_step(1);
 80088d2:	2601      	movs	r6, #1
  {
    thread_descriptor_t td = {
 80088d4:	2500      	movs	r5, #0
  return ch.rlist.current;
 80088d6:	4a4b      	ldr	r2, [pc, #300]	; (8008a04 <oslib_test_005_001_execute+0x134>)
static void oslib_test_005_001_execute(void) {
 80088d8:	b08a      	sub	sp, #40	; 0x28
  return chThdGetSelfX()->prio;
 80088da:	6992      	ldr	r2, [r2, #24]
    thread_descriptor_t td = {
 80088dc:	4b4a      	ldr	r3, [pc, #296]	; (8008a08 <oslib_test_005_001_execute+0x138>)
      .name  = "dispatcher",
      .wbase = waThread1,
      .wend  = THD_WORKING_AREA_END(waThread1),
      .prio  = chThdGetPriorityX() + 1,
 80088de:	6892      	ldr	r2, [r2, #8]
    thread_descriptor_t td = {
 80088e0:	494a      	ldr	r1, [pc, #296]	; (8008a0c <oslib_test_005_001_execute+0x13c>)
      .prio  = chThdGetPriorityX() + 1,
 80088e2:	4432      	add	r2, r6
  test_set_step(1);
 80088e4:	4c4a      	ldr	r4, [pc, #296]	; (8008a10 <oslib_test_005_001_execute+0x140>)
    thread_descriptor_t td = {
 80088e6:	9207      	str	r2, [sp, #28]
 80088e8:	4a4a      	ldr	r2, [pc, #296]	; (8008a14 <oslib_test_005_001_execute+0x144>)
 80088ea:	9305      	str	r3, [sp, #20]
      .funcp = Thread1,
      .arg   = NULL
    };
    tp = chThdCreate(&td);
 80088ec:	a804      	add	r0, sp, #16
    thread_descriptor_t td = {
 80088ee:	f503 73e4 	add.w	r3, r3, #456	; 0x1c8
 80088f2:	9306      	str	r3, [sp, #24]
 80088f4:	9509      	str	r5, [sp, #36]	; 0x24
 80088f6:	9104      	str	r1, [sp, #16]
 80088f8:	9208      	str	r2, [sp, #32]
  test_set_step(1);
 80088fa:	6026      	str	r6, [r4, #0]
    tp = chThdCreate(&td);
 80088fc:	f7fa ffd0 	bl	80038a0 <chThdCreate>
  }
  test_end_step(1);

  /* [5.1.2] Calling the default veneers, checking the result and the
     emitted tokens.*/
  test_set_step(2);
 8008900:	2302      	movs	r3, #2
 * @param[in] func      pointer to the function to be called
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect0(thread_t *tp, delegate_fn0_t func) {

  return chDelegateCallVeneer(tp, __ch_delegate_fn0, func);
 8008902:	4945      	ldr	r1, [pc, #276]	; (8008a18 <oslib_test_005_001_execute+0x148>)
 8008904:	4a45      	ldr	r2, [pc, #276]	; (8008a1c <oslib_test_005_001_execute+0x14c>)
 8008906:	6023      	str	r3, [r4, #0]
    tp = chThdCreate(&td);
 8008908:	4605      	mov	r5, r0
 800890a:	f7fb ff49 	bl	80047a0 <chDelegateCallVeneer>
  {
    int retval;

    retval = chDelegateCallDirect0(tp, (delegate_fn0_t)dis_func0);
    test_assert(retval == 0x55AA, "invalid return value");
 800890e:	f245 53aa 	movw	r3, #21930	; 0x55aa
 8008912:	1ac0      	subs	r0, r0, r3
 8008914:	fab0 f080 	clz	r0, r0
 8008918:	4941      	ldr	r1, [pc, #260]	; (8008a20 <oslib_test_005_001_execute+0x150>)
 800891a:	0940      	lsrs	r0, r0, #5
 800891c:	f7f8 fa38 	bl	8000d90 <_test_assert>
 8008920:	b108      	cbz	r0, 8008926 <oslib_test_005_001_execute+0x56>
  {
    msg_t msg = chThdWait(tp);
    test_assert(msg == 0x0FA5, "invalid exit code");
  }
  test_end_step(3);
}
 8008922:	b00a      	add	sp, #40	; 0x28
 8008924:	bd70      	pop	{r4, r5, r6, pc}
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect1(thread_t *tp, delegate_fn1_t func,
                                          msg_t p1) {

  return chDelegateCallVeneer(tp, __ch_delegate_fn1, func, p1);
 8008926:	493f      	ldr	r1, [pc, #252]	; (8008a24 <oslib_test_005_001_execute+0x154>)
 8008928:	2341      	movs	r3, #65	; 0x41
 800892a:	4a3f      	ldr	r2, [pc, #252]	; (8008a28 <oslib_test_005_001_execute+0x158>)
 800892c:	4628      	mov	r0, r5
 800892e:	f7fb ff37 	bl	80047a0 <chDelegateCallVeneer>
    test_assert(retval == (int)'A', "invalid return value");
 8008932:	f1a0 0041 	sub.w	r0, r0, #65	; 0x41
 8008936:	fab0 f080 	clz	r0, r0
 800893a:	4939      	ldr	r1, [pc, #228]	; (8008a20 <oslib_test_005_001_execute+0x150>)
 800893c:	0940      	lsrs	r0, r0, #5
 800893e:	f7f8 fa27 	bl	8000d90 <_test_assert>
 8008942:	2800      	cmp	r0, #0
 8008944:	d1ed      	bne.n	8008922 <oslib_test_005_001_execute+0x52>
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect2(thread_t *tp, delegate_fn2_t func,
                                          msg_t p1, msg_t p2) {

  return chDelegateCallVeneer(tp, __ch_delegate_fn2, func, p1, p2);
 8008946:	2243      	movs	r2, #67	; 0x43
 8008948:	4938      	ldr	r1, [pc, #224]	; (8008a2c <oslib_test_005_001_execute+0x15c>)
 800894a:	9200      	str	r2, [sp, #0]
 800894c:	2342      	movs	r3, #66	; 0x42
 800894e:	4a38      	ldr	r2, [pc, #224]	; (8008a30 <oslib_test_005_001_execute+0x160>)
 8008950:	4628      	mov	r0, r5
 8008952:	f7fb ff25 	bl	80047a0 <chDelegateCallVeneer>
    test_assert(retval == (int)'B', "invalid return value");
 8008956:	f1a0 0042 	sub.w	r0, r0, #66	; 0x42
 800895a:	fab0 f080 	clz	r0, r0
 800895e:	4930      	ldr	r1, [pc, #192]	; (8008a20 <oslib_test_005_001_execute+0x150>)
 8008960:	0940      	lsrs	r0, r0, #5
 8008962:	f7f8 fa15 	bl	8000d90 <_test_assert>
 8008966:	2800      	cmp	r0, #0
 8008968:	d1db      	bne.n	8008922 <oslib_test_005_001_execute+0x52>
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect3(thread_t *tp, delegate_fn3_t func,
                                          msg_t p1, msg_t p2, msg_t p3) {

  return chDelegateCallVeneer(tp, __ch_delegate_fn3, func, p1, p2, p3);
 800896a:	2345      	movs	r3, #69	; 0x45
 800896c:	2246      	movs	r2, #70	; 0x46
 800896e:	4931      	ldr	r1, [pc, #196]	; (8008a34 <oslib_test_005_001_execute+0x164>)
 8008970:	e9cd 3200 	strd	r3, r2, [sp]
 8008974:	4628      	mov	r0, r5
 8008976:	2344      	movs	r3, #68	; 0x44
 8008978:	4a2f      	ldr	r2, [pc, #188]	; (8008a38 <oslib_test_005_001_execute+0x168>)
 800897a:	f7fb ff11 	bl	80047a0 <chDelegateCallVeneer>
    test_assert(retval == (int)'D', "invalid return value");
 800897e:	f1a0 0044 	sub.w	r0, r0, #68	; 0x44
 8008982:	fab0 f080 	clz	r0, r0
 8008986:	4926      	ldr	r1, [pc, #152]	; (8008a20 <oslib_test_005_001_execute+0x150>)
 8008988:	0940      	lsrs	r0, r0, #5
 800898a:	f7f8 fa01 	bl	8000d90 <_test_assert>
 800898e:	2800      	cmp	r0, #0
 8008990:	d1c7      	bne.n	8008922 <oslib_test_005_001_execute+0x52>
 */
static inline msg_t chDelegateCallDirect4(thread_t *tp, delegate_fn4_t func,
                                          msg_t p1, msg_t p2, msg_t p3,
                                          msg_t p4) {

  return chDelegateCallVeneer(tp, __ch_delegate_fn4, func, p1, p2, p3, p4);
 8008992:	2148      	movs	r1, #72	; 0x48
 8008994:	2249      	movs	r2, #73	; 0x49
 8008996:	234a      	movs	r3, #74	; 0x4a
 8008998:	4628      	mov	r0, r5
 800899a:	e88d 000e 	stmia.w	sp, {r1, r2, r3}
 800899e:	4927      	ldr	r1, [pc, #156]	; (8008a3c <oslib_test_005_001_execute+0x16c>)
 80089a0:	2347      	movs	r3, #71	; 0x47
 80089a2:	4a27      	ldr	r2, [pc, #156]	; (8008a40 <oslib_test_005_001_execute+0x170>)
 80089a4:	f7fb fefc 	bl	80047a0 <chDelegateCallVeneer>
    test_assert(retval == (int)'G', "invalid return value");
 80089a8:	f1a0 0047 	sub.w	r0, r0, #71	; 0x47
 80089ac:	fab0 f080 	clz	r0, r0
 80089b0:	491b      	ldr	r1, [pc, #108]	; (8008a20 <oslib_test_005_001_execute+0x150>)
 80089b2:	0940      	lsrs	r0, r0, #5
 80089b4:	f7f8 f9ec 	bl	8000d90 <_test_assert>
 80089b8:	2800      	cmp	r0, #0
 80089ba:	d1b2      	bne.n	8008922 <oslib_test_005_001_execute+0x52>
  return chDelegateCallVeneer(tp, __ch_delegate_fn0, func);
 80089bc:	4916      	ldr	r1, [pc, #88]	; (8008a18 <oslib_test_005_001_execute+0x148>)
 80089be:	4a21      	ldr	r2, [pc, #132]	; (8008a44 <oslib_test_005_001_execute+0x174>)
 80089c0:	4628      	mov	r0, r5
 80089c2:	f7fb feed 	bl	80047a0 <chDelegateCallVeneer>
    test_assert(retval == 0xAA55, "invalid return value");
 80089c6:	f64a 2355 	movw	r3, #43605	; 0xaa55
 80089ca:	1ac0      	subs	r0, r0, r3
 80089cc:	fab0 f080 	clz	r0, r0
 80089d0:	4913      	ldr	r1, [pc, #76]	; (8008a20 <oslib_test_005_001_execute+0x150>)
 80089d2:	0940      	lsrs	r0, r0, #5
 80089d4:	f7f8 f9dc 	bl	8000d90 <_test_assert>
 80089d8:	2800      	cmp	r0, #0
 80089da:	d1a2      	bne.n	8008922 <oslib_test_005_001_execute+0x52>
    test_assert_sequence("0ABCDEFGHIJZ", "unexpected tokens");
 80089dc:	491a      	ldr	r1, [pc, #104]	; (8008a48 <oslib_test_005_001_execute+0x178>)
 80089de:	481b      	ldr	r0, [pc, #108]	; (8008a4c <oslib_test_005_001_execute+0x17c>)
 80089e0:	f7f8 fb56 	bl	8001090 <_test_assert_sequence>
 80089e4:	2800      	cmp	r0, #0
 80089e6:	d19c      	bne.n	8008922 <oslib_test_005_001_execute+0x52>
  test_set_step(3);
 80089e8:	2303      	movs	r3, #3
    msg_t msg = chThdWait(tp);
 80089ea:	4628      	mov	r0, r5
  test_set_step(3);
 80089ec:	6023      	str	r3, [r4, #0]
    msg_t msg = chThdWait(tp);
 80089ee:	f7ff fcff 	bl	80083f0 <chThdWait>
    test_assert(msg == 0x0FA5, "invalid exit code");
 80089f2:	f640 73a5 	movw	r3, #4005	; 0xfa5
 80089f6:	1ac3      	subs	r3, r0, r3
 80089f8:	4258      	negs	r0, r3
 80089fa:	4915      	ldr	r1, [pc, #84]	; (8008a50 <oslib_test_005_001_execute+0x180>)
 80089fc:	4158      	adcs	r0, r3
 80089fe:	f7f8 f9c7 	bl	8000d90 <_test_assert>
 8008a02:	e78e      	b.n	8008922 <oslib_test_005_001_execute+0x52>
 8008a04:	20001254 	.word	0x20001254
 8008a08:	20002180 	.word	0x20002180
 8008a0c:	0800b2dc 	.word	0x0800b2dc
 8008a10:	20001d94 	.word	0x20001d94
 8008a14:	08004e51 	.word	0x08004e51
 8008a18:	080009f1 	.word	0x080009f1
 8008a1c:	08000f21 	.word	0x08000f21
 8008a20:	0800b2e8 	.word	0x0800b2e8
 8008a24:	08000a01 	.word	0x08000a01
 8008a28:	08000f31 	.word	0x08000f31
 8008a2c:	08000a21 	.word	0x08000a21
 8008a30:	08000f41 	.word	0x08000f41
 8008a34:	08000a41 	.word	0x08000a41
 8008a38:	08000f61 	.word	0x08000f61
 8008a3c:	08000a61 	.word	0x08000a61
 8008a40:	08000f81 	.word	0x08000f81
 8008a44:	08000fb1 	.word	0x08000fb1
 8008a48:	0800b358 	.word	0x0800b358
 8008a4c:	0800b300 	.word	0x0800b300
 8008a50:	0800b310 	.word	0x0800b310
	...

08008a60 <oslib_test_004_001_execute>:
 * - [4.1.3] Sending jobs with various timings.
 * - [4.1.4] Sending two null jobs to make threads exit.
 * .
 */

static void oslib_test_004_001_execute(void) {
 8008a60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  mp->align = align;
 8008a64:	2304      	movs	r3, #4
  mp->next = NULL;
 8008a66:	2600      	movs	r6, #0
  mp->object_size = size;
 8008a68:	2708      	movs	r7, #8
  thread_t *tp1, *tp2;

  /* [4.1.1] Initializing the Jobs Queue object.*/
  test_set_step(1);
 8008a6a:	2501      	movs	r5, #1
  mp->next = NULL;
 8008a6c:	4c45      	ldr	r4, [pc, #276]	; (8008b84 <oslib_test_004_001_execute+0x124>)
 8008a6e:	f8df 8144 	ldr.w	r8, [pc, #324]	; 8008bb4 <oslib_test_004_001_execute+0x154>
static void oslib_test_004_001_execute(void) {
 8008a72:	b08c      	sub	sp, #48	; 0x30
 8008a74:	e9c4 6703 	strd	r6, r7, [r4, #12]
  chGuardedPoolLoadArray(&jqp->free, (void *)jobsbuf, jobsn);
 8008a78:	461a      	mov	r2, r3
 8008a7a:	4620      	mov	r0, r4
  mp->align = align;
 8008a7c:	6163      	str	r3, [r4, #20]
  mp->provider = provider;
 8008a7e:	61a6      	str	r6, [r4, #24]
 8008a80:	60a6      	str	r6, [r4, #8]
 8008a82:	4941      	ldr	r1, [pc, #260]	; (8008b88 <oslib_test_004_001_execute+0x128>)
 8008a84:	e9c4 4400 	strd	r4, r4, [r4]
  test_set_step(1);
 8008a88:	f8c8 5000 	str.w	r5, [r8]
 8008a8c:	f7fc ff10 	bl	80058b0 <chGuardedPoolLoadArray>
    chJobObjectInit(&jq, JOBS_QUEUE_SIZE, jobs, msg_queue);
  }
  test_end_step(1);

  /* [4.1.2] Starting the dispatcher threads.*/
  test_set_step(2);
 8008a90:	2002      	movs	r0, #2
  return ch.rlist.current;
 8008a92:	4d3e      	ldr	r5, [pc, #248]	; (8008b8c <oslib_test_004_001_execute+0x12c>)
 8008a94:	4b3e      	ldr	r3, [pc, #248]	; (8008b90 <oslib_test_004_001_execute+0x130>)
  return chThdGetSelfX()->prio;
 8008a96:	69aa      	ldr	r2, [r5, #24]
  {
    thread_descriptor_t td1 = {
 8008a98:	493e      	ldr	r1, [pc, #248]	; (8008b94 <oslib_test_004_001_execute+0x134>)
      .name  = "dispatcher1",
      .wbase = wa1Thread1,
      .wend  = THD_WORKING_AREA_END(wa1Thread1),
      .prio  = chThdGetPriorityX() - 1,
 8008a9a:	6892      	ldr	r2, [r2, #8]
 8008a9c:	61e3      	str	r3, [r4, #28]
  mbp->wrptr  = buf;
 8008a9e:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
  mbp->top    = &buf[n];
 8008aa2:	3310      	adds	r3, #16
 8008aa4:	6223      	str	r3, [r4, #32]
 8008aa6:	3a01      	subs	r2, #1
    thread_descriptor_t td1 = {
 8008aa8:	f501 73e4 	add.w	r3, r1, #456	; 0x1c8
 8008aac:	f8df c108 	ldr.w	ip, [pc, #264]	; 8008bb8 <oslib_test_004_001_execute+0x158>
 8008ab0:	4f39      	ldr	r7, [pc, #228]	; (8008b98 <oslib_test_004_001_execute+0x138>)
 8008ab2:	9209      	str	r2, [sp, #36]	; 0x24
 8008ab4:	9308      	str	r3, [sp, #32]
  tqp->next = (thread_t *)tqp;
 8008ab6:	f104 0234 	add.w	r2, r4, #52	; 0x34
 8008aba:	f104 033c 	add.w	r3, r4, #60	; 0x3c
  mbp->cnt    = (size_t)0;
 8008abe:	62e6      	str	r6, [r4, #44]	; 0x2c
  mbp->reset  = false;
 8008ac0:	f884 6030 	strb.w	r6, [r4, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 8008ac4:	e9c4 220d 	strd	r2, r2, [r4, #52]	; 0x34
 8008ac8:	e9c4 330f 	strd	r3, r3, [r4, #60]	; 0x3c
  test_set_step(2);
 8008acc:	f8c8 0000 	str.w	r0, [r8]
      .funcp = Thread1,
      .arg   = NULL
    };
    tp1 = chThdCreate(&td1);
 8008ad0:	a806      	add	r0, sp, #24
    thread_descriptor_t td1 = {
 8008ad2:	960b      	str	r6, [sp, #44]	; 0x2c
 8008ad4:	9107      	str	r1, [sp, #28]
 8008ad6:	f8cd c018 	str.w	ip, [sp, #24]
 8008ada:	970a      	str	r7, [sp, #40]	; 0x28
    tp1 = chThdCreate(&td1);
 8008adc:	f7fa fee0 	bl	80038a0 <chThdCreate>
 8008ae0:	69ab      	ldr	r3, [r5, #24]

    thread_descriptor_t td2 = {
 8008ae2:	4a2e      	ldr	r2, [pc, #184]	; (8008b9c <oslib_test_004_001_execute+0x13c>)
      .name  = "dispatcher2",
      .wbase = wa2Thread1,
      .wend  = THD_WORKING_AREA_END(wa2Thread1),
      .prio  = chThdGetPriorityX() - 2,
 8008ae4:	689b      	ldr	r3, [r3, #8]
    thread_descriptor_t td2 = {
 8008ae6:	492e      	ldr	r1, [pc, #184]	; (8008ba0 <oslib_test_004_001_execute+0x140>)
      .prio  = chThdGetPriorityX() - 2,
 8008ae8:	3b02      	subs	r3, #2
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008aea:	4625      	mov	r5, r4
    tp1 = chThdCreate(&td1);
 8008aec:	4681      	mov	r9, r0
    thread_descriptor_t td2 = {
 8008aee:	f502 74e4 	add.w	r4, r2, #456	; 0x1c8
      .funcp = Thread1,
      .arg   = NULL
    };
    tp2 = chThdCreate(&td2);
 8008af2:	4668      	mov	r0, sp
    thread_descriptor_t td2 = {
 8008af4:	9605      	str	r6, [sp, #20]
 8008af6:	9303      	str	r3, [sp, #12]
 8008af8:	9704      	str	r7, [sp, #16]
 8008afa:	e9cd 2401 	strd	r2, r4, [sp, #4]
 8008afe:	9100      	str	r1, [sp, #0]
    tp2 = chThdCreate(&td2);
 8008b00:	f7fa fece 	bl	80038a0 <chThdCreate>
  }
  test_end_step(2);

  /* [4.1.3] Sending jobs with various timings.*/
  test_set_step(3);
 8008b04:	2303      	movs	r3, #3
    tp2 = chThdCreate(&td2);
 8008b06:	4682      	mov	sl, r0
  test_set_step(3);
 8008b08:	2461      	movs	r4, #97	; 0x61
 8008b0a:	4f26      	ldr	r7, [pc, #152]	; (8008ba4 <oslib_test_004_001_execute+0x144>)
 8008b0c:	f8c8 3000 	str.w	r3, [r8]
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008b10:	f105 061c 	add.w	r6, r5, #28
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008b14:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008b18:	4628      	mov	r0, r5
 8008b1a:	f7fb f861 	bl	8003be0 <chGuardedPoolAllocTimeout>
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008b1e:	2200      	movs	r2, #0
    job_descriptor_t *jdp;

    for (i = 0; i < 8; i++) {
      jdp = chJobGet(&jq);
      jdp->jobfunc = job_slow;
      jdp->jobarg  = (void *)('a' + i);
 8008b20:	e9c0 7400 	strd	r7, r4, [r0]
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008b24:	4601      	mov	r1, r0
 8008b26:	3401      	adds	r4, #1
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008b28:	4630      	mov	r0, r6
 8008b2a:	f7fc ffb9 	bl	8005aa0 <chMBPostTimeout>
    for (i = 0; i < 8; i++) {
 8008b2e:	2c69      	cmp	r4, #105	; 0x69
 8008b30:	d1f0      	bne.n	8008b14 <oslib_test_004_001_execute+0xb4>
    }
  }
  test_end_step(3);

  /* [4.1.4] Sending two null jobs to make threads exit.*/
  test_set_step(4);
 8008b32:	2304      	movs	r3, #4
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008b34:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008b38:	4812      	ldr	r0, [pc, #72]	; (8008b84 <oslib_test_004_001_execute+0x124>)
 8008b3a:	f8c8 3000 	str.w	r3, [r8]
  {
    job_descriptor_t *jdp;

    jdp = chJobGet(&jq);
    jdp->jobfunc = NULL;
 8008b3e:	2400      	movs	r4, #0
 8008b40:	f7fb f84e 	bl	8003be0 <chGuardedPoolAllocTimeout>
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008b44:	4622      	mov	r2, r4
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008b46:	4601      	mov	r1, r0
    jdp->jobarg  = NULL;
 8008b48:	e9c0 4400 	strd	r4, r4, [r0]
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008b4c:	4816      	ldr	r0, [pc, #88]	; (8008ba8 <oslib_test_004_001_execute+0x148>)
 8008b4e:	f7fc ffa7 	bl	8005aa0 <chMBPostTimeout>
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008b52:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008b56:	480b      	ldr	r0, [pc, #44]	; (8008b84 <oslib_test_004_001_execute+0x124>)
 8008b58:	f7fb f842 	bl	8003be0 <chGuardedPoolAllocTimeout>
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008b5c:	4622      	mov	r2, r4
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008b5e:	4601      	mov	r1, r0
    chJobPost(&jq, jdp);
    jdp = chJobGet(&jq);
    jdp->jobfunc = NULL;
    jdp->jobarg  = NULL;
 8008b60:	e9c0 4400 	strd	r4, r4, [r0]
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008b64:	4810      	ldr	r0, [pc, #64]	; (8008ba8 <oslib_test_004_001_execute+0x148>)
 8008b66:	f7fc ff9b 	bl	8005aa0 <chMBPostTimeout>
    chJobPost(&jq, jdp);
    (void) chThdWait(tp1);
 8008b6a:	4648      	mov	r0, r9
 8008b6c:	f7ff fc40 	bl	80083f0 <chThdWait>
    (void) chThdWait(tp2);
 8008b70:	4650      	mov	r0, sl
 8008b72:	f7ff fc3d 	bl	80083f0 <chThdWait>
    test_assert_sequence("abcdefgh", "unexpected tokens");
 8008b76:	490d      	ldr	r1, [pc, #52]	; (8008bac <oslib_test_004_001_execute+0x14c>)
 8008b78:	480d      	ldr	r0, [pc, #52]	; (8008bb0 <oslib_test_004_001_execute+0x150>)
 8008b7a:	f7f8 fa89 	bl	8001090 <_test_assert_sequence>
  }
  test_end_step(4);
}
 8008b7e:	b00c      	add	sp, #48	; 0x30
 8008b80:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008b84:	200014dc 	.word	0x200014dc
 8008b88:	200014bc 	.word	0x200014bc
 8008b8c:	20001254 	.word	0x20001254
 8008b90:	20001540 	.word	0x20001540
 8008b94:	20001df0 	.word	0x20001df0
 8008b98:	08005a51 	.word	0x08005a51
 8008b9c:	20001fb8 	.word	0x20001fb8
 8008ba0:	0800b2c0 	.word	0x0800b2c0
 8008ba4:	08004091 	.word	0x08004091
 8008ba8:	200014f8 	.word	0x200014f8
 8008bac:	0800b358 	.word	0x0800b358
 8008bb0:	0800b388 	.word	0x0800b388
 8008bb4:	20001d94 	.word	0x20001d94
 8008bb8:	0800b2b4 	.word	0x0800b2b4
 8008bbc:	00000000 	.word	0x00000000

08008bc0 <rt_test_011_005_execute>:
  test_set_step(1);
 8008bc0:	2201      	movs	r2, #1
static void rt_test_011_005_execute(void) {
 8008bc2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 8008bc6:	4b17      	ldr	r3, [pc, #92]	; (8008c24 <rt_test_011_005_execute+0x64>)
  test_set_step(1);
 8008bc8:	f8df 906c 	ldr.w	r9, [pc, #108]	; 8008c38 <rt_test_011_005_execute+0x78>
  return chThdGetSelfX()->prio;
 8008bcc:	699b      	ldr	r3, [r3, #24]
 8008bce:	f8c9 2000 	str.w	r2, [r9]
  tprio_t prio = chThdGetPriorityX() - 1;
 8008bd2:	689d      	ldr	r5, [r3, #8]
    start = test_wait_tick();
 8008bd4:	f7fb fad4 	bl	8004180 <test_wait_tick>
    n = 0;
 8008bd8:	2400      	movs	r4, #0
    start = test_wait_tick();
 8008bda:	4680      	mov	r8, r0
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8008bdc:	4f12      	ldr	r7, [pc, #72]	; (8008c28 <rt_test_011_005_execute+0x68>)
 8008bde:	4e13      	ldr	r6, [pc, #76]	; (8008c2c <rt_test_011_005_execute+0x6c>)
  tprio_t prio = chThdGetPriorityX() - 1;
 8008be0:	3d01      	subs	r5, #1
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8008be2:	2300      	movs	r3, #0
 8008be4:	463a      	mov	r2, r7
 8008be6:	4629      	mov	r1, r5
 8008be8:	4630      	mov	r0, r6
 8008bea:	f7fa fda9 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008bee:	f7ff fbff 	bl	80083f0 <chThdWait>
 8008bf2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008bf6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      n++;
 8008bf8:	3401      	adds	r4, #1
 8008bfa:	eba3 0308 	sub.w	r3, r3, r8
    } while (chVTIsSystemTimeWithinX(start, end));
 8008bfe:	b29b      	uxth	r3, r3
 8008c00:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8008c04:	d3ed      	bcc.n	8008be2 <rt_test_011_005_execute+0x22>
  test_set_step(2);
 8008c06:	2302      	movs	r3, #2
    test_print("--- Score : ");
 8008c08:	4809      	ldr	r0, [pc, #36]	; (8008c30 <rt_test_011_005_execute+0x70>)
  test_set_step(2);
 8008c0a:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 8008c0e:	f7f8 fa27 	bl	8001060 <test_print>
    test_printn(n);
 8008c12:	4620      	mov	r0, r4
 8008c14:	f7f8 f954 	bl	8000ec0 <test_printn>
}
 8008c18:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" threads/S");
 8008c1c:	4805      	ldr	r0, [pc, #20]	; (8008c34 <rt_test_011_005_execute+0x74>)
 8008c1e:	f7f8 b9ff 	b.w	8001020 <test_println>
 8008c22:	bf00      	nop
 8008c24:	20001254 	.word	0x20001254
 8008c28:	08004ea1 	.word	0x08004ea1
 8008c2c:	20001680 	.word	0x20001680
 8008c30:	0800c4fc 	.word	0x0800c4fc
 8008c34:	0800c4a0 	.word	0x0800c4a0
 8008c38:	20001d94 	.word	0x20001d94
 8008c3c:	00000000 	.word	0x00000000

08008c40 <test_wait_threads>:
void test_wait_threads(void) {
 8008c40:	b570      	push	{r4, r5, r6, lr}
      threads[i] = NULL;
 8008c42:	2600      	movs	r6, #0
 8008c44:	4c06      	ldr	r4, [pc, #24]	; (8008c60 <test_wait_threads+0x20>)
 8008c46:	f104 0514 	add.w	r5, r4, #20
    if (threads[i] != NULL) {
 8008c4a:	f854 0b04 	ldr.w	r0, [r4], #4
 8008c4e:	b118      	cbz	r0, 8008c58 <test_wait_threads+0x18>
      chThdWait(threads[i]);
 8008c50:	f7ff fbce 	bl	80083f0 <chThdWait>
      threads[i] = NULL;
 8008c54:	f844 6c04 	str.w	r6, [r4, #-4]
  for (i = 0; i < MAX_THREADS; i++)
 8008c58:	42ac      	cmp	r4, r5
 8008c5a:	d1f6      	bne.n	8008c4a <test_wait_threads+0xa>
}
 8008c5c:	bd70      	pop	{r4, r5, r6, pc}
 8008c5e:	bf00      	nop
 8008c60:	20001dac 	.word	0x20001dac
	...

08008c70 <rt_test_011_008_execute>:
  test_set_step(1);
 8008c70:	2201      	movs	r2, #1
    n = 0;
 8008c72:	2300      	movs	r3, #0
static void rt_test_011_008_execute(void) {
 8008c74:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 8008c78:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8008d4c <rt_test_011_008_execute+0xdc>
 8008c7c:	b083      	sub	sp, #12
  test_set_step(1);
 8008c7e:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8008d50 <rt_test_011_008_execute+0xe0>
    n = 0;
 8008c82:	ac02      	add	r4, sp, #8
 8008c84:	f844 3d04 	str.w	r3, [r4, #-4]!
  test_set_step(1);
 8008c88:	f8c9 2000 	str.w	r2, [r9]
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8008c8c:	f7fb fa78 	bl	8004180 <test_wait_tick>
  return chThdGetSelfX()->prio;
 8008c90:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8008c94:	4f28      	ldr	r7, [pc, #160]	; (8008d38 <rt_test_011_008_execute+0xc8>)
 8008c96:	4e29      	ldr	r6, [pc, #164]	; (8008d3c <rt_test_011_008_execute+0xcc>)
 8008c98:	6899      	ldr	r1, [r3, #8]
 8008c9a:	463a      	mov	r2, r7
 8008c9c:	4623      	mov	r3, r4
 8008c9e:	3901      	subs	r1, #1
 8008ca0:	4630      	mov	r0, r6
 8008ca2:	f7fa fd4d 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008ca6:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8008caa:	4d25      	ldr	r5, [pc, #148]	; (8008d40 <rt_test_011_008_execute+0xd0>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8008cac:	6899      	ldr	r1, [r3, #8]
 8008cae:	463a      	mov	r2, r7
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8008cb0:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8008cb2:	4623      	mov	r3, r4
 8008cb4:	3901      	subs	r1, #1
 8008cb6:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 8008cba:	f7fa fd41 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008cbe:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8008cc2:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8008cc4:	6899      	ldr	r1, [r3, #8]
 8008cc6:	463a      	mov	r2, r7
 8008cc8:	4623      	mov	r3, r4
 8008cca:	3901      	subs	r1, #1
 8008ccc:	f506 7024 	add.w	r0, r6, #656	; 0x290
 8008cd0:	f7fa fd36 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008cd4:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8008cd8:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8008cda:	6899      	ldr	r1, [r3, #8]
 8008cdc:	463a      	mov	r2, r7
 8008cde:	4623      	mov	r3, r4
 8008ce0:	3901      	subs	r1, #1
 8008ce2:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
 8008ce6:	f7fa fd2b 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008cea:	f8d8 3018 	ldr.w	r3, [r8, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8008cee:	463a      	mov	r2, r7
 8008cf0:	6899      	ldr	r1, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8008cf2:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8008cf4:	3901      	subs	r1, #1
 8008cf6:	4623      	mov	r3, r4
 8008cf8:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
 8008cfc:	f7fa fd20 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(2);
 8008d00:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8008d02:	6128      	str	r0, [r5, #16]
    chThdSleepSeconds(1);
 8008d04:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
  test_set_step(2);
 8008d08:	f8c9 3000 	str.w	r3, [r9]
    chThdSleepSeconds(1);
 8008d0c:	f7fb f998 	bl	8004040 <chThdSleep>
    test_terminate_threads();
 8008d10:	f7f8 f886 	bl	8000e20 <test_terminate_threads>
    test_wait_threads();
 8008d14:	f7ff ff94 	bl	8008c40 <test_wait_threads>
  test_set_step(3);
 8008d18:	2303      	movs	r3, #3
    test_print("--- Score : ");
 8008d1a:	480a      	ldr	r0, [pc, #40]	; (8008d44 <rt_test_011_008_execute+0xd4>)
  test_set_step(3);
 8008d1c:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 8008d20:	f7f8 f99e 	bl	8001060 <test_print>
    test_printn(n);
 8008d24:	9801      	ldr	r0, [sp, #4]
 8008d26:	f7f8 f8cb 	bl	8000ec0 <test_printn>
    test_println(" ctxswc/S");
 8008d2a:	4807      	ldr	r0, [pc, #28]	; (8008d48 <rt_test_011_008_execute+0xd8>)
 8008d2c:	f7f8 f978 	bl	8001020 <test_println>
}
 8008d30:	b003      	add	sp, #12
 8008d32:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008d36:	bf00      	nop
 8008d38:	080036b1 	.word	0x080036b1
 8008d3c:	20001680 	.word	0x20001680
 8008d40:	20001dac 	.word	0x20001dac
 8008d44:	0800c4fc 	.word	0x0800c4fc
 8008d48:	0800c4e0 	.word	0x0800c4e0
 8008d4c:	20001254 	.word	0x20001254
 8008d50:	20001d94 	.word	0x20001d94
	...

08008d60 <rt_test_011_007_execute>:
static void rt_test_011_007_execute(void) {
 8008d60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8008d64:	2401      	movs	r4, #1
  return ch.rlist.current;
 8008d66:	4d34      	ldr	r5, [pc, #208]	; (8008e38 <rt_test_011_007_execute+0xd8>)
 8008d68:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8008e68 <rt_test_011_007_execute+0x108>
  return chThdGetSelfX()->prio;
 8008d6c:	69aa      	ldr	r2, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8008d6e:	2300      	movs	r3, #0
 8008d70:	6891      	ldr	r1, [r2, #8]
 8008d72:	4832      	ldr	r0, [pc, #200]	; (8008e3c <rt_test_011_007_execute+0xdc>)
 8008d74:	4a32      	ldr	r2, [pc, #200]	; (8008e40 <rt_test_011_007_execute+0xe0>)
 8008d76:	3105      	adds	r1, #5
  test_set_step(1);
 8008d78:	f8c8 4000 	str.w	r4, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8008d7c:	f7fa fce0 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008d80:	69ab      	ldr	r3, [r5, #24]
 8008d82:	4c30      	ldr	r4, [pc, #192]	; (8008e44 <rt_test_011_007_execute+0xe4>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 8008d84:	6899      	ldr	r1, [r3, #8]
 8008d86:	4a2e      	ldr	r2, [pc, #184]	; (8008e40 <rt_test_011_007_execute+0xe0>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8008d88:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 8008d8a:	3104      	adds	r1, #4
 8008d8c:	2300      	movs	r3, #0
 8008d8e:	482e      	ldr	r0, [pc, #184]	; (8008e48 <rt_test_011_007_execute+0xe8>)
 8008d90:	f7fa fcd6 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008d94:	69ab      	ldr	r3, [r5, #24]
 8008d96:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 8008d98:	6899      	ldr	r1, [r3, #8]
 8008d9a:	4a29      	ldr	r2, [pc, #164]	; (8008e40 <rt_test_011_007_execute+0xe0>)
 8008d9c:	2300      	movs	r3, #0
 8008d9e:	3103      	adds	r1, #3
 8008da0:	482a      	ldr	r0, [pc, #168]	; (8008e4c <rt_test_011_007_execute+0xec>)
 8008da2:	f7fa fccd 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008da6:	69ab      	ldr	r3, [r5, #24]
 8008da8:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 8008daa:	6899      	ldr	r1, [r3, #8]
 8008dac:	4a24      	ldr	r2, [pc, #144]	; (8008e40 <rt_test_011_007_execute+0xe0>)
 8008dae:	2300      	movs	r3, #0
 8008db0:	3102      	adds	r1, #2
 8008db2:	4827      	ldr	r0, [pc, #156]	; (8008e50 <rt_test_011_007_execute+0xf0>)
 8008db4:	f7fa fcc4 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008db8:	69ab      	ldr	r3, [r5, #24]
 8008dba:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 8008dbc:	6899      	ldr	r1, [r3, #8]
 8008dbe:	4a20      	ldr	r2, [pc, #128]	; (8008e40 <rt_test_011_007_execute+0xe0>)
 8008dc0:	2300      	movs	r3, #0
 8008dc2:	3101      	adds	r1, #1
 8008dc4:	4823      	ldr	r0, [pc, #140]	; (8008e54 <rt_test_011_007_execute+0xf4>)
 8008dc6:	f7fa fcbb 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(2);
 8008dca:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 8008dcc:	6120      	str	r0, [r4, #16]
  test_set_step(2);
 8008dce:	f8c8 3000 	str.w	r3, [r8]
    start = test_wait_tick();
 8008dd2:	f7fb f9d5 	bl	8004180 <test_wait_tick>
    n = 0;
 8008dd6:	2400      	movs	r4, #0
    start = test_wait_tick();
 8008dd8:	4607      	mov	r7, r0
 8008dda:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 8008dde:	4d1e      	ldr	r5, [pc, #120]	; (8008e58 <rt_test_011_007_execute+0xf8>)
 8008de0:	2100      	movs	r1, #0
 8008de2:	4628      	mov	r0, r5
 8008de4:	f7fc f894 	bl	8004f10 <chSemResetWithMessage.constprop.66>
 8008de8:	6a73      	ldr	r3, [r6, #36]	; 0x24
      n++;
 8008dea:	3401      	adds	r4, #1
 8008dec:	1bdb      	subs	r3, r3, r7
    } while (chVTIsSystemTimeWithinX(start, end));
 8008dee:	b29b      	uxth	r3, r3
 8008df0:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8008df4:	d3f4      	bcc.n	8008de0 <rt_test_011_007_execute+0x80>
  test_set_step(3);
 8008df6:	2303      	movs	r3, #3
 8008df8:	f8c8 3000 	str.w	r3, [r8]
    test_terminate_threads();
 8008dfc:	f7f8 f810 	bl	8000e20 <test_terminate_threads>
 8008e00:	2100      	movs	r1, #0
 8008e02:	4815      	ldr	r0, [pc, #84]	; (8008e58 <rt_test_011_007_execute+0xf8>)
 8008e04:	f7fc f884 	bl	8004f10 <chSemResetWithMessage.constprop.66>
    test_wait_threads();
 8008e08:	f7ff ff1a 	bl	8008c40 <test_wait_threads>
  test_set_step(4);
 8008e0c:	2304      	movs	r3, #4
    test_print("--- Score : ");
 8008e0e:	4813      	ldr	r0, [pc, #76]	; (8008e5c <rt_test_011_007_execute+0xfc>)
  test_set_step(4);
 8008e10:	f8c8 3000 	str.w	r3, [r8]
    test_print("--- Score : ");
 8008e14:	f7f8 f924 	bl	8001060 <test_print>
    test_printn(n);
 8008e18:	4620      	mov	r0, r4
 8008e1a:	f7f8 f851 	bl	8000ec0 <test_printn>
    test_printn(n * 6);
 8008e1e:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    test_print(" reschedules/S, ");
 8008e22:	480f      	ldr	r0, [pc, #60]	; (8008e60 <rt_test_011_007_execute+0x100>)
 8008e24:	f7f8 f91c 	bl	8001060 <test_print>
    test_printn(n * 6);
 8008e28:	0060      	lsls	r0, r4, #1
 8008e2a:	f7f8 f849 	bl	8000ec0 <test_printn>
}
 8008e2e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_println(" ctxswc/S");
 8008e32:	480c      	ldr	r0, [pc, #48]	; (8008e64 <rt_test_011_007_execute+0x104>)
 8008e34:	f7f8 b8f4 	b.w	8001020 <test_println>
 8008e38:	20001254 	.word	0x20001254
 8008e3c:	20001680 	.word	0x20001680
 8008e40:	08004ae1 	.word	0x08004ae1
 8008e44:	20001dac 	.word	0x20001dac
 8008e48:	200017c8 	.word	0x200017c8
 8008e4c:	20001910 	.word	0x20001910
 8008e50:	20001a58 	.word	0x20001a58
 8008e54:	20001ba0 	.word	0x20001ba0
 8008e58:	2000166c 	.word	0x2000166c
 8008e5c:	0800c4fc 	.word	0x0800c4fc
 8008e60:	0800c4bc 	.word	0x0800c4bc
 8008e64:	0800c4e0 	.word	0x0800c4e0
 8008e68:	20001d94 	.word	0x20001d94
 8008e6c:	00000000 	.word	0x00000000

08008e70 <rt_test_011_004_execute>:
  return ch.rlist.current;
 8008e70:	4b2b      	ldr	r3, [pc, #172]	; (8008f20 <rt_test_011_004_execute+0xb0>)
static void rt_test_011_004_execute(void) {
 8008e72:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  test_set_step(1);
 8008e76:	2401      	movs	r4, #1
  return chThdGetSelfX()->prio;
 8008e78:	699a      	ldr	r2, [r3, #24]
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8008e7a:	2300      	movs	r3, #0
 8008e7c:	6891      	ldr	r1, [r2, #8]
  test_set_step(1);
 8008e7e:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 8008f38 <rt_test_011_004_execute+0xc8>
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8008e82:	4421      	add	r1, r4
 8008e84:	4a27      	ldr	r2, [pc, #156]	; (8008f24 <rt_test_011_004_execute+0xb4>)
 8008e86:	4828      	ldr	r0, [pc, #160]	; (8008f28 <rt_test_011_004_execute+0xb8>)
    n = 0;
 8008e88:	461d      	mov	r5, r3
  test_set_step(1);
 8008e8a:	f8ca 4000 	str.w	r4, [sl]
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8008e8e:	f7fa fc57 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(2);
 8008e92:	2202      	movs	r2, #2
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8008e94:	4b25      	ldr	r3, [pc, #148]	; (8008f2c <rt_test_011_004_execute+0xbc>)
 8008e96:	4604      	mov	r4, r0
  test_set_step(2);
 8008e98:	f8ca 2000 	str.w	r2, [sl]
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8008e9c:	6018      	str	r0, [r3, #0]
    start = test_wait_tick();
 8008e9e:	f7fb f96f 	bl	8004180 <test_wait_tick>
      chSchWakeupS(tp, MSG_OK);
 8008ea2:	462e      	mov	r6, r5
    start = test_wait_tick();
 8008ea4:	4681      	mov	r9, r0
 8008ea6:	2720      	movs	r7, #32
 8008ea8:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 8008eac:	f387 8811 	msr	BASEPRI, r7
      chSchWakeupS(tp, MSG_OK);
 8008eb0:	2100      	movs	r1, #0
 8008eb2:	4620      	mov	r0, r4
 8008eb4:	f7fa fc14 	bl	80036e0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8008eb8:	4620      	mov	r0, r4
 8008eba:	2100      	movs	r1, #0
 8008ebc:	f7fa fc10 	bl	80036e0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8008ec0:	4620      	mov	r0, r4
 8008ec2:	2100      	movs	r1, #0
 8008ec4:	f7fa fc0c 	bl	80036e0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8008ec8:	4620      	mov	r0, r4
 8008eca:	2100      	movs	r1, #0
 8008ecc:	f7fa fc08 	bl	80036e0 <chSchWakeupS>
 8008ed0:	f386 8811 	msr	BASEPRI, r6
 8008ed4:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
      n += 4;
 8008ed8:	3504      	adds	r5, #4
 8008eda:	eba3 0309 	sub.w	r3, r3, r9
    } while (chVTIsSystemTimeWithinX(start, end));
 8008ede:	b29b      	uxth	r3, r3
 8008ee0:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8008ee4:	d3e2      	bcc.n	8008eac <rt_test_011_004_execute+0x3c>
  test_set_step(3);
 8008ee6:	2303      	movs	r3, #3
 8008ee8:	f8ca 3000 	str.w	r3, [sl]
 8008eec:	f387 8811 	msr	BASEPRI, r7
    chSchWakeupS(tp, MSG_TIMEOUT);
 8008ef0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008ef4:	4620      	mov	r0, r4
 8008ef6:	f7fa fbf3 	bl	80036e0 <chSchWakeupS>
 8008efa:	f386 8811 	msr	BASEPRI, r6
    test_wait_threads();
 8008efe:	f7ff fe9f 	bl	8008c40 <test_wait_threads>
  test_set_step(4);
 8008f02:	2304      	movs	r3, #4
    test_print("--- Score : ");
 8008f04:	480a      	ldr	r0, [pc, #40]	; (8008f30 <rt_test_011_004_execute+0xc0>)
  test_set_step(4);
 8008f06:	f8ca 3000 	str.w	r3, [sl]
    test_print("--- Score : ");
 8008f0a:	f7f8 f8a9 	bl	8001060 <test_print>
    test_printn(n * 2);
 8008f0e:	0068      	lsls	r0, r5, #1
 8008f10:	f7f7 ffd6 	bl	8000ec0 <test_printn>
}
 8008f14:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    test_println(" ctxswc/S");
 8008f18:	4806      	ldr	r0, [pc, #24]	; (8008f34 <rt_test_011_004_execute+0xc4>)
 8008f1a:	f7f8 b881 	b.w	8001020 <test_println>
 8008f1e:	bf00      	nop
 8008f20:	20001254 	.word	0x20001254
 8008f24:	080039a1 	.word	0x080039a1
 8008f28:	20001680 	.word	0x20001680
 8008f2c:	20001dac 	.word	0x20001dac
 8008f30:	0800c4fc 	.word	0x0800c4fc
 8008f34:	0800c4e0 	.word	0x0800c4e0
 8008f38:	20001d94 	.word	0x20001d94
 8008f3c:	00000000 	.word	0x00000000

08008f40 <rt_test_011_003_execute>:
static void rt_test_011_003_execute(void) {
 8008f40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8008f44:	2401      	movs	r4, #1
  return ch.rlist.current;
 8008f46:	4e2b      	ldr	r6, [pc, #172]	; (8008ff4 <rt_test_011_003_execute+0xb4>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8008f48:	4d2b      	ldr	r5, [pc, #172]	; (8008ff8 <rt_test_011_003_execute+0xb8>)
  return chThdGetSelfX()->prio;
 8008f4a:	69b3      	ldr	r3, [r6, #24]
  test_set_step(1);
 8008f4c:	4f2b      	ldr	r7, [pc, #172]	; (8008ffc <rt_test_011_003_execute+0xbc>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8008f4e:	6899      	ldr	r1, [r3, #8]
 8008f50:	4628      	mov	r0, r5
 8008f52:	4421      	add	r1, r4
 8008f54:	2300      	movs	r3, #0
 8008f56:	4a2a      	ldr	r2, [pc, #168]	; (8009000 <rt_test_011_003_execute+0xc0>)
  test_set_step(1);
 8008f58:	603c      	str	r4, [r7, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8008f5a:	f7fa fbf1 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(2);
 8008f5e:	f04f 0c02 	mov.w	ip, #2
 8008f62:	69b3      	ldr	r3, [r6, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8008f64:	4c27      	ldr	r4, [pc, #156]	; (8009004 <rt_test_011_003_execute+0xc4>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8008f66:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 8009014 <rt_test_011_003_execute+0xd4>
 8008f6a:	6899      	ldr	r1, [r3, #8]
 8008f6c:	4642      	mov	r2, r8
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8008f6e:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8008f70:	3902      	subs	r1, #2
 8008f72:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 8008f76:	2300      	movs	r3, #0
  test_set_step(2);
 8008f78:	f8c7 c000 	str.w	ip, [r7]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8008f7c:	f7fa fbe0 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008f80:	69b3      	ldr	r3, [r6, #24]
 8008f82:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8008f84:	6899      	ldr	r1, [r3, #8]
 8008f86:	4642      	mov	r2, r8
 8008f88:	3903      	subs	r1, #3
 8008f8a:	f505 7024 	add.w	r0, r5, #656	; 0x290
 8008f8e:	2300      	movs	r3, #0
 8008f90:	f7fa fbd6 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008f94:	69b3      	ldr	r3, [r6, #24]
 8008f96:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 8008f98:	6899      	ldr	r1, [r3, #8]
 8008f9a:	4642      	mov	r2, r8
 8008f9c:	3904      	subs	r1, #4
 8008f9e:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
 8008fa2:	2300      	movs	r3, #0
 8008fa4:	f7fa fbcc 	bl	8003740 <chThdCreateStatic.constprop.68>
 8008fa8:	69b3      	ldr	r3, [r6, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8008faa:	4642      	mov	r2, r8
 8008fac:	6899      	ldr	r1, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 8008fae:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8008fb0:	3905      	subs	r1, #5
 8008fb2:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
 8008fb6:	2300      	movs	r3, #0
 8008fb8:	f7fa fbc2 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(3);
 8008fbc:	2303      	movs	r3, #3
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8008fbe:	6120      	str	r0, [r4, #16]
    n = msg_loop_test(threads[0]);
 8008fc0:	6820      	ldr	r0, [r4, #0]
  test_set_step(3);
 8008fc2:	603b      	str	r3, [r7, #0]
    n = msg_loop_test(threads[0]);
 8008fc4:	f7fb fbb4 	bl	8004730 <msg_loop_test>
 8008fc8:	4604      	mov	r4, r0
    test_wait_threads();
 8008fca:	f7ff fe39 	bl	8008c40 <test_wait_threads>
  test_set_step(4);
 8008fce:	2304      	movs	r3, #4
    test_print("--- Score : ");
 8008fd0:	480d      	ldr	r0, [pc, #52]	; (8009008 <rt_test_011_003_execute+0xc8>)
  test_set_step(4);
 8008fd2:	603b      	str	r3, [r7, #0]
    test_print("--- Score : ");
 8008fd4:	f7f8 f844 	bl	8001060 <test_print>
    test_printn(n);
 8008fd8:	4620      	mov	r0, r4
 8008fda:	f7f7 ff71 	bl	8000ec0 <test_printn>
    test_print(" msgs/S, ");
 8008fde:	480b      	ldr	r0, [pc, #44]	; (800900c <rt_test_011_003_execute+0xcc>)
 8008fe0:	f7f8 f83e 	bl	8001060 <test_print>
    test_printn(n << 1);
 8008fe4:	0060      	lsls	r0, r4, #1
 8008fe6:	f7f7 ff6b 	bl	8000ec0 <test_printn>
}
 8008fea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_println(" ctxswc/S");
 8008fee:	4808      	ldr	r0, [pc, #32]	; (8009010 <rt_test_011_003_execute+0xd0>)
 8008ff0:	f7f8 b816 	b.w	8001020 <test_println>
 8008ff4:	20001254 	.word	0x20001254
 8008ff8:	20001680 	.word	0x20001680
 8008ffc:	20001d94 	.word	0x20001d94
 8009000:	080046c1 	.word	0x080046c1
 8009004:	20001dac 	.word	0x20001dac
 8009008:	0800c4fc 	.word	0x0800c4fc
 800900c:	0800c464 	.word	0x0800c464
 8009010:	0800c4e0 	.word	0x0800c4e0
 8009014:	08004ea1 	.word	0x08004ea1
	...

08009020 <rt_test_011_002_execute>:
static void rt_test_011_002_execute(void) {
 8009020:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 8009022:	2501      	movs	r5, #1
  return ch.rlist.current;
 8009024:	4b13      	ldr	r3, [pc, #76]	; (8009074 <rt_test_011_002_execute+0x54>)
 8009026:	4c14      	ldr	r4, [pc, #80]	; (8009078 <rt_test_011_002_execute+0x58>)
  return chThdGetSelfX()->prio;
 8009028:	699a      	ldr	r2, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800902a:	4814      	ldr	r0, [pc, #80]	; (800907c <rt_test_011_002_execute+0x5c>)
 800902c:	6891      	ldr	r1, [r2, #8]
 800902e:	2300      	movs	r3, #0
 8009030:	4429      	add	r1, r5
 8009032:	4a13      	ldr	r2, [pc, #76]	; (8009080 <rt_test_011_002_execute+0x60>)
  test_set_step(1);
 8009034:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8009036:	f7fa fb83 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(2);
 800903a:	2202      	movs	r2, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800903c:	4b11      	ldr	r3, [pc, #68]	; (8009084 <rt_test_011_002_execute+0x64>)
  test_set_step(2);
 800903e:	6022      	str	r2, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8009040:	6018      	str	r0, [r3, #0]
    n = msg_loop_test(threads[0]);
 8009042:	f7fb fb75 	bl	8004730 <msg_loop_test>
 8009046:	4605      	mov	r5, r0
    test_wait_threads();
 8009048:	f7ff fdfa 	bl	8008c40 <test_wait_threads>
  test_set_step(3);
 800904c:	2303      	movs	r3, #3
    test_print("--- Score : ");
 800904e:	480e      	ldr	r0, [pc, #56]	; (8009088 <rt_test_011_002_execute+0x68>)
  test_set_step(3);
 8009050:	6023      	str	r3, [r4, #0]
    test_print("--- Score : ");
 8009052:	f7f8 f805 	bl	8001060 <test_print>
    test_printn(n);
 8009056:	4628      	mov	r0, r5
 8009058:	f7f7 ff32 	bl	8000ec0 <test_printn>
    test_print(" msgs/S, ");
 800905c:	480b      	ldr	r0, [pc, #44]	; (800908c <rt_test_011_002_execute+0x6c>)
 800905e:	f7f7 ffff 	bl	8001060 <test_print>
    test_printn(n << 1);
 8009062:	0068      	lsls	r0, r5, #1
 8009064:	f7f7 ff2c 	bl	8000ec0 <test_printn>
}
 8009068:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println(" ctxswc/S");
 800906c:	4808      	ldr	r0, [pc, #32]	; (8009090 <rt_test_011_002_execute+0x70>)
 800906e:	f7f7 bfd7 	b.w	8001020 <test_println>
 8009072:	bf00      	nop
 8009074:	20001254 	.word	0x20001254
 8009078:	20001d94 	.word	0x20001d94
 800907c:	20001680 	.word	0x20001680
 8009080:	080046c1 	.word	0x080046c1
 8009084:	20001dac 	.word	0x20001dac
 8009088:	0800c4fc 	.word	0x0800c4fc
 800908c:	0800c464 	.word	0x0800c464
 8009090:	0800c4e0 	.word	0x0800c4e0
	...

080090a0 <rt_test_011_001_execute>:
static void rt_test_011_001_execute(void) {
 80090a0:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 80090a2:	2501      	movs	r5, #1
  return ch.rlist.current;
 80090a4:	4b13      	ldr	r3, [pc, #76]	; (80090f4 <rt_test_011_001_execute+0x54>)
 80090a6:	4c14      	ldr	r4, [pc, #80]	; (80090f8 <rt_test_011_001_execute+0x58>)
  return chThdGetSelfX()->prio;
 80090a8:	699a      	ldr	r2, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80090aa:	4814      	ldr	r0, [pc, #80]	; (80090fc <rt_test_011_001_execute+0x5c>)
 80090ac:	6891      	ldr	r1, [r2, #8]
 80090ae:	2300      	movs	r3, #0
 80090b0:	3901      	subs	r1, #1
 80090b2:	4a13      	ldr	r2, [pc, #76]	; (8009100 <rt_test_011_001_execute+0x60>)
  test_set_step(1);
 80090b4:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80090b6:	f7fa fb43 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(2);
 80090ba:	2202      	movs	r2, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80090bc:	4b11      	ldr	r3, [pc, #68]	; (8009104 <rt_test_011_001_execute+0x64>)
  test_set_step(2);
 80090be:	6022      	str	r2, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80090c0:	6018      	str	r0, [r3, #0]
    n = msg_loop_test(threads[0]);
 80090c2:	f7fb fb35 	bl	8004730 <msg_loop_test>
 80090c6:	4605      	mov	r5, r0
    test_wait_threads();
 80090c8:	f7ff fdba 	bl	8008c40 <test_wait_threads>
  test_set_step(3);
 80090cc:	2303      	movs	r3, #3
    test_print("--- Score : ");
 80090ce:	480e      	ldr	r0, [pc, #56]	; (8009108 <rt_test_011_001_execute+0x68>)
  test_set_step(3);
 80090d0:	6023      	str	r3, [r4, #0]
    test_print("--- Score : ");
 80090d2:	f7f7 ffc5 	bl	8001060 <test_print>
    test_printn(n);
 80090d6:	4628      	mov	r0, r5
 80090d8:	f7f7 fef2 	bl	8000ec0 <test_printn>
    test_print(" msgs/S, ");
 80090dc:	480b      	ldr	r0, [pc, #44]	; (800910c <rt_test_011_001_execute+0x6c>)
 80090de:	f7f7 ffbf 	bl	8001060 <test_print>
    test_printn(n << 1);
 80090e2:	0068      	lsls	r0, r5, #1
 80090e4:	f7f7 feec 	bl	8000ec0 <test_printn>
}
 80090e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println(" ctxswc/S");
 80090ec:	4808      	ldr	r0, [pc, #32]	; (8009110 <rt_test_011_001_execute+0x70>)
 80090ee:	f7f7 bf97 	b.w	8001020 <test_println>
 80090f2:	bf00      	nop
 80090f4:	20001254 	.word	0x20001254
 80090f8:	20001d94 	.word	0x20001d94
 80090fc:	20001680 	.word	0x20001680
 8009100:	080046c1 	.word	0x080046c1
 8009104:	20001dac 	.word	0x20001dac
 8009108:	0800c4fc 	.word	0x0800c4fc
 800910c:	0800c464 	.word	0x0800c464
 8009110:	0800c4e0 	.word	0x0800c4e0
	...

08009120 <rt_test_010_002_execute>:
static void rt_test_010_002_execute(void) {
  unsigned i;
  tprio_t prio;

  /* [10.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 8009120:	2001      	movs	r0, #1
static void rt_test_010_002_execute(void) {
 8009122:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009124:	2720      	movs	r7, #32
 8009126:	2600      	movs	r6, #0
  test_set_step(1);
 8009128:	4d3b      	ldr	r5, [pc, #236]	; (8009218 <rt_test_010_002_execute+0xf8>)
 800912a:	4b3c      	ldr	r3, [pc, #240]	; (800921c <rt_test_010_002_execute+0xfc>)
 800912c:	4a3c      	ldr	r2, [pc, #240]	; (8009220 <rt_test_010_002_execute+0x100>)
 800912e:	493d      	ldr	r1, [pc, #244]	; (8009224 <rt_test_010_002_execute+0x104>)
 8009130:	6028      	str	r0, [r5, #0]
 8009132:	f103 040c 	add.w	r4, r3, #12
 8009136:	f387 8811 	msr	BASEPRI, r7
  php->next = mp->next;
 800913a:	6808      	ldr	r0, [r1, #0]
 800913c:	6010      	str	r0, [r2, #0]
  mp->next = php;
 800913e:	600a      	str	r2, [r1, #0]
 8009140:	f386 8811 	msr	BASEPRI, r6
  {
    for (i = 0; i < 4; i++)
 8009144:	429c      	cmp	r4, r3
 8009146:	d002      	beq.n	800914e <rt_test_010_002_execute+0x2e>
 8009148:	f853 2b04 	ldr.w	r2, [r3], #4
 800914c:	e7f3      	b.n	8009136 <rt_test_010_002_execute+0x16>
    prio = chThdGetPriorityX();
  }
  test_end_step(2);

  /* [10.2.3] Creating the five threads.*/
  test_set_step(3);
 800914e:	2303      	movs	r3, #3
  return ch.rlist.current;
 8009150:	4935      	ldr	r1, [pc, #212]	; (8009228 <rt_test_010_002_execute+0x108>)
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8009152:	4a36      	ldr	r2, [pc, #216]	; (800922c <rt_test_010_002_execute+0x10c>)
  return chThdGetSelfX()->prio;
 8009154:	6989      	ldr	r1, [r1, #24]
 8009156:	4836      	ldr	r0, [pc, #216]	; (8009230 <rt_test_010_002_execute+0x110>)
 8009158:	688e      	ldr	r6, [r1, #8]
  test_set_step(3);
 800915a:	602b      	str	r3, [r5, #0]
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 800915c:	1e71      	subs	r1, r6, #1
 800915e:	f7fa fb4f 	bl	8003800 <chThdCreateFromMemoryPool.constprop.40>
 8009162:	4c34      	ldr	r4, [pc, #208]	; (8009234 <rt_test_010_002_execute+0x114>)
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8009164:	1eb1      	subs	r1, r6, #2
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8009166:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8009168:	4a33      	ldr	r2, [pc, #204]	; (8009238 <rt_test_010_002_execute+0x118>)
 800916a:	4834      	ldr	r0, [pc, #208]	; (800923c <rt_test_010_002_execute+0x11c>)
 800916c:	f7fa fb48 	bl	8003800 <chThdCreateFromMemoryPool.constprop.40>
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8009170:	1ef1      	subs	r1, r6, #3
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8009172:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8009174:	4a32      	ldr	r2, [pc, #200]	; (8009240 <rt_test_010_002_execute+0x120>)
 8009176:	4833      	ldr	r0, [pc, #204]	; (8009244 <rt_test_010_002_execute+0x124>)
 8009178:	f7fa fb42 	bl	8003800 <chThdCreateFromMemoryPool.constprop.40>
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 800917c:	1f31      	subs	r1, r6, #4
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 800917e:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8009180:	4a31      	ldr	r2, [pc, #196]	; (8009248 <rt_test_010_002_execute+0x128>)
 8009182:	4832      	ldr	r0, [pc, #200]	; (800924c <rt_test_010_002_execute+0x12c>)
 8009184:	f7fa fb3c 	bl	8003800 <chThdCreateFromMemoryPool.constprop.40>
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8009188:	1f71      	subs	r1, r6, #5
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 800918a:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800918c:	4a30      	ldr	r2, [pc, #192]	; (8009250 <rt_test_010_002_execute+0x130>)
 800918e:	4831      	ldr	r0, [pc, #196]	; (8009254 <rt_test_010_002_execute+0x134>)
 8009190:	f7fa fb36 	bl	8003800 <chThdCreateFromMemoryPool.constprop.40>
  }
  test_end_step(3);

  /* [10.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
 8009194:	2304      	movs	r3, #4
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8009196:	4606      	mov	r6, r0
  {
    test_assert((threads[0] != NULL) &&
 8009198:	6820      	ldr	r0, [r4, #0]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800919a:	6126      	str	r6, [r4, #16]
  test_set_step(4);
 800919c:	602b      	str	r3, [r5, #0]
    test_assert((threads[0] != NULL) &&
 800919e:	b138      	cbz	r0, 80091b0 <rt_test_010_002_execute+0x90>
 80091a0:	6860      	ldr	r0, [r4, #4]
 80091a2:	b128      	cbz	r0, 80091b0 <rt_test_010_002_execute+0x90>
 80091a4:	68a0      	ldr	r0, [r4, #8]
 80091a6:	b118      	cbz	r0, 80091b0 <rt_test_010_002_execute+0x90>
 80091a8:	68e0      	ldr	r0, [r4, #12]
 80091aa:	3000      	adds	r0, #0
 80091ac:	bf18      	it	ne
 80091ae:	2001      	movne	r0, #1
 80091b0:	4929      	ldr	r1, [pc, #164]	; (8009258 <rt_test_010_002_execute+0x138>)
 80091b2:	f7f7 fded 	bl	8000d90 <_test_assert>
 80091b6:	b100      	cbz	r0, 80091ba <rt_test_010_002_execute+0x9a>
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
  }
  test_end_step(6);
}
 80091b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert(threads[4] == NULL,
 80091ba:	fab6 f086 	clz	r0, r6
 80091be:	4927      	ldr	r1, [pc, #156]	; (800925c <rt_test_010_002_execute+0x13c>)
 80091c0:	0940      	lsrs	r0, r0, #5
 80091c2:	f7f7 fde5 	bl	8000d90 <_test_assert>
 80091c6:	2800      	cmp	r0, #0
 80091c8:	d1f6      	bne.n	80091b8 <rt_test_010_002_execute+0x98>
  test_set_step(5);
 80091ca:	2305      	movs	r3, #5
 80091cc:	602b      	str	r3, [r5, #0]
    test_wait_threads();
 80091ce:	f7ff fd37 	bl	8008c40 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 80091d2:	4923      	ldr	r1, [pc, #140]	; (8009260 <rt_test_010_002_execute+0x140>)
 80091d4:	4823      	ldr	r0, [pc, #140]	; (8009264 <rt_test_010_002_execute+0x144>)
 80091d6:	f7f7 ff5b 	bl	8001090 <_test_assert_sequence>
 80091da:	2800      	cmp	r0, #0
 80091dc:	d1ec      	bne.n	80091b8 <rt_test_010_002_execute+0x98>
  test_set_step(6);
 80091de:	2306      	movs	r3, #6
 80091e0:	2404      	movs	r4, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 80091e2:	4f10      	ldr	r7, [pc, #64]	; (8009224 <rt_test_010_002_execute+0x104>)
 80091e4:	4e20      	ldr	r6, [pc, #128]	; (8009268 <rt_test_010_002_execute+0x148>)
  test_set_step(6);
 80091e6:	602b      	str	r3, [r5, #0]
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 80091e8:	4638      	mov	r0, r7
 80091ea:	f7f8 f811 	bl	8001210 <chPoolAlloc>
 80091ee:	3000      	adds	r0, #0
 80091f0:	bf18      	it	ne
 80091f2:	2001      	movne	r0, #1
 80091f4:	4631      	mov	r1, r6
 80091f6:	f7f7 fdcb 	bl	8000d90 <_test_assert>
 80091fa:	2800      	cmp	r0, #0
 80091fc:	d1dc      	bne.n	80091b8 <rt_test_010_002_execute+0x98>
    for (i = 0; i < 4; i++)
 80091fe:	3c01      	subs	r4, #1
 8009200:	d1f2      	bne.n	80091e8 <rt_test_010_002_execute+0xc8>
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8009202:	4808      	ldr	r0, [pc, #32]	; (8009224 <rt_test_010_002_execute+0x104>)
 8009204:	f7f8 f804 	bl	8001210 <chPoolAlloc>
}
 8009208:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800920c:	fab0 f080 	clz	r0, r0
 8009210:	4916      	ldr	r1, [pc, #88]	; (800926c <rt_test_010_002_execute+0x14c>)
 8009212:	0940      	lsrs	r0, r0, #5
 8009214:	f7f7 bdbc 	b.w	8000d90 <_test_assert>
 8009218:	20001d94 	.word	0x20001d94
 800921c:	0800d560 	.word	0x0800d560
 8009220:	20001680 	.word	0x20001680
 8009224:	20001530 	.word	0x20001530
 8009228:	20001254 	.word	0x20001254
 800922c:	0800c184 	.word	0x0800c184
 8009230:	0800c3b0 	.word	0x0800c3b0
 8009234:	20001dac 	.word	0x20001dac
 8009238:	0800c188 	.word	0x0800c188
 800923c:	0800c3b8 	.word	0x0800c3b8
 8009240:	0800c3c0 	.word	0x0800c3c0
 8009244:	0800c3c4 	.word	0x0800c3c4
 8009248:	0800d248 	.word	0x0800d248
 800924c:	0800c3cc 	.word	0x0800c3cc
 8009250:	0800c200 	.word	0x0800c200
 8009254:	0800c3d4 	.word	0x0800c3d4
 8009258:	0800c3dc 	.word	0x0800c3dc
 800925c:	0800c3f4 	.word	0x0800c3f4
 8009260:	0800c260 	.word	0x0800c260
 8009264:	0800b220 	.word	0x0800b220
 8009268:	0800c410 	.word	0x0800c410
 800926c:	0800c420 	.word	0x0800c420

08009270 <rt_test_010_001_execute>:
  test_set_step(2);
 8009270:	2302      	movs	r3, #2
static void rt_test_010_001_execute(void) {
 8009272:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
 8009276:	4a48      	ldr	r2, [pc, #288]	; (8009398 <rt_test_010_001_execute+0x128>)
 8009278:	b086      	sub	sp, #24
  return chThdGetSelfX()->prio;
 800927a:	6995      	ldr	r5, [r2, #24]
  test_set_step(2);
 800927c:	4c47      	ldr	r4, [pc, #284]	; (800939c <rt_test_010_001_execute+0x12c>)
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 800927e:	a905      	add	r1, sp, #20
 8009280:	aa04      	add	r2, sp, #16
 8009282:	4847      	ldr	r0, [pc, #284]	; (80093a0 <rt_test_010_001_execute+0x130>)
 8009284:	68ae      	ldr	r6, [r5, #8]
  test_set_step(2);
 8009286:	6023      	str	r3, [r4, #0]
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8009288:	f7fe fa32 	bl	80076f0 <chHeapStatus>
 800928c:	4605      	mov	r5, r0
    test_assert(n1 == 1, "heap fragmented");
 800928e:	f1a0 0001 	sub.w	r0, r0, #1
 8009292:	fab0 f080 	clz	r0, r0
 8009296:	4943      	ldr	r1, [pc, #268]	; (80093a4 <rt_test_010_001_execute+0x134>)
 8009298:	0940      	lsrs	r0, r0, #5
 800929a:	f7f7 fd79 	bl	8000d90 <_test_assert>
 800929e:	b110      	cbz	r0, 80092a6 <rt_test_010_001_execute+0x36>
}
 80092a0:	b006      	add	sp, #24
 80092a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(3);
 80092a6:	2703      	movs	r7, #3
    threads[0] = chThdCreateFromHeap(&heap1,
 80092a8:	4b3f      	ldr	r3, [pc, #252]	; (80093a8 <rt_test_010_001_execute+0x138>)
 80092aa:	f8df 8134 	ldr.w	r8, [pc, #308]	; 80093e0 <rt_test_010_001_execute+0x170>
 80092ae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80092b2:	e9cd 8300 	strd	r8, r3, [sp]
 80092b6:	4a3d      	ldr	r2, [pc, #244]	; (80093ac <rt_test_010_001_execute+0x13c>)
 80092b8:	1e73      	subs	r3, r6, #1
 80092ba:	4839      	ldr	r0, [pc, #228]	; (80093a0 <rt_test_010_001_execute+0x130>)
  test_set_step(3);
 80092bc:	6027      	str	r7, [r4, #0]
    threads[0] = chThdCreateFromHeap(&heap1,
 80092be:	f7fd f8a7 	bl	8006410 <chThdCreateFromHeap>
 80092c2:	4603      	mov	r3, r0
 80092c4:	4f3a      	ldr	r7, [pc, #232]	; (80093b0 <rt_test_010_001_execute+0x140>)
    test_assert(threads[0] != NULL, "thread creation failed");
 80092c6:	3000      	adds	r0, #0
 80092c8:	bf18      	it	ne
 80092ca:	2001      	movne	r0, #1
 80092cc:	4939      	ldr	r1, [pc, #228]	; (80093b4 <rt_test_010_001_execute+0x144>)
    threads[0] = chThdCreateFromHeap(&heap1,
 80092ce:	603b      	str	r3, [r7, #0]
    test_assert(threads[0] != NULL, "thread creation failed");
 80092d0:	f7f7 fd5e 	bl	8000d90 <_test_assert>
 80092d4:	2800      	cmp	r0, #0
 80092d6:	d1e3      	bne.n	80092a0 <rt_test_010_001_execute+0x30>
  test_set_step(4);
 80092d8:	f04f 0c04 	mov.w	ip, #4
    threads[1] = chThdCreateFromHeap(&heap1,
 80092dc:	4b36      	ldr	r3, [pc, #216]	; (80093b8 <rt_test_010_001_execute+0x148>)
 80092de:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80092e2:	e9cd 8300 	strd	r8, r3, [sp]
 80092e6:	4a35      	ldr	r2, [pc, #212]	; (80093bc <rt_test_010_001_execute+0x14c>)
 80092e8:	1eb3      	subs	r3, r6, #2
 80092ea:	482d      	ldr	r0, [pc, #180]	; (80093a0 <rt_test_010_001_execute+0x130>)
  test_set_step(4);
 80092ec:	f8c4 c000 	str.w	ip, [r4]
    threads[1] = chThdCreateFromHeap(&heap1,
 80092f0:	f7fd f88e 	bl	8006410 <chThdCreateFromHeap>
 80092f4:	4603      	mov	r3, r0
    test_assert(threads[1] != NULL, "thread creation failed");
 80092f6:	3000      	adds	r0, #0
 80092f8:	bf18      	it	ne
 80092fa:	2001      	movne	r0, #1
 80092fc:	492d      	ldr	r1, [pc, #180]	; (80093b4 <rt_test_010_001_execute+0x144>)
    threads[1] = chThdCreateFromHeap(&heap1,
 80092fe:	607b      	str	r3, [r7, #4]
    test_assert(threads[1] != NULL, "thread creation failed");
 8009300:	f7f7 fd46 	bl	8000d90 <_test_assert>
 8009304:	2800      	cmp	r0, #0
 8009306:	d1cb      	bne.n	80092a0 <rt_test_010_001_execute+0x30>
  test_set_step(5);
 8009308:	f04f 0c05 	mov.w	ip, #5
    threads[2] = chThdCreateFromHeap(&heap1,
 800930c:	4a2c      	ldr	r2, [pc, #176]	; (80093c0 <rt_test_010_001_execute+0x150>)
 800930e:	1ef3      	subs	r3, r6, #3
 8009310:	9201      	str	r2, [sp, #4]
 8009312:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8009316:	f8cd 8000 	str.w	r8, [sp]
 800931a:	4a2a      	ldr	r2, [pc, #168]	; (80093c4 <rt_test_010_001_execute+0x154>)
 800931c:	4820      	ldr	r0, [pc, #128]	; (80093a0 <rt_test_010_001_execute+0x130>)
  test_set_step(5);
 800931e:	f8c4 c000 	str.w	ip, [r4]
    threads[2] = chThdCreateFromHeap(&heap1,
 8009322:	f7fd f875 	bl	8006410 <chThdCreateFromHeap>
 8009326:	4603      	mov	r3, r0
    test_assert(threads[2] == NULL, "thread creation not failed");
 8009328:	fab0 f080 	clz	r0, r0
 800932c:	4926      	ldr	r1, [pc, #152]	; (80093c8 <rt_test_010_001_execute+0x158>)
 800932e:	0940      	lsrs	r0, r0, #5
    threads[2] = chThdCreateFromHeap(&heap1,
 8009330:	60bb      	str	r3, [r7, #8]
    test_assert(threads[2] == NULL, "thread creation not failed");
 8009332:	f7f7 fd2d 	bl	8000d90 <_test_assert>
 8009336:	2800      	cmp	r0, #0
 8009338:	d1b2      	bne.n	80092a0 <rt_test_010_001_execute+0x30>
  test_set_step(6);
 800933a:	2306      	movs	r3, #6
 800933c:	6023      	str	r3, [r4, #0]
    test_wait_threads();
 800933e:	f7ff fc7f 	bl	8008c40 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 8009342:	4922      	ldr	r1, [pc, #136]	; (80093cc <rt_test_010_001_execute+0x15c>)
 8009344:	4822      	ldr	r0, [pc, #136]	; (80093d0 <rt_test_010_001_execute+0x160>)
 8009346:	f7f7 fea3 	bl	8001090 <_test_assert_sequence>
 800934a:	2800      	cmp	r0, #0
 800934c:	d1a8      	bne.n	80092a0 <rt_test_010_001_execute+0x30>
  test_set_step(7);
 800934e:	2307      	movs	r3, #7
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8009350:	a903      	add	r1, sp, #12
 8009352:	aa02      	add	r2, sp, #8
 8009354:	4812      	ldr	r0, [pc, #72]	; (80093a0 <rt_test_010_001_execute+0x130>)
  test_set_step(7);
 8009356:	6023      	str	r3, [r4, #0]
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8009358:	f7fe f9ca 	bl	80076f0 <chHeapStatus>
    test_assert(n1 == n2, "fragmentation changed");
 800935c:	1a28      	subs	r0, r5, r0
 800935e:	fab0 f080 	clz	r0, r0
 8009362:	491c      	ldr	r1, [pc, #112]	; (80093d4 <rt_test_010_001_execute+0x164>)
 8009364:	0940      	lsrs	r0, r0, #5
 8009366:	f7f7 fd13 	bl	8000d90 <_test_assert>
 800936a:	2800      	cmp	r0, #0
 800936c:	d198      	bne.n	80092a0 <rt_test_010_001_execute+0x30>
    test_assert(total1 == total2, "total free space changed");
 800936e:	9805      	ldr	r0, [sp, #20]
 8009370:	9b03      	ldr	r3, [sp, #12]
 8009372:	4919      	ldr	r1, [pc, #100]	; (80093d8 <rt_test_010_001_execute+0x168>)
 8009374:	1ac0      	subs	r0, r0, r3
 8009376:	fab0 f080 	clz	r0, r0
 800937a:	0940      	lsrs	r0, r0, #5
 800937c:	f7f7 fd08 	bl	8000d90 <_test_assert>
 8009380:	2800      	cmp	r0, #0
 8009382:	d18d      	bne.n	80092a0 <rt_test_010_001_execute+0x30>
    test_assert(largest1 == largest2, "largest fragment size changed");
 8009384:	9804      	ldr	r0, [sp, #16]
 8009386:	9b02      	ldr	r3, [sp, #8]
 8009388:	4914      	ldr	r1, [pc, #80]	; (80093dc <rt_test_010_001_execute+0x16c>)
 800938a:	1ac3      	subs	r3, r0, r3
 800938c:	4258      	negs	r0, r3
 800938e:	4158      	adcs	r0, r3
 8009390:	f7f7 fcfe 	bl	8000d90 <_test_assert>
 8009394:	e784      	b.n	80092a0 <rt_test_010_001_execute+0x30>
 8009396:	bf00      	nop
 8009398:	20001254 	.word	0x20001254
 800939c:	20001d94 	.word	0x20001d94
 80093a0:	200014a0 	.word	0x200014a0
 80093a4:	0800b40c 	.word	0x0800b40c
 80093a8:	0800c184 	.word	0x0800c184
 80093ac:	0800c3b0 	.word	0x0800c3b0
 80093b0:	20001dac 	.word	0x20001dac
 80093b4:	0800c3dc 	.word	0x0800c3dc
 80093b8:	0800c188 	.word	0x0800c188
 80093bc:	0800c3b8 	.word	0x0800c3b8
 80093c0:	0800c3c0 	.word	0x0800c3c0
 80093c4:	0800c3c4 	.word	0x0800c3c4
 80093c8:	0800c3f4 	.word	0x0800c3f4
 80093cc:	0800c260 	.word	0x0800c260
 80093d0:	0800c348 	.word	0x0800c348
 80093d4:	0800c34c 	.word	0x0800c34c
 80093d8:	0800c364 	.word	0x0800c364
 80093dc:	0800c380 	.word	0x0800c380
 80093e0:	08001011 	.word	0x08001011
	...

080093f0 <rt_test_009_007_execute>:

static void rt_test_009_007_execute(void) {
 80093f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  event_listener_t el1, el2;
  systime_t target_time;

  /* [9.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 80093f4:	2501      	movs	r5, #1
 80093f6:	4e3f      	ldr	r6, [pc, #252]	; (80094f4 <rt_test_009_007_execute+0x104>)
static void rt_test_009_007_execute(void) {
 80093f8:	b08b      	sub	sp, #44	; 0x2c
 80093fa:	2420      	movs	r4, #32
  test_set_step(1);
 80093fc:	6035      	str	r5, [r6, #0]
 80093fe:	f384 8811 	msr	BASEPRI, r4
  elp->flags    = (eventflags_t)0;
 8009402:	2300      	movs	r3, #0
  elp->wflags   = wflags;
 8009404:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  elp->next     = esp->next;
 8009408:	f8df 8104 	ldr.w	r8, [pc, #260]	; 8009510 <rt_test_009_007_execute+0x120>
  elp->listener = currp;
 800940c:	f8df b104 	ldr.w	fp, [pc, #260]	; 8009514 <rt_test_009_007_execute+0x124>
  elp->next     = esp->next;
 8009410:	f8d8 1000 	ldr.w	r1, [r8]
 8009414:	af0a      	add	r7, sp, #40	; 0x28
  elp->listener = currp;
 8009416:	f8db 2018 	ldr.w	r2, [fp, #24]
  elp->next     = esp->next;
 800941a:	f847 1d14 	str.w	r1, [r7, #-20]!
  elp->listener = currp;
 800941e:	e9cd 2506 	strd	r2, r5, [sp, #24]
  esp->next     = elp;
 8009422:	f8c8 7000 	str.w	r7, [r8]
  elp->wflags   = wflags;
 8009426:	e9cd 3008 	strd	r3, r0, [sp, #32]
 800942a:	f383 8811 	msr	BASEPRI, r3
 800942e:	f384 8811 	msr	BASEPRI, r4
  elp->events   = events;
 8009432:	f04f 0a04 	mov.w	sl, #4
  elp->next     = esp->next;
 8009436:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 8009518 <rt_test_009_007_execute+0x128>
 800943a:	ad0a      	add	r5, sp, #40	; 0x28
 800943c:	f8d9 1000 	ldr.w	r1, [r9]
  elp->listener = currp;
 8009440:	f8db 2018 	ldr.w	r2, [fp, #24]
  elp->next     = esp->next;
 8009444:	f845 1d28 	str.w	r1, [r5, #-40]!
  elp->flags    = (eventflags_t)0;
 8009448:	9303      	str	r3, [sp, #12]
  elp->wflags   = wflags;
 800944a:	9004      	str	r0, [sp, #16]
  elp->listener = currp;
 800944c:	9201      	str	r2, [sp, #4]
  esp->next     = elp;
 800944e:	f8c9 5000 	str.w	r5, [r9]
  elp->events   = events;
 8009452:	f8cd a008 	str.w	sl, [sp, #8]
 8009456:	f383 8811 	msr	BASEPRI, r3
  test_end_step(1);

  /* [9.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 800945a:	2302      	movs	r3, #2
 800945c:	6033      	str	r3, [r6, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 800945e:	f7fa fe8f 	bl	8004180 <test_wait_tick>
 8009462:	f8db 2018 	ldr.w	r2, [fp, #24]
 8009466:	4604      	mov	r4, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009468:	6891      	ldr	r1, [r2, #8]
 800946a:	4b23      	ldr	r3, [pc, #140]	; (80094f8 <rt_test_009_007_execute+0x108>)
 800946c:	3901      	subs	r1, #1
 800946e:	4a23      	ldr	r2, [pc, #140]	; (80094fc <rt_test_009_007_execute+0x10c>)
 8009470:	4823      	ldr	r0, [pc, #140]	; (8009500 <rt_test_009_007_execute+0x110>)
 8009472:	f7fa f965 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_end_step(2);

  /* [9.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8009476:	2203      	movs	r2, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009478:	4b22      	ldr	r3, [pc, #136]	; (8009504 <rt_test_009_007_execute+0x114>)
  test_set_step(3);
 800947a:	6032      	str	r2, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800947c:	6018      	str	r0, [r3, #0]
  {
    m = chEvtWaitAll(5);
 800947e:	f7fa fa6f 	bl	8003960 <chEvtWaitAll.constprop.45>
  return systime + (systime_t)interval;
 8009482:	f104 0168 	add.w	r1, r4, #104	; 0x68
 8009486:	f104 0064 	add.w	r0, r4, #100	; 0x64
    test_assert_time_window(target_time,
 800948a:	b289      	uxth	r1, r1
 800948c:	b280      	uxth	r0, r0
 800948e:	f7f7 fa1f 	bl	80008d0 <_test_assert_time_window.constprop.3>
 8009492:	b110      	cbz	r0, 800949a <rt_test_009_007_execute+0xaa>
    chEvtUnregister(&es2, &el2);
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  }
  test_end_step(4);
}
 8009494:	b00b      	add	sp, #44	; 0x2c
 8009496:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800949a:	f7f7 fa09 	bl	80008b0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 800949e:	fab0 f080 	clz	r0, r0
 80094a2:	4919      	ldr	r1, [pc, #100]	; (8009508 <rt_test_009_007_execute+0x118>)
 80094a4:	0940      	lsrs	r0, r0, #5
 80094a6:	f7f7 fc73 	bl	8000d90 <_test_assert>
 80094aa:	2800      	cmp	r0, #0
 80094ac:	d1f2      	bne.n	8009494 <rt_test_009_007_execute+0xa4>
    test_wait_threads();
 80094ae:	f7ff fbc7 	bl	8008c40 <test_wait_threads>
    chEvtUnregister(&es1, &el1);
 80094b2:	4639      	mov	r1, r7
 80094b4:	4640      	mov	r0, r8
  test_set_step(4);
 80094b6:	f8c6 a000 	str.w	sl, [r6]
    chEvtUnregister(&es1, &el1);
 80094ba:	f7f7 ff59 	bl	8001370 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 80094be:	4629      	mov	r1, r5
 80094c0:	4648      	mov	r0, r9
 80094c2:	f7f7 ff55 	bl	8001370 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 80094c6:	f8d8 0000 	ldr.w	r0, [r8]
 80094ca:	4910      	ldr	r1, [pc, #64]	; (800950c <rt_test_009_007_execute+0x11c>)
 80094cc:	eba0 0008 	sub.w	r0, r0, r8
 80094d0:	fab0 f080 	clz	r0, r0
 80094d4:	0940      	lsrs	r0, r0, #5
 80094d6:	f7f7 fc5b 	bl	8000d90 <_test_assert>
 80094da:	2800      	cmp	r0, #0
 80094dc:	d1da      	bne.n	8009494 <rt_test_009_007_execute+0xa4>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 80094de:	f8d9 0000 	ldr.w	r0, [r9]
 80094e2:	490a      	ldr	r1, [pc, #40]	; (800950c <rt_test_009_007_execute+0x11c>)
 80094e4:	eba0 0009 	sub.w	r0, r0, r9
 80094e8:	fab0 f080 	clz	r0, r0
 80094ec:	0940      	lsrs	r0, r0, #5
 80094ee:	f7f7 fc4f 	bl	8000d90 <_test_assert>
 80094f2:	e7cf      	b.n	8009494 <rt_test_009_007_execute+0xa4>
 80094f4:	20001d94 	.word	0x20001d94
 80094f8:	0800c184 	.word	0x0800c184
 80094fc:	080055c1 	.word	0x080055c1
 8009500:	20001680 	.word	0x20001680
 8009504:	20001dac 	.word	0x20001dac
 8009508:	0800c32c 	.word	0x0800c32c
 800950c:	0800c240 	.word	0x0800c240
 8009510:	20000c0c 	.word	0x20000c0c
 8009514:	20001254 	.word	0x20001254
 8009518:	20000c10 	.word	0x20000c10
 800951c:	00000000 	.word	0x00000000

08009520 <rt_test_009_005_execute>:
static void rt_test_009_005_execute(void) {
 8009520:	b538      	push	{r3, r4, r5, lr}
    chEvtAddEvents(5);
 8009522:	2005      	movs	r0, #5
 8009524:	f7f7 ff14 	bl	8001350 <chEvtAddEvents>
  test_set_step(2);
 8009528:	2302      	movs	r3, #2
 800952a:	4c28      	ldr	r4, [pc, #160]	; (80095cc <rt_test_009_005_execute+0xac>)
 800952c:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAll(5);
 800952e:	f7fa fa17 	bl	8003960 <chEvtWaitAll.constprop.45>
    test_assert(m == 5, "unexpected pending bit");
 8009532:	f1a0 0005 	sub.w	r0, r0, #5
 8009536:	fab0 f080 	clz	r0, r0
 800953a:	4925      	ldr	r1, [pc, #148]	; (80095d0 <rt_test_009_005_execute+0xb0>)
 800953c:	0940      	lsrs	r0, r0, #5
 800953e:	f7f7 fc27 	bl	8000d90 <_test_assert>
 8009542:	b100      	cbz	r0, 8009546 <rt_test_009_005_execute+0x26>
}
 8009544:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8009546:	f7f7 f9b3 	bl	80008b0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 800954a:	fab0 f080 	clz	r0, r0
 800954e:	4921      	ldr	r1, [pc, #132]	; (80095d4 <rt_test_009_005_execute+0xb4>)
 8009550:	0940      	lsrs	r0, r0, #5
 8009552:	f7f7 fc1d 	bl	8000d90 <_test_assert>
 8009556:	2800      	cmp	r0, #0
 8009558:	d1f4      	bne.n	8009544 <rt_test_009_005_execute+0x24>
    chEvtAddEvents(4);
 800955a:	2004      	movs	r0, #4
 800955c:	f7f7 fef8 	bl	8001350 <chEvtAddEvents>
  test_set_step(4);
 8009560:	2304      	movs	r3, #4
 8009562:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8009564:	f7fa fe0c 	bl	8004180 <test_wait_tick>
  return ch.rlist.current;
 8009568:	4b1b      	ldr	r3, [pc, #108]	; (80095d8 <rt_test_009_005_execute+0xb8>)
 800956a:	4605      	mov	r5, r0
 800956c:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800956e:	4a1b      	ldr	r2, [pc, #108]	; (80095dc <rt_test_009_005_execute+0xbc>)
 8009570:	6899      	ldr	r1, [r3, #8]
 8009572:	481b      	ldr	r0, [pc, #108]	; (80095e0 <rt_test_009_005_execute+0xc0>)
 8009574:	3901      	subs	r1, #1
 8009576:	f7fa f8e3 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(5);
 800957a:	2205      	movs	r2, #5
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800957c:	4b19      	ldr	r3, [pc, #100]	; (80095e4 <rt_test_009_005_execute+0xc4>)
  test_set_step(5);
 800957e:	6022      	str	r2, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009580:	6018      	str	r0, [r3, #0]
    m = chEvtWaitAll(5);
 8009582:	f7fa f9ed 	bl	8003960 <chEvtWaitAll.constprop.45>
 8009586:	f105 0168 	add.w	r1, r5, #104	; 0x68
 800958a:	4604      	mov	r4, r0
 800958c:	f105 0064 	add.w	r0, r5, #100	; 0x64
    test_assert_time_window(target_time,
 8009590:	b289      	uxth	r1, r1
 8009592:	b280      	uxth	r0, r0
 8009594:	f7f7 f99c 	bl	80008d0 <_test_assert_time_window.constprop.3>
 8009598:	2800      	cmp	r0, #0
 800959a:	d1d3      	bne.n	8009544 <rt_test_009_005_execute+0x24>
    test_assert(m == 5, "event flags error");
 800959c:	f1a4 0005 	sub.w	r0, r4, #5
 80095a0:	fab0 f080 	clz	r0, r0
 80095a4:	4910      	ldr	r1, [pc, #64]	; (80095e8 <rt_test_009_005_execute+0xc8>)
 80095a6:	0940      	lsrs	r0, r0, #5
 80095a8:	f7f7 fbf2 	bl	8000d90 <_test_assert>
 80095ac:	2800      	cmp	r0, #0
 80095ae:	d1c9      	bne.n	8009544 <rt_test_009_005_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 80095b0:	f7f7 f97e 	bl	80008b0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 80095b4:	fab0 f080 	clz	r0, r0
 80095b8:	4906      	ldr	r1, [pc, #24]	; (80095d4 <rt_test_009_005_execute+0xb4>)
 80095ba:	0940      	lsrs	r0, r0, #5
 80095bc:	f7f7 fbe8 	bl	8000d90 <_test_assert>
 80095c0:	2800      	cmp	r0, #0
 80095c2:	d1bf      	bne.n	8009544 <rt_test_009_005_execute+0x24>
}
 80095c4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
 80095c8:	f7ff bb3a 	b.w	8008c40 <test_wait_threads>
 80095cc:	20001d94 	.word	0x20001d94
 80095d0:	0800c2d0 	.word	0x0800c2d0
 80095d4:	0800c32c 	.word	0x0800c32c
 80095d8:	20001254 	.word	0x20001254
 80095dc:	08005601 	.word	0x08005601
 80095e0:	20001680 	.word	0x20001680
 80095e4:	20001dac 	.word	0x20001dac
 80095e8:	0800c2e8 	.word	0x0800c2e8
 80095ec:	00000000 	.word	0x00000000

080095f0 <rt_test_009_004_execute>:
static void rt_test_009_004_execute(void) {
 80095f0:	b538      	push	{r3, r4, r5, lr}
    chEvtAddEvents(5);
 80095f2:	2005      	movs	r0, #5
 80095f4:	f7f7 feac 	bl	8001350 <chEvtAddEvents>
  test_set_step(2);
 80095f8:	2302      	movs	r3, #2
 80095fa:	4c27      	ldr	r4, [pc, #156]	; (8009698 <rt_test_009_004_execute+0xa8>)
 80095fc:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 80095fe:	f7fa f997 	bl	8003930 <chEvtWaitAny.constprop.46>
    test_assert(m == 5, "unexpected pending bit");
 8009602:	f1a0 0005 	sub.w	r0, r0, #5
 8009606:	fab0 f080 	clz	r0, r0
 800960a:	4924      	ldr	r1, [pc, #144]	; (800969c <rt_test_009_004_execute+0xac>)
 800960c:	0940      	lsrs	r0, r0, #5
 800960e:	f7f7 fbbf 	bl	8000d90 <_test_assert>
 8009612:	b100      	cbz	r0, 8009616 <rt_test_009_004_execute+0x26>
}
 8009614:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8009616:	f7f7 f94b 	bl	80008b0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 800961a:	fab0 f080 	clz	r0, r0
 800961e:	4920      	ldr	r1, [pc, #128]	; (80096a0 <rt_test_009_004_execute+0xb0>)
 8009620:	0940      	lsrs	r0, r0, #5
 8009622:	f7f7 fbb5 	bl	8000d90 <_test_assert>
 8009626:	2800      	cmp	r0, #0
 8009628:	d1f4      	bne.n	8009614 <rt_test_009_004_execute+0x24>
  test_set_step(3);
 800962a:	2303      	movs	r3, #3
 800962c:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 800962e:	f7fa fda7 	bl	8004180 <test_wait_tick>
 8009632:	4b1c      	ldr	r3, [pc, #112]	; (80096a4 <rt_test_009_004_execute+0xb4>)
 8009634:	4605      	mov	r5, r0
 8009636:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009638:	4a1b      	ldr	r2, [pc, #108]	; (80096a8 <rt_test_009_004_execute+0xb8>)
 800963a:	6899      	ldr	r1, [r3, #8]
 800963c:	481b      	ldr	r0, [pc, #108]	; (80096ac <rt_test_009_004_execute+0xbc>)
 800963e:	3901      	subs	r1, #1
 8009640:	f7fa f87e 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(4);
 8009644:	2204      	movs	r2, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009646:	4b1a      	ldr	r3, [pc, #104]	; (80096b0 <rt_test_009_004_execute+0xc0>)
  test_set_step(4);
 8009648:	6022      	str	r2, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800964a:	6018      	str	r0, [r3, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 800964c:	f7fa f970 	bl	8003930 <chEvtWaitAny.constprop.46>
 8009650:	f105 0168 	add.w	r1, r5, #104	; 0x68
 8009654:	4604      	mov	r4, r0
 8009656:	f105 0064 	add.w	r0, r5, #100	; 0x64
    test_assert_time_window(target_time,
 800965a:	b289      	uxth	r1, r1
 800965c:	b280      	uxth	r0, r0
 800965e:	f7f7 f937 	bl	80008d0 <_test_assert_time_window.constprop.3>
 8009662:	2800      	cmp	r0, #0
 8009664:	d1d6      	bne.n	8009614 <rt_test_009_004_execute+0x24>
    test_assert(m == 1, "event flag error");
 8009666:	f1a4 0001 	sub.w	r0, r4, #1
 800966a:	fab0 f080 	clz	r0, r0
 800966e:	4911      	ldr	r1, [pc, #68]	; (80096b4 <rt_test_009_004_execute+0xc4>)
 8009670:	0940      	lsrs	r0, r0, #5
 8009672:	f7f7 fb8d 	bl	8000d90 <_test_assert>
 8009676:	2800      	cmp	r0, #0
 8009678:	d1cc      	bne.n	8009614 <rt_test_009_004_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800967a:	f7f7 f919 	bl	80008b0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 800967e:	fab0 f080 	clz	r0, r0
 8009682:	4907      	ldr	r1, [pc, #28]	; (80096a0 <rt_test_009_004_execute+0xb0>)
 8009684:	0940      	lsrs	r0, r0, #5
 8009686:	f7f7 fb83 	bl	8000d90 <_test_assert>
 800968a:	2800      	cmp	r0, #0
 800968c:	d1c2      	bne.n	8009614 <rt_test_009_004_execute+0x24>
}
 800968e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
 8009692:	f7ff bad5 	b.w	8008c40 <test_wait_threads>
 8009696:	bf00      	nop
 8009698:	20001d94 	.word	0x20001d94
 800969c:	0800c2d0 	.word	0x0800c2d0
 80096a0:	0800c32c 	.word	0x0800c32c
 80096a4:	20001254 	.word	0x20001254
 80096a8:	08005601 	.word	0x08005601
 80096ac:	20001680 	.word	0x20001680
 80096b0:	20001dac 	.word	0x20001dac
 80096b4:	0800c2ac 	.word	0x0800c2ac
	...

080096c0 <rt_test_009_003_execute>:
static void rt_test_009_003_execute(void) {
 80096c0:	b538      	push	{r3, r4, r5, lr}
    chEvtAddEvents(7);
 80096c2:	2007      	movs	r0, #7
 80096c4:	f7f7 fe44 	bl	8001350 <chEvtAddEvents>
  test_set_step(2);
 80096c8:	2302      	movs	r3, #2
 80096ca:	4c33      	ldr	r4, [pc, #204]	; (8009798 <rt_test_009_003_execute+0xd8>)
 80096cc:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 80096ce:	f7fa f90f 	bl	80038f0 <chEvtWaitOne.constprop.47>
    test_assert(m == 1, "single event error");
 80096d2:	f1a0 0001 	sub.w	r0, r0, #1
 80096d6:	fab0 f080 	clz	r0, r0
 80096da:	4930      	ldr	r1, [pc, #192]	; (800979c <rt_test_009_003_execute+0xdc>)
 80096dc:	0940      	lsrs	r0, r0, #5
 80096de:	f7f7 fb57 	bl	8000d90 <_test_assert>
 80096e2:	b100      	cbz	r0, 80096e6 <rt_test_009_003_execute+0x26>
}
 80096e4:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtWaitOne(ALL_EVENTS);
 80096e6:	f7fa f903 	bl	80038f0 <chEvtWaitOne.constprop.47>
    test_assert(m == 2, "single event error");
 80096ea:	f1a0 0002 	sub.w	r0, r0, #2
 80096ee:	fab0 f080 	clz	r0, r0
 80096f2:	492a      	ldr	r1, [pc, #168]	; (800979c <rt_test_009_003_execute+0xdc>)
 80096f4:	0940      	lsrs	r0, r0, #5
 80096f6:	f7f7 fb4b 	bl	8000d90 <_test_assert>
 80096fa:	2800      	cmp	r0, #0
 80096fc:	d1f2      	bne.n	80096e4 <rt_test_009_003_execute+0x24>
    m = chEvtWaitOne(ALL_EVENTS);
 80096fe:	f7fa f8f7 	bl	80038f0 <chEvtWaitOne.constprop.47>
    test_assert(m == 4, "single event error");
 8009702:	f1a0 0004 	sub.w	r0, r0, #4
 8009706:	fab0 f080 	clz	r0, r0
 800970a:	4924      	ldr	r1, [pc, #144]	; (800979c <rt_test_009_003_execute+0xdc>)
 800970c:	0940      	lsrs	r0, r0, #5
 800970e:	f7f7 fb3f 	bl	8000d90 <_test_assert>
 8009712:	2800      	cmp	r0, #0
 8009714:	d1e6      	bne.n	80096e4 <rt_test_009_003_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8009716:	f7f7 f8cb 	bl	80008b0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 800971a:	fab0 f080 	clz	r0, r0
 800971e:	4920      	ldr	r1, [pc, #128]	; (80097a0 <rt_test_009_003_execute+0xe0>)
 8009720:	0940      	lsrs	r0, r0, #5
 8009722:	f7f7 fb35 	bl	8000d90 <_test_assert>
 8009726:	2800      	cmp	r0, #0
 8009728:	d1dc      	bne.n	80096e4 <rt_test_009_003_execute+0x24>
  test_set_step(3);
 800972a:	2303      	movs	r3, #3
 800972c:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 800972e:	f7fa fd27 	bl	8004180 <test_wait_tick>
 8009732:	4b1c      	ldr	r3, [pc, #112]	; (80097a4 <rt_test_009_003_execute+0xe4>)
 8009734:	4605      	mov	r5, r0
 8009736:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009738:	4a1b      	ldr	r2, [pc, #108]	; (80097a8 <rt_test_009_003_execute+0xe8>)
 800973a:	6899      	ldr	r1, [r3, #8]
 800973c:	481b      	ldr	r0, [pc, #108]	; (80097ac <rt_test_009_003_execute+0xec>)
 800973e:	3901      	subs	r1, #1
 8009740:	f7f9 fffe 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(4);
 8009744:	2204      	movs	r2, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009746:	4b1a      	ldr	r3, [pc, #104]	; (80097b0 <rt_test_009_003_execute+0xf0>)
  test_set_step(4);
 8009748:	6022      	str	r2, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800974a:	6018      	str	r0, [r3, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 800974c:	f7fa f8d0 	bl	80038f0 <chEvtWaitOne.constprop.47>
 8009750:	f105 0168 	add.w	r1, r5, #104	; 0x68
 8009754:	4604      	mov	r4, r0
 8009756:	f105 0064 	add.w	r0, r5, #100	; 0x64
    test_assert_time_window(target_time,
 800975a:	b289      	uxth	r1, r1
 800975c:	b280      	uxth	r0, r0
 800975e:	f7f7 f8b7 	bl	80008d0 <_test_assert_time_window.constprop.3>
 8009762:	2800      	cmp	r0, #0
 8009764:	d1be      	bne.n	80096e4 <rt_test_009_003_execute+0x24>
    test_assert(m == 1, "event flag error");
 8009766:	f1a4 0001 	sub.w	r0, r4, #1
 800976a:	fab0 f080 	clz	r0, r0
 800976e:	4911      	ldr	r1, [pc, #68]	; (80097b4 <rt_test_009_003_execute+0xf4>)
 8009770:	0940      	lsrs	r0, r0, #5
 8009772:	f7f7 fb0d 	bl	8000d90 <_test_assert>
 8009776:	2800      	cmp	r0, #0
 8009778:	d1b4      	bne.n	80096e4 <rt_test_009_003_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800977a:	f7f7 f899 	bl	80008b0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 800977e:	fab0 f080 	clz	r0, r0
 8009782:	4907      	ldr	r1, [pc, #28]	; (80097a0 <rt_test_009_003_execute+0xe0>)
 8009784:	0940      	lsrs	r0, r0, #5
 8009786:	f7f7 fb03 	bl	8000d90 <_test_assert>
 800978a:	2800      	cmp	r0, #0
 800978c:	d1aa      	bne.n	80096e4 <rt_test_009_003_execute+0x24>
}
 800978e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
 8009792:	f7ff ba55 	b.w	8008c40 <test_wait_threads>
 8009796:	bf00      	nop
 8009798:	20001d94 	.word	0x20001d94
 800979c:	0800c288 	.word	0x0800c288
 80097a0:	0800c32c 	.word	0x0800c32c
 80097a4:	20001254 	.word	0x20001254
 80097a8:	08005601 	.word	0x08005601
 80097ac:	20001680 	.word	0x20001680
 80097b0:	20001dac 	.word	0x20001dac
 80097b4:	0800c2ac 	.word	0x0800c2ac
	...

080097c0 <rt_test_008_001_execute>:
 * - [8.1.1] Starting the messenger thread.
 * - [8.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void rt_test_008_001_execute(void) {
 80097c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *tp;
  msg_t msg;

  /* [8.1.1] Starting the messenger thread.*/
  test_set_step(1);
 80097c2:	2401      	movs	r4, #1
 80097c4:	4b15      	ldr	r3, [pc, #84]	; (800981c <rt_test_008_001_execute+0x5c>)
 80097c6:	4d16      	ldr	r5, [pc, #88]	; (8009820 <rt_test_008_001_execute+0x60>)
 80097c8:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 80097ca:	4a16      	ldr	r2, [pc, #88]	; (8009824 <rt_test_008_001_execute+0x64>)
 80097cc:	6899      	ldr	r1, [r3, #8]
 80097ce:	4816      	ldr	r0, [pc, #88]	; (8009828 <rt_test_008_001_execute+0x68>)
 80097d0:	4421      	add	r1, r4
  test_set_step(1);
 80097d2:	602c      	str	r4, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 80097d4:	f7f9 ffb4 	bl	8003740 <chThdCreateStatic.constprop.68>
  }
  test_end_step(1);

  /* [8.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 80097d8:	2202      	movs	r2, #2
 80097da:	2404      	movs	r4, #4
 80097dc:	2720      	movs	r7, #32
 80097de:	2600      	movs	r6, #0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 80097e0:	4b12      	ldr	r3, [pc, #72]	; (800982c <rt_test_008_001_execute+0x6c>)
  test_set_step(2);
 80097e2:	602a      	str	r2, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 80097e4:	6018      	str	r0, [r3, #0]
 80097e6:	f387 8811 	msr	BASEPRI, r7
  tp = chMsgWaitS();
 80097ea:	f7fa ff49 	bl	8004680 <chMsgWaitS>
 80097ee:	f386 8811 	msr	BASEPRI, r6
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
      msg = chMsgGet(tp);
 80097f2:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80097f4:	f387 8811 	msr	BASEPRI, r7
  chSchWakeupS(tp, msg);
 80097f8:	4629      	mov	r1, r5
 80097fa:	f7f9 ff71 	bl	80036e0 <chSchWakeupS>
 80097fe:	f386 8811 	msr	BASEPRI, r6
      chMsgRelease(tp, msg);
      test_emit_token(msg);
 8009802:	b2e8      	uxtb	r0, r5
 8009804:	f7f7 fb6c 	bl	8000ee0 <test_emit_token>
    for (i = 0; i < 4; i++) {
 8009808:	3c01      	subs	r4, #1
 800980a:	d1ec      	bne.n	80097e6 <rt_test_008_001_execute+0x26>
    }
    test_wait_threads();
 800980c:	f7ff fa18 	bl	8008c40 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
  }
  test_end_step(2);
}
 8009810:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCD", "invalid sequence");
 8009814:	4906      	ldr	r1, [pc, #24]	; (8009830 <rt_test_008_001_execute+0x70>)
 8009816:	4807      	ldr	r0, [pc, #28]	; (8009834 <rt_test_008_001_execute+0x74>)
 8009818:	f7f7 bc3a 	b.w	8001090 <_test_assert_sequence>
 800981c:	20001254 	.word	0x20001254
 8009820:	20001d94 	.word	0x20001d94
 8009824:	08004771 	.word	0x08004771
 8009828:	20001680 	.word	0x20001680
 800982c:	20001dac 	.word	0x20001dac
 8009830:	0800c260 	.word	0x0800c260
 8009834:	0800b220 	.word	0x0800b220
	...

08009840 <rt_test_007_009_execute>:

static void rt_test_007_009_execute(void) {
 8009840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  }
  test_end_step(1);

  /* [7.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8009842:	2502      	movs	r5, #2
 8009844:	4b1b      	ldr	r3, [pc, #108]	; (80098b4 <rt_test_007_009_execute+0x74>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8009846:	4e1c      	ldr	r6, [pc, #112]	; (80098b8 <rt_test_007_009_execute+0x78>)
  return chThdGetSelfX()->prio;
 8009848:	699b      	ldr	r3, [r3, #24]
  test_set_step(2);
 800984a:	4c1c      	ldr	r4, [pc, #112]	; (80098bc <rt_test_007_009_execute+0x7c>)
 800984c:	689f      	ldr	r7, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 800984e:	4630      	mov	r0, r6
 8009850:	1c79      	adds	r1, r7, #1
 8009852:	4b1b      	ldr	r3, [pc, #108]	; (80098c0 <rt_test_007_009_execute+0x80>)
 8009854:	4a1b      	ldr	r2, [pc, #108]	; (80098c4 <rt_test_007_009_execute+0x84>)
  test_set_step(2);
 8009856:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8009858:	f7f9 ff72 	bl	8003740 <chThdCreateStatic.constprop.68>
  }
  test_end_step(2);

  /* [7.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 800985c:	f04f 0c03 	mov.w	ip, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8009860:	4d19      	ldr	r5, [pc, #100]	; (80098c8 <rt_test_007_009_execute+0x88>)
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8009862:	1cb9      	adds	r1, r7, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8009864:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8009866:	4b19      	ldr	r3, [pc, #100]	; (80098cc <rt_test_007_009_execute+0x8c>)
 8009868:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 800986c:	4a18      	ldr	r2, [pc, #96]	; (80098d0 <rt_test_007_009_execute+0x90>)
  test_set_step(3);
 800986e:	f8c4 c000 	str.w	ip, [r4]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8009872:	f7f9 ff65 	bl	8003740 <chThdCreateStatic.constprop.68>
  }
  test_end_step(3);

  /* [7.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 8009876:	f04f 0c04 	mov.w	ip, #4
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 800987a:	1cf9      	adds	r1, r7, #3
 800987c:	4a15      	ldr	r2, [pc, #84]	; (80098d4 <rt_test_007_009_execute+0x94>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 800987e:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8009880:	4b15      	ldr	r3, [pc, #84]	; (80098d8 <rt_test_007_009_execute+0x98>)
 8009882:	f506 7024 	add.w	r0, r6, #656	; 0x290
  test_set_step(4);
 8009886:	f8c4 c000 	str.w	ip, [r4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 800988a:	f7f9 ff59 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_end_step(4);

  /* [7.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 800988e:	2305      	movs	r3, #5
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8009890:	60a8      	str	r0, [r5, #8]
  test_set_step(5);
 8009892:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8009894:	f7f9 ff9c 	bl	80037d0 <chCondSignal.constprop.59>
  }
  test_end_step(5);

  /* [7.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 8009898:	2306      	movs	r3, #6
 800989a:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 800989c:	f7f9 ff98 	bl	80037d0 <chCondSignal.constprop.59>
  }
  test_end_step(6);

  /* [7.9.7] Checking the order of operations.*/
  test_set_step(7);
 80098a0:	2307      	movs	r3, #7
 80098a2:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 80098a4:	f7ff f9cc 	bl	8008c40 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
  }
  test_end_step(7);
}
 80098a8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABC", "invalid sequence");
 80098ac:	490b      	ldr	r1, [pc, #44]	; (80098dc <rt_test_007_009_execute+0x9c>)
 80098ae:	480c      	ldr	r0, [pc, #48]	; (80098e0 <rt_test_007_009_execute+0xa0>)
 80098b0:	f7f7 bbee 	b.w	8001090 <_test_assert_sequence>
 80098b4:	20001254 	.word	0x20001254
 80098b8:	20001680 	.word	0x20001680
 80098bc:	20001d94 	.word	0x20001d94
 80098c0:	0800c184 	.word	0x0800c184
 80098c4:	08006f31 	.word	0x08006f31
 80098c8:	20001dac 	.word	0x20001dac
 80098cc:	0800c3c0 	.word	0x0800c3c0
 80098d0:	08006fc1 	.word	0x08006fc1
 80098d4:	08007031 	.word	0x08007031
 80098d8:	0800c188 	.word	0x0800c188
 80098dc:	0800c260 	.word	0x0800c260
 80098e0:	0800c274 	.word	0x0800c274
	...

080098f0 <rt_test_007_008_execute>:
static void rt_test_007_008_execute(void) {
 80098f0:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 80098f2:	2401      	movs	r4, #1
  return ch.rlist.current;
 80098f4:	4b25      	ldr	r3, [pc, #148]	; (800998c <rt_test_007_008_execute+0x9c>)
 80098f6:	4e26      	ldr	r6, [pc, #152]	; (8009990 <rt_test_007_008_execute+0xa0>)
  return chThdGetSelfX()->prio;
 80098f8:	699a      	ldr	r2, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80098fa:	4826      	ldr	r0, [pc, #152]	; (8009994 <rt_test_007_008_execute+0xa4>)
 80098fc:	6895      	ldr	r5, [r2, #8]
 80098fe:	4b26      	ldr	r3, [pc, #152]	; (8009998 <rt_test_007_008_execute+0xa8>)
 8009900:	1929      	adds	r1, r5, r4
 8009902:	4a26      	ldr	r2, [pc, #152]	; (800999c <rt_test_007_008_execute+0xac>)
  test_set_step(1);
 8009904:	6034      	str	r4, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8009906:	f7f9 ff1b 	bl	8003740 <chThdCreateStatic.constprop.68>
 800990a:	4c25      	ldr	r4, [pc, #148]	; (80099a0 <rt_test_007_008_execute+0xb0>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 800990c:	1ca9      	adds	r1, r5, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800990e:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8009910:	4b24      	ldr	r3, [pc, #144]	; (80099a4 <rt_test_007_008_execute+0xb4>)
 8009912:	4a22      	ldr	r2, [pc, #136]	; (800999c <rt_test_007_008_execute+0xac>)
 8009914:	4824      	ldr	r0, [pc, #144]	; (80099a8 <rt_test_007_008_execute+0xb8>)
 8009916:	f7f9 ff13 	bl	8003740 <chThdCreateStatic.constprop.68>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800991a:	1ce9      	adds	r1, r5, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 800991c:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800991e:	4b23      	ldr	r3, [pc, #140]	; (80099ac <rt_test_007_008_execute+0xbc>)
 8009920:	4a1e      	ldr	r2, [pc, #120]	; (800999c <rt_test_007_008_execute+0xac>)
 8009922:	4823      	ldr	r0, [pc, #140]	; (80099b0 <rt_test_007_008_execute+0xc0>)
 8009924:	f7f9 ff0c 	bl	8003740 <chThdCreateStatic.constprop.68>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8009928:	1d29      	adds	r1, r5, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800992a:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800992c:	4b21      	ldr	r3, [pc, #132]	; (80099b4 <rt_test_007_008_execute+0xc4>)
 800992e:	4a1b      	ldr	r2, [pc, #108]	; (800999c <rt_test_007_008_execute+0xac>)
 8009930:	4821      	ldr	r0, [pc, #132]	; (80099b8 <rt_test_007_008_execute+0xc8>)
 8009932:	f7f9 ff05 	bl	8003740 <chThdCreateStatic.constprop.68>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8009936:	1d69      	adds	r1, r5, #5
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8009938:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800993a:	4b20      	ldr	r3, [pc, #128]	; (80099bc <rt_test_007_008_execute+0xcc>)
 800993c:	4a17      	ldr	r2, [pc, #92]	; (800999c <rt_test_007_008_execute+0xac>)
 800993e:	4820      	ldr	r0, [pc, #128]	; (80099c0 <rt_test_007_008_execute+0xd0>)
 8009940:	f7f9 fefe 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(2);
 8009944:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8009946:	6120      	str	r0, [r4, #16]
  test_set_step(2);
 8009948:	6033      	str	r3, [r6, #0]
 800994a:	2320      	movs	r3, #32
 800994c:	f383 8811 	msr	BASEPRI, r3
  return (bool)(tqp->next != (const thread_t *)tqp);
 8009950:	4c1c      	ldr	r4, [pc, #112]	; (80099c4 <rt_test_007_008_execute+0xd4>)
 8009952:	6823      	ldr	r3, [r4, #0]
  while (queue_notempty(&cp->queue)) {
 8009954:	42a3      	cmp	r3, r4
 8009956:	d00b      	beq.n	8009970 <rt_test_007_008_execute+0x80>
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8009958:	f06f 0501 	mvn.w	r5, #1
  tqp->next             = tp->queue.next;
 800995c:	681a      	ldr	r2, [r3, #0]
 800995e:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 8009960:	6054      	str	r4, [r2, #4]
  tqp->next             = tp->queue.next;
 8009962:	6022      	str	r2, [r4, #0]
 8009964:	f7f7 fe44 	bl	80015f0 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8009968:	6823      	ldr	r3, [r4, #0]
 800996a:	6245      	str	r5, [r0, #36]	; 0x24
  while (queue_notempty(&cp->queue)) {
 800996c:	42a3      	cmp	r3, r4
 800996e:	d1f5      	bne.n	800995c <rt_test_007_008_execute+0x6c>
  chSchRescheduleS();
 8009970:	f7fb fabe 	bl	8004ef0 <chSchRescheduleS>
 8009974:	2300      	movs	r3, #0
 8009976:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 800997a:	f7ff f961 	bl	8008c40 <test_wait_threads>
}
 800997e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 8009982:	4911      	ldr	r1, [pc, #68]	; (80099c8 <rt_test_007_008_execute+0xd8>)
 8009984:	4811      	ldr	r0, [pc, #68]	; (80099cc <rt_test_007_008_execute+0xdc>)
 8009986:	f7f7 bb83 	b.w	8001090 <_test_assert_sequence>
 800998a:	bf00      	nop
 800998c:	20001254 	.word	0x20001254
 8009990:	20001d94 	.word	0x20001d94
 8009994:	20001680 	.word	0x20001680
 8009998:	0800c200 	.word	0x0800c200
 800999c:	08006fc1 	.word	0x08006fc1
 80099a0:	20001dac 	.word	0x20001dac
 80099a4:	0800d248 	.word	0x0800d248
 80099a8:	200017c8 	.word	0x200017c8
 80099ac:	0800c3c0 	.word	0x0800c3c0
 80099b0:	20001910 	.word	0x20001910
 80099b4:	0800c188 	.word	0x0800c188
 80099b8:	20001a58 	.word	0x20001a58
 80099bc:	0800c184 	.word	0x0800c184
 80099c0:	20001ba0 	.word	0x20001ba0
 80099c4:	20000c04 	.word	0x20000c04
 80099c8:	0800c260 	.word	0x0800c260
 80099cc:	0800c1fc 	.word	0x0800c1fc

080099d0 <rt_test_007_007_execute>:
static void rt_test_007_007_execute(void) {
 80099d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 80099d4:	2401      	movs	r4, #1
  return ch.rlist.current;
 80099d6:	4b27      	ldr	r3, [pc, #156]	; (8009a74 <rt_test_007_007_execute+0xa4>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80099d8:	4e27      	ldr	r6, [pc, #156]	; (8009a78 <rt_test_007_007_execute+0xa8>)
  return chThdGetSelfX()->prio;
 80099da:	699b      	ldr	r3, [r3, #24]
 80099dc:	4d27      	ldr	r5, [pc, #156]	; (8009a7c <rt_test_007_007_execute+0xac>)
 80099de:	689f      	ldr	r7, [r3, #8]
  test_set_step(1);
 80099e0:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 8009aa0 <rt_test_007_007_execute+0xd0>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80099e4:	1939      	adds	r1, r7, r4
 80099e6:	4632      	mov	r2, r6
 80099e8:	4628      	mov	r0, r5
 80099ea:	4b25      	ldr	r3, [pc, #148]	; (8009a80 <rt_test_007_007_execute+0xb0>)
  test_set_step(1);
 80099ec:	f8c8 4000 	str.w	r4, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80099f0:	f7f9 fea6 	bl	8003740 <chThdCreateStatic.constprop.68>
 80099f4:	4c23      	ldr	r4, [pc, #140]	; (8009a84 <rt_test_007_007_execute+0xb4>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80099f6:	1cb9      	adds	r1, r7, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80099f8:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80099fa:	4632      	mov	r2, r6
 80099fc:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 8009a00:	4b21      	ldr	r3, [pc, #132]	; (8009a88 <rt_test_007_007_execute+0xb8>)
 8009a02:	f7f9 fe9d 	bl	8003740 <chThdCreateStatic.constprop.68>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8009a06:	1cf9      	adds	r1, r7, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8009a08:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8009a0a:	4632      	mov	r2, r6
 8009a0c:	f505 7024 	add.w	r0, r5, #656	; 0x290
 8009a10:	4b1e      	ldr	r3, [pc, #120]	; (8009a8c <rt_test_007_007_execute+0xbc>)
 8009a12:	f7f9 fe95 	bl	8003740 <chThdCreateStatic.constprop.68>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8009a16:	1d39      	adds	r1, r7, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8009a18:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8009a1a:	4632      	mov	r2, r6
 8009a1c:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
 8009a20:	4b1b      	ldr	r3, [pc, #108]	; (8009a90 <rt_test_007_007_execute+0xc0>)
 8009a22:	f7f9 fe8d 	bl	8003740 <chThdCreateStatic.constprop.68>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8009a26:	1d79      	adds	r1, r7, #5
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8009a28:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8009a2a:	4632      	mov	r2, r6
 8009a2c:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
 8009a30:	4b18      	ldr	r3, [pc, #96]	; (8009a94 <rt_test_007_007_execute+0xc4>)
 8009a32:	f7f9 fe85 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(2);
 8009a36:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8009a38:	6120      	str	r0, [r4, #16]
  test_set_step(2);
 8009a3a:	f8c8 3000 	str.w	r3, [r8]
 8009a3e:	2320      	movs	r3, #32
 8009a40:	f383 8811 	msr	BASEPRI, r3
    chCondSignalI(&c1);
 8009a44:	f7f7 fe8c 	bl	8001760 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 8009a48:	f7f7 fe8a 	bl	8001760 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 8009a4c:	f7f7 fe88 	bl	8001760 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 8009a50:	f7f7 fe86 	bl	8001760 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 8009a54:	f7f7 fe84 	bl	8001760 <chCondSignalI.constprop.58>
    chSchRescheduleS();
 8009a58:	f7fb fa4a 	bl	8004ef0 <chSchRescheduleS>
 8009a5c:	2300      	movs	r3, #0
 8009a5e:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 8009a62:	f7ff f8ed 	bl	8008c40 <test_wait_threads>
}
 8009a66:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 8009a6a:	490b      	ldr	r1, [pc, #44]	; (8009a98 <rt_test_007_007_execute+0xc8>)
 8009a6c:	480b      	ldr	r0, [pc, #44]	; (8009a9c <rt_test_007_007_execute+0xcc>)
 8009a6e:	f7f7 bb0f 	b.w	8001090 <_test_assert_sequence>
 8009a72:	bf00      	nop
 8009a74:	20001254 	.word	0x20001254
 8009a78:	08006fc1 	.word	0x08006fc1
 8009a7c:	20001680 	.word	0x20001680
 8009a80:	0800c200 	.word	0x0800c200
 8009a84:	20001dac 	.word	0x20001dac
 8009a88:	0800d248 	.word	0x0800d248
 8009a8c:	0800c3c0 	.word	0x0800c3c0
 8009a90:	0800c188 	.word	0x0800c188
 8009a94:	0800c184 	.word	0x0800c184
 8009a98:	0800c260 	.word	0x0800c260
 8009a9c:	0800c1fc 	.word	0x0800c1fc
 8009aa0:	20001d94 	.word	0x20001d94
	...

08009ab0 <rt_test_006_006_teardown>:
  test_wait_threads();
 8009ab0:	f7ff b8c6 	b.w	8008c40 <test_wait_threads>
	...

08009ac0 <rt_test_007_004_teardown>:
 8009ac0:	f7ff b8be 	b.w	8008c40 <test_wait_threads>
	...

08009ad0 <rt_test_007_001_execute>:
static void rt_test_007_001_execute(void) {
 8009ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(2);
 8009ad2:	2302      	movs	r3, #2
  test_set_step(3);
 8009ad4:	2503      	movs	r5, #3
  return ch.rlist.current;
 8009ad6:	4f22      	ldr	r7, [pc, #136]	; (8009b60 <rt_test_007_001_execute+0x90>)
  test_set_step(2);
 8009ad8:	4e22      	ldr	r6, [pc, #136]	; (8009b64 <rt_test_007_001_execute+0x94>)
  return chThdGetSelfX()->prio;
 8009ada:	69ba      	ldr	r2, [r7, #24]
    chMtxLock(&m1);
 8009adc:	4822      	ldr	r0, [pc, #136]	; (8009b68 <rt_test_007_001_execute+0x98>)
 8009ade:	6894      	ldr	r4, [r2, #8]
  test_set_step(2);
 8009ae0:	6033      	str	r3, [r6, #0]
    chMtxLock(&m1);
 8009ae2:	f7fa feed 	bl	80048c0 <chMtxLock>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8009ae6:	1c61      	adds	r1, r4, #1
 8009ae8:	4b20      	ldr	r3, [pc, #128]	; (8009b6c <rt_test_007_001_execute+0x9c>)
 8009aea:	4a21      	ldr	r2, [pc, #132]	; (8009b70 <rt_test_007_001_execute+0xa0>)
 8009aec:	4821      	ldr	r0, [pc, #132]	; (8009b74 <rt_test_007_001_execute+0xa4>)
  test_set_step(3);
 8009aee:	6035      	str	r5, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8009af0:	f7f9 fe26 	bl	8003740 <chThdCreateStatic.constprop.68>
 8009af4:	4d20      	ldr	r5, [pc, #128]	; (8009b78 <rt_test_007_001_execute+0xa8>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8009af6:	1ca1      	adds	r1, r4, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8009af8:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8009afa:	4b20      	ldr	r3, [pc, #128]	; (8009b7c <rt_test_007_001_execute+0xac>)
 8009afc:	4a1c      	ldr	r2, [pc, #112]	; (8009b70 <rt_test_007_001_execute+0xa0>)
 8009afe:	4820      	ldr	r0, [pc, #128]	; (8009b80 <rt_test_007_001_execute+0xb0>)
 8009b00:	f7f9 fe1e 	bl	8003740 <chThdCreateStatic.constprop.68>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8009b04:	1ce1      	adds	r1, r4, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8009b06:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8009b08:	4b1e      	ldr	r3, [pc, #120]	; (8009b84 <rt_test_007_001_execute+0xb4>)
 8009b0a:	4a19      	ldr	r2, [pc, #100]	; (8009b70 <rt_test_007_001_execute+0xa0>)
 8009b0c:	481e      	ldr	r0, [pc, #120]	; (8009b88 <rt_test_007_001_execute+0xb8>)
 8009b0e:	f7f9 fe17 	bl	8003740 <chThdCreateStatic.constprop.68>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8009b12:	1d21      	adds	r1, r4, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8009b14:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8009b16:	4b1d      	ldr	r3, [pc, #116]	; (8009b8c <rt_test_007_001_execute+0xbc>)
 8009b18:	4a15      	ldr	r2, [pc, #84]	; (8009b70 <rt_test_007_001_execute+0xa0>)
 8009b1a:	481d      	ldr	r0, [pc, #116]	; (8009b90 <rt_test_007_001_execute+0xc0>)
 8009b1c:	f7f9 fe10 	bl	8003740 <chThdCreateStatic.constprop.68>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8009b20:	1d61      	adds	r1, r4, #5
 8009b22:	4a13      	ldr	r2, [pc, #76]	; (8009b70 <rt_test_007_001_execute+0xa0>)
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8009b24:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8009b26:	4b1b      	ldr	r3, [pc, #108]	; (8009b94 <rt_test_007_001_execute+0xc4>)
 8009b28:	481b      	ldr	r0, [pc, #108]	; (8009b98 <rt_test_007_001_execute+0xc8>)
 8009b2a:	f7f9 fe09 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(4);
 8009b2e:	2304      	movs	r3, #4
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8009b30:	6128      	str	r0, [r5, #16]
    chMtxUnlock(&m1);
 8009b32:	480d      	ldr	r0, [pc, #52]	; (8009b68 <rt_test_007_001_execute+0x98>)
  test_set_step(4);
 8009b34:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m1);
 8009b36:	f7fc fb93 	bl	8006260 <chMtxUnlock>
    test_wait_threads();
 8009b3a:	f7ff f881 	bl	8008c40 <test_wait_threads>
 8009b3e:	69bb      	ldr	r3, [r7, #24]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 8009b40:	4916      	ldr	r1, [pc, #88]	; (8009b9c <rt_test_007_001_execute+0xcc>)
 8009b42:	6898      	ldr	r0, [r3, #8]
 8009b44:	1b00      	subs	r0, r0, r4
 8009b46:	fab0 f080 	clz	r0, r0
 8009b4a:	0940      	lsrs	r0, r0, #5
 8009b4c:	f7f7 f920 	bl	8000d90 <_test_assert>
 8009b50:	b100      	cbz	r0, 8009b54 <rt_test_007_001_execute+0x84>
}
 8009b52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert_sequence("ABCDE", "invalid sequence");
 8009b54:	4912      	ldr	r1, [pc, #72]	; (8009ba0 <rt_test_007_001_execute+0xd0>)
 8009b56:	4813      	ldr	r0, [pc, #76]	; (8009ba4 <rt_test_007_001_execute+0xd4>)
}
 8009b58:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 8009b5c:	f7f7 ba98 	b.w	8001090 <_test_assert_sequence>
 8009b60:	20001254 	.word	0x20001254
 8009b64:	20001d94 	.word	0x20001d94
 8009b68:	20000c38 	.word	0x20000c38
 8009b6c:	0800c200 	.word	0x0800c200
 8009b70:	08007301 	.word	0x08007301
 8009b74:	20001680 	.word	0x20001680
 8009b78:	20001dac 	.word	0x20001dac
 8009b7c:	0800d248 	.word	0x0800d248
 8009b80:	200017c8 	.word	0x200017c8
 8009b84:	0800c3c0 	.word	0x0800c3c0
 8009b88:	20001910 	.word	0x20001910
 8009b8c:	0800c188 	.word	0x0800c188
 8009b90:	20001a58 	.word	0x20001a58
 8009b94:	0800c184 	.word	0x0800c184
 8009b98:	20001ba0 	.word	0x20001ba0
 8009b9c:	0800c1c4 	.word	0x0800c1c4
 8009ba0:	0800c260 	.word	0x0800c260
 8009ba4:	0800c1fc 	.word	0x0800c1fc
	...

08009bb0 <rt_test_006_005_teardown>:
 8009bb0:	f7ff b846 	b.w	8008c40 <test_wait_threads>
	...

08009bc0 <rt_test_006_004_execute>:
static void rt_test_006_004_execute(void) {
 8009bc0:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 8009bc2:	2501      	movs	r5, #1
  return ch.rlist.current;
 8009bc4:	4b22      	ldr	r3, [pc, #136]	; (8009c50 <rt_test_006_004_execute+0x90>)
 8009bc6:	4c23      	ldr	r4, [pc, #140]	; (8009c54 <rt_test_006_004_execute+0x94>)
  return chThdGetSelfX()->prio;
 8009bc8:	699a      	ldr	r2, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8009bca:	4823      	ldr	r0, [pc, #140]	; (8009c58 <rt_test_006_004_execute+0x98>)
 8009bcc:	6891      	ldr	r1, [r2, #8]
 8009bce:	4b23      	ldr	r3, [pc, #140]	; (8009c5c <rt_test_006_004_execute+0x9c>)
 8009bd0:	4429      	add	r1, r5
 8009bd2:	4a23      	ldr	r2, [pc, #140]	; (8009c60 <rt_test_006_004_execute+0xa0>)
  test_set_step(1);
 8009bd4:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8009bd6:	f7f9 fdb3 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(2);
 8009bda:	2502      	movs	r5, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8009bdc:	4b21      	ldr	r3, [pc, #132]	; (8009c64 <rt_test_006_004_execute+0xa4>)
  test_set_step(2);
 8009bde:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8009be0:	6018      	str	r0, [r3, #0]
 8009be2:	2320      	movs	r3, #32
 8009be4:	f383 8811 	msr	BASEPRI, r3
 8009be8:	4c1f      	ldr	r4, [pc, #124]	; (8009c68 <rt_test_006_004_execute+0xa8>)
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8009bea:	2600      	movs	r6, #0
 8009bec:	e002      	b.n	8009bf4 <rt_test_006_004_execute+0x34>
  while (n > (cnt_t)0) {
 8009bee:	2d01      	cmp	r5, #1
 8009bf0:	d00e      	beq.n	8009c10 <rt_test_006_004_execute+0x50>
 8009bf2:	2501      	movs	r5, #1
    if (++sp->cnt <= (cnt_t)0) {
 8009bf4:	68a3      	ldr	r3, [r4, #8]
 8009bf6:	3301      	adds	r3, #1
 8009bf8:	2b00      	cmp	r3, #0
 8009bfa:	60a3      	str	r3, [r4, #8]
 8009bfc:	dcf7      	bgt.n	8009bee <rt_test_006_004_execute+0x2e>
  thread_t *tp = tqp->next;
 8009bfe:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
 8009c00:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8009c02:	605c      	str	r4, [r3, #4]
  tqp->next             = tp->queue.next;
 8009c04:	6023      	str	r3, [r4, #0]
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8009c06:	f7f7 fcf3 	bl	80015f0 <chSchReadyI>
  while (n > (cnt_t)0) {
 8009c0a:	2d01      	cmp	r5, #1
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8009c0c:	6246      	str	r6, [r0, #36]	; 0x24
  while (n > (cnt_t)0) {
 8009c0e:	d1f0      	bne.n	8009bf2 <rt_test_006_004_execute+0x32>
    chSchRescheduleS();
 8009c10:	f7fb f96e 	bl	8004ef0 <chSchRescheduleS>
 8009c14:	2500      	movs	r5, #0
 8009c16:	f385 8811 	msr	BASEPRI, r5
    test_wait_threads();
 8009c1a:	f7ff f811 	bl	8008c40 <test_wait_threads>
 8009c1e:	2320      	movs	r3, #32
 8009c20:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 8009c24:	68a0      	ldr	r0, [r4, #8]
 8009c26:	4911      	ldr	r1, [pc, #68]	; (8009c6c <rt_test_006_004_execute+0xac>)
 8009c28:	f1a0 0001 	sub.w	r0, r0, #1
 8009c2c:	fab0 f080 	clz	r0, r0
 8009c30:	0940      	lsrs	r0, r0, #5
 8009c32:	f7f7 f8ad 	bl	8000d90 <_test_assert>
 8009c36:	b110      	cbz	r0, 8009c3e <rt_test_006_004_execute+0x7e>
 8009c38:	f385 8811 	msr	BASEPRI, r5
}
 8009c3c:	bd70      	pop	{r4, r5, r6, pc}
 8009c3e:	f380 8811 	msr	BASEPRI, r0
    test_assert_sequence("A", "invalid sequence");
 8009c42:	490b      	ldr	r1, [pc, #44]	; (8009c70 <rt_test_006_004_execute+0xb0>)
 8009c44:	4805      	ldr	r0, [pc, #20]	; (8009c5c <rt_test_006_004_execute+0x9c>)
}
 8009c46:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert_sequence("A", "invalid sequence");
 8009c4a:	f7f7 ba21 	b.w	8001090 <_test_assert_sequence>
 8009c4e:	bf00      	nop
 8009c50:	20001254 	.word	0x20001254
 8009c54:	20001d94 	.word	0x20001d94
 8009c58:	20001680 	.word	0x20001680
 8009c5c:	0800c184 	.word	0x0800c184
 8009c60:	08004b31 	.word	0x08004b31
 8009c64:	20001dac 	.word	0x20001dac
 8009c68:	20001660 	.word	0x20001660
 8009c6c:	0800c0d0 	.word	0x0800c0d0
 8009c70:	0800c260 	.word	0x0800c260
	...

08009c80 <rt_test_006_003_execute>:
  test_set_step(1);
 8009c80:	2001      	movs	r0, #1
static void rt_test_006_003_execute(void) {
 8009c82:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_set_step(1);
 8009c86:	4d4b      	ldr	r5, [pc, #300]	; (8009db4 <rt_test_006_003_execute+0x134>)
 8009c88:	2320      	movs	r3, #32
 8009c8a:	6028      	str	r0, [r5, #0]
 8009c8c:	f383 8811 	msr	BASEPRI, r3
  if (--sp->cnt < (cnt_t)0) {
 8009c90:	4c49      	ldr	r4, [pc, #292]	; (8009db8 <rt_test_006_003_execute+0x138>)
 8009c92:	68a3      	ldr	r3, [r4, #8]
 8009c94:	3b01      	subs	r3, #1
 8009c96:	bf5c      	itt	pl
 8009c98:	60a3      	strpl	r3, [r4, #8]
 8009c9a:	2000      	movpl	r0, #0
 8009c9c:	2300      	movs	r3, #0
 8009c9e:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8009ca2:	4946      	ldr	r1, [pc, #280]	; (8009dbc <rt_test_006_003_execute+0x13c>)
 8009ca4:	f7f7 f874 	bl	8000d90 <_test_assert>
 8009ca8:	b108      	cbz	r0, 8009cae <rt_test_006_003_execute+0x2e>
}
 8009caa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  return (bool)(tqp->next == (const thread_t *)tqp);
 8009cae:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8009cb0:	4943      	ldr	r1, [pc, #268]	; (8009dc0 <rt_test_006_003_execute+0x140>)
 8009cb2:	1b00      	subs	r0, r0, r4
 8009cb4:	fab0 f080 	clz	r0, r0
 8009cb8:	0940      	lsrs	r0, r0, #5
 8009cba:	f7f7 f869 	bl	8000d90 <_test_assert>
 8009cbe:	2800      	cmp	r0, #0
 8009cc0:	d1f3      	bne.n	8009caa <rt_test_006_003_execute+0x2a>
    test_assert(sem1.cnt == 0, "counter not zero");
 8009cc2:	68a0      	ldr	r0, [r4, #8]
 8009cc4:	493f      	ldr	r1, [pc, #252]	; (8009dc4 <rt_test_006_003_execute+0x144>)
 8009cc6:	fab0 f080 	clz	r0, r0
 8009cca:	0940      	lsrs	r0, r0, #5
 8009ccc:	f7f7 f860 	bl	8000d90 <_test_assert>
 8009cd0:	2800      	cmp	r0, #0
 8009cd2:	d1ea      	bne.n	8009caa <rt_test_006_003_execute+0x2a>
  test_set_step(2);
 8009cd4:	2602      	movs	r6, #2
  return ch.rlist.current;
 8009cd6:	4a3c      	ldr	r2, [pc, #240]	; (8009dc8 <rt_test_006_003_execute+0x148>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009cd8:	4603      	mov	r3, r0
  return chThdGetSelfX()->prio;
 8009cda:	6991      	ldr	r1, [r2, #24]
 8009cdc:	483b      	ldr	r0, [pc, #236]	; (8009dcc <rt_test_006_003_execute+0x14c>)
 8009cde:	6889      	ldr	r1, [r1, #8]
 8009ce0:	4a3b      	ldr	r2, [pc, #236]	; (8009dd0 <rt_test_006_003_execute+0x150>)
 8009ce2:	3901      	subs	r1, #1
  test_set_step(2);
 8009ce4:	602e      	str	r6, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009ce6:	f7f9 fd2b 	bl	8003740 <chThdCreateStatic.constprop.68>
 8009cea:	4b3a      	ldr	r3, [pc, #232]	; (8009dd4 <rt_test_006_003_execute+0x154>)
 8009cec:	6018      	str	r0, [r3, #0]
    msg = chSemWaitTimeout(&sem1, TIME_MS2I(500));
 8009cee:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8009cf2:	f7f9 fe95 	bl	8003a20 <chSemWaitTimeout.constprop.65>
 8009cf6:	4606      	mov	r6, r0
    test_wait_threads();
 8009cf8:	f7fe ffa2 	bl	8008c40 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 8009cfc:	fab6 f086 	clz	r0, r6
 8009d00:	492e      	ldr	r1, [pc, #184]	; (8009dbc <rt_test_006_003_execute+0x13c>)
 8009d02:	0940      	lsrs	r0, r0, #5
 8009d04:	f7f7 f844 	bl	8000d90 <_test_assert>
 8009d08:	2800      	cmp	r0, #0
 8009d0a:	d1ce      	bne.n	8009caa <rt_test_006_003_execute+0x2a>
 8009d0c:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8009d0e:	492c      	ldr	r1, [pc, #176]	; (8009dc0 <rt_test_006_003_execute+0x140>)
 8009d10:	1b00      	subs	r0, r0, r4
 8009d12:	fab0 f080 	clz	r0, r0
 8009d16:	0940      	lsrs	r0, r0, #5
 8009d18:	f7f7 f83a 	bl	8000d90 <_test_assert>
 8009d1c:	2800      	cmp	r0, #0
 8009d1e:	d1c4      	bne.n	8009caa <rt_test_006_003_execute+0x2a>
    test_assert(sem1.cnt == 0, "counter not zero");
 8009d20:	68a0      	ldr	r0, [r4, #8]
 8009d22:	4928      	ldr	r1, [pc, #160]	; (8009dc4 <rt_test_006_003_execute+0x144>)
 8009d24:	fab0 f080 	clz	r0, r0
 8009d28:	0940      	lsrs	r0, r0, #5
 8009d2a:	f7f7 f831 	bl	8000d90 <_test_assert>
 8009d2e:	2800      	cmp	r0, #0
 8009d30:	d1bb      	bne.n	8009caa <rt_test_006_003_execute+0x2a>
  test_set_step(3);
 8009d32:	2303      	movs	r3, #3
 8009d34:	602b      	str	r3, [r5, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
 8009d36:	f7fa fa23 	bl	8004180 <test_wait_tick>
 8009d3a:	2641      	movs	r6, #65	; 0x41
 8009d3c:	4681      	mov	r9, r0
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8009d3e:	f8df 807c 	ldr.w	r8, [pc, #124]	; 8009dbc <rt_test_006_003_execute+0x13c>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8009d42:	4f1f      	ldr	r7, [pc, #124]	; (8009dc0 <rt_test_006_003_execute+0x140>)
      test_assert(sem1.cnt == 0, "counter not zero");
 8009d44:	4d1f      	ldr	r5, [pc, #124]	; (8009dc4 <rt_test_006_003_execute+0x144>)
      test_emit_token('A' + i);
 8009d46:	4630      	mov	r0, r6
 8009d48:	f7f7 f8ca 	bl	8000ee0 <test_emit_token>
      msg = chSemWaitTimeout(&sem1, TIME_MS2I(50));
 8009d4c:	2064      	movs	r0, #100	; 0x64
 8009d4e:	f7f9 fe67 	bl	8003a20 <chSemWaitTimeout.constprop.65>
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8009d52:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8009d56:	fab0 f080 	clz	r0, r0
 8009d5a:	4641      	mov	r1, r8
 8009d5c:	0940      	lsrs	r0, r0, #5
 8009d5e:	f7f7 f817 	bl	8000d90 <_test_assert>
 8009d62:	2800      	cmp	r0, #0
 8009d64:	d1a1      	bne.n	8009caa <rt_test_006_003_execute+0x2a>
 8009d66:	6820      	ldr	r0, [r4, #0]
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8009d68:	4639      	mov	r1, r7
 8009d6a:	1b00      	subs	r0, r0, r4
 8009d6c:	fab0 f080 	clz	r0, r0
 8009d70:	0940      	lsrs	r0, r0, #5
 8009d72:	f7f7 f80d 	bl	8000d90 <_test_assert>
 8009d76:	2800      	cmp	r0, #0
 8009d78:	d197      	bne.n	8009caa <rt_test_006_003_execute+0x2a>
      test_assert(sem1.cnt == 0, "counter not zero");
 8009d7a:	68a0      	ldr	r0, [r4, #8]
 8009d7c:	4629      	mov	r1, r5
 8009d7e:	fab0 f080 	clz	r0, r0
 8009d82:	0940      	lsrs	r0, r0, #5
 8009d84:	f7f7 f804 	bl	8000d90 <_test_assert>
 8009d88:	3601      	adds	r6, #1
 8009d8a:	b2f6      	uxtb	r6, r6
 8009d8c:	2800      	cmp	r0, #0
 8009d8e:	d18c      	bne.n	8009caa <rt_test_006_003_execute+0x2a>
    for (i = 0; i < 5; i++) {
 8009d90:	2e46      	cmp	r6, #70	; 0x46
 8009d92:	d1d8      	bne.n	8009d46 <rt_test_006_003_execute+0xc6>
    test_assert_sequence("ABCDE", "invalid sequence");
 8009d94:	4910      	ldr	r1, [pc, #64]	; (8009dd8 <rt_test_006_003_execute+0x158>)
 8009d96:	4811      	ldr	r0, [pc, #68]	; (8009ddc <rt_test_006_003_execute+0x15c>)
 8009d98:	f7f7 f97a 	bl	8001090 <_test_assert_sequence>
 8009d9c:	2800      	cmp	r0, #0
 8009d9e:	d184      	bne.n	8009caa <rt_test_006_003_execute+0x2a>
 8009da0:	f509 71fc 	add.w	r1, r9, #504	; 0x1f8
 8009da4:	f509 70fa 	add.w	r0, r9, #500	; 0x1f4
    test_assert_time_window(target_time,
 8009da8:	b289      	uxth	r1, r1
 8009daa:	b280      	uxth	r0, r0
}
 8009dac:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_assert_time_window(target_time,
 8009db0:	f7f6 bd8e 	b.w	80008d0 <_test_assert_time_window.constprop.3>
 8009db4:	20001d94 	.word	0x20001d94
 8009db8:	20001660 	.word	0x20001660
 8009dbc:	0800b238 	.word	0x0800b238
 8009dc0:	0800c0f0 	.word	0x0800c0f0
 8009dc4:	0800c100 	.word	0x0800c100
 8009dc8:	20001254 	.word	0x20001254
 8009dcc:	20001680 	.word	0x20001680
 8009dd0:	08005811 	.word	0x08005811
 8009dd4:	20001dac 	.word	0x20001dac
 8009dd8:	0800c260 	.word	0x0800c260
 8009ddc:	0800c1fc 	.word	0x0800c1fc

08009de0 <rt_test_006_002_execute>:
static void rt_test_006_002_execute(void) {
 8009de0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8009de4:	2501      	movs	r5, #1
  return ch.rlist.current;
 8009de6:	4f2a      	ldr	r7, [pc, #168]	; (8009e90 <rt_test_006_002_execute+0xb0>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8009de8:	4e2a      	ldr	r6, [pc, #168]	; (8009e94 <rt_test_006_002_execute+0xb4>)
  return chThdGetSelfX()->prio;
 8009dea:	69bb      	ldr	r3, [r7, #24]
 8009dec:	4c2a      	ldr	r4, [pc, #168]	; (8009e98 <rt_test_006_002_execute+0xb8>)
 8009dee:	6899      	ldr	r1, [r3, #8]
  test_set_step(1);
 8009df0:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 8009ec0 <rt_test_006_002_execute+0xe0>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8009df4:	4632      	mov	r2, r6
 8009df6:	3105      	adds	r1, #5
 8009df8:	4620      	mov	r0, r4
 8009dfa:	4b28      	ldr	r3, [pc, #160]	; (8009e9c <rt_test_006_002_execute+0xbc>)
  test_set_step(1);
 8009dfc:	f8c8 5000 	str.w	r5, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8009e00:	f7f9 fc9e 	bl	8003740 <chThdCreateStatic.constprop.68>
 8009e04:	69bb      	ldr	r3, [r7, #24]
 8009e06:	4d26      	ldr	r5, [pc, #152]	; (8009ea0 <rt_test_006_002_execute+0xc0>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8009e08:	6899      	ldr	r1, [r3, #8]
 8009e0a:	4632      	mov	r2, r6
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8009e0c:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8009e0e:	3101      	adds	r1, #1
 8009e10:	f504 70a4 	add.w	r0, r4, #328	; 0x148
 8009e14:	4b23      	ldr	r3, [pc, #140]	; (8009ea4 <rt_test_006_002_execute+0xc4>)
 8009e16:	f7f9 fc93 	bl	8003740 <chThdCreateStatic.constprop.68>
 8009e1a:	69bb      	ldr	r3, [r7, #24]
 8009e1c:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8009e1e:	6899      	ldr	r1, [r3, #8]
 8009e20:	4632      	mov	r2, r6
 8009e22:	3103      	adds	r1, #3
 8009e24:	f504 7024 	add.w	r0, r4, #656	; 0x290
 8009e28:	4b1f      	ldr	r3, [pc, #124]	; (8009ea8 <rt_test_006_002_execute+0xc8>)
 8009e2a:	f7f9 fc89 	bl	8003740 <chThdCreateStatic.constprop.68>
 8009e2e:	69bb      	ldr	r3, [r7, #24]
 8009e30:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8009e32:	6899      	ldr	r1, [r3, #8]
 8009e34:	4632      	mov	r2, r6
 8009e36:	3104      	adds	r1, #4
 8009e38:	f504 7076 	add.w	r0, r4, #984	; 0x3d8
 8009e3c:	4b1b      	ldr	r3, [pc, #108]	; (8009eac <rt_test_006_002_execute+0xcc>)
 8009e3e:	f7f9 fc7f 	bl	8003740 <chThdCreateStatic.constprop.68>
 8009e42:	69bb      	ldr	r3, [r7, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8009e44:	4632      	mov	r2, r6
 8009e46:	6899      	ldr	r1, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8009e48:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8009e4a:	3102      	adds	r1, #2
 8009e4c:	f504 60a4 	add.w	r0, r4, #1312	; 0x520
 8009e50:	4b17      	ldr	r3, [pc, #92]	; (8009eb0 <rt_test_006_002_execute+0xd0>)
 8009e52:	f7f9 fc75 	bl	8003740 <chThdCreateStatic.constprop.68>
  test_set_step(2);
 8009e56:	2302      	movs	r3, #2
    chSemSignal(&sem1);
 8009e58:	4c16      	ldr	r4, [pc, #88]	; (8009eb4 <rt_test_006_002_execute+0xd4>)
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8009e5a:	6128      	str	r0, [r5, #16]
    chSemSignal(&sem1);
 8009e5c:	4620      	mov	r0, r4
  test_set_step(2);
 8009e5e:	f8c8 3000 	str.w	r3, [r8]
    chSemSignal(&sem1);
 8009e62:	f7f9 fcfd 	bl	8003860 <chSemSignal>
    chSemSignal(&sem1);
 8009e66:	4620      	mov	r0, r4
 8009e68:	f7f9 fcfa 	bl	8003860 <chSemSignal>
    chSemSignal(&sem1);
 8009e6c:	4620      	mov	r0, r4
 8009e6e:	f7f9 fcf7 	bl	8003860 <chSemSignal>
    chSemSignal(&sem1);
 8009e72:	4620      	mov	r0, r4
 8009e74:	f7f9 fcf4 	bl	8003860 <chSemSignal>
    chSemSignal(&sem1);
 8009e78:	4620      	mov	r0, r4
 8009e7a:	f7f9 fcf1 	bl	8003860 <chSemSignal>
    test_wait_threads();
 8009e7e:	f7fe fedf 	bl	8008c40 <test_wait_threads>
}
 8009e82:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 8009e86:	490c      	ldr	r1, [pc, #48]	; (8009eb8 <rt_test_006_002_execute+0xd8>)
 8009e88:	480c      	ldr	r0, [pc, #48]	; (8009ebc <rt_test_006_002_execute+0xdc>)
 8009e8a:	f7f7 b901 	b.w	8001090 <_test_assert_sequence>
 8009e8e:	bf00      	nop
 8009e90:	20001254 	.word	0x20001254
 8009e94:	08004b31 	.word	0x08004b31
 8009e98:	20001680 	.word	0x20001680
 8009e9c:	0800c184 	.word	0x0800c184
 8009ea0:	20001dac 	.word	0x20001dac
 8009ea4:	0800c188 	.word	0x0800c188
 8009ea8:	0800c3c0 	.word	0x0800c3c0
 8009eac:	0800d248 	.word	0x0800d248
 8009eb0:	0800c200 	.word	0x0800c200
 8009eb4:	20001660 	.word	0x20001660
 8009eb8:	0800c260 	.word	0x0800c260
 8009ebc:	0800c1fc 	.word	0x0800c1fc
 8009ec0:	20001d94 	.word	0x20001d94
	...

08009ed0 <rt_test_005_001_execute>:

static void rt_test_005_001_execute(void) {
 8009ed0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  msg_t msg;

  /* [5.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 8009ed4:	2401      	movs	r4, #1
  return ch.rlist.current;
 8009ed6:	4d31      	ldr	r5, [pc, #196]	; (8009f9c <rt_test_005_001_execute+0xcc>)
 8009ed8:	4f31      	ldr	r7, [pc, #196]	; (8009fa0 <rt_test_005_001_execute+0xd0>)
  return chThdGetSelfX()->prio;
 8009eda:	69aa      	ldr	r2, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 8009edc:	4b31      	ldr	r3, [pc, #196]	; (8009fa4 <rt_test_005_001_execute+0xd4>)
 8009ede:	6891      	ldr	r1, [r2, #8]
 8009ee0:	4831      	ldr	r0, [pc, #196]	; (8009fa8 <rt_test_005_001_execute+0xd8>)
 8009ee2:	4a32      	ldr	r2, [pc, #200]	; (8009fac <rt_test_005_001_execute+0xdc>)
 8009ee4:	3901      	subs	r1, #1
  test_set_step(1);
 8009ee6:	603c      	str	r4, [r7, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 8009ee8:	f7f9 fc2a 	bl	8003740 <chThdCreateStatic.constprop.68>
 8009eec:	4b30      	ldr	r3, [pc, #192]	; (8009fb0 <rt_test_005_001_execute+0xe0>)
 8009eee:	2620      	movs	r6, #32
 8009ef0:	6018      	str	r0, [r3, #0]
 8009ef2:	f386 8811 	msr	BASEPRI, r6
  *trp = tp;
 8009ef6:	4c2f      	ldr	r4, [pc, #188]	; (8009fb4 <rt_test_005_001_execute+0xe4>)
  return ch.rlist.current;
 8009ef8:	69ab      	ldr	r3, [r5, #24]
    chSchGoSleepS(newstate);
 8009efa:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
 8009efc:	625c      	str	r4, [r3, #36]	; 0x24
  *trp = tp;
 8009efe:	6023      	str	r3, [r4, #0]
 8009f00:	f7f9 fcde 	bl	80038c0 <chSchGoSleepS>
  return currp->u.rdymsg;
 8009f04:	69aa      	ldr	r2, [r5, #24]
 8009f06:	2300      	movs	r3, #0
 8009f08:	f8d2 8024 	ldr.w	r8, [r2, #36]	; 0x24
 8009f0c:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
 8009f10:	6820      	ldr	r0, [r4, #0]
 8009f12:	4929      	ldr	r1, [pc, #164]	; (8009fb8 <rt_test_005_001_execute+0xe8>)
 8009f14:	fab0 f080 	clz	r0, r0
 8009f18:	0940      	lsrs	r0, r0, #5
 8009f1a:	f7f6 ff39 	bl	8000d90 <_test_assert>
 8009f1e:	b108      	cbz	r0, 8009f24 <rt_test_005_001_execute+0x54>
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
  }
  test_end_step(2);
}
 8009f20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(MSG_OK == msg,"wrong returned message");
 8009f24:	fab8 f088 	clz	r0, r8
 8009f28:	4924      	ldr	r1, [pc, #144]	; (8009fbc <rt_test_005_001_execute+0xec>)
 8009f2a:	0940      	lsrs	r0, r0, #5
 8009f2c:	f7f6 ff30 	bl	8000d90 <_test_assert>
 8009f30:	4680      	mov	r8, r0
 8009f32:	2800      	cmp	r0, #0
 8009f34:	d1f4      	bne.n	8009f20 <rt_test_005_001_execute+0x50>
    test_wait_threads();
 8009f36:	f7fe fe83 	bl	8008c40 <test_wait_threads>
  test_set_step(2);
 8009f3a:	2302      	movs	r3, #2
 8009f3c:	603b      	str	r3, [r7, #0]
 8009f3e:	f386 8811 	msr	BASEPRI, r6
 8009f42:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8009f46:	69ab      	ldr	r3, [r5, #24]
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8009f48:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8009f4c:	6a55      	ldr	r5, [r2, #36]	; 0x24
 8009f4e:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
 8009f50:	625c      	str	r4, [r3, #36]	; 0x24
  *trp = tp;
 8009f52:	6023      	str	r3, [r4, #0]
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8009f54:	f7f9 fd3c 	bl	80039d0 <chSchGoSleepTimeoutS>
 8009f58:	b2ad      	uxth	r5, r5
 8009f5a:	4606      	mov	r6, r0
 8009f5c:	f388 8811 	msr	BASEPRI, r8
 8009f60:	f205 71d3 	addw	r1, r5, #2003	; 0x7d3
 8009f64:	f505 60fa 	add.w	r0, r5, #2000	; 0x7d0
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(1000)),
 8009f68:	b289      	uxth	r1, r1
 8009f6a:	b280      	uxth	r0, r0
 8009f6c:	f7f6 fcb0 	bl	80008d0 <_test_assert_time_window.constprop.3>
 8009f70:	2800      	cmp	r0, #0
 8009f72:	d1d5      	bne.n	8009f20 <rt_test_005_001_execute+0x50>
    test_assert(NULL == tr1, "not NULL");
 8009f74:	6820      	ldr	r0, [r4, #0]
 8009f76:	4910      	ldr	r1, [pc, #64]	; (8009fb8 <rt_test_005_001_execute+0xe8>)
 8009f78:	fab0 f080 	clz	r0, r0
 8009f7c:	0940      	lsrs	r0, r0, #5
 8009f7e:	f7f6 ff07 	bl	8000d90 <_test_assert>
 8009f82:	2800      	cmp	r0, #0
 8009f84:	d1cc      	bne.n	8009f20 <rt_test_005_001_execute+0x50>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8009f86:	f1a6 30ff 	sub.w	r0, r6, #4294967295	; 0xffffffff
 8009f8a:	fab0 f080 	clz	r0, r0
}
 8009f8e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8009f92:	0940      	lsrs	r0, r0, #5
 8009f94:	4909      	ldr	r1, [pc, #36]	; (8009fbc <rt_test_005_001_execute+0xec>)
 8009f96:	f7f6 befb 	b.w	8000d90 <_test_assert>
 8009f9a:	bf00      	nop
 8009f9c:	20001254 	.word	0x20001254
 8009fa0:	20001d94 	.word	0x20001d94
 8009fa4:	0800c184 	.word	0x0800c184
 8009fa8:	20001680 	.word	0x20001680
 8009fac:	08005871 	.word	0x08005871
 8009fb0:	20001dac 	.word	0x20001dac
 8009fb4:	20001dc0 	.word	0x20001dc0
 8009fb8:	0800c058 	.word	0x0800c058
 8009fbc:	0800c088 	.word	0x0800c088

08009fc0 <rt_test_004_002_execute>:
 * - [4.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void rt_test_004_002_execute(void) {
 8009fc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [4.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 8009fc2:	2401      	movs	r4, #1
 8009fc4:	4d53      	ldr	r5, [pc, #332]	; (800a114 <rt_test_004_002_execute+0x154>)
 8009fc6:	4e54      	ldr	r6, [pc, #336]	; (800a118 <rt_test_004_002_execute+0x158>)
  return chThdGetSelfX()->prio;
 8009fc8:	69aa      	ldr	r2, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8009fca:	4b54      	ldr	r3, [pc, #336]	; (800a11c <rt_test_004_002_execute+0x15c>)
 8009fcc:	6891      	ldr	r1, [r2, #8]
 8009fce:	4854      	ldr	r0, [pc, #336]	; (800a120 <rt_test_004_002_execute+0x160>)
 8009fd0:	4a54      	ldr	r2, [pc, #336]	; (800a124 <rt_test_004_002_execute+0x164>)
 8009fd2:	3905      	subs	r1, #5
  test_set_step(1);
 8009fd4:	6034      	str	r4, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8009fd6:	f7f9 fbb3 	bl	8003740 <chThdCreateStatic.constprop.68>
 8009fda:	69ab      	ldr	r3, [r5, #24]
 8009fdc:	4c52      	ldr	r4, [pc, #328]	; (800a128 <rt_test_004_002_execute+0x168>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8009fde:	6899      	ldr	r1, [r3, #8]
 8009fe0:	4a50      	ldr	r2, [pc, #320]	; (800a124 <rt_test_004_002_execute+0x164>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8009fe2:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8009fe4:	3904      	subs	r1, #4
 8009fe6:	4b51      	ldr	r3, [pc, #324]	; (800a12c <rt_test_004_002_execute+0x16c>)
 8009fe8:	4851      	ldr	r0, [pc, #324]	; (800a130 <rt_test_004_002_execute+0x170>)
 8009fea:	f7f9 fba9 	bl	8003740 <chThdCreateStatic.constprop.68>
 8009fee:	69ab      	ldr	r3, [r5, #24]
 8009ff0:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8009ff2:	6899      	ldr	r1, [r3, #8]
 8009ff4:	4a4b      	ldr	r2, [pc, #300]	; (800a124 <rt_test_004_002_execute+0x164>)
 8009ff6:	4b4f      	ldr	r3, [pc, #316]	; (800a134 <rt_test_004_002_execute+0x174>)
 8009ff8:	3903      	subs	r1, #3
 8009ffa:	484f      	ldr	r0, [pc, #316]	; (800a138 <rt_test_004_002_execute+0x178>)
 8009ffc:	f7f9 fba0 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a000:	69ab      	ldr	r3, [r5, #24]
 800a002:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800a004:	6899      	ldr	r1, [r3, #8]
 800a006:	4a47      	ldr	r2, [pc, #284]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a008:	4b4c      	ldr	r3, [pc, #304]	; (800a13c <rt_test_004_002_execute+0x17c>)
 800a00a:	3902      	subs	r1, #2
 800a00c:	484c      	ldr	r0, [pc, #304]	; (800a140 <rt_test_004_002_execute+0x180>)
 800a00e:	f7f9 fb97 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a012:	69ab      	ldr	r3, [r5, #24]
 800a014:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800a016:	6899      	ldr	r1, [r3, #8]
 800a018:	4a42      	ldr	r2, [pc, #264]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a01a:	3901      	subs	r1, #1
 800a01c:	4b49      	ldr	r3, [pc, #292]	; (800a144 <rt_test_004_002_execute+0x184>)
 800a01e:	484a      	ldr	r0, [pc, #296]	; (800a148 <rt_test_004_002_execute+0x188>)
 800a020:	f7f9 fb8e 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a024:	6120      	str	r0, [r4, #16]
    test_wait_threads();
 800a026:	f7fe fe0b 	bl	8008c40 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800a02a:	4948      	ldr	r1, [pc, #288]	; (800a14c <rt_test_004_002_execute+0x18c>)
 800a02c:	4848      	ldr	r0, [pc, #288]	; (800a150 <rt_test_004_002_execute+0x190>)
 800a02e:	f7f7 f82f 	bl	8001090 <_test_assert_sequence>
 800a032:	b100      	cbz	r0, 800a036 <rt_test_004_002_execute+0x76>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
  }
  test_end_step(3);
}
 800a034:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 800a036:	2702      	movs	r7, #2
 800a038:	69aa      	ldr	r2, [r5, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800a03a:	4b42      	ldr	r3, [pc, #264]	; (800a144 <rt_test_004_002_execute+0x184>)
 800a03c:	6891      	ldr	r1, [r2, #8]
 800a03e:	4842      	ldr	r0, [pc, #264]	; (800a148 <rt_test_004_002_execute+0x188>)
 800a040:	4a38      	ldr	r2, [pc, #224]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a042:	3901      	subs	r1, #1
  test_set_step(2);
 800a044:	6037      	str	r7, [r6, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800a046:	f7f9 fb7b 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a04a:	69ab      	ldr	r3, [r5, #24]
 800a04c:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800a04e:	6899      	ldr	r1, [r3, #8]
 800a050:	4a34      	ldr	r2, [pc, #208]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a052:	4b3a      	ldr	r3, [pc, #232]	; (800a13c <rt_test_004_002_execute+0x17c>)
 800a054:	3902      	subs	r1, #2
 800a056:	483a      	ldr	r0, [pc, #232]	; (800a140 <rt_test_004_002_execute+0x180>)
 800a058:	f7f9 fb72 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a05c:	69ab      	ldr	r3, [r5, #24]
 800a05e:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800a060:	6899      	ldr	r1, [r3, #8]
 800a062:	4a30      	ldr	r2, [pc, #192]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a064:	4b33      	ldr	r3, [pc, #204]	; (800a134 <rt_test_004_002_execute+0x174>)
 800a066:	3903      	subs	r1, #3
 800a068:	4833      	ldr	r0, [pc, #204]	; (800a138 <rt_test_004_002_execute+0x178>)
 800a06a:	f7f9 fb69 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a06e:	69ab      	ldr	r3, [r5, #24]
 800a070:	60a0      	str	r0, [r4, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800a072:	6899      	ldr	r1, [r3, #8]
 800a074:	4a2b      	ldr	r2, [pc, #172]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a076:	4b2d      	ldr	r3, [pc, #180]	; (800a12c <rt_test_004_002_execute+0x16c>)
 800a078:	3904      	subs	r1, #4
 800a07a:	482d      	ldr	r0, [pc, #180]	; (800a130 <rt_test_004_002_execute+0x170>)
 800a07c:	f7f9 fb60 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a080:	69ab      	ldr	r3, [r5, #24]
 800a082:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800a084:	6899      	ldr	r1, [r3, #8]
 800a086:	4a27      	ldr	r2, [pc, #156]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a088:	3905      	subs	r1, #5
 800a08a:	4b24      	ldr	r3, [pc, #144]	; (800a11c <rt_test_004_002_execute+0x15c>)
 800a08c:	4824      	ldr	r0, [pc, #144]	; (800a120 <rt_test_004_002_execute+0x160>)
 800a08e:	f7f9 fb57 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a092:	6020      	str	r0, [r4, #0]
    test_wait_threads();
 800a094:	f7fe fdd4 	bl	8008c40 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800a098:	492c      	ldr	r1, [pc, #176]	; (800a14c <rt_test_004_002_execute+0x18c>)
 800a09a:	482d      	ldr	r0, [pc, #180]	; (800a150 <rt_test_004_002_execute+0x190>)
 800a09c:	f7f6 fff8 	bl	8001090 <_test_assert_sequence>
 800a0a0:	2800      	cmp	r0, #0
 800a0a2:	d1c7      	bne.n	800a034 <rt_test_004_002_execute+0x74>
  test_set_step(3);
 800a0a4:	2003      	movs	r0, #3
 800a0a6:	69aa      	ldr	r2, [r5, #24]
 800a0a8:	6030      	str	r0, [r6, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800a0aa:	6891      	ldr	r1, [r2, #8]
 800a0ac:	4b1f      	ldr	r3, [pc, #124]	; (800a12c <rt_test_004_002_execute+0x16c>)
 800a0ae:	4a1d      	ldr	r2, [pc, #116]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a0b0:	3904      	subs	r1, #4
 800a0b2:	481f      	ldr	r0, [pc, #124]	; (800a130 <rt_test_004_002_execute+0x170>)
 800a0b4:	f7f9 fb44 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a0b8:	69ab      	ldr	r3, [r5, #24]
 800a0ba:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800a0bc:	6899      	ldr	r1, [r3, #8]
 800a0be:	4a19      	ldr	r2, [pc, #100]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a0c0:	4b16      	ldr	r3, [pc, #88]	; (800a11c <rt_test_004_002_execute+0x15c>)
 800a0c2:	3905      	subs	r1, #5
 800a0c4:	4816      	ldr	r0, [pc, #88]	; (800a120 <rt_test_004_002_execute+0x160>)
 800a0c6:	f7f9 fb3b 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a0ca:	69ab      	ldr	r3, [r5, #24]
 800a0cc:	6020      	str	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800a0ce:	6899      	ldr	r1, [r3, #8]
 800a0d0:	4a14      	ldr	r2, [pc, #80]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a0d2:	4b1c      	ldr	r3, [pc, #112]	; (800a144 <rt_test_004_002_execute+0x184>)
 800a0d4:	3901      	subs	r1, #1
 800a0d6:	481c      	ldr	r0, [pc, #112]	; (800a148 <rt_test_004_002_execute+0x188>)
 800a0d8:	f7f9 fb32 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a0dc:	69ab      	ldr	r3, [r5, #24]
 800a0de:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800a0e0:	6899      	ldr	r1, [r3, #8]
 800a0e2:	4a10      	ldr	r2, [pc, #64]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a0e4:	4b15      	ldr	r3, [pc, #84]	; (800a13c <rt_test_004_002_execute+0x17c>)
 800a0e6:	3902      	subs	r1, #2
 800a0e8:	4815      	ldr	r0, [pc, #84]	; (800a140 <rt_test_004_002_execute+0x180>)
 800a0ea:	f7f9 fb29 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a0ee:	69ab      	ldr	r3, [r5, #24]
 800a0f0:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800a0f2:	6899      	ldr	r1, [r3, #8]
 800a0f4:	4a0b      	ldr	r2, [pc, #44]	; (800a124 <rt_test_004_002_execute+0x164>)
 800a0f6:	4b0f      	ldr	r3, [pc, #60]	; (800a134 <rt_test_004_002_execute+0x174>)
 800a0f8:	3903      	subs	r1, #3
 800a0fa:	480f      	ldr	r0, [pc, #60]	; (800a138 <rt_test_004_002_execute+0x178>)
 800a0fc:	f7f9 fb20 	bl	8003740 <chThdCreateStatic.constprop.68>
 800a100:	60a0      	str	r0, [r4, #8]
    test_wait_threads();
 800a102:	f7fe fd9d 	bl	8008c40 <test_wait_threads>
}
 800a106:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 800a10a:	4910      	ldr	r1, [pc, #64]	; (800a14c <rt_test_004_002_execute+0x18c>)
 800a10c:	4810      	ldr	r0, [pc, #64]	; (800a150 <rt_test_004_002_execute+0x190>)
 800a10e:	f7f6 bfbf 	b.w	8001090 <_test_assert_sequence>
 800a112:	bf00      	nop
 800a114:	20001254 	.word	0x20001254
 800a118:	20001d94 	.word	0x20001d94
 800a11c:	0800c200 	.word	0x0800c200
 800a120:	20001680 	.word	0x20001680
 800a124:	08001001 	.word	0x08001001
 800a128:	20001dac 	.word	0x20001dac
 800a12c:	0800d248 	.word	0x0800d248
 800a130:	200017c8 	.word	0x200017c8
 800a134:	0800c3c0 	.word	0x0800c3c0
 800a138:	20001910 	.word	0x20001910
 800a13c:	0800c188 	.word	0x0800c188
 800a140:	20001a58 	.word	0x20001a58
 800a144:	0800c184 	.word	0x0800c184
 800a148:	20001ba0 	.word	0x20001ba0
 800a14c:	0800c260 	.word	0x0800c260
 800a150:	0800c1fc 	.word	0x0800c1fc
	...

0800a160 <cmd_test>:
}

static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 800a160:	b530      	push	{r4, r5, lr}
  thread_t *tp;
  tfunc_t tfp;

  (void)argv;
  if (argc != 1) {
 800a162:	2901      	cmp	r1, #1
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 800a164:	b083      	sub	sp, #12
 800a166:	4604      	mov	r4, r0
  if (argc != 1) {
 800a168:	d11c      	bne.n	800a1a4 <cmd_test+0x44>
    shellUsage(chp, "test rt|oslib");
    return;
  }
  if (!strcmp(argv[0], "rt")) {
 800a16a:	6815      	ldr	r5, [r2, #0]
 800a16c:	4916      	ldr	r1, [pc, #88]	; (800a1c8 <cmd_test+0x68>)
 800a16e:	4628      	mov	r0, r5
 800a170:	f7f6 f9e2 	bl	8000538 <strcmp>
 800a174:	b1f0      	cbz	r0, 800a1b4 <cmd_test+0x54>
    tfp = test_rt;
  }
  else if (!strcmp(argv[0], "oslib")) {
 800a176:	4628      	mov	r0, r5
 800a178:	4914      	ldr	r1, [pc, #80]	; (800a1cc <cmd_test+0x6c>)
 800a17a:	f7f6 f9dd 	bl	8000538 <strcmp>
 800a17e:	b988      	cbnz	r0, 800a1a4 <cmd_test+0x44>
    tfp = test_oslib;
 800a180:	4813      	ldr	r0, [pc, #76]	; (800a1d0 <cmd_test+0x70>)
  return ch.rlist.current;
 800a182:	4b14      	ldr	r3, [pc, #80]	; (800a1d4 <cmd_test+0x74>)
  }
  else {
    shellUsage(chp, "test rt|oslib");
    return;
  }
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
 800a184:	4a14      	ldr	r2, [pc, #80]	; (800a1d8 <cmd_test+0x78>)
  return chThdGetSelfX()->prio;
 800a186:	699b      	ldr	r3, [r3, #24]
 800a188:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 800a18c:	689b      	ldr	r3, [r3, #8]
 800a18e:	e9cd 0400 	strd	r0, r4, [sp]
 800a192:	2000      	movs	r0, #0
 800a194:	f7fc f93c 	bl	8006410 <chThdCreateFromHeap>
                           "test", chThdGetPriorityX(),
                           tfp, chp);
  if (tp == NULL) {
 800a198:	b170      	cbz	r0, 800a1b8 <cmd_test+0x58>
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
    return;
  }
  chThdWait(tp);
}
 800a19a:	b003      	add	sp, #12
 800a19c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  chThdWait(tp);
 800a1a0:	f7fe b926 	b.w	80083f0 <chThdWait>
    shellUsage(chp, "test rt|oslib");
 800a1a4:	4620      	mov	r0, r4
 800a1a6:	4a0d      	ldr	r2, [pc, #52]	; (800a1dc <cmd_test+0x7c>)
 800a1a8:	490d      	ldr	r1, [pc, #52]	; (800a1e0 <cmd_test+0x80>)
}
 800a1aa:	b003      	add	sp, #12
 800a1ac:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    shellUsage(chp, "test rt|oslib");
 800a1b0:	f7f8 bf16 	b.w	8002fe0 <chprintf>
    tfp = test_rt;
 800a1b4:	480b      	ldr	r0, [pc, #44]	; (800a1e4 <cmd_test+0x84>)
 800a1b6:	e7e4      	b.n	800a182 <cmd_test+0x22>
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
 800a1b8:	4620      	mov	r0, r4
 800a1ba:	490b      	ldr	r1, [pc, #44]	; (800a1e8 <cmd_test+0x88>)
}
 800a1bc:	b003      	add	sp, #12
 800a1be:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
 800a1c2:	f7f8 bf0d 	b.w	8002fe0 <chprintf>
 800a1c6:	bf00      	nop
 800a1c8:	0800abf4 	.word	0x0800abf4
 800a1cc:	0800abec 	.word	0x0800abec
 800a1d0:	08004671 	.word	0x08004671
 800a1d4:	20001254 	.word	0x20001254
 800a1d8:	0800cd34 	.word	0x0800cd34
 800a1dc:	0800abe4 	.word	0x0800abe4
 800a1e0:	0800abd0 	.word	0x0800abd0
 800a1e4:	08004661 	.word	0x08004661
 800a1e8:	0800abf8 	.word	0x0800abf8
 800a1ec:	00000000 	.word	0x00000000

0800a1f0 <chThdSetPriority>:
tprio_t chThdSetPriority(tprio_t newprio) {
 800a1f0:	b510      	push	{r4, lr}
 800a1f2:	2320      	movs	r3, #32
 800a1f4:	f383 8811 	msr	BASEPRI, r3
  oldprio = currp->realprio;
 800a1f8:	4b08      	ldr	r3, [pc, #32]	; (800a21c <chThdSetPriority+0x2c>)
 800a1fa:	699b      	ldr	r3, [r3, #24]
 800a1fc:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 800a1fe:	6899      	ldr	r1, [r3, #8]
 800a200:	42a1      	cmp	r1, r4
 800a202:	d001      	beq.n	800a208 <chThdSetPriority+0x18>
 800a204:	4281      	cmp	r1, r0
 800a206:	d200      	bcs.n	800a20a <chThdSetPriority+0x1a>
    currp->prio = newprio;
 800a208:	6098      	str	r0, [r3, #8]
  currp->realprio = newprio;
 800a20a:	63d8      	str	r0, [r3, #60]	; 0x3c
  chSchRescheduleS();
 800a20c:	f7fa fe70 	bl	8004ef0 <chSchRescheduleS>
 800a210:	2300      	movs	r3, #0
 800a212:	f383 8811 	msr	BASEPRI, r3
}
 800a216:	4620      	mov	r0, r4
 800a218:	bd10      	pop	{r4, pc}
 800a21a:	bf00      	nop
 800a21c:	20001254 	.word	0x20001254

0800a220 <rt_test_004_004_execute>:
  }
  test_end_step(1);

  /* [4.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 800a220:	2202      	movs	r2, #2
static void rt_test_004_004_execute(void) {
 800a222:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
 800a226:	4d2f      	ldr	r5, [pc, #188]	; (800a2e4 <rt_test_004_004_execute+0xc4>)
  test_set_step(2);
 800a228:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 800a2f8 <rt_test_004_004_execute+0xd8>
 800a22c:	69ab      	ldr	r3, [r5, #24]
 800a22e:	f8c8 2000 	str.w	r2, [r8]
  return chThdGetSelfX()->prio;
 800a232:	689c      	ldr	r4, [r3, #8]
    chThdGetSelfX()->prio += 2;
 800a234:	18a6      	adds	r6, r4, r2
  {
    p1 = chThdSetPriority(prio + 1);
 800a236:	1c67      	adds	r7, r4, #1
    chThdGetSelfX()->prio += 2;
 800a238:	609e      	str	r6, [r3, #8]
    p1 = chThdSetPriority(prio + 1);
 800a23a:	4638      	mov	r0, r7
 800a23c:	f7ff ffd8 	bl	800a1f0 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 800a240:	1b00      	subs	r0, r0, r4
 800a242:	fab0 f080 	clz	r0, r0
 800a246:	4928      	ldr	r1, [pc, #160]	; (800a2e8 <rt_test_004_004_execute+0xc8>)
 800a248:	0940      	lsrs	r0, r0, #5
 800a24a:	f7f6 fda1 	bl	8000d90 <_test_assert>
 800a24e:	b108      	cbz	r0, 800a254 <rt_test_004_004_execute+0x34>
    chThdGetSelfX()->prio = prio;
    chThdGetSelfX()->realprio = prio;
    chSysUnlock();
  }
  test_end_step(4);
}
 800a250:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 800a254:	69ab      	ldr	r3, [r5, #24]
 800a256:	4925      	ldr	r1, [pc, #148]	; (800a2ec <rt_test_004_004_execute+0xcc>)
 800a258:	6898      	ldr	r0, [r3, #8]
 800a25a:	1b80      	subs	r0, r0, r6
 800a25c:	fab0 f080 	clz	r0, r0
 800a260:	0940      	lsrs	r0, r0, #5
 800a262:	f7f6 fd95 	bl	8000d90 <_test_assert>
 800a266:	2800      	cmp	r0, #0
 800a268:	d1f2      	bne.n	800a250 <rt_test_004_004_execute+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 800a26a:	69ab      	ldr	r3, [r5, #24]
 800a26c:	4920      	ldr	r1, [pc, #128]	; (800a2f0 <rt_test_004_004_execute+0xd0>)
 800a26e:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 800a270:	1bc0      	subs	r0, r0, r7
 800a272:	fab0 f080 	clz	r0, r0
 800a276:	0940      	lsrs	r0, r0, #5
 800a278:	f7f6 fd8a 	bl	8000d90 <_test_assert>
 800a27c:	2800      	cmp	r0, #0
 800a27e:	d1e7      	bne.n	800a250 <rt_test_004_004_execute+0x30>
  test_set_step(3);
 800a280:	2303      	movs	r3, #3
    p1 = chThdSetPriority(prio + 3);
 800a282:	18e6      	adds	r6, r4, r3
 800a284:	4630      	mov	r0, r6
  test_set_step(3);
 800a286:	f8c8 3000 	str.w	r3, [r8]
    p1 = chThdSetPriority(prio + 3);
 800a28a:	f7ff ffb1 	bl	800a1f0 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 800a28e:	1a38      	subs	r0, r7, r0
 800a290:	fab0 f080 	clz	r0, r0
 800a294:	4914      	ldr	r1, [pc, #80]	; (800a2e8 <rt_test_004_004_execute+0xc8>)
 800a296:	0940      	lsrs	r0, r0, #5
 800a298:	f7f6 fd7a 	bl	8000d90 <_test_assert>
 800a29c:	2800      	cmp	r0, #0
 800a29e:	d1d7      	bne.n	800a250 <rt_test_004_004_execute+0x30>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 800a2a0:	69ab      	ldr	r3, [r5, #24]
 800a2a2:	4912      	ldr	r1, [pc, #72]	; (800a2ec <rt_test_004_004_execute+0xcc>)
 800a2a4:	6898      	ldr	r0, [r3, #8]
 800a2a6:	1b80      	subs	r0, r0, r6
 800a2a8:	fab0 f080 	clz	r0, r0
 800a2ac:	0940      	lsrs	r0, r0, #5
 800a2ae:	f7f6 fd6f 	bl	8000d90 <_test_assert>
 800a2b2:	2800      	cmp	r0, #0
 800a2b4:	d1cc      	bne.n	800a250 <rt_test_004_004_execute+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 800a2b6:	69ab      	ldr	r3, [r5, #24]
 800a2b8:	490e      	ldr	r1, [pc, #56]	; (800a2f4 <rt_test_004_004_execute+0xd4>)
 800a2ba:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 800a2bc:	1b80      	subs	r0, r0, r6
 800a2be:	fab0 f080 	clz	r0, r0
 800a2c2:	0940      	lsrs	r0, r0, #5
 800a2c4:	f7f6 fd64 	bl	8000d90 <_test_assert>
 800a2c8:	2800      	cmp	r0, #0
 800a2ca:	d1c1      	bne.n	800a250 <rt_test_004_004_execute+0x30>
  test_set_step(4);
 800a2cc:	2304      	movs	r3, #4
 800a2ce:	f8c8 3000 	str.w	r3, [r8]
 800a2d2:	2320      	movs	r3, #32
 800a2d4:	f383 8811 	msr	BASEPRI, r3
  return ch.rlist.current;
 800a2d8:	69ab      	ldr	r3, [r5, #24]
    chThdGetSelfX()->prio = prio;
 800a2da:	609c      	str	r4, [r3, #8]
    chThdGetSelfX()->realprio = prio;
 800a2dc:	63dc      	str	r4, [r3, #60]	; 0x3c
 800a2de:	f380 8811 	msr	BASEPRI, r0
 800a2e2:	e7b5      	b.n	800a250 <rt_test_004_004_execute+0x30>
 800a2e4:	20001254 	.word	0x20001254
 800a2e8:	0800bfc0 	.word	0x0800bfc0
 800a2ec:	0800bfe4 	.word	0x0800bfe4
 800a2f0:	0800c000 	.word	0x0800c000
 800a2f4:	0800c028 	.word	0x0800c028
 800a2f8:	20001d94 	.word	0x20001d94
 800a2fc:	00000000 	.word	0x00000000

0800a300 <rt_test_004_003_execute>:
  test_set_step(1);
 800a300:	2201      	movs	r2, #1
static void rt_test_004_003_execute(void) {
 800a302:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a306:	4e1c      	ldr	r6, [pc, #112]	; (800a378 <rt_test_004_003_execute+0x78>)
  test_set_step(1);
 800a308:	4f1c      	ldr	r7, [pc, #112]	; (800a37c <rt_test_004_003_execute+0x7c>)
  return chThdGetSelfX()->prio;
 800a30a:	69b3      	ldr	r3, [r6, #24]
 800a30c:	603a      	str	r2, [r7, #0]
 800a30e:	689c      	ldr	r4, [r3, #8]
    p1 = chThdSetPriority(prio + 1);
 800a310:	18a5      	adds	r5, r4, r2
 800a312:	4628      	mov	r0, r5
 800a314:	f7ff ff6c 	bl	800a1f0 <chThdSetPriority>
 800a318:	4680      	mov	r8, r0
    test_assert(p1 == prio, "unexpected returned priority level");
 800a31a:	1b00      	subs	r0, r0, r4
 800a31c:	fab0 f080 	clz	r0, r0
 800a320:	4917      	ldr	r1, [pc, #92]	; (800a380 <rt_test_004_003_execute+0x80>)
 800a322:	0940      	lsrs	r0, r0, #5
 800a324:	f7f6 fd34 	bl	8000d90 <_test_assert>
 800a328:	b108      	cbz	r0, 800a32e <rt_test_004_003_execute+0x2e>
}
 800a32a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a32e:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 800a330:	4914      	ldr	r1, [pc, #80]	; (800a384 <rt_test_004_003_execute+0x84>)
 800a332:	6898      	ldr	r0, [r3, #8]
 800a334:	1b40      	subs	r0, r0, r5
 800a336:	fab0 f080 	clz	r0, r0
 800a33a:	0940      	lsrs	r0, r0, #5
 800a33c:	f7f6 fd28 	bl	8000d90 <_test_assert>
 800a340:	2800      	cmp	r0, #0
 800a342:	d1f2      	bne.n	800a32a <rt_test_004_003_execute+0x2a>
  test_set_step(2);
 800a344:	2302      	movs	r3, #2
    p1 = chThdSetPriority(p1);
 800a346:	4640      	mov	r0, r8
  test_set_step(2);
 800a348:	603b      	str	r3, [r7, #0]
    p1 = chThdSetPriority(p1);
 800a34a:	f7ff ff51 	bl	800a1f0 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 800a34e:	1a28      	subs	r0, r5, r0
 800a350:	fab0 f080 	clz	r0, r0
 800a354:	490a      	ldr	r1, [pc, #40]	; (800a380 <rt_test_004_003_execute+0x80>)
 800a356:	0940      	lsrs	r0, r0, #5
 800a358:	f7f6 fd1a 	bl	8000d90 <_test_assert>
 800a35c:	2800      	cmp	r0, #0
 800a35e:	d1e4      	bne.n	800a32a <rt_test_004_003_execute+0x2a>
 800a360:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 800a362:	4908      	ldr	r1, [pc, #32]	; (800a384 <rt_test_004_003_execute+0x84>)
 800a364:	6898      	ldr	r0, [r3, #8]
 800a366:	1b00      	subs	r0, r0, r4
 800a368:	fab0 f080 	clz	r0, r0
}
 800a36c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 800a370:	0940      	lsrs	r0, r0, #5
 800a372:	f7f6 bd0d 	b.w	8000d90 <_test_assert>
 800a376:	bf00      	nop
 800a378:	20001254 	.word	0x20001254
 800a37c:	20001d94 	.word	0x20001d94
 800a380:	0800bfc0 	.word	0x0800bfc0
 800a384:	0800bfe4 	.word	0x0800bfe4
	...

0800a390 <chSysRestoreStatusX.part.2>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 800a390:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800a392:	f3ef 8405 	mrs	r4, IPSR
  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 800a396:	f3c4 0408 	ubfx	r4, r4, #0, #9

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 800a39a:	b11c      	cbz	r4, 800a3a4 <chSysRestoreStatusX.part.2+0x14>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a39c:	2300      	movs	r3, #0
 800a39e:	f383 8811 	msr	BASEPRI, r3
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
 800a3a2:	bd10      	pop	{r4, pc}
      chSchRescheduleS();
 800a3a4:	f7fa fda4 	bl	8004ef0 <chSchRescheduleS>
 800a3a8:	f384 8811 	msr	BASEPRI, r4
}
 800a3ac:	bd10      	pop	{r4, pc}
 800a3ae:	bf00      	nop

0800a3b0 <rt_test_002_002_execute>:
  test_set_step(1);
 800a3b0:	2301      	movs	r3, #1
static void rt_test_002_002_execute(void) {
 800a3b2:	b510      	push	{r4, lr}
  test_set_step(1);
 800a3b4:	4c30      	ldr	r4, [pc, #192]	; (800a478 <rt_test_002_002_execute+0xc8>)
static void rt_test_002_002_execute(void) {
 800a3b6:	b086      	sub	sp, #24
  test_set_step(1);
 800a3b8:	6023      	str	r3, [r4, #0]
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a3ba:	f3ef 8311 	mrs	r3, BASEPRI
  if (port_irq_enabled(sts)) {
 800a3be:	b91b      	cbnz	r3, 800a3c8 <rt_test_002_002_execute+0x18>
 800a3c0:	f7f7 fb46 	bl	8001a50 <chSysGetStatusAndLockX.part.1>
 800a3c4:	f7ff ffe4 	bl	800a390 <chSysRestoreStatusX.part.2>
  test_set_step(2);
 800a3c8:	2202      	movs	r2, #2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a3ca:	2320      	movs	r3, #32
 800a3cc:	6022      	str	r2, [r4, #0]
 800a3ce:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a3d2:	f3ef 8311 	mrs	r3, BASEPRI
 800a3d6:	b91b      	cbnz	r3, 800a3e0 <rt_test_002_002_execute+0x30>
 800a3d8:	f7f7 fb3a 	bl	8001a50 <chSysGetStatusAndLockX.part.1>
 800a3dc:	f7ff ffd8 	bl	800a390 <chSysRestoreStatusX.part.2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a3e0:	2300      	movs	r3, #0
 800a3e2:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 800a3e6:	2303      	movs	r3, #3
 800a3e8:	6023      	str	r3, [r4, #0]
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a3ea:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 800a3ee:	b913      	cbnz	r3, 800a3f6 <rt_test_002_002_execute+0x46>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a3f0:	2320      	movs	r3, #32
 800a3f2:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a3f6:	f3ef 8311 	mrs	r3, BASEPRI
 800a3fa:	b913      	cbnz	r3, 800a402 <rt_test_002_002_execute+0x52>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a3fc:	2320      	movs	r3, #32
 800a3fe:	f383 8811 	msr	BASEPRI, r3
 800a402:	2300      	movs	r3, #0
 800a404:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
 800a408:	2104      	movs	r1, #4
 800a40a:	2220      	movs	r2, #32
 800a40c:	6021      	str	r1, [r4, #0]
 800a40e:	f382 8811 	msr	BASEPRI, r2
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a412:	f3ef 8211 	mrs	r2, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 800a416:	b10a      	cbz	r2, 800a41c <rt_test_002_002_execute+0x6c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a418:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a41c:	f3ef 8311 	mrs	r3, BASEPRI
 800a420:	b113      	cbz	r3, 800a428 <rt_test_002_002_execute+0x78>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a422:	2300      	movs	r3, #0
 800a424:	f383 8811 	msr	BASEPRI, r3
  test_set_step(5);
 800a428:	2205      	movs	r2, #5
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 800a42a:	2300      	movs	r3, #0
 800a42c:	6022      	str	r2, [r4, #0]
 800a42e:	9304      	str	r3, [sp, #16]
 800a430:	2320      	movs	r3, #32
 800a432:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 800a436:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 800a438:	ac01      	add	r4, sp, #4
  if (chVTIsArmedI(vtp)) {
 800a43a:	b113      	cbz	r3, 800a442 <rt_test_002_002_execute+0x92>
    chVTDoResetI(vtp);
 800a43c:	4620      	mov	r0, r4
 800a43e:	f7f7 fa57 	bl	80018f0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 800a442:	4620      	mov	r0, r4
 800a444:	2300      	movs	r3, #0
 800a446:	4a0d      	ldr	r2, [pc, #52]	; (800a47c <rt_test_002_002_execute+0xcc>)
 800a448:	2101      	movs	r1, #1
 800a44a:	f7f7 fa99 	bl	8001980 <chVTDoSetI>
 800a44e:	2400      	movs	r4, #0
 800a450:	f384 8811 	msr	BASEPRI, r4
    chThdSleep(10);
 800a454:	200a      	movs	r0, #10
 800a456:	f7f9 fdf3 	bl	8004040 <chThdSleep>
 800a45a:	2320      	movs	r3, #32
 800a45c:	f383 8811 	msr	BASEPRI, r3
  b = chVTIsArmedI(vtp);
 800a460:	9804      	ldr	r0, [sp, #16]
 800a462:	f384 8811 	msr	BASEPRI, r4
    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 800a466:	fab0 f080 	clz	r0, r0
 800a46a:	4905      	ldr	r1, [pc, #20]	; (800a480 <rt_test_002_002_execute+0xd0>)
 800a46c:	0940      	lsrs	r0, r0, #5
 800a46e:	f7f6 fc8f 	bl	8000d90 <_test_assert>
}
 800a472:	b006      	add	sp, #24
 800a474:	bd10      	pop	{r4, pc}
 800a476:	bf00      	nop
 800a478:	20001d94 	.word	0x20001d94
 800a47c:	0800a491 	.word	0x0800a491
 800a480:	0800bf3c 	.word	0x0800bf3c
	...

0800a490 <vtcb>:
static void vtcb(void *p) {
 800a490:	b508      	push	{r3, lr}
 800a492:	2320      	movs	r3, #32
 800a494:	f383 8811 	msr	BASEPRI, r3
 800a498:	2200      	movs	r2, #0
 800a49a:	f382 8811 	msr	BASEPRI, r2
 800a49e:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a4a2:	f3ef 8311 	mrs	r3, BASEPRI
 800a4a6:	b91b      	cbnz	r3, 800a4b0 <vtcb+0x20>
 800a4a8:	f7f7 fad2 	bl	8001a50 <chSysGetStatusAndLockX.part.1>
 800a4ac:	f7ff ff70 	bl	800a390 <chSysRestoreStatusX.part.2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a4b0:	2300      	movs	r3, #0
 800a4b2:	f383 8811 	msr	BASEPRI, r3
}
 800a4b6:	bd08      	pop	{r3, pc}
	...

0800a4c0 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800a4c0:	4b1b      	ldr	r3, [pc, #108]	; (800a530 <__early_init+0x70>)
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800a4c2:	461a      	mov	r2, r3
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800a4c4:	6819      	ldr	r1, [r3, #0]
 800a4c6:	f041 0101 	orr.w	r1, r1, #1
 800a4ca:	6019      	str	r1, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800a4cc:	6813      	ldr	r3, [r2, #0]
 800a4ce:	0798      	lsls	r0, r3, #30
 800a4d0:	d5fc      	bpl.n	800a4cc <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800a4d2:	2000      	movs	r0, #0
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800a4d4:	6813      	ldr	r3, [r2, #0]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800a4d6:	4916      	ldr	r1, [pc, #88]	; (800a530 <__early_init+0x70>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800a4d8:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 800a4dc:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800a4de:	6050      	str	r0, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800a4e0:	684b      	ldr	r3, [r1, #4]
 800a4e2:	f013 0f0c 	tst.w	r3, #12
 800a4e6:	d1fb      	bne.n	800a4e0 <__early_init+0x20>
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 800a4e8:	680b      	ldr	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 800a4ea:	4a11      	ldr	r2, [pc, #68]	; (800a530 <__early_init+0x70>)
  RCC->CR |= RCC_CR_HSEON;
 800a4ec:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800a4f0:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 800a4f2:	6813      	ldr	r3, [r2, #0]
 800a4f4:	0399      	lsls	r1, r3, #14
 800a4f6:	d5fc      	bpl.n	800a4f2 <__early_init+0x32>
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 800a4f8:	6853      	ldr	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800a4fa:	490d      	ldr	r1, [pc, #52]	; (800a530 <__early_init+0x70>)
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 800a4fc:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 800a500:	6053      	str	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
 800a502:	6813      	ldr	r3, [r2, #0]
 800a504:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800a508:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800a50a:	680b      	ldr	r3, [r1, #0]
 800a50c:	019b      	lsls	r3, r3, #6
 800a50e:	d5fc      	bpl.n	800a50a <__early_init+0x4a>
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800a510:	2212      	movs	r2, #18
 800a512:	4b08      	ldr	r3, [pc, #32]	; (800a534 <__early_init+0x74>)
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 800a514:	4808      	ldr	r0, [pc, #32]	; (800a538 <__early_init+0x78>)
 800a516:	6048      	str	r0, [r1, #4]
  FLASH->ACR = STM32_FLASHBITS;
 800a518:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 800a51a:	684b      	ldr	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800a51c:	4a04      	ldr	r2, [pc, #16]	; (800a530 <__early_init+0x70>)
  RCC->CFGR |= STM32_SW;
 800a51e:	f043 0302 	orr.w	r3, r3, #2
 800a522:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800a524:	6853      	ldr	r3, [r2, #4]
 800a526:	f003 030c 	and.w	r3, r3, #12
 800a52a:	2b08      	cmp	r3, #8
 800a52c:	d1fa      	bne.n	800a524 <__early_init+0x64>
 * any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 800a52e:	4770      	bx	lr
 800a530:	40021000 	.word	0x40021000
 800a534:	40022000 	.word	0x40022000
 800a538:	001d6400 	.word	0x001d6400
 800a53c:	00000000 	.word	0x00000000

0800a540 <Vector90>:
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 800a540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  istr = STM32_USB->ISTR;
 800a544:	4bc3      	ldr	r3, [pc, #780]	; (800a854 <Vector90+0x314>)
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 800a546:	b085      	sub	sp, #20
  istr = STM32_USB->ISTR;
 800a548:	6c5c      	ldr	r4, [r3, #68]	; 0x44
  if (istr & ISTR_RESET) {
 800a54a:	0567      	lsls	r7, r4, #21
 800a54c:	f100 80ac 	bmi.w	800a6a8 <Vector90+0x168>
  if (istr & ISTR_SUSP) {
 800a550:	0526      	lsls	r6, r4, #20
 800a552:	f100 80cf 	bmi.w	800a6f4 <Vector90+0x1b4>
  if (istr & ISTR_WKUP) {
 800a556:	04e5      	lsls	r5, r4, #19
 800a558:	d508      	bpl.n	800a56c <Vector90+0x2c>
    uint32_t fnr = STM32_USB->FNR;
 800a55a:	4bbe      	ldr	r3, [pc, #760]	; (800a854 <Vector90+0x314>)
 800a55c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    if (!(fnr & FNR_RXDP)) {
 800a55e:	0410      	lsls	r0, r2, #16
 800a560:	f140 8150 	bpl.w	800a804 <Vector90+0x2c4>
    STM32_USB->ISTR = ~ISTR_WKUP;
 800a564:	f46f 5280 	mvn.w	r2, #4096	; 0x1000
 800a568:	4bba      	ldr	r3, [pc, #744]	; (800a854 <Vector90+0x314>)
 800a56a:	645a      	str	r2, [r3, #68]	; 0x44
  if (istr & ISTR_SOF) {
 800a56c:	05a1      	lsls	r1, r4, #22
 800a56e:	d50b      	bpl.n	800a588 <Vector90+0x48>
    _usb_isr_invoke_sof_cb(usbp);
 800a570:	f8df a2e4 	ldr.w	sl, [pc, #740]	; 800a858 <Vector90+0x318>
 800a574:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a578:	68db      	ldr	r3, [r3, #12]
 800a57a:	b10b      	cbz	r3, 800a580 <Vector90+0x40>
 800a57c:	4650      	mov	r0, sl
 800a57e:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_SOF;
 800a580:	f46f 7200 	mvn.w	r2, #512	; 0x200
 800a584:	4bb3      	ldr	r3, [pc, #716]	; (800a854 <Vector90+0x314>)
 800a586:	645a      	str	r2, [r3, #68]	; 0x44
  while (istr & ISTR_CTR) {
 800a588:	0423      	lsls	r3, r4, #16
 800a58a:	d579      	bpl.n	800a680 <Vector90+0x140>
 800a58c:	f8df a2c8 	ldr.w	sl, [pc, #712]	; 800a858 <Vector90+0x318>
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800a590:	f8df b2c0 	ldr.w	fp, [pc, #704]	; 800a854 <Vector90+0x314>
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
 800a594:	f004 040f 	and.w	r4, r4, #15
 800a598:	00a5      	lsls	r5, r4, #2
 800a59a:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 800a59e:	f505 45b8 	add.w	r5, r5, #23552	; 0x5c00
  uint32_t epr = STM32_USB->EPR[ep];
 800a5a2:	f8d5 8000 	ldr.w	r8, [r5]
  const USBEndpointConfig *epcp = usbp->epc[ep];
 800a5a6:	1ca6      	adds	r6, r4, #2
 800a5a8:	eb0a 0386 	add.w	r3, sl, r6, lsl #2
  if (epr & EPR_CTR_TX) {
 800a5ac:	f018 0f80 	tst.w	r8, #128	; 0x80
  const USBEndpointConfig *epcp = usbp->epc[ep];
 800a5b0:	685f      	ldr	r7, [r3, #4]
  if (epr & EPR_CTR_TX) {
 800a5b2:	d04c      	beq.n	800a64e <Vector90+0x10e>
    USBInEndpointState *isp = epcp->in_state;
 800a5b4:	f8d7 c014 	ldr.w	ip, [r7, #20]
    EPR_CLEAR_CTR_TX(ep);
 800a5b8:	682a      	ldr	r2, [r5, #0]
    isp->txcnt += isp->txlast;
 800a5ba:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a5be:	f8dc 100c 	ldr.w	r1, [ip, #12]
    n = isp->txsize - isp->txcnt;
 800a5c2:	f8dc 0000 	ldr.w	r0, [ip]
    EPR_CLEAR_CTR_TX(ep);
 800a5c6:	f422 4278 	bic.w	r2, r2, #63488	; 0xf800
    isp->txcnt += isp->txlast;
 800a5ca:	440b      	add	r3, r1
    EPR_CLEAR_CTR_TX(ep);
 800a5cc:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 800a5d0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    if (n > 0) {
 800a5d4:	1ac0      	subs	r0, r0, r3
    EPR_CLEAR_CTR_TX(ep);
 800a5d6:	602a      	str	r2, [r5, #0]
    isp->txcnt += isp->txlast;
 800a5d8:	f8cc 3004 	str.w	r3, [ip, #4]
    if (n > 0) {
 800a5dc:	d055      	beq.n	800a68a <Vector90+0x14a>
      if (n > epcp->in_maxsize)
 800a5de:	8a3b      	ldrh	r3, [r7, #16]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800a5e0:	ea4f 1e04 	mov.w	lr, r4, lsl #4
 800a5e4:	4298      	cmp	r0, r3
 800a5e6:	bf28      	it	cs
 800a5e8:	4618      	movcs	r0, r3
      isp->txlast = n;
 800a5ea:	f8cc 000c 	str.w	r0, [ip, #12]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800a5ee:	f8db 2050 	ldr.w	r2, [fp, #80]	; 0x50
      isp->txbuf += isp->txlast;
 800a5f2:	f8dc 3008 	ldr.w	r3, [ip, #8]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800a5f6:	f102 4980 	add.w	r9, r2, #1073741824	; 0x40000000
 800a5fa:	f509 49c0 	add.w	r9, r9, #24576	; 0x6000
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 800a5fe:	f85e 2009 	ldr.w	r2, [lr, r9]
      isp->txbuf += isp->txlast;
 800a602:	4419      	add	r1, r3
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 800a604:	f102 5200 	add.w	r2, r2, #536870912	; 0x20000000
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800a608:	44ce      	add	lr, r9
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 800a60a:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
      isp->txbuf += isp->txlast;
 800a60e:	f8cc 1008 	str.w	r1, [ip, #8]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 800a612:	0052      	lsls	r2, r2, #1
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 800a614:	f8ce 0004 	str.w	r0, [lr, #4]
  while (i > 0) {
 800a618:	b168      	cbz	r0, 800a636 <Vector90+0xf6>
 800a61a:	3801      	subs	r0, #1
 800a61c:	0840      	lsrs	r0, r0, #1
 800a61e:	1d13      	adds	r3, r2, #4
 800a620:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800a624:	4684      	mov	ip, r0
 800a626:	e000      	b.n	800a62a <Vector90+0xea>
 800a628:	3304      	adds	r3, #4
    w |= *buf++ << 8;
 800a62a:	f831 0b02 	ldrh.w	r0, [r1], #2
  while (i > 0) {
 800a62e:	4563      	cmp	r3, ip
    *pmap++ = (stm32_usb_pma_t)w;
 800a630:	6010      	str	r0, [r2, #0]
 800a632:	461a      	mov	r2, r3
  while (i > 0) {
 800a634:	d1f8      	bne.n	800a628 <Vector90+0xe8>
      EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 800a636:	682b      	ldr	r3, [r5, #0]
 800a638:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 800a63c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a640:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 800a644:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a648:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a64c:	602b      	str	r3, [r5, #0]
  if (epr & EPR_CTR_RX) {
 800a64e:	f418 4f00 	tst.w	r8, #32768	; 0x8000
 800a652:	d011      	beq.n	800a678 <Vector90+0x138>
    EPR_CLEAR_CTR_RX(ep);
 800a654:	682b      	ldr	r3, [r5, #0]
    if (epr & EPR_SETUP) {
 800a656:	f418 6f00 	tst.w	r8, #2048	; 0x800
    EPR_CLEAR_CTR_RX(ep);
 800a65a:	f423 4378 	bic.w	r3, r3, #63488	; 0xf800
 800a65e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800a662:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a666:	b2e1      	uxtb	r1, r4
 800a668:	602b      	str	r3, [r5, #0]
    if (epr & EPR_SETUP) {
 800a66a:	d05f      	beq.n	800a72c <Vector90+0x1ec>
      _usb_isr_invoke_setup_cb(usbp, ep);
 800a66c:	eb0a 0686 	add.w	r6, sl, r6, lsl #2
 800a670:	6873      	ldr	r3, [r6, #4]
 800a672:	4879      	ldr	r0, [pc, #484]	; (800a858 <Vector90+0x318>)
 800a674:	685b      	ldr	r3, [r3, #4]
 800a676:	4798      	blx	r3
    istr = STM32_USB->ISTR;
 800a678:	f8db 4044 	ldr.w	r4, [fp, #68]	; 0x44
  while (istr & ISTR_CTR) {
 800a67c:	0422      	lsls	r2, r4, #16
 800a67e:	d489      	bmi.n	800a594 <Vector90+0x54>
}
 800a680:	b005      	add	sp, #20
 800a682:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 800a686:	f7f6 bd83 	b.w	8001190 <_port_irq_epilogue>
      _usb_isr_invoke_in_cb(usbp, ep);
 800a68a:	2101      	movs	r1, #1
 800a68c:	f8ba 3008 	ldrh.w	r3, [sl, #8]
 800a690:	40a1      	lsls	r1, r4
 800a692:	68ba      	ldr	r2, [r7, #8]
 800a694:	ea23 0301 	bic.w	r3, r3, r1
 800a698:	f8aa 3008 	strh.w	r3, [sl, #8]
 800a69c:	2a00      	cmp	r2, #0
 800a69e:	d0d6      	beq.n	800a64e <Vector90+0x10e>
 800a6a0:	4621      	mov	r1, r4
 800a6a2:	486d      	ldr	r0, [pc, #436]	; (800a858 <Vector90+0x318>)
 800a6a4:	4790      	blx	r2
 800a6a6:	e7d2      	b.n	800a64e <Vector90+0x10e>
    STM32_USB->ISTR = ~ISTR_RESET;
 800a6a8:	f46f 6180 	mvn.w	r1, #1024	; 0x400
  usbp->status        = 0;
 800a6ac:	2500      	movs	r5, #0
  usbp->state         = USB_READY;
 800a6ae:	2202      	movs	r2, #2
 800a6b0:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 800a858 <Vector90+0x318>
 800a6b4:	6459      	str	r1, [r3, #68]	; 0x44
  usb_lld_reset(usbp);
 800a6b6:	4650      	mov	r0, sl
  usbp->state         = USB_READY;
 800a6b8:	f88a 2000 	strb.w	r2, [sl]
  usbp->status        = 0;
 800a6bc:	f8ca 507c 	str.w	r5, [sl, #124]	; 0x7c
  usbp->receiving     = 0;
 800a6c0:	e9ca 5502 	strd	r5, r5, [sl, #8]
    usbp->epc[i] = NULL;
 800a6c4:	e9ca 5504 	strd	r5, r5, [sl, #16]
 800a6c8:	e9ca 5506 	strd	r5, r5, [sl, #24]
 800a6cc:	e9ca 5508 	strd	r5, r5, [sl, #32]
 800a6d0:	f8ca 5028 	str.w	r5, [sl, #40]	; 0x28
  usbp->ep0state = USB_EP0_STP_WAITING;
 800a6d4:	f88a 5064 	strb.w	r5, [sl, #100]	; 0x64
  usb_lld_reset(usbp);
 800a6d8:	f7f7 fb5a 	bl	8001d90 <usb_lld_reset>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 800a6dc:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a6e0:	681b      	ldr	r3, [r3, #0]
 800a6e2:	2b00      	cmp	r3, #0
 800a6e4:	f43f af34 	beq.w	800a550 <Vector90+0x10>
 800a6e8:	4629      	mov	r1, r5
 800a6ea:	4650      	mov	r0, sl
 800a6ec:	4798      	blx	r3
  if (istr & ISTR_SUSP) {
 800a6ee:	0526      	lsls	r6, r4, #20
 800a6f0:	f57f af31 	bpl.w	800a556 <Vector90+0x16>
    STM32_USB->ISTR = ~ISTR_SUSP;
 800a6f4:	f46f 6000 	mvn.w	r0, #2048	; 0x800
  usbp->state       = USB_SUSPENDED;
 800a6f8:	2105      	movs	r1, #5
    STM32_USB->CNTR |= CNTR_FSUSP;
 800a6fa:	4b56      	ldr	r3, [pc, #344]	; (800a854 <Vector90+0x314>)
  usbp->saved_state = usbp->state;
 800a6fc:	f8df a158 	ldr.w	sl, [pc, #344]	; 800a858 <Vector90+0x318>
 800a700:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a702:	f042 0208 	orr.w	r2, r2, #8
 800a706:	641a      	str	r2, [r3, #64]	; 0x40
    STM32_USB->ISTR = ~ISTR_SUSP;
 800a708:	6458      	str	r0, [r3, #68]	; 0x44
 800a70a:	f89a 2000 	ldrb.w	r2, [sl]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800a70e:	f8da 3004 	ldr.w	r3, [sl, #4]
  usbp->saved_state = usbp->state;
 800a712:	f88a 2080 	strb.w	r2, [sl, #128]	; 0x80
  usbp->state       = USB_SUSPENDED;
 800a716:	f88a 1000 	strb.w	r1, [sl]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800a71a:	681b      	ldr	r3, [r3, #0]
 800a71c:	b113      	cbz	r3, 800a724 <Vector90+0x1e4>
 800a71e:	2104      	movs	r1, #4
 800a720:	4650      	mov	r0, sl
 800a722:	4798      	blx	r3
  usbp->transmitting  = 0;
 800a724:	2300      	movs	r3, #0
 800a726:	f8ca 3008 	str.w	r3, [sl, #8]
 800a72a:	e714      	b.n	800a556 <Vector90+0x16>
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800a72c:	f8db 3050 	ldr.w	r3, [fp, #80]	; 0x50
      USBOutEndpointState *osp = epcp->out_state;
 800a730:	f8d7 e018 	ldr.w	lr, [r7, #24]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800a734:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800a738:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 800a73c:	eb03 1304 	add.w	r3, r3, r4, lsl #4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800a740:	689a      	ldr	r2, [r3, #8]
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 800a742:	68d8      	ldr	r0, [r3, #12]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800a744:	f102 5300 	add.w	r3, r2, #536870912	; 0x20000000
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 800a748:	f3c0 0909 	ubfx	r9, r0, #0, #10
 800a74c:	9002      	str	r0, [sp, #8]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800a74e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
 800a752:	f8de 0008 	ldr.w	r0, [lr, #8]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800a756:	005b      	lsls	r3, r3, #1
  while (i >= 2) {
 800a758:	f1b9 0f01 	cmp.w	r9, #1
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800a75c:	461a      	mov	r2, r3
 800a75e:	9300      	str	r3, [sp, #0]
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
 800a760:	9001      	str	r0, [sp, #4]
  while (i >= 2) {
 800a762:	d972      	bls.n	800a84a <Vector90+0x30a>
 800a764:	f1a9 0302 	sub.w	r3, r9, #2
 800a768:	085b      	lsrs	r3, r3, #1
 800a76a:	f102 0804 	add.w	r8, r2, #4
 800a76e:	9303      	str	r3, [sp, #12]
 800a770:	eb08 0883 	add.w	r8, r8, r3, lsl #2
 800a774:	1c83      	adds	r3, r0, #2
    uint32_t w = *pmap++;
 800a776:	6810      	ldr	r0, [r2, #0]
 800a778:	3204      	adds	r2, #4
    *buf++ = (uint8_t)(w >> 8);
 800a77a:	ea4f 2c10 	mov.w	ip, r0, lsr #8
  while (i >= 2) {
 800a77e:	4590      	cmp	r8, r2
    *buf++ = (uint8_t)w;
 800a780:	f803 0c02 	strb.w	r0, [r3, #-2]
    *buf++ = (uint8_t)(w >> 8);
 800a784:	f803 cc01 	strb.w	ip, [r3, #-1]
 800a788:	f103 0302 	add.w	r3, r3, #2
  while (i >= 2) {
 800a78c:	d1f3      	bne.n	800a776 <Vector90+0x236>
 800a78e:	9b03      	ldr	r3, [sp, #12]
 800a790:	9a00      	ldr	r2, [sp, #0]
 800a792:	3301      	adds	r3, #1
 800a794:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800a798:	9200      	str	r2, [sp, #0]
 800a79a:	9a01      	ldr	r2, [sp, #4]
 800a79c:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800a7a0:	9301      	str	r3, [sp, #4]
 800a7a2:	9b02      	ldr	r3, [sp, #8]
 800a7a4:	f003 0301 	and.w	r3, r3, #1
  if (i >= 1) {
 800a7a8:	b11b      	cbz	r3, 800a7b2 <Vector90+0x272>
    *buf = (uint8_t)*pmap;
 800a7aa:	9b00      	ldr	r3, [sp, #0]
 800a7ac:	9a01      	ldr	r2, [sp, #4]
 800a7ae:	681b      	ldr	r3, [r3, #0]
 800a7b0:	7013      	strb	r3, [r2, #0]
      osp->rxpkts -= 1;
 800a7b2:	f8be 300c 	ldrh.w	r3, [lr, #12]
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 800a7b6:	f8b7 c012 	ldrh.w	ip, [r7, #18]
      osp->rxpkts -= 1;
 800a7ba:	1e5f      	subs	r7, r3, #1
      osp->rxsize -= n;
 800a7bc:	f8de 3000 	ldr.w	r3, [lr]
      osp->rxcnt  += n;
 800a7c0:	e9de 0201 	ldrd	r0, r2, [lr, #4]
      osp->rxpkts -= 1;
 800a7c4:	b2bf      	uxth	r7, r7
      osp->rxbuf += n;
 800a7c6:	444a      	add	r2, r9
      osp->rxcnt  += n;
 800a7c8:	4448      	add	r0, r9
      osp->rxsize -= n;
 800a7ca:	eba3 0309 	sub.w	r3, r3, r9
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 800a7ce:	45cc      	cmp	ip, r9
      osp->rxpkts -= 1;
 800a7d0:	f8ae 700c 	strh.w	r7, [lr, #12]
      osp->rxcnt  += n;
 800a7d4:	e9ce 0201 	strd	r0, r2, [lr, #4]
      osp->rxsize -= n;
 800a7d8:	f8ce 3000 	str.w	r3, [lr]
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 800a7dc:	d926      	bls.n	800a82c <Vector90+0x2ec>
        _usb_isr_invoke_out_cb(usbp, ep);
 800a7de:	2201      	movs	r2, #1
 800a7e0:	eb0a 0686 	add.w	r6, sl, r6, lsl #2
 800a7e4:	6870      	ldr	r0, [r6, #4]
 800a7e6:	f8ba 300a 	ldrh.w	r3, [sl, #10]
 800a7ea:	fa02 f404 	lsl.w	r4, r2, r4
 800a7ee:	68c5      	ldr	r5, [r0, #12]
 800a7f0:	ea23 0404 	bic.w	r4, r3, r4
 800a7f4:	f8aa 400a 	strh.w	r4, [sl, #10]
 800a7f8:	2d00      	cmp	r5, #0
 800a7fa:	f43f af3d 	beq.w	800a678 <Vector90+0x138>
 800a7fe:	4816      	ldr	r0, [pc, #88]	; (800a858 <Vector90+0x318>)
 800a800:	47a8      	blx	r5
 800a802:	e739      	b.n	800a678 <Vector90+0x138>
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 800a804:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  usbp->state = usbp->saved_state;
 800a806:	f8df a050 	ldr.w	sl, [pc, #80]	; 800a858 <Vector90+0x318>
 800a80a:	f022 0208 	bic.w	r2, r2, #8
 800a80e:	641a      	str	r2, [r3, #64]	; 0x40
 800a810:	f89a 2080 	ldrb.w	r2, [sl, #128]	; 0x80
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800a814:	f8da 3004 	ldr.w	r3, [sl, #4]
  usbp->state = usbp->saved_state;
 800a818:	f88a 2000 	strb.w	r2, [sl]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800a81c:	681b      	ldr	r3, [r3, #0]
 800a81e:	2b00      	cmp	r3, #0
 800a820:	f43f aea0 	beq.w	800a564 <Vector90+0x24>
 800a824:	4650      	mov	r0, sl
 800a826:	2105      	movs	r1, #5
 800a828:	4798      	blx	r3
 800a82a:	e69b      	b.n	800a564 <Vector90+0x24>
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 800a82c:	2f00      	cmp	r7, #0
 800a82e:	d0d6      	beq.n	800a7de <Vector90+0x29e>
        EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 800a830:	682b      	ldr	r3, [r5, #0]
 800a832:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 800a836:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800a83a:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 800a83e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a842:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a846:	602b      	str	r3, [r5, #0]
 800a848:	e716      	b.n	800a678 <Vector90+0x138>
  while (i >= 2) {
 800a84a:	464b      	mov	r3, r9
  if (i >= 1) {
 800a84c:	2b00      	cmp	r3, #0
 800a84e:	d1ac      	bne.n	800a7aa <Vector90+0x26a>
 800a850:	e7af      	b.n	800a7b2 <Vector90+0x272>
 800a852:	bf00      	nop
 800a854:	40005c00 	.word	0x40005c00
 800a858:	20001178 	.word	0x20001178
 800a85c:	00000000 	.word	0x00000000

0800a860 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 800a860:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 800a864:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 800a868:	6933      	ldr	r3, [r6, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 800a86a:	68f2      	ldr	r2, [r6, #12]
 800a86c:	4013      	ands	r3, r2
 800a86e:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;
 800a870:	43d2      	mvns	r2, r2

  if ((sr & TIM_SR_CC1IF) != 0U)
 800a872:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 800a874:	6132      	str	r2, [r6, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 800a876:	d403      	bmi.n	800a880 <VectorB0+0x20>
}
 800a878:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
 800a87c:	f7f6 bc88 	b.w	8001190 <_port_irq_epilogue>
 800a880:	2320      	movs	r3, #32
 800a882:	f383 8811 	msr	BASEPRI, r3
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 800a886:	4c22      	ldr	r4, [pc, #136]	; (800a910 <VectorB0+0xb0>)
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 800a888:	f04f 0800 	mov.w	r8, #0
  vtp = ch.vtlist.next;
 800a88c:	46a1      	mov	r9, r4
 800a88e:	f859 3f1c 	ldr.w	r3, [r9, #28]!
 800a892:	689a      	ldr	r2, [r3, #8]
 800a894:	6a70      	ldr	r0, [r6, #36]	; 0x24
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 800a896:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 800a898:	b280      	uxth	r0, r0
  return (sysinterval_t)((systime_t)(end - start));
 800a89a:	1a47      	subs	r7, r0, r1
 800a89c:	b2bf      	uxth	r7, r7
    if (nowdelta < vtp->delta) {
 800a89e:	4297      	cmp	r7, r2
 800a8a0:	d31b      	bcc.n	800a8da <VectorB0+0x7a>
 800a8a2:	2520      	movs	r5, #32
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800a8a4:	6818      	ldr	r0, [r3, #0]
      ch.vtlist.lasttime += vtp->delta;
 800a8a6:	4411      	add	r1, r2

      /* If the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800a8a8:	4548      	cmp	r0, r9
      ch.vtlist.lasttime += vtp->delta;
 800a8aa:	8521      	strh	r1, [r4, #40]	; 0x28
      nowdelta -= vtp->delta;
 800a8ac:	eba7 0702 	sub.w	r7, r7, r2
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800a8b0:	f8c0 9004 	str.w	r9, [r0, #4]
      fn = vtp->func;
 800a8b4:	68da      	ldr	r2, [r3, #12]
      ch.vtlist.next = vtp->next;
 800a8b6:	61e0      	str	r0, [r4, #28]
      vtp->func = NULL;
 800a8b8:	f8c3 800c 	str.w	r8, [r3, #12]
  STM32_ST_TIM->DIER = 0U;
 800a8bc:	bf08      	it	eq
 800a8be:	f8c6 800c 	streq.w	r8, [r6, #12]
 800a8c2:	f388 8811 	msr	BASEPRI, r8
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 800a8c6:	6918      	ldr	r0, [r3, #16]
 800a8c8:	4790      	blx	r2
 800a8ca:	f385 8811 	msr	BASEPRI, r5
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 800a8ce:	69e3      	ldr	r3, [r4, #28]
    }
    while (vtp->delta <= nowdelta);
 800a8d0:	689a      	ldr	r2, [r3, #8]
 800a8d2:	4297      	cmp	r7, r2
 800a8d4:	d3de      	bcc.n	800a894 <VectorB0+0x34>
 800a8d6:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 800a8d8:	e7e4      	b.n	800a8a4 <VectorB0+0x44>
  }

  /* If the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800a8da:	69e2      	ldr	r2, [r4, #28]
 800a8dc:	454a      	cmp	r2, r9
 800a8de:	d00f      	beq.n	800a900 <VectorB0+0xa0>
  return systime + (systime_t)interval;
 800a8e0:	f64f 75ff 	movw	r5, #65535	; 0xffff
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 800a8e4:	6891      	ldr	r1, [r2, #8]
  ch.vtlist.lasttime += nowdelta;
 800a8e6:	8520      	strh	r0, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 800a8e8:	1bcf      	subs	r7, r1, r7
 800a8ea:	6097      	str	r7, [r2, #8]
 800a8ec:	689b      	ldr	r3, [r3, #8]
 800a8ee:	42ab      	cmp	r3, r5
 800a8f0:	bf28      	it	cs
 800a8f2:	462b      	movcs	r3, r5
 800a8f4:	2b02      	cmp	r3, #2
 800a8f6:	bf2c      	ite	cs
 800a8f8:	18c0      	addcs	r0, r0, r3
 800a8fa:	3002      	addcc	r0, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 800a8fc:	b280      	uxth	r0, r0
 800a8fe:	6370      	str	r0, [r6, #52]	; 0x34
 800a900:	2300      	movs	r3, #0
 800a902:	f383 8811 	msr	BASEPRI, r3
}
 800a906:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
 800a90a:	f7f6 bc41 	b.w	8001190 <_port_irq_epilogue>
 800a90e:	bf00      	nop
 800a910:	20001254 	.word	0x20001254
	...

0800a920 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800a920:	b4f0      	push	{r4, r5, r6, r7}
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800a922:	2700      	movs	r7, #0
 800a924:	4e13      	ldr	r6, [pc, #76]	; (800a974 <__init_ram_areas+0x54>)
void __init_ram_areas(void) {
 800a926:	4d14      	ldr	r5, [pc, #80]	; (800a978 <__init_ram_areas+0x58>)
 800a928:	4c14      	ldr	r4, [pc, #80]	; (800a97c <__init_ram_areas+0x5c>)
 800a92a:	4b15      	ldr	r3, [pc, #84]	; (800a980 <__init_ram_areas+0x60>)
 800a92c:	4915      	ldr	r1, [pc, #84]	; (800a984 <__init_ram_areas+0x64>)
 800a92e:	f106 0c70 	add.w	ip, r6, #112	; 0x70
    while (p < rap->clear_area) {
 800a932:	429c      	cmp	r4, r3
 800a934:	d911      	bls.n	800a95a <__init_ram_areas+0x3a>
 800a936:	461a      	mov	r2, r3
 800a938:	3904      	subs	r1, #4
      *p = *tp;
 800a93a:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800a93e:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
 800a942:	4294      	cmp	r4, r2
 800a944:	d8f9      	bhi.n	800a93a <__init_ram_areas+0x1a>
 800a946:	43da      	mvns	r2, r3
 800a948:	4414      	add	r4, r2
 800a94a:	f024 0403 	bic.w	r4, r4, #3
 800a94e:	3404      	adds	r4, #4
 800a950:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
 800a952:	429d      	cmp	r5, r3
 800a954:	d903      	bls.n	800a95e <__init_ram_areas+0x3e>
      *p = 0;
 800a956:	f843 7b04 	str.w	r7, [r3], #4
    while (p < rap->no_init_area) {
 800a95a:	429d      	cmp	r5, r3
 800a95c:	d8fb      	bhi.n	800a956 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800a95e:	4566      	cmp	r6, ip
 800a960:	d005      	beq.n	800a96e <__init_ram_areas+0x4e>
 800a962:	e9d6 1304 	ldrd	r1, r3, [r6, #16]
 800a966:	e9d6 4506 	ldrd	r4, r5, [r6, #24]
 800a96a:	3610      	adds	r6, #16
 800a96c:	e7e1      	b.n	800a932 <__init_ram_areas+0x12>
#endif
}
 800a96e:	bcf0      	pop	{r4, r5, r6, r7}
 800a970:	4770      	bx	lr
 800a972:	bf00      	nop
 800a974:	0800b698 	.word	0x0800b698
 800a978:	20002490 	.word	0x20002490
 800a97c:	20002490 	.word	0x20002490
 800a980:	20002490 	.word	0x20002490
 800a984:	0800da5c 	.word	0x0800da5c
	...

0800a990 <__default_exit>:
void __default_exit(void) {
 800a990:	e7fe      	b.n	800a990 <__default_exit>
 800a992:	bf00      	nop
	...

0800a9a0 <__late_init>:
 800a9a0:	4770      	bx	lr
 800a9a2:	bf00      	nop
	...

0800a9b0 <__core_init>:
}
 800a9b0:	4770      	bx	lr
 800a9b2:	bf00      	nop
