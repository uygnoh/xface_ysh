//______________________________________________________________________________
//      => STM32 I2C
//______________________________________________________________________________
void i2c_setup(void)
{
        RCC->APB2RSTR   |=  BIT_00;     // AFIO
        RCC->APB2RSTR   &= ~BIT_00;
        RCC->APB2RSTR   |=  BIT_02;     // GPIOA
        RCC->APB2RSTR   &= ~BIT_02;
        RCC->APB2RSTR   |=  BIT_03;     // GPIOB
        RCC->APB2RSTR   &= ~BIT_03;
        RCC->APB2ENR    |=  BIT_00;     // 打开 AFIO 时钟
        RCC->APB2ENR    |=  BIT_02;     // 打开 GPIOA时钟
        RCC->APB2ENR    |=  BIT_03;     // 打开 GPIOB时钟
        GPIOB->CRL      &=  0x00FFFFFF; // 清除相关位
                                        // 复用开漏输出@50MHz
                                        // PB6  --> I2C1_SCL
        GPIOB->CRL      |=  0xFF000000; // PB7  --> I2C1_SDA
        
        
        
        RCC->APB1RSTR   |=  BIT_21;     // I2C外设复位
        RCC->APB1RSTR   &= ~BIT_21;     // I2C外设停止复位
        RCC->APB1ENR    |=  BIT_21;     // 打开 I2C 时钟
        I2C1->CR1       |=  BIT_10;     // 使能自动应答（ACK）
        I2C1->CR2       |=  0x24;       // I2C模块输入时钟频率 = 36MHz
        I2C1->OAR1       =  0x4030;     // 自身地址寄存器 1
                                        // 普通模式 100KHz 
        I2C1->CCR        =  0xB4;       // 快速/标准模式下的时钟控制分频系数
        I2C1->TRISE      =  0x25;       // 快速/标准模式下的最大上升时间
        I2C1->CR1       |=  BIT_00;     // I2C模块使能
}



//______________________________________________________________________________
//      => SSD1306
//______________________________________________________________________________
        EV5     SB=1            // 读SR1然后将地址写入DR寄存器将清除该事件。
        EV6     ADDR=1          // 读SR1然后读SR2将清除该事件。
        EV8_1   TxE=1           // 移位寄存器空,数据寄存器空,写DR寄存器。
        EV8     TxE=1           // 移位寄存器非空,数据寄存器空,写入DR寄存器将清除该事件
        EV8_2   TxE=1,BTF=1     // 请求设置停止位。TxE和BTF位由硬件在产生停止条件时清除
        EV9     ADDR10=1        // 读SR1然后写入DR寄存器将清除该事件。
void ssd1306_write_cmd(uint8_t cmd)
{
        uint32_t timeout;
        
        // 检测__BUSY__
        // 1:在总线上正在进行数据通讯
        // ____________________________________________________
        timeout = LONG_TIMEOUT;
        while ((I2C1->SR2 & BIT_01)) {
                if ((timeout--) == 0) {
                        return timeout_user_callback();
                }
        }
        
        
        // 产生起始信号
        // ____________________________________________________
        I2C1->CR1 |= BIT_08;
        // 检测__EV5事件__
        // 1:起始条件已发送
        timeout = LONG_TIMEOUT;
        while (!(I2C1->SR1 & BIT_00)) {
                if ((timeout--) == 0) {
                        return timeout_user_callback();
                }
        }
        
        
        // 发送从机设备地址
        // ____________________________________________________
        I2C1->DR = 0x78;
        // 检测__EV6事件__
        // 1:地址发送结束
        timeout = LONG_TIMEOUT;
        while (!(I2C1->SR1 & BIT_01)) {
                if ((timeout--) == 0) {
                        return timeout_user_callback();
                }
        }
        
        
        
        
        
        
        
        
        
        
        
        //发送EEPROM内部存储器单元地址
        I2C_SendData(I2C1, addr);
        //检测__EV8事件__
        while (I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR);
        //向EEPROM发送一个字节数据
        I2C_SendData(I2C1, data);
        //检测__EV8_2事件__
        while (I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR);
        //产生I2C停止信号
        I2C_GenerateSTOP(I2C1, ENABLE);
}

void ssd1306_write_dat(uint8_t dat)
{
}
