/*******************************************************************************
        => GPIO
*******************************************************************************/
        GPIOx_MODER     // 一个端口工作模式寄存器
        GPIOx_OTYPER    // 一个端口输出类型寄存器
        GPIOx_OSPEEDR   // 一个端口输出速度寄存器
        GPIOx_PUPDR     // 一个端口上拉下拉寄存器
        GPIOx_IDR       // 一个端口输入数据寄存器
        GPIOx_ODR       // 一个端口输出数据寄存器
        GPIOx_BSRR      // 一个端口置位复位寄存器
        GPIOx_LCKR      // 一个端口配置锁存寄存器
        GPIOx_AFRL      // 两个端口复用功能寄存器
        GPIOx_AFRH      // 两个端口复用功能寄存器




// GPIOx_MODER（端口模式寄存器）, 用于配置 I/O 方向模式
//_____________________________________________________________
MODER_PIN_00[1:0] ~ MODER_PIN_15[31:30]
        00      // INPUT        通用输入模式(复位状态)
        01      // OUTPUT       通用输出模式
        10      // ALTERNATE    复用功能模式
        11      // ANALOG       模拟功能模式


// GPIOx_OTYPER（端口输出类型寄存器）
//_____________________________________________________________
OTYPER[0] ~ OTYPER[15]
        0       // 输出推挽__OUTPUT_PUSHPULL
        1       // 输出开漏__OUTPUT_OPENDRAIN


// GPIOGPIOx_OSPEEDR（端口输出速度寄存器）
//_____________________________________________________________
        00      // 2MHz  (低速)
        01      // 25MHz (中速)
        10      // 50MHZ (快速)
        11      // 80MHz (高速_15pF时)
                // 100MHz(高速_30pF时)
GPIOA->OSPEEDR &= ~(3 << PIN*2);//（首先清除要设置的相应位）
GPIOA->OSPEEDR |=  (0 << PIN*2);//低速__2MHz__
GPIOA->OSPEEDR |=  (1 << PIN*2);//中速__25MHz__
GPIOA->OSPEEDR |=  (2 << PIN*2);//快速__50MHz__
GPIOA->OSPEEDR |=  (3 << PIN*2);//高速__100MHz__


// GPIO（端口上拉/下拉寄存器）
// GPIO port pull-up/pull-down register
//_____________________________________________________________
        00      //无上拉或下拉
        01      //上拉
        10      //下拉
        11      //保留




/*******************************************************************************
        => GPIO（端口置位/复位寄存器）
        => GPIO port set/reset register
*******************************************************************************/
//_____________________________________________________________
PIN             = 0..15         //引脚编号
//_____________________________________________________________
// 高16位（写“1”，对相应的 ODRx 位进行复位）
// 低16位（写“1”，对相应的 ODRx 位进行置位）
//_____________________________________________________________
GPIOA->BSRR &= ~(1 << PIN+16);  //（首先清除要设置的相应位）
GPIOA->BSRR |=  (1 << PIN+16);  //复位__高16位__
GPIOA->BSRR &= ~(1 << PIN   );  //（首先清除要设置的相应位）
GPIOA->BSRR |=  (1 << PIN   );  //置位__低16位__



/*******************************************************************************
        => GPIO（端口配置锁定寄存器）
        => GPIO port configuration lock register
*******************************************************************************/
//锁定键写序列:
        WR LCKR[16] = ‘1’ + LCKR[15:0]
        WR LCKR[16] = ‘0’ + LCKR[15:0]
        WR LCKR[16] = ‘1’ + LCKR[15:0]
        RD LCKR
        RD LCKR[16] = ‘1’(此读操作为可选操作,但它可确认锁定已激活)
//注意: 在锁定键写序列期间,不能更改 LCK[15:0] 的值
        1 锁定序列中的任何错误都将中止锁定操作。
        2 在任一端口位上的第一个锁定序列之后,对 LCKK 位的任何读访问都
          将返回“ 1 ”, 直到下一次 CPU 复位为止。
//位 15:0 LCKy:端口 x 锁定位 y (Port x lock bit y) (y= 0..15)
//这些位都是读 /写位,但只能在 LCKK 位等于“0”时执行写操作。
        0:端口配置未锁定
        1:端口配置已锁定
void gpio_pin_lock(port, pin)
{
        uint32_t porta;
        uint32_t retval;
        GPIOAA->LCKR |= (uint32_t)(0x00010000);         //写（1）
        GPIOAA->LCKR &= (uint32_t)(0xFFFEFFFF);         //写（0）
        GPIOAA->LCKR |= (uint32_t)(0x00010000);         //写（1）
        porta         = GPIOAA->LCKR;                   //读
        retval        = porta & (uint32_t)(0x00010000); //读取第（16）位
        if (retval != 0) {
                printf("端口已锁定");
        }    
}



/*******************************************************************************
        => GPIO（复用功能低位寄存器）
        => GPIO alternate function low register
*******************************************************************************/
|_________________________________________________________________.
| 0     1       2       3       4       5       6       7      *4 |
|_________________________________________________________________|
| 0     4       8       12      16      20      24      28        |
|_________________________________________________________________|
//pin_low  = (0 ~ 7)
//af       = (AF0 ~ AF15)
GPIOA->AFRL &= ~(15  << pin_low*4);  //（首先清除要设置的相应位）
GPIOA->AFRL |=  (af  << pin_low*4);  //设置af=（0~15）



/*******************************************************************************
        => GPIO（复用功能高位寄存器）
        => GPIO alternate function hight register
*******************************************************************************/
|_________________________________________________________________.
| 8     9       10      11      12      13      14      15     *4 |
|_________________________________________________________________|
| 0     4       8       12      16      20      24      28        |
|_________________________________________________________________|
//pin_high  = (0 ~ 7)
//af        = (AF0 ~ AF15)
GPIOA->AFRL &= ~(15  << pin_high*4);  //（首先清除要设置的相应位）
GPIOA->AFRL |=  (af  << pin_high*4);  //设置af=（0~15）
        
        
        
