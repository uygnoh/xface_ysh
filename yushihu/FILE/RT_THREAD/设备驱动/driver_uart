//////////////////////////////////////////////////
        rt_device_find()                // 查找设备
        rt_device_open()                // 打开设备
        rt_device_read()                // 读取数据
        rt_device_write()               // 写入数据
        rt_device_control()             // 控制设备
        rt_device_set_rx_indicate()     // 设置接收回调函数
        rt_device_set_tx_complete()     // 设置发送回调函数
        rt_device_close()               // 关闭设备
//////////////////////////////////////////////////
// 查找串口设备（例如： "uart2"）
// 打开串口设备（串口收发数据模式： 中断，轮询，DMA）
// 控制串口设备
        rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *args)
        cmd  命令控制字，可取值：   RT_DEVICE_CTRL_CONFIG
        arts 控制的参数，可取类型： struct serial_configure
        struct serial_configure {
                rt_uint32_t baud_rate;
                rt_uint32_t data_bit:4;
                rt_uint32_t stop_bit:2;
                rt_uint32_t parity:2
                rt_uint32_t bit_order:1;
                rt_uint32_t invert:1;
                rt_uint32_t bufsz:16;
                rt_uint32_t reserved:4;
        };
        // 波特率可取值
        #define BAUD_RATE_2400       2400
        #define BAUD_RATE_4800       4800
        #define BAUD_RATE_9600       9600
        #define BAUD_RATE_19200      19200
        #define BAUD_RATE_38400      38400
        #define BAUD_RATE_115200     115200
        // 数据位可取值
        #define DATA_BITS_5          5
        #define DATA_BITS_6          6
        #define DATA_BITS_7          7
        #define DATA_BITS_8          8
        #define DATA_BITS_9          9
        // 停止位可取值
        #define STOP_BITS_1          0
        #define STOP_BITS_2          1
        #define STOP_BITS_3          2
        #define STOP_BITS_4          3
        // 极性位可取值
        #define PARITY_NONE          0
        #define PARITY_ODD           1
        #define PARITY_EVEN          2
        // 高低位顺序可取值
        #define BIT_ORDER_LSB        0
        #define BIT_ORDER_MSB        1
        // 模式可取值
        #define NRZ_NORMAL           0
        #define NRZ_INVERTED         1
        // 缓冲区大小
        #define RT_SERIAL_RB_BUFSZ
        // RT-THREAD 默认串口配置
        #define RT_SERIAL_CONFIG_DEFAULT        \
        {                                       \
                BAUD_RATE_115200,               \
                DATA_BIT_8,                     \
                STOP_BIT_1,                     \
                PARITY_NONE,                    \
                BIT_ORDER_LSB,                  \
                NRZ_NORMAL,                     \
                RT_SERIAL_RB_BUFSZ,             \
                0                               \
        }



////////////////////////////////////////////////////////////////////////////////
//              串口发送
////////////////////////////////////////////////////////////////////////////////
// board.h
#define BSP_USING_UART1                 // 使用串口1
#define BSP_UART1_TX_PIN        "PA9"   // RX引脚
#define BSP_UART1_RX_PIN        "PA10"  // TX引脚


// main.c
#include <rtthread.h>
#include <rtdbg.h>
#include <serial.h>

rt_device_t     u1_dev; // 设备句柄
                        // 串口配置（使用默认配置）
struct serial_configure u1_config = RT_SERIAL_CONFIG_DEFAULT;

int main(void)
{
        rt_err_t ret = 0;
        // 查找串口1设备
        u1_dev = rt_device_find("uart1");
        if (u1_dev == RT_NULL) {
                LOG_E("rt_device_find[uart1] failed ...\n");
                return -EINVAL;
        }
        
        // 打开设备（u1_dev = 串口1； oflag = 读写 + 中断接收）
        ret = rt_device_open(u1_dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX);
        if (ret < 0) {
                 LOG_E("rt_device_open[uart1] failed ...\n");
                 return ret;
        }
        
        // 配置串口
        rt_device_control(u1_dev, RT_DEVICE_CTRL_CONFIG, (void *)&u1_config);
        
        // 向串口中写入数据
        rt_device_write(u1_dev, 0, "Uart1 config ...\n", rt_strlen("Uart1 config ...\n"));
        
        return RT_EOK;
}



////////////////////////////////////////////////////////////////////////////////
//              中断接收方法
////////////////////////////////////////////////////////////////////////////////
// board.h
#define BSP_USING_UART1
#define BSP_UART1_TX_PIN        "PA9"
#define BSP_UART1_RX_PIN        "PA10"


// main.c
#include <rtthread.h>
#include <rtdbg.h>
#include <serial.h>

rt_device_t     u1_dev;         // 设备句柄
rt_thread_t     u1_th;          // 线程句柄
struct rt_semaphore sem;
struct serial_configure u1_config = RT_SERIAL_CONFIG_DEFAULT;
rt_err_t rx_callback(rt_device_t dev, rt_size_t size)
{
        rt_sem_release(&sem);   // 释放信号量，唤醒
        return RT_EOK;
}
void serial_thread_entry(void *parameter)
{
        char buffer;
        while (1) {
                while (rt_device_read(u1_dev, 0, &buffer, 1) != 1) {
                        // RT_WAITING_FOREVER 一直阻塞
                        rt_sem_take(&sem, RT_WAITING_FOREVER);
                }
                rt_kprintf("%c", buffer);
        }
}
int main(void)
{
        rt_err_t ret = 0;
        u1_dev = rt_device_find("uart1");
        if (u1_dev == RT_NULL) {
                LOG_E("rt_device_find[uart1] failed ...\n");
                return -EINVAL;
        }
        // oflag = 读写 + 中断接收
        ret = rt_device_open(u1_dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX);
        if (ret < 0) {
                 LOG_E("rt_device_open[uart1] failed ...\n");
                 return ret;
        }
        
        // 配置串口
        rt_device_control(u1_dev, RT_DEVICE_CTRL_CONFIG, (void *)&u1_config);
        // 配置中断接收回调函数
        rt_device_set_rx_indicate(u1_dev, rx_callback);
        // 创建信号量
        rt_sem_init(&sem, "rx_sem", 0, RT_IPC_FLAG_FIFO);
        // 创建线程
        u1_th = rt_thread_create("u1_recv", serial_thread_entry, NULL, 1024, 10, 5);
        // 启动线程
        rt_thread_startup(u1_th);

        return RT_EOK;
}



////////////////////////////////////////////////////////////////////////////////
//              DMA接收方法
////////////////////////////////////////////////////////////////////////////////
// board.h
#define BSP_USING_UART1
#define BSP_UART1_RX_USING_DMA
#define BSP_UART1_TX_PIN                "PA9"
#define BSP_UART1_RX_PIN                "PA10"



// main.c
#include <rtthread.h>
#include <rtdbg.h>
#include <serial.h>

rt_device_t     u1_dev;
rt_thread_t     u1_th;
rt_size_t       rx_len = 0;
struct rt_semaphore sem;
struct serial_configure u1_config = RT_SERIAL_CONFIG_DEFAULT;
rt_err_t rx_callback(rt_device_t dev, rt_size_t size)
{
        
        rx_len = size;
        rt_sem_release(&sem);   // 唤醒 -> 线程
        return RT_EOK;
}
void serial_thread_entry(void *parameter)
{
        char buffer[512] = 0;
        rt_size_t len = 0;
        while (1) {
                rt_sem_take(&sem, RT_WAITING_FOREVER);
                rt_device_read(u1_dev, 0, buffer, rx_len);
                buffer[len] = '\0';
                rt_kprintf("buffer: %s\n", buffer);
        }

}
int main(void)
{
        rt_err_t ret = 0;
        u1_dev = rt_device_find("uart1");
        if (u1_dev == RT_NULL) {
                LOG_E("rt_device_find[uart1] failed ...\n");
                return -EINVAL;
        }
        // oflag = DMA接收
        ret = rt_device_open(u1_dev, RT_DEVICE_FLAG_DMA_RX);
        if (ret < 0) {
                 LOG_E("rt_device_open[uart1] failed ...\n");
                 return ret;
        }
        
        // 配置串口
        rt_device_control(u1_dev, RT_DEVICE_CTRL_CONFIG, (void *)&u1_config);
        // 配置中断接收回调函数
        rt_device_set_rx_indicate(u1_dev, rx_callback);
        // 创建信号量
        rt_sem_init(&sem, "rx_sem", 0, RT_IPC_FLAG_FIFO);
        // 创建线程
        u1_th = rt_thread_create("u1_recv", serial_thread_entry, NULL, 1024, 10, 5);
        // 启动线程
        rt_thread_startup(u1_th);

        return RT_EOK;
}
