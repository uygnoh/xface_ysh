/*******************************************************************************
        => ThreadX移植
*******************************************************************************/
common/src                              //文件夹下所有源文件
common/inc                              //文件夹下所有头文件
ports/cortex_m4/gnu/src                 //文件夹下所有源文件
ports/cortex_m4/gnu/inc                 //文件夹下的所有头文件
ports/cortex_m4/gnu/example_build       //文件夹下的tx_initialize_low_level.S文件


//threadx 系统中会用到这两个中断服务函数，所以需要屏蔽掉 
//stm32l4xx_it.c 文件中工程自带的这两个中断服务函数。
 multiple definition of `SysTick_Handler'
 multiple definition of `PendSV_Handler'
 
 
//中断向量表未定义报错
//将 tx_initialize_low_level.S 文件中的 _vectors 换为自己的中断向量表，例如本例中 
//startup_stm32l475vetx.s 启动文件中定义了中断向量表为 g_pfnVectors，将其替换即可。
threadx/ports/cortex_m4/gnu/example_build/tx_initialize_low_level.S:114: 
undefined reference to `_vectors'


//__RAM_segment_used_end__ 未定义报错
undefined reference to `__RAM_segment_used_end__'
//需要在链接脚本中指定未使用的 RAM 地址，所以在链接脚本栈中栈结束的地方指定为 RAM 未使用的地址
//解决：修改STM32F103ZETx_FLASH.ld 链接脚本
._user_heap_stack :
{
    . = ALIGN(8);
    PROVIDE ( end = . );
    PROVIDE ( _end = . );
    . = . + _Min_Heap_Size;
    . = . + _Min_Stack_Size;
    . = ALIGN(8);
    __RAM_segment_used_end__ = .;       //加上这句
} >RAM



/*******************************************************************************
        => ThreadX 任务状态
*******************************************************************************/
Ready State             //就绪态
Suspended State         //挂起态
Executing State         //执行态
Terminated State        //终止执行态
Complete State          //执行完成态



/*******************************************************************************
        =>  ThreadX的启动流程
*******************************************************************************/
1 tx_kernel_enter               //进入ThreadX内核
2 _tx_initialize_low_level      //初始化滴答定时器，使能PendSV，SVC和SysTick中断
3 _tx_initialize_high_level     //初始化信号量，事件标志组，消息队列等
4 tx_application_define         //应用程序回调函数，用户可在里面创建任务
5 _tx_thread_scheduler          //启用调度器
//启动操作系统内核
main.c 文件中包含 threadx 系统头文件 tx_api.h ，
并在 while(1) 之前调用 tx_kernel_enter() 函数，此时会报错
undefined reference to `tx_application_define'
//所以需要自己定义 tx_application_define 这个函数，并在这
//个函数中启动一个线程来进行 LED 的闪烁，示例代码如下：

#include "tx_api.h"
#define TASK00_ARGV             0u
#define TASK00_PRIO             2u
#define TASK00_PRIORITY         2u
#define TASK00_STACK_SIZE       4096u
static TX_THREAD task00_tcb;
static uint64_t task00_stack[TASK00_STACK_SIZE / 8];

void demo_thread_entry(ULONG thread_input);
void tx_application_define(void *first_unused_memory);

void demo_thread_entry(ULONG thread_input)
{
        while (1) {
                HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_RESET);
                tx_thread_sleep(1000);
                HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_SET);
                tx_thread_sleep(1000);
        }
}
void tx_application_define(void *first_unused_memory)
{
        tx_thread_create(
                &task00_tcb,            //任务控制块地址
                "TASK00_NAME",          //任务名称
                task00_entry,           //任务入口函数
                TASK00_ARGV,            //任务参数
                &task00_stack[0],       //任务栈起始地址
                TASK00_STACK_SIZE,      //任务栈大小
                TASK00_PRIO,            //任务优先级
                TASK00_PRIORITY,        //任务抢占阈值
                TX_NO_TIME_SLICE,       //不开启时间片
                TX_AUTO_START   );      //创建后立即启动
}




/*******************************************************************************
        => tx_user.h
*******************************************************************************/
// 最快速度优化需要开启的选项 :
//_____________________________________________________________

TX_MAX_PRIORITIES                                       32
TX_DISABLE_PREEMPTION_THRESHOLD
TX_DISABLE_REDUNDANT_CLEARING
TX_DISABLE_NOTIFY_CALLBACKS
TX_NOT_INTERRUPTABLE
TX_TIMER_PROCESS_IN_ISR
TX_REACTIVATE_INLINE
TX_DISABLE_STACK_FILLING
TX_INLINE_THREAD_RESUME_SUSPEND
   
// 最小代码优化需要开启的选项:
//_____________________________________________________________
TX_MAX_PRIORITIES                                       32
TX_DISABLE_PREEMPTION_THRESHOLD
TX_DISABLE_REDUNDANT_CLEARING
TX_DISABLE_NOTIFY_CALLBACKS
TX_NOT_INTERRUPTABLE
TX_TIMER_PROCESS_IN_ISR



// 覆盖tx_port.h 里面的宏定义 
//_____________________________________________________________
#define TX_MAX_PRIORITIES                       32
#define TX_MINIMUM_STACK                        ????
#define TX_THREAD_USER_EXTENSION                ????
#define TX_TIMER_THREAD_STACK_SIZE              ????
#define TX_TIMER_THREAD_PRIORITY                ????



// 确定定时器是否到期的处理，比如应用定时器，溢出时间和函数tx_thread_sleep
// 调用等，是在系统定时器任务里面还是在定时器中断里面调用。 默认是在定时任务里面，
// 当定义了下面函数后，将直接在定时器中断里面处理，可以去掉定时器任务所消耗资源。
//_____________________________________________________________
//#define TX_TIMER_PROCESS_IN_ISR


// 用于设置定时器激活是否采用内联方式，默认此功能是关闭的。如果使能后，
// 内联方式的执行速度快，但增加代码量
//_____________________________________________________________
//#define TX_REACTIVATE_INLINE


// 用于设置是否关闭栈填充，默认情况下是使能的，所有任务的栈空间全部填充
// 为0xEF，带有ThreadX调试组件或者运行时栈检测会用到。
//_____________________________________________________________
//#define TX_DISABLE_STACK_FILLING


// 用于使能栈检测，默认是关闭的。此选项使能后，而TX_DISABLE_STACK_FILLING
// 没使能时，栈填充将开启，方便栈检测
//_____________________________________________________________
//#define TX_ENABLE_STACK_CHECKING


// 用于设置是否关闭抢占阀值，默认是开启的。如果应用程序不需要此功能，
// 关闭后可以降低代码需求，提升性能
//_____________________________________________________________
//#define TX_DISABLE_PREEMPTION_THRESHOLD


// 用于设置是否清零ThreadX全局变量，如果编译器启动代码在ThreadX运行
// 前清除了.bss段，那么可以关闭不必要的清零
//_____________________________________________________________
//#define TX_DISABLE_REDUNDANT_CLEARING


// 确定是否不需要定时器组，禁止后需要用户注释掉tx_initialize_low_level文
// 件里面tx_timer_interrupt的调用。另外，禁止后，必须使能TX_TIMER_PROCESS_IN_ISR 
//_____________________________________________________________
#define TX_NO_TIMER
#ifndef TX_TIMER_PROCESS_IN_ISR
#define TX_TIMER_PROCESS_IN_ISR
#endif


// 用于设置是否关闭通知回调，默认是使能的。如果应用程序没有用到
// 消息回调，关闭掉后可以减小代码，并且可以提升性能 
//_____________________________________________________________
//#define TX_DISABLE_NOTIFY_CALLBACKS


// 使能tx_thread_resume和tx_thread_suspend使用内联代码，
// 优势是提升这两个函数的执行性能，劣势是增加代码量
//_____________________________________________________________
//#define TX_INLINE_THREAD_RESUME_SUSPEND


// 设置TreadX内核不可中断，好处是降低处理负担，并且产生的代码小。
// 但增加锁时间
//_____________________________________________________________
//#define TX_NOT_INTERRUPTABLE


// 使能事件Trace，会稍微增加点代码
//_____________________________________________________________
//#define TX_ENABLE_EVENT_TRACE


// 使能BLOCK_POOL信息获取
//_____________________________________________________________
//#define TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO


// 使能BYTE_POOL信息获取 
//_____________________________________________________________
//#define TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO


// 使能事件标志信息获取 */
//_____________________________________________________________
//#define TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO


// 使能互斥信号量信息获取
//_____________________________________________________________
//#define TX_MUTEX_ENABLE_PERFORMANCE_INFO


// 使能消息对象信息获取
//_____________________________________________________________
//#define TX_QUEUE_ENABLE_PERFORMANCE_INFO

// 使能信号量信息获取
//_____________________________________________________________
//#define TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO


// 使能任务信息获取
//_____________________________________________________________
//#define TX_THREAD_ENABLE_PERFORMANCE_INFO


// 使能定时器信息获取
//_____________________________________________________________
//#define TX_TIMER_ENABLE_PERFORMANCE_INFO



/*******************************************************************************
        => tx_initialize_low_level.s
*******************************************************************************/
// 这个汇编文件里面有个重要参数需要大家配置，即芯片主频和系统时钟节拍。
// 400000000是系统时钟主频，1000对应的就是系统时钟节拍，这里1000就表示1000Hz。
SYSTEM_CLOCK       EQU     400000000
SYSTICK_CYCLES     EQU     ((SYSTEM_CLOCK / 1000) -1)







/*******************************************************************************
        => ThreadX_Makefile
*******************************************************************************/
// .s文件是直接汇编文件，
// .S文件需要进行预处理之后才能汇编，两者编译时有区别，所以使用两个变量进行区分
#######################################
# build the application
#######################################
# list of objects
OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))
vpath %.c $(sort $(dir $(C_SOURCES)))
# list of ASM program objects
OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))
vpath %.s $(sort $(dir $(ASM_SOURCES)))

#// 在此添加编译规则文件（修改为大写S）
# list of ASM2 program objects
OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES2:.S=.o)))
vpath %.S $(sort $(dir $(ASM_SOURCES2)))


$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) 
	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(<:.c=.lst)) $< -o $@

$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR)
	$(AS) -c $(CFLAGS) $< -o $@

#// 在此添加编译规则文件（修改为大写S）
$(BUILD_DIR)/%.o: %.S Makefile | $(BUILD_DIR)
	$(AS) -c $(CFLAGS) $< -o $@




1 // 在threadX底层初始化汇编文件中有两个全局变量
  // 修改stm32启动文件startup_stm32l431xx.s，声明中断向量表_vectors标号是全局的：
  .global _vectors

2 // 将此标号位置添加到中断向量表处
g_pfnVectors:
_vectors:
  .word  _estack
  .word  Reset_Handler
  .word  NMI_Handler
  .word  HardFault_Handler
  .word  MemManage_Handler
  .word  BusFault_Handler
  .word  UsageFault_Handler

3 // 修改stm32链接文件STM32L431RCTx_FLASH.ld，添加此标号所表示的位置
._user_heap_stack :
{
    . = ALIGN(8);
    PROVIDE ( end = . );
    PROVIDE ( _end = . );
    . = . + _Min_Heap_Size;
    . = . + _Min_Stack_Size;
    . = ALIGN(8);
    __RAM_segment_used_end__ = .;       //加上这句
} >RAM


4 // 修改时钟频率
找到threadX的底层初始化汇编文件tx_initialize_low_level_sample.S，
修改系统主频为80Mhz，修改系统tick为1000个tick：




