/*******************************************************************************
        => RV32I 寄存器
*******************************************************************************/
        x0          zero        // 硬编码“0”(Hard-wired zero)
        x1          ra          // 返回地址值(return address)
        x2          sp          // 栈指针(stack pointer)
        x3          gp          // 全局指针(Global pointer)
        x4          tp          // 线程指针(Thread pointer)
        x5~x7       t0~t2       // 临时寄存器(temporaries)
        x28~x31     t3~t6       // 临时寄存器(temporaries)
        x8, x9      s0, s1      // 保存寄存器(saved)
        x18~x27     s2, s11     // 保存寄存器(saved)
        x10, x11    a0, a1      // 参数寄存器(argument)
        x12~x17     a2~a7       // 参数寄存器(argument)
        PC                      // 程序计数器



/*******************************************************************************
        => RV32I 函数调用
*******************************************************************************/
1. 发生函数调用时，在执行函数功能前，先将这次调用中需要用到的参数保存，方便取用
2. 将控制权移交给这次调用的功能函数
3. 根据情况为函数申请一定的本地存储空间，以满足函数执行过程中需要的存储需求
4. 执行该函数的功能
5. 在函数执行完成后，将得到的结果数据保存好，便于主进程来获取，同时还原函数执行
   过程中使用到的寄存器值，释放函数执行过程中使用到的寄存器值，释放分配给函数的
   本地存储空间
6. 将控制权转移给原进程



/*******************************************************************************
        => RV32I 加载__存储
*******************************************************************************/
        lb                      // 加载一个字节
        lh                      // 加载一个半节
        lw                      // 加载一个字
        lbu                     // 加载一个字节（unsigned）
        lhu                     // 加载一个半节（unsigned）


        lw      t0, 8(s1)       // (把“s1寄存器内容 + 8”)以此为地址，读取里面的内容
        sw      t0, 0(s1)       // 把“t0寄存器内容”写入(“s1寄存器内容 + 0”)的地址中
        


//_____________________________________________________________
// "LUI(Load Upper Immediate)" 指令采用U-type, 用于构造20立即数
// LUI指令会构造一个32bits的立即数，这个立即数的高20位对应指令中的imm，
// 低12位清零。  这个立即数作为结果存放在“RD”中
//_____________________________________________________________
|__________________________________________________________|
|          imm[31:12]          |  rd[11:7]  |  opcode[6:0] |
|           20bit              |  5bit      |  7bit        |
|______________________________|____________|______________|


        // 利用 LUI+ADDI 来为寄存器加载一个大数(0x12345678)
        lui  x1, 0x12345        // x1 = 0x12345000
        addi x1, x1, 0x678      // x1 = 0x12345678


        // 利用LUI+ADDI来为寄存器加载一个大数(0x12345FFF)
        lui x1, 0x12346         // x1 = 0x12346000
        addi x1, x1, -1         // x1 = 0x12345FFF



//_____________________________________________________________
// AUIPC(构造程序的相对地址), AUIPC指令采用 "U-type"
//_____________________________________________________________
|__________________________________________________________|
|          imm[31:12]         |  rd[11:7]   |  opcode[6:0] |         
|          20bit              |  5bit       |  7bit        |         
|_____________________________|_____________|______________|
和LUI指令类似，AUIPC指令也会构造一个32bits的立即数，这个立即数的高20位
对应指令中的imm， 低12位清零。 但是和LUI不同的是，AUIPC会先将这个立即数
和PC值相加， 将相加的结果存放在“RD”中。
        auipc x5, 0x12345       // x5 = (0x12345000) + PC




/*******************************************************************************
        => RV32I 移位指令
*******************************************************************************/
 // AND“与”两个值都为“1”，结果才为“1”
|—————————————————————————————————————————————————————————|
|  and x5, x6, x7          //x5 = (x6 & x7)               |
|  andi x5, x6, 3          //x5 = (x6 & 3)                |
|—————————————————————————————————————————————————————————|


 // XOR“异或”(两个bit值不同(异)则取值为“1”, 两个bit值相同则取值为“0”)
|___________________________________________________________|
|  1 0 1 0 1 0 1 0                                          |
|  1 1 1 1 1 1 1 1      //(-1)                              |
|  _______________                                          |
|  0 1 0 1 0 1 0 1                                          |
|___________________________________________________________|


 // 逻辑移位运算, 补足的都是“0”
|—————————————————————————————————————————————————————————|
|  sll  x5, x6, x7         //x5 = (x6 << x7)              |
|  srl  x5, x6, x7         //x5 = (x6 >> x7)              |
|  slli x5, x6, 3          //x5 = (x6 << 3)               |
|  srli x5, x6, 3          //x5 = (x6 >> 3)               |
|—————————————————————————————————————————————————————————|


 // 算术移位运算, 补足的都是“0”
 // 算术右移立即数(Shift Right Arithmetic Immediate)  
|—————————————————————————————————————————————————————————|
|  sra x5, x6, x7          //x5 = (x6 >> x7)              |
|  sra x5, x6, 3           //x5 = (x6 >> 3)               |
|—————————————————————————————————————————————————————————|
1 0 0 1 0 0 0 0         //(0x90)算术右移1位
__________________________________________________________
1 1 0 0 1 0 0 0         //算术右移1位结果(算术右移按照符号位补足)



0 0 0 1 0 0 0 0         //(0x40)算术右移1位
__________________________________________________________
0 0 0 0 1 0 0 0         //算术右移1位结果(算术右移按照符号位补足)



/*******************************************************************************
        => RV32I 跳转指令
*******************************************************************************/
 // Branch if Equal. 比x5和x6的值,
 // 如果相等, 则执行路径跳转到一个新的地址
|_________________________________________________________|
|  beq  x5, x6, LABLE                                     |
|_________________________________________________________|


 // Branch if Not Equal. 比x5和x6的值, 
 // 如果不相等, 则执行路径跳转到一个新的地址
|_________________________________________________________|
|  bne  x5, x6, LABLE                                     |
|_________________________________________________________|


 // Branch if Greater than or Equal. 按照“有符号方式”
 // 比x5和x6的值, 如果(x5 < x6), 则执行路径跳转到一个新的地址
|_________________________________________________________|
|  blt  x5, x6, LABLE                                     |
|_________________________________________________________|


 // Branch if Greater than or Equal. 按照“无符号方式”
 // 比x5和x6的值, 如果(x5 < x6), 则执行路径跳转到一个新的地址
|_________________________________________________________|
|  bltu  x5, x6, LABLE                                    |
|_________________________________________________________|


 // JAL(Jump And Link)
|_________________________________________________________|
|  jal x1, Label                                          |
|_________________________________________________________|
|  31:12                     |    11:7   |  6:0           |
|  imm[20|10:1|11|19:12]     |    rd     |  opcode        |
|____________________________|___________|________________|
1 // JAL指令使用J-type编码格式
2 // JAL指令用于调用子程序(subroutine/function)
3 // 子程序的地址计算方法： 首先对“20bits”宽的“IMM*2”后
  // 进行sign-extended，然后将符号扩展后的值和“PC”的值相加。
  // 因此该函数跳转的范围是以“PC”为基准，上下“-1MB, +1MB”
4 // JAL指令的下一条指令的地址写入“x1”，保存为返回地址(ra)
5 // 实际编程时，用Label给出跳转的目标，具体“IMM”值由编译器
  // 和链接器最终负责生成。



 // JALR(Jump And Link Register)
|___________________________________________________________________|
|  jalr x1, 0(x5)                                                   |
|___________________________________________________________________|
|       31:20        |  19:15 |  14:12    |  11:7   |    6:0        |
|       imm[11:0]    |  [rs1] |  [funct3] |  [rd]   |    [opcode]   |
|____________________|________|___________|_________|_______________|
1 // JALR指令使用I-type编码格式
2 // JALR(subroutine/function)
3 // 子程序地址的计算方法： 首先对“12bits”宽的“IMM”进行
  // sign-extended，然后将符号刘扩展后的值和“x5”的值相加，
  // 得到最终的结果后将其最低位设置为“0”(确保地址按2字节对齐)。
  // 因此该函数跳转地址的范围是以“x5”为基准，上下(+/-2KB).
4 // JALR指令的下一条指令的地址写入“x1”，保存为返回地址(ra)



//_____________________________________________________________
// 判断，如果(i == j)成立，  则 f = g + h;
// 判断，如果(i == j)不成立， 则 f = g -h;
// f->x10, g->x11, h->x12, i->x13, j->x14
//_____________________________________________________________
                bne x13, x14, ELSE
                add x10, x11, x12
                j   EXIT
        ELSE:
                sub x10, x11, x12
        EXIT:


// bne 不相等则跳转到指定位置
//_____________________________________________________________
        if (x13 == x14) {
                x10 = x11 + x12;
        }
        //_____________________________//
                bne     x13, x14, EXIT
                add     x10, x11, x12
        EXIT:



// bne 不相等则跳转到指定位置
//_____________________________________________________________
        if (x13 == x14) {
                x10 = x11 + x12;
        } else {
                x10 = x11 - x12;
        }
        //_____________________________//
                bne     x13, x14, ELSE
                add     x10, x11, x12
                j       EXIT
        ELSE:
                sub     x10, x11, x12
        EXIT:
        
        
        
/*******************************************************************************
        => RV32I 扩展指令
*******************************************************************************/
        CSRRW(Atomic Read/Write CSR)
        // CSRRW RD, CSR, RS1
|____________________________________________________________________|
|crrw t6, mscratch, t6       // t6 = mscratch; mscratch = t6         |
|____________________________________________________________________|
|       31:20       |   19:15    |  14:12  |   11:7   |   6:0        |
|       csr         |   rs1      |  funct3 |   rd     |   opcode     |
|       12          |   5        |  3      |   5      |   7          |
|___________________|____________|_________|__________|______________|
1 // CSRRW先读出“CSR”中的值，将其按“XLEN位”的宽度进行“零扩展(zero-extend)”,
  // 后写入“RD”； 然后将“RS1”中的值写入“CSR”。
2 // 以上两步操作以“原子性(atomically)”方式完成
3 // 如果“RD”是“x0”，则不对“CSR”执行读的操作。
4 // 伪指令         |   基本指令(写 CSR)
     csrw csr, rs  |   csrrw x0, csr, rs




CSRRS(Atomic Read and Set Bits in CSR)
        // CSRRS RD, CSR, RS1
|_________________________________________________________| 
|  csrrs x5, mie, x6           // x5 = mie; mie |= x6;    |
|_________________________________________________________|  
1 // CSRRS先读出“CSR”中的值，将其按“XLEN位”的宽度进行
  // “零扩展(zero-extend)”后写入“RD”； 然后逐个检查“RS1”中的值，
  // 如果某一位为“1”则对“CSR”的对应位置“1”，否则保持不变。
2 // 以上两步操作以“原子性(atomically)”方式完成
3 //伪指令          |    基本指令(读 CSR)
  csrr rd, csr     |    csrrs rd, csr, x0




   
/*******************************************************************************
        => 32-bit Instruction Formats
*******************************************************************************/
add x5, x23, x21        // 指令码: 0x015B82B3
// 功能码    |源寄存器2  |源寄存器1 |功能码  |目的寄存器 | 操作码   //
|___________|_________|_________|_______|_________|___________|
| func7     |  rs2    |   rs1   | func3 |   rd    |    op     |      
|___________|_________|_________|_______|_________|___________|
|  0x00     |   21    |   23    |  0x2  |    5    |   0x33    |
|___________|_________|_________|_______|_________|___________|
|  0000000  |  10101  |  10111  |  000  |  00101  |  0110011  |
|___________|_________|_________|_______|_________|___________|
|  31~25    |  24~20  |  19~15  | 14~12 |   11~7  |    6~0    |
|___________|_________|_________|_______|_________|___________|


lw x5, 23(x19)
// 指令码: 0x0179A283
//        立即数       |源寄存器1  |功能码  |目的寄存器 | 操作码   //
|_____________________|_________|_______|_________|___________|
|        immediate    |   rs1   | func3 |   rd    |    op     |      
|_____________________|_________|_______|_________|___________|
|         23          |   19    |  0x0  |    5    |   0x03    |
|_____________________|_________|_______|_________|___________|
|     000000010111    |  10011  |  010  |  00101  |  0000011  |
|_____________________|_________|_______|_________|___________|
|        31~20        |  19~15  | 14~12 |   11~7  |    6~0    |
|_____________________|_________|_______|_________|___________|


sw x5, 1200(x6)
// 指令码: 0x4A532823
// 立即数    |源寄存器2  |源寄存器1 |功能码  |  立即数  | 操作码   //
|___________|_________|_________|_______|_________|___________|
|  11:5     |  rs2    |   rs1   | func3 |   4:0   |    op     |      
|___________|_________|_________|_______|_________|___________|
|   37      |    5    |    6    |  0x2  |   16    |   0x23    |
|___________|_________|_________|_______|_________|___________|
|  0100101  |  00101  |  00110  |  010  |  10000  |  0100011  |
|___________|_________|_________|_______|_________|___________|
|  31~25    |  24~20  |  19~15  | 14~12 |   11~7  |    6~0    |
|___________|_________|_________|_______|_________|___________|


// 32-bit Instruction Formats //
|_____|___________|_________|_________|_______|_________|___________|
|32bit|  31~25    |  24~20  |  19~15  | 14~12 |   11~7  |    6~0    |
|_____|___________|_________|_________|_______|_________|___________|
|__R  | func7     |  rs2    |   rs1   | func3 |   rd    |   opcode  |
|_____|___________|_________|_________|_______|_________|___________|
|__I  |        i[11:0]      |   rs1   | func3 |   rd    |   opcode  |
|_____|_____________________|_________|_______|_________|___________|
|__S  |  i[11:5]  |  rs2    |   rs1   | func3 | i[4:0]  |   opcode  |
|_____|___________|_________|_________|_______|_________|___________|
|__B  |i[12|10:5] |  rs2    |   rs1   | func3 |i[4:1|11]|   opcode  |
|_____|___________|_________|_________|_______|_________|___________|
|__U  |               i[31:12]                |   rd    |   opcode  |
|_____|_______________________________________|_________|___________|
|__J  |           i[20|10:1|11|19:12]         |   rd    |   opcode  |
|_____|_______________________________________|_________|___________|
