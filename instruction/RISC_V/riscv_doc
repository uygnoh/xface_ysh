/*******************************************************************************
        => RV32I BASE
*******************************************************************************/
                                                // Shift Left Logical
                                                // Shift Right Logical
                                                // 逻辑移位
        (R)     SLL     rd, rs1, rs2            // rd = rs1 << rs2
        (I)     SLLI    rd, rs1, shamt          // rd = rs1 << shamt
        (R)     SRL     rd, rs1, rs2            // rd = rs1 >> rs2
        (I)     SRLI    rd, rs1, shamt          // rd = rs1 >> shamt
        (R)     SRA     rd, rs1, rs2            // Shift Right Arithmetic
        (I)     SRAI    rd, rs1, shamt          // 算术右移
        ////////////////////////////////////////// Arithmetic
        (R)     ADD     rd, rs1, rs2            // ADD
        (I)     ADDI    rd, rs1, imm            // ADD Immediate
        (R)     SUB     rd, rs1, rs2            // SUBTract
        (U)     LUI     rd, imm                 // Load Upper Imm
        (U)     AUIPC   rd, imm                 // Add Upper Imm to PC
        ////////////////////////////////////////// Logical
        (R)     XOR     rd, rs1, rs2            // XOR
        (I)     XORI    rd, rs1, imm            // XOR Immediate
        (R)     OR      rd, rs1, rs2            // OR
        (I)     ORI     rd, rs1, imm            // OR  Immediate
        (R)     AND     rd, rs1, rs2            // AND
        (I)     ANDI    rd, rs1, imm            // AND Immediate
        ////////////////////////////////////////// Compare
        (R)     SLT     rd, rs1, rs2            // Set <
        (I)     SLTI    rd, rs1, imm            // Set < Immediate
        (R)     SLTU    rd, rs1, rs2            // Set < Unsigned
        (I)     SLTIU   rd, rs1, imm            // Set < Imm Unsigned
        ////////////////////////////////////////// Branches
        (B)     BEQ     rs1, rs2, imm           // Branch =
        (B)     BNE     rs1, rs2, imm           // Branch !=
        (B)     BLT     rs1, rs2, imm           // Branch <
        (B)     BGE     rs1, rs2, imm           // Branch >=
        (B)     BLTU    rs1, rs2, imm           // Branch <  Unsigned
        (B)     BGEU    rs1, rs2, imm           // Branch >= Unsigned
        ////////////////////////////////////////// JUMP
        (J)     JAL     rd, imm                 // Jump & Link
        (I)     JALR    rd, rs1, imm            // Jump & Link Register
        ////////////////////////////////////////// Synch
        (I)     FENCE                           // Synch thread
        (I)     FENCE.I                         // Synch Instr & Data
        ////////////////////////////////////////// Enviroment
        (I)     ECALL                           // CALL
        (I)     EBREAK                          // BREAK
        ////////////////////////////////////////// Control Stauts Register (CSR)
        (I)     CSRRW   rd, csr, rs1            // Read/Wirte
        (I)     CSRRS   rd, csr, rs1            // Read & Set   Bit
        (I)     CSRRC   rd, csr, rs1            // Read & Clear Bit
        (I)     CSRRWI  rd, csr, imm            // Read/Wirte       Imm
        (I)     CSRRSI  rd, csr, imm            // Read & Set   Bit IMM
        (I)     CSRRCI  rd, csr, imm            // Read & Clear Bit IMM
        ////////////////////////////////////////// Loads & Stores
        (I)     LB      rd, rs1, imm
        (I)     LH      rd, rs1, imm
        (I)     LBU     rd, rs1, imm
        (I)     LHU     rd, rs1, imm
        (I)     LW      rd, rs1, imm
        (S)     SB      rd, rs1, imm
        (S)     SH      rd, rs1, imm
        (S)     SW      rd, rs1, imm
        
        

/*******************************************************************************
        => RV32I 寄存器
*******************************************************************************/
        x0          zero        // 硬编码“0”(Hard-wired zero)
        x1          ra          // 返回地址值(return address)
        x2          sp          // 栈指针(stack pointer)
        x3          gp          // 全局指针(Global pointer)
        x4          tp          // 线程指针(Thread pointer)
        x5~x7       t0~t2       // 临时寄存器(temporaries)
        x28~x31     t3~t6       // 临时寄存器(temporaries)
        x8, x9      s0, s1      // 保存寄存器(saved)
        x18~x27     s2~s11      // 保存寄存器(saved)
        x10, x11    a0, a1      // 参数寄存器(argument)
        x12~x17     a2~a7       // 参数寄存器(argument)
        PC                      // 程序计数器



/*******************************************************************************
        => RV32I 加载__存储
*******************************************************************************/
        lb                      // 加载一个字节
        lh                      // 加载一个半节
        lw                      // 加载一个字
        lbu                     // 加载一个字节（unsigned）
        lhu                     // 加载一个半节（unsigned）


        lw      t0, 8(s1)       // (把“s1寄存器内容 + 8”)以此为地址，读取里面的内容
        sw      t0, 0(s1)       // 把“t0寄存器内容”写入(“s1寄存器内容 + 0”)的地址中
        


//______________________________________________________________________________
// "LUI(Load Upper Immediate)" 指令采用U-type, 用于构造20立即数
// LUI指令会构造一个32bits的立即数，这个立即数的高20位对应指令中的imm，
// 低12位清零。  这个立即数作为结果存放在“RD”中
//______________________________________________________________________________
        |__________________________________________________________|
        |          imm[31:12]          |  rd[11:7]  |  opcode[6:0] |
        |           20bit              |  5bit      |  7bit        |
        |______________________________|____________|______________|


        // 利用 LUI+ADDI 来为寄存器加载一个大数(0x12345678)
        lui  x1, 0x12345        // x1 = 0x12345000
        addi x1, x1, 0x678      // x1 = 0x12345678


        // 利用LUI+ADDI来为寄存器加载一个大数(0x12345FFF)
        lui x1, 0x12346         // x1 = 0x12346000
        addi x1, x1, -1         // x1 = 0x12345FFF


        // How to set 0xDEADBEEF?
        LUI     x10, 0xDEADB    // x10 = 0xDEADB000
        ADDI    x10, x10, 0xEEF // x10 = 0xDEADAEEF
        所以当这个12位的立即数为负， 也就是最高比特位为 1 时，
        得到的结果是高 20 位减 1 再和低 12 位拼接而来。
        解决办法是：
        当数值的低12位的符号位为 1 时， 将利用LUI装入高 20 位
        的立即数数值预先加 1， 而ADDI写入的低 12 位不变。
        // HOW to set 0xDEADBEEF?
        lui     x10, 0xDEADC            // x10 = 0xDEADC000
        addi    x10, x10, 0xEEF         // x10 = 0xDEADBEEF



//______________________________________________________________________________
// AUIPC(构造程序的相对地址), AUIPC指令采用 "U-type"
//______________________________________________________________________________
        |__________________________________________________________|
        |          imm[31:12]         |  rd[11:7]   |  opcode[6:0] |         
        |          20bit              |  5bit       |  7bit        |         
        |_____________________________|_____________|______________|
        和LUI指令类似，AUIPC指令也会构造一个32bits的立即数，这个立即数的高20位
        对应指令中的imm， 低12位清零。 但是和LUI不同的是，AUIPC会先将这个立即数
        和PC值相加， 将相加的结果存放在“RD”中。
        auipc x5, 0x12345       // x5 = (0x12345000) + PC
        
        
        // Used for PC-Relative addressing
        LABEL:
                AUIPC   x10, 0  // puts address of LABEL in x10




/*******************************************************************************
        => RV32I 移位指令
*******************************************************************************/
//______________________________________________________________________________
// AND“与”两个值都为“1”，结果才为“1”
//______________________________________________________________________________
        and x5, x6, x7          // x5 = (x6 & x7)
        andi x5, x6, 3          // x5 = (x6 & 3 )



//______________________________________________________________________________
// XOR“异或”(两个bit值不同(异)则取值为“1”, 两个bit值相同则取值为“0”)
//______________________________________________________________________________
        |___________________________________________________________|
        |  1 0 1 0 1 0 1 0                                          |
        |  1 1 1 1 1 1 1 1      //(-1)                              |
        |  _______________                                          |
        |  0 1 0 1 0 1 0 1                                          |
        |___________________________________________________________|



//______________________________________________________________________________
// 逻辑移位运算, 补足的都是“0”
//______________________________________________________________________________
        sll  x5, x6, x7         // x5 = (x6 << x7)
        srl  x5, x6, x7         // x5 = (x6 >> x7)
        slli x5, x6, 3          // x5 = (x6 << 3 )
        srli x5, x6, 3          // x5 = (x6 >> 3 )



//______________________________________________________________________________
// 算术右移立即数, 补足的都是“0”
// 算术右移立即数(Shift Right Arithmetic Immediate)  
//______________________________________________________________________________
        sra x5, x6, x7          // x5 = (x6 >> x7)
        sra x5, x6, 3           // x5 = (x6 >> 3 )


        1 0 0 1 0 0 0 0         // (0x90有符号数)算术右移1位
        __________________________________________________________
        1 1 0 0 1 0 0 0         // 算术右移1位结果(算术右移按照符号位补足)



        0 0 0 1 0 0 0 0         // (0x40)算术右移1位
        __________________________________________________________
        0 0 0 0 1 0 0 0         // 算术右移1位结果(算术右移按照符号位补足)



/*******************************************************************************
        => RV32I 跳转指令
*******************************************************************************/
 // Branch if Equal. 比x5和x6的值,
 // 如果相等, 则执行路径跳转到一个新的地址
|_________________________________________________________|
|  beq  x5, x6, LABLE                                     |
|_________________________________________________________|


 // Branch if Not Equal. 比x5和x6的值, 
 // 如果不相等, 则执行路径跳转到一个新的地址
|_________________________________________________________|
|  bne  x5, x6, LABLE                                     |
|_________________________________________________________|


 // Branch if Greater than or Equal. 按照“有符号方式”
 // 比x5和x6的值, 如果(x5 < x6), 则执行路径跳转到一个新的地址
|_________________________________________________________|
|  blt  x5, x6, LABLE                                     |
|_________________________________________________________|


 // Branch if Greater than or Equal. 按照“无符号方式”
 // 比x5和x6的值, 如果(x5 < x6), 则执行路径跳转到一个新的地址
|_________________________________________________________|
|  bltu  x5, x6, LABLE                                    |
|_________________________________________________________|


 // JAL(Jump And Link)
|_________________________________________________________|
|  jal x1, Label                                          |
|_________________________________________________________|
|  31:12                     |    11:7   |  6:0           |
|  imm[20|10:1|11|19:12]     |    rd     |  opcode        |
|____________________________|___________|________________|
        1 // JAL指令使用J-type编码格式
        2 // JAL指令用于调用子程序(subroutine/function)
        3 // 子程序的地址计算方法： 首先对“20bits”宽的“IMM*2”后
          // 进行sign-extended，然后将符号扩展后的值和“PC”的值相加。
          // 因此该函数跳转的范围是以“PC”为基准，上下“-1MB, +1MB”
        4 // JAL指令的下一条指令的地址写入“x1”，保存为返回地址(ra)
        5 // 实际编程时，用Label给出跳转的目标，具体“IMM”值由编译器
          // 和链接器最终负责生成。



 // JALR(Jump And Link Register)
|___________________________________________________________________|
|  jalr x1, 0(x5)                                                   |
|___________________________________________________________________|
|       31:20        |  19:15 |  14:12    |  11:7   |    6:0        |
|       imm[11:0]    |  [rs1] |  [funct3] |  [rd]   |    [opcode]   |
|____________________|________|___________|_________|_______________|
        1 // JALR指令使用I-type编码格式
        2 // JALR(subroutine/function)
        3 // 子程序地址的计算方法： 首先对“12bits”宽的“IMM”进行
          // sign-extended，然后将符号刘扩展后的值和“x5”的值相加，
          // 得到最终的结果后将其最低位设置为“0”(确保地址按2字节对齐)。
          // 因此该函数跳转地址的范围是以“x5”为基准，上下(+/-2KB).
        4 // JALR指令的下一条指令的地址写入“x1”，保存为返回地址(ra)



//_____________________________________________________________
// 判断，如果(i == j)成立，  则 f = g + h;
// 判断，如果(i == j)不成立， 则 f = g -h;
// f->x10, g->x11, h->x12, i->x13, j->x14
//_____________________________________________________________
                bne x13, x14, ELSE
                add x10, x11, x12
                j   EXIT
        ELSE:
                sub x10, x11, x12
        EXIT:



//_____________________________________________________________
// bne 不相等则跳转到指定位置
//_____________________________________________________________
        if (x13 == x14) {
                x10 = x11 + x12;
        }
        //_____________________________//
                bne     x13, x14, EXIT
                add     x10, x11, x12
        EXIT:



//_____________________________________________________________
// bne 不相等则跳转到指定位置
//_____________________________________________________________
        if (x13 == x14) {
                x10 = x11 + x12;
        } else {
                x10 = x11 - x12;
        }
        //_____________________________//
                bne     x13, x14, ELSE
                add     x10, x11, x12
                j       EXIT
        ELSE:
                sub     x10, x11, x12
        EXIT:
        
        
        
/*******************************************************************************
        => RV32I 扩展指令
*******************************************************************************/
        CSRRW(Atomic Read/Write CSR)
        // CSRRW RD, CSR, RS1
|____________________________________________________________________|
|crrw t6, mscratch, t6       // t6 = mscratch; mscratch = t6         |
|____________________________________________________________________|
|       31:20       |   19:15    |  14:12  |   11:7   |   6:0        |
|       csr         |   rs1      |  funct3 |   rd     |   opcode     |
|       12          |   5        |  3      |   5      |   7          |
|___________________|____________|_________|__________|______________|
1 // CSRRW先读出“CSR”中的值，将其按“XLEN位”的宽度进行“零扩展(zero-extend)”,
  // 后写入“RD”； 然后将“RS1”中的值写入“CSR”。
2 // 以上两步操作以“原子性(atomically)”方式完成
3 // 如果“RD”是“x0”，则不对“CSR”执行读的操作。
4 // 伪指令         |   基本指令(写 CSR)
     csrw csr, rs  |   csrrw x0, csr, rs




CSRRS(Atomic Read and Set Bits in CSR)
        // CSRRS RD, CSR, RS1
|_________________________________________________________| 
|  csrrs x5, mie, x6           // x5 = mie; mie |= x6;    |
|_________________________________________________________|  
1 // CSRRS先读出“CSR”中的值，将其按“XLEN位”的宽度进行
  // “零扩展(zero-extend)”后写入“RD”； 然后逐个检查“RS1”中的值，
  // 如果某一位为“1”则对“CSR”的对应位置“1”，否则保持不变。
2 // 以上两步操作以“原子性(atomically)”方式完成
3 //伪指令          |    基本指令(读 CSR)
  csrr rd, csr     |    csrrs rd, csr, x0




   
/*******************************************************************************
        => 32-bit Instruction Formats
*******************************************************************************/
add x5, x23, x21        // 指令码: 0x015B82B3
// 功能码    |源寄存器2  |源寄存器1 |功能码  |目的寄存器 | 操作码   //
|___________|_________|_________|_______|_________|___________|
| func7     |  rs2    |   rs1   | func3 |   rd    |    op     |      
|___________|_________|_________|_______|_________|___________|
|  0x00     |   21    |   23    |  0x2  |    5    |   0x33    |
|___________|_________|_________|_______|_________|___________|
|  0000000  |  10101  |  10111  |  000  |  00101  |  0110011  |
|___________|_________|_________|_______|_________|___________|
|  31~25    |  24~20  |  19~15  | 14~12 |   11~7  |    6~0    |
|___________|_________|_________|_______|_________|___________|


lw x5, 23(x19)
// 指令码: 0x0179A283
//        立即数       |源寄存器1  |功能码  |目的寄存器 | 操作码   //
|_____________________|_________|_______|_________|___________|
|        immediate    |   rs1   | func3 |   rd    |    op     |      
|_____________________|_________|_______|_________|___________|
|         23          |   19    |  0x0  |    5    |   0x03    |
|_____________________|_________|_______|_________|___________|
|     000000010111    |  10011  |  010  |  00101  |  0000011  |
|_____________________|_________|_______|_________|___________|
|        31~20        |  19~15  | 14~12 |   11~7  |    6~0    |
|_____________________|_________|_______|_________|___________|


sw x5, 1200(x6)
// 指令码: 0x4A532823
// 立即数    |源寄存器2  |源寄存器1 |功能码  |  立即数  | 操作码   //
|___________|_________|_________|_______|_________|___________|
|  11:5     |  rs2    |   rs1   | func3 |   4:0   |    op     |      
|___________|_________|_________|_______|_________|___________|
|   37      |    5    |    6    |  0x2  |   16    |   0x23    |
|___________|_________|_________|_______|_________|___________|
|  0100101  |  00101  |  00110  |  010  |  10000  |  0100011  |
|___________|_________|_________|_______|_________|___________|
|  31~25    |  24~20  |  19~15  | 14~12 |   11~7  |    6~0    |
|___________|_________|_________|_______|_________|___________|


// 32-bit Instruction Formats //
|_____|___________|_________|_________|_______|_________|___________|
|32bit|  31~25    |  24~20  |  19~15  | 14~12 |   11~7  |    6~0    |
|_____|___________|_________|_________|_______|_________|___________|
|__R  | func7     |  rs2    |   rs1   | func3 |   rd    |   opcode  |
|_____|___________|_________|_________|_______|_________|___________|
|__I  |        i[11:0]      |   rs1   | func3 |   rd    |   opcode  |
|_____|_____________________|_________|_______|_________|___________|
|__S  |  i[11:5]  |  rs2    |   rs1   | func3 | i[4:0]  |   opcode  |
|_____|___________|_________|_________|_______|_________|___________|
|__B  |i[12|10:5] |  rs2    |   rs1   | func3 |i[4:1|11]|   opcode  |
|_____|___________|_________|_________|_______|_________|___________|
|__U  |               i[31:12]                |   rd    |   opcode  |
|_____|_______________________________________|_________|___________|
|__J  |           i[20|10:1|11|19:12]         |   rd    |   opcode  |
|_____|_______________________________________|_________|___________|
