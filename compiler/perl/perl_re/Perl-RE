###########################################################
###  Perl Regular Expression
###########################################################
.       匹配除换行符以外的所有字符
x?      匹配 0 次或一次 x 字符串
x*      匹配 0 次或多次 x 字符串,但匹配可能的最少次数
x+      匹配 1 次或多次 x 字符串,但匹配可能的最少次数
.*      匹配 0 次或多次的任何字符(除换行符)
.+      匹配 1 次或多次的任何字符(除换行符)
{m} 	匹配刚好是 m 个 的指定字符串
{m,n}	匹配在 m个 以上 n个 以下 的指定字符串
{m,} 	匹配 m个 以上 的指定字符串
[]      匹配符合 [] 内的字符
[^]     匹配不符合 [] 内的字符
[0-9]	匹配所有数字字符
[a-z] 	匹配所有小写字母字符
[^0-9] 	匹配所有非数字字符
[^a-z]	匹配所有非小写字母字符
^ 	    匹配字符开头的字符
$	    匹配字符结尾的字符
\d 	    匹配一个数字的字符,和 [0-9] 语法一样
\d+ 	匹配多个数字字符串,和 [0-9]+ 语法一样
\D 	    非数字,其他同 \d
\D+ 	非数字,其他同 \d+
\w 	    英文字母或数字的字符串,和 [a-zA-Z0-9_] 语法一样
\w+ 	和 [a-zA-Z0-9_]+ 语法一样
\W 	    非英文字母或数字的字符串,和 [^a-zA-Z0-9_] 语法一样
\W+ 	和 [^a-zA-Z0-9_]+ 语法一样
\s 	    空格,和 [\n\t\r\f] 语法一样
\s+ 	和 [\n\t\r\f]+ 一样
\S 	    非空格,和 [^\n\t\r\f] 语法一样
\S+ 	和 [^\n\t\r\f]+ 语法一样
\b 	    匹配以英文字母,数字为边界的字符串
\B 	    匹配不以英文字母,数值为边界的字符串
a|b|c 	匹配符合a字符 或是b字符 或是c字符 的字符串

           
            


###########################################################            
###  文字处理模式的简单范例  
###########################################################
% 很多特殊的变量有一个很长的英文名，操作系统变量 $! 可以写为 $OS_ERROR
% 最常用的特殊变量为 $_，该变量包含了默认输入和模式匹配内容

$_ = I Love 8888 you;
if (/[0-9]*/) {
    print "hello,world";
}    
   
   
    


###########################################################
###  贪婪&懒惰
###########################################################
% 贪婪(尽可能多的匹配)
/a.*b/  (aabab)匹配aabab    

% 懒惰(尽可能少的匹配),匹配任意数量的重复，
% 但是在能使整个匹配成功的前提下使用最少的重复。
/a.*b?/  (aabab)匹配aab


*?          重复任意次，但尽可能少重复
+?          重复1次或多次，但尽可能少重复
??          重复1次或多次，但尽可能少重复
{n, m}?     重复n到m次，但尽可能少重复
{n, }?      重复n次以上，但尽可能少重复





###########################################################
###  量词, 通用量词
###########################################################
% ？号，表示a为1个到0个
$_ = "abc";
if (/a?/) {
    print "匹配上了！";
}


% *号，表示a可以没有，a也可以有多个
$_ = "abc";
if (/a*/) {
    print "匹配上了！";
}


% +号，表示a至少有1个， a也可以有多个 
$_ = "abc";
if (/a+/) {
    print "匹配上了！";
}


$_ = "abc";
if (/a?b*c+/) {
    print "匹配上了！";
}


% 用{}大括号来指定量词，它叫做通用量词
$_ = "abcddddddeef";
if (/a?b*c+d{5}e{2,5}/) {
    print "匹配上了！";
}

% 容易出错的地主,表示以fred开头，或barney结尾
if (/^fred|barney$/) {
    print "匹配上了！";
}
% 修改后的,表示以fred开头，以fred结尾
% 或以barney开头，以barney结尾
if (/^(fred|barney)$/) {
    print "匹配上了！";
}





###########################################################
###  模式测试程序
###########################################################
%% demo
while (<>) {
    chomp;
    if (/你的正则表达式/) {
        print "匹配上的是： |$`<$&>$'|\n";
    } else {
        print "没有匹配上\n";
    }
}


% 测试程序1
while (<>) {
    chomp;
    if (/\s\d+\s) {
        print "匹配上的是： |$`<$&>$'|\n";
    } else {
        print "没有匹配上\n";
    }
}





###########################################################
###  正则表达式的优先级
###########################################################
圆括号         ()
量词           a* a+ a? a{n, m}
锚位和序列      abc ^a a$
择一           a|b|c
元素           a [abc] \d \1





###########################################################
###  模式匹配修饰符
###########################################################

% 指定模式匹配的修饰符，可以改变正则表达式的匹配行为。
% 例如，下面的i就是一种修饰符，它让前面的正则REG匹配时忽略大小写。
m/REG/i

% perl总共支持以下几种修饰符：msixpodualngc
    i   ：匹配时忽略大小写
    g   ：全局匹配，默认情况下，正则表达式"abc"匹配"abcdabc"字符串的时候，
          将之匹配左边的abc，使用g将匹配两个"abc"
    c   ：在开启g的情况下，如果匹配失败，将不重置搜索位置
    m   ：多行匹配模式
    s   ：让.可以匹配换行符"\n"，也就是说该修饰符让.真的可以匹配任意字符
    x   ：允许正则表达式使用空白符号，免得让整个表达式难读难懂，
          但这样会让原本的空白符号失去意义，这是可以使用\s来表示空白
    o   ：只编译一次正则表达式
    n   ：非捕获模式
    d   ：使用unicode或原生字符集，就像5.12和之前那样，也不用考虑这个修饰符
    p   ：保存匹配的字符串到${^PREMATCH}、${^MATCH}、${^POSTMATCH}中，
          它们在结果上对应$`、$&和$'，但性能上要更好 
%   a和u和l：分别表示用ASCII、Unicode和Locale的方式来解释正则表达式，一般不用考虑这几个修饰符
    
    
    
    

###########################################################
###  范围模式匹配修饰符(?imsx-imsx:pattern)
###########################################################
% 前文介绍的修饰符adluoimsxpngc都是放在m//{FLAG}的flag处的，
% 放在这个位置会对整个正则表达式产生影响，所以它的作用范围有点广。
% 例如m/pattern1 pattern2/i的i修饰符会影响pattern1和pattern2。

perl允许我们定义只在一定范围内生效的修饰符，
方式是(?imsx:pattern)或(?-imsx:pattern)或(?imsx-imsx:pattern)，
其中加上-表示去除这个修饰符的影响。这里只列出了imsx，因为这几个最常用，其他的修饰符也一样有效。


+ 例如，对于待匹配字符串"Hello world gaoxiaofang"，使用以下几种模式去匹配的话：
/(?i:hello) world/
% 表示匹配hello时，可忽略大小写，但匹配world时仍然区分大小写。所以匹配成功

/(?ims:hello.)world/
% 表示可以跨行匹配helloworld，也可以匹配单行的hellosworld，且hello部分忽略大小写。所以匹配成功

/(?i:hello (?-i:world) gaoxiaoFANG)/
% 表示在第二个括号之前，可用忽略大小写进行匹配，但因为第二个括号里指明了去除i的影响，
% 所以对world的匹配会区分大小写，但是对gaoxiaofang部分的匹配又不区分大小写。所以匹配成功

/(?i:hello (?-i:world) gaoxiao)FANG/
% 和前面的类似，但是将"FANG"放到了括号外，意味着这部分要区分大小写。所以匹配失败








