###########################################################
###  % 位运算
###########################################################
1 % 查看A的某一位是0还是1, 如果它等于零，则第n位是0
    A & (1 << n)
    
2 % 将A的第n位置位(1)
    A |= (1 << n)

3 % 将A的第n位清零(0)
    A &= ~(1 << n)

4 % 将A的第n位取反(^异或：相同为0，不同为1)
    A ^= (1 << n)



############################################################
###  % Bit_Mask位掩码
############################################################
#define bit0_mask 0b00000001
#define bit1_mask 0b00000010
#define bit2_mask 0b00000100
uint8_t uchar_var = 0x34;
/* % 判断第“0”位是不是等于“0” */
if ((uchar_var & bit0_mask0) == 0)
/* % 判断第“1”位是不是等于“1” */
if ((uchar_var & bit1_mask1) == 1)

define high4_mask 0b11110000
define low4_mask  0b00001111
uint8_t ucahr_var = 0x43;
/* extract low 4 bit */
uchar_var = uchar_var & low4_mask;
/* extraxt high 4 bit */
uchar_var = （uchar_var & high4) >> 4;



###########################################################
###  % 取模运算
###########################################################
% ###取模运算，对于整型数a，b来说，取模运算是： 
 1.求 整数商： c = a/b; 
 2.计算模：    a%b = a - c*b.



###########################################################
###  % const关键字
###########################################################
1 % 它表示 p 可以改变， *p 不可以改变。const修饰 *p
    char a = 'a';
    const char *p = &a;
    char const *p = &a;

2 % 它表示 *p可以改变，但是 p不可改变。const修饰 p;
    char a = 'w';
    char * const p = &a;

3 % 它表示 *p和p都不可以改变，const修饰 p和*p;
  % const即修饰p,又修饰*p;所以p和*p都不可改变
    const char * const p = &a;



###########################################################
###  % 条件编译指令 
###########################################################
#               % 空指令
#include        % 包含一个源码文件
#define         % 宏定义
#undef          % 取消已定义的宏
#if             % 如果给定的条件位真，则编译下面的代码
#elif           % 如果前面 #if 给定的条件为假，当前条件为真，则编译下面的代码
#endif          % 条件编译结束
#else           % 如果前面 #if 给定的条件都为假，则编译下面的代码
#error          % 停止编译，并显示错误信息
#ifdef          % 如果宏已定义，则编译下面的代码
#ifndef         % 如果宏没有定义，则编译下面的代码
#if defined(x)  % 如果 x 被定义过，则编译下面的代码
#if !defined(x) % 如果 x 没有被定义过，则编译下面的代码
#line           % #line 使您可以修改编译器的行号以及（可选）错误和警告的文件名输出
#pragma         % #pragma的作用是：用于给编辑器提供特殊的指令，说明如何编译包含杂注的文件


% ###  防止重复定义
#ifndef __COMMON_H
#define __COMMON_H
/* common.h */
#endif



###########################################################
###  % macro 宏
###########################################################
#define SWAP1(a, b) \
{                   \
    int t = a;      \
    a = b;          \
    b = t;          \
}                   

/* SWAP2 这种算法的缺陷为，当a和b的数值很大时，可能出现溢出 */
#define SWAP2(a, b) \
{                   \
    a = a+b         \
    b = a-b;        \
    a = a-b;        \
}			

/* SWAP3 采用按位异或运算，效率是非常高的 */
#define SWAP3(a, b) \
{                   \
    a = a^b;        \
    b = a^b;        \
    a = a^b;        \
}		



###########################################################
###  % volatile关键字
###########################################################
% volatile 关键字（易失的，可变的）, 此关键字主要用于处理器的寄存器编程！
*((uint_32 volatile *)(0x40032810))




###########################################################
### %  i++, ++i
###########################################################
自增运算符： i++, ++i
int i = 0;
int j = i++;
(i++表达式是加前取值) 运行结果：i=1;j=0

int i = 0;
int j = ++i;
(++i是加后取值)       运行结果：i=1;j=1


*与&的关系：互为逆运算
&取地址运算符，取变量的地址
*指针运算符(间接访问运算符)，取指针变量所指向的内容  



###########################################################
% C语言运算符优先级(1代表最高级别)
###########################################################

%级别    运算符              结合性
_________________________________________________      
1     ()    []   ->    .    左->右
        i++ i--
_________________________________________________      
2     + - ++i --i sizeof 
      ! ~  * &  (type)      右->左 单目
_________________________________________________      
3      *   /   %            左->右 双目 
_________________________________________________      
4      +   -                左->右
_________________________________________________      
5      <<   >>              左->右 
_________________________________________________      
6      <  >  <=  >=         左->右    
_________________________________________________      
7      ==  !=               左->右
_________________________________________________      
8      &                    左->右
_________________________________________________      
9      ^                    左->右
_________________________________________________      
10     |                    左->右
_________________________________________________      
11     &&                   左->右
_________________________________________________      
12     ||                   左->右
_________________________________________________      
13     ?:                   右->左 三目
_________________________________________________      
14     =                    右->左
_________________________________________________      
15     ,                    左->右
_________________________________________________      




