###########################################################
### % STM32链接脚本详解
###########################################################
1 % 首先我们需要了解一个image文件的构成。
image即编译的产物，我们编译STM32生成的bin文件此处称之为image。
一个image文件由RO段和RW段组成，RO段包含只读的代码段和常量，RW段包含可读可写的全局变量和静态变量。
因为程序刚运行时，RW段还在FLASH中，需要一段程序将这些变量复制到RAM中，STM32的启动文件的__main
函数帮我们完成了这一动作。RW段中初始值为0的段为ZI段，image文件无需包含ZI段，因为ZI段包含的是全
局或静态初始值为0的变量，只要在程序运行后，将对应的RAM区域清零即可。

2 % 这里又涉及到另一个概念：加载地址和运行地址。
加载地址是指读取程序的地址，运行地址是指程序运行的入口地址。
STM32因为有XIP（executed in place）技术，加载地址和运行地址是一样的，都是0x08000000。
简而言之，如果程序在FLASH中运行，加载地址和运行地址是相同的，例如STM32等单片机；如果程序存
放在FLASH里，而运行是在RAM里，那么加载地址指向FLASH，运行地址指向RAM，例如跑Linux系统的
一些芯片。上面的RW段，其加载地址指向FLASH，而运行地址指向RAM，因此需要拷贝。

3 % 如何指定各个C文件的编译产物(.o格式)在RO段的顺序？又如何确定程序的加载地址和运行地址呢？
这都是靠一个脚本来完成的，即链接脚本。在Linux下，链接脚本为lds文件；在KEIL中，链接脚本为sct文件；
在IAR中，链接脚本为icf文件。本文以KEIL下的sct文件为例，讲解链接脚本结构。

4 % 我们可以通过编写一个分散加载文件来指定 ARM 连接器在生成映像文件时如何分配 
Code、RO-Data， RW-Data， ZI-Data 等数据的存放地址。称为分散加载文件实际上就是链接脚本，
如果不修改KEIL的链接脚本，那么会使用默认的链接脚本，我们按照下图的操作方式来查看默认的链接脚本，
方法为点击工程设置，找到Link选项，去掉“Use Memory Layout from Target Dialog”前面的勾选，
然后点击Edit。


5 % 查看到的默认链接脚本如下，注：本例中使用的MCU型号为STM32F103RC，FLASH容量为256KB，RAM大小为64KB。
; *************************************************************
; *** Scatter-Loading Description File generated by uVision ***
; *************************************************************
LR_IROM1 0x08000000 0x00040000  {    ; 加载时域起始地址为0x08000000，大小为0x40000
  ER_IROM1 0x08000000 0x00040000  {  ; 第一个运行时域，运行地址为0x08000000，大小为0x40000
   *.o (RESET, +First)               ; RESET段最先链接，RESET段在启动文件中有声明
   *(InRoot$$Sections)               ; 链接__main函数,该函数用于RW段数据的拷贝和ZI段数据的清零
   .ANY (+RO)                        ; 剩余的code、RO数据随意链接
  }
  RW_IRAM1 0x20000000 0x0000C000  {  ; 第二个运行时域,运行地址为0x20000000，大小为0xC000
   .ANY (+RW +ZI)                    ; 存放所有的RW段数据和ZI段数据
  }
}


6 % 分散加载文件主要由一个加载时域和多个运行时域组成。
加载时域，顾名思义用于加载并存储数据，包括 Code、 RO-Data 和 RW-Data。
运行时域， 用于为运行时分配变量及代码映射空间， 包含 Code、 ZI-Data、 RW-Data。


% 分散加载有3条规则需要特别注意：
1、第一个运行时域的基址必须与加载域基址相同。
2、第一个运行时域存放的代码不会进行额外拷贝。
3、一个加载时域，有且仅有一个不拷贝的运行时域，FIXED关键字修饰除外。
 

% 分散加载的用途有很多，例如：
1、我们可以通过修改分散加载文件将部分代码或整个代码放到RAM中运行以提高运行速度。
2、可以将一组函数放在特定地址上，作为Firmware供app程序调用。
3、将程序分成boot和app，实现升级功能。实现这个功能可以不修改分散加载文件，直接在keil里设置即可。
4、定义section来灵活地存放特定的数据。
关于分散加载的更多知识，可以参考周立功写的一篇文档《keil分散加载文件浅释》，我已经传到百度网盘：


有时候我们需要在程序运行时知道各个段的起始地址、结束地址、大小等信息，
这些信息链接器已经帮我们导出了，下面给出了一个使用的例子，这个例子实际上完成了__main的部分功能，
即把FLASH中的RW段数据拷贝到RAM的运行地址上，并将RAM中的ZI段数据清零。
void RW_And_ZI_Init (void)
{
    extern unsigned char Image$$ER_IROM1$$Limit;       // 获取RW段在FLASH中的加载地址
    extern unsigned char Image$$RW_IRAM1$$Base;        // 获取RW段在RAM中的运行地址    
    extern unsigned char Image$$RW_IRAM1$$RW$$Limit;   // 获取RW段在RAM中的结束地址
    extern unsigned char Image$$RW_IRAM1$$ZI$$Limit;   // 获取ZI段在RAM中的结束地址
    unsigned char * psrc, *pdst, *plimt;
		
    psrc  = (unsigned char *)&Image$$ER_IROM1$$Limit;
    pdst  = (unsigned char *)&Image$$RW_IRAM1$$Base;
    plimt = (unsigned char *)&Image$$RW_IRAM1$$RW$$Limit;
    while(pdst < plimt)     // 将FLASH中的RW段拷贝到RAM的RW段运行地址上
    {
        *pdst++ = *psrc++;
    }
 
    psrc  = (unsigned char *)&Image$$RW_IRAM1$$RW$$Limit;
    plimt = (unsigned char *)&Image$$RW_IRAM1$$ZI$$Limit;
    while(psrc < plimt)     // 将RAM中的ZI段清零
    {
        *psrc++ = 0;
    }
}  






###########################################################
### % STM32_GCC链接脚本详解
###########################################################
1 % input section & output section
所谓的输入段，是指连接的时候提供LD的所有目标文件(OBJ)中的段
所谓的输出段，是指生成的文件，例如 Elf 中的每个段


2 % lma | vma
lma = load memory address       ;加载地址
vma = virtual memory address    ;运行地址


3 % 两个基本架构， 都是系统默认的关键字
OUTPUT_FORMAT("elf32-littlearm","elf32-bigarm",
                                "elf32-littlearm")
OUTPUT_ARCH(arm)


4 % ENTRY(__ENTRY)
指定入口点，LD手册说， ENTRY POINT就是程序第一条执行的指令
第1，生成elf文件并不是能直接用在嵌入式平台上面裸跑的，因为我们并没有操作系统
我们不需要 elf文件头的那些指示信息提供给操作系统，指示系统怎么去加载文件
第2，在嵌入式上面完全没有这个必要，只需要将实际代码提取出来，直接运行就Ok
也说是Objcopy的操作，在嵌入式系统上面，ENTRY POIN是没有意义的，只需要
指向整个代码最形如的指令就好了



5 % 链接器脚本格式,链接器脚本是文本文件（textfile）。
编写一个链接器脚本就是就是书写一系列命令，每个命令要么是一个关键字，可能会跟随一些参数，要么是对
一个符号的分配。你可以使用分号分割命令，空格通常被忽略。
字符串比如文件或者格式名字通常可以直接键入（直接书写出来）。如果文件名包含字符，比如逗号，
这可能导致文件名分开，你可以将文件名放在双引号之间。文件名中是无法包含双引号字符的。
你可以在链接器脚本中加入注释（就像给C程序进行注释一样），以‘/*’和‘*/‘为界，将注释放在二者之间，
就像在C中，注释在语法上等同于空格。


6 % 简单的链接脚本例子,许多链接器脚本都相当简单。
最简单的链接器脚本只有一个命令：‘SECTIONS’,你用SECTIONS命令描述输出文件在内存布局

% ‘SECTIONS’命令是一个强大的命令，假设你的程序中只有，
% 代码节， 初始化过的数据节， 未初始化过的数据节'.text'、‘.data’、‘.bss’
对于下面这个例子，代码应该被载入地址'0x10000'处， 而数据应当从0x8000000处开始
SECTIONS
{
    . = 0x10000;
    .text : {*(.text)}
    . = 0x8000000
    .data : {*(.data)}
    .bss :{*(.bss)}
}

'.'     第一行是对一个特殊的符号‘.’赋值，这是一个定位计数器
'.text' 第二行定义一个输出节‘.text’,冒号是语法需要，现在可以被忽略，节名后面的花括号中，
        你列出所有应当被放入到这个输出节中的输入节的名字， ‘*’是一个通配符，匹配任何文件名
        表达式‘*(.text)’意思是所有的输入文件中的‘(.text)’输入节



