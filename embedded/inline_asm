/*******************************************************************************
        => gcc-arm-none-eabi
*******************************************************************************/
//通用的内嵌汇编模版
asm (assembler template 
		: output operands             // optional  输出运算符列表
		: input operands              // optional  输入运算符列表
		: list of clobbered registers // optional  被更改资源列表
		);



//http://www.ethernut.de/en/documents/arm-inline-asm.html
// 换行符和制表符的使用可以使得指令列表看起来变得美观
// 下例中内嵌了一条汇编指令实现了将立即数（1）赋值给寄存器R1的操作
// 由于没有任何形式的输入和输出，所以输入和输出列表的位置上什么都没有填写
// 但是在汇编代码执行的过程中R1寄存器会被修改，因此为了通知编译器，在被更
// 改资源列表中，需要写上寄存器R1
        __asm (
		        "mov r1, #1\n\t"
		        :
		        :
		        : "r1"

        );


// 下面一条MOV指令，该指令将（%0）赋值给（R4）
// 符号（%0）代表出现在输入运算符列表和输出运算符列表中的第一个值
// 符号（%1）代表出现在输入运算符列表和输出运算符列表中的第二个值
// 所以在该代码中，（%0）代表就是 “r”(tmp) 这个表达式的值
// 那么这个新表达式该怎样解释呢？
// 在“r”(tmp) 这个表达式中， tmp代表正是C语言向内嵌汇编输入的变量
// 操作符“r”则代表tmp的值会通过某一个寄存器来传递。
//      操作符  含义
//      r       通用寄存器（R0~R15）
//      m       一个有效的内存地址
//      I       数据处理指令中的立即数
//      X       被修饰的操作符只能作为输出
        int tmp = 5;
        asm (
                "mov r4, %0\n"
                :
                : "r"(tmp)
                : "r4"
        );




// 在下面的代码中，原本出现在输入运算符列表中的运算符，
// 现在出现在了输出运算符列表中，同时变量tmp将会存储内联汇编的输出结果
// 代码中操作符“r”的前面多了一个“=”，这个符号称为约束修饰符，作用是内联汇编的操作符进行修饰
//      修饰符     说明
//      无        被修饰的操作符是只读的
//      =         被修饰的操作符是只写的
//      +         被修饰的操作符可读可写   
//      &         被修饰的操作符只能作为输出
//当一个操作符没有修饰符对其进行修饰时，代表这个操作符是只读的。当我们需要将内联汇编的结果输出
//出来，那么至少要保证该操作符是可写的。 因此，“=”或者“+”也就必不可少了。
        int tmp;
        asm (
                "mov %0, #1\n"
                : "=r"(tmp)
                :
        );


