/*******************************************************************************
               AFIO_MAPR_复用重映射和调试I/O配置寄存器
SWJ_CFG[26:24]  //串行线JTAG配置 (Serial wire JTAG configuration)
                ！这些位只可由软件写(读这些位，将返回未定义的数据值)
    (0)000     *完全SWJ(JTAG-DP + SW-DP)：复位状态； 
    (1)001     *完全SWJ(JTAG-DP + SW-DP)但没有NJTRST；
    (2)010     *关闭JTAG-DP，启用SW-DP；
    (4)100     !关闭JTAG-DP，关闭SW-DP；!
*******************************************************************************/
void afio_swd_setup(void)
{
	//使能AFIO时钟， 禁用JTAG, 开启SWD
	AFIO_CLOCK_ENABLE();
	AFIO->MAPR &= (uint32_t)(0xF8FFFFFF);
	AFIO->MAPR |= (uint32_t)(0x02000000);
}



/*******************************************************************************
                           USART波特率设置 72MHz@9600
*******************************************************************************/
//设置系统时钟为72MHz， 波特率为9600bps
|_________________________________________________________|
|                                                         |
|                               SystemClock               |
|       Tx/Rx-baud_rate  = _____________________          |
|                              16 * USARTDIV              |
|                                                         |
|                                                         |
|                                                         |
|       9600 = (72*1000*1000) / (16 * U)                  |
|       U    = 72000000 / (9600 * 16)                     |
|_________________________________________________________|
float Float_Div;            //浮点数
u16 DIV_Mantissa,           //整数部分
u16 DIV_Fraction,           //小数部分
u16 BRR;                    //最终存入寄存器的数值
u32 BoundRate;              //波特率设置
BoundRate    = 9600;
Float_Div    = (float)(72 * 1000 * 1000) / (BoundRate * 16);
DIV_Mantissa = Float_Div;	// 取整数部分
DIV_Fraction = (Float_Div - DIV_Mantissa)*16;   // 小数部分
/* 整合整数部分和小数部分 */
BRR          = (DIV_Mantissa << 4) + DIV_Fraction;
USART1->BRR  = BRR;

//72MHz@9600 = 1D4C



/*******************************************************************************
        => USART_SR_状态寄存器
*******************************************************************************/
|_________________________________________________________|
| 9   | 8   | 7   | 6  | 5    | 4    | 3   | 2  | 1  | 0  |
| CTS | LBD | TXE | TC | RXNE | IDLE | ORE | NE | FE | PE |
|_____|_____|_____|____|______|______|_____|____|____|____|
CTS[9]          //CTS标志
                //如果设置了“CTSE”位， 当nCTS输入变化状态时， 该位被硬件置“1”。 由软件清“0”
                //（向该位写“0”）， 如果USART_CR3中的“CTSE”为“1”， 则产生中断
    0           //nCTS状态线上没有变化
    1           //nCTS状态线上发生变化
___________________________________________________________
TXE[7]          //发送数据寄存器空(Transmit data register empty)
                //当TDR寄存器中的数据被硬件转移到移位寄存器的时候，该位由硬件置“1”。
                //如果USART_CR1寄存器中的“TXEIE=1”，则产生中断。 对USART_DR寄存器写操作，该位清零。
    0           //数据还没有被转移到移位寄存器中
    1           //数据已经被转移到移位寄存器中
                ！注意：单缓冲器传输中使用该位。
___________________________________________________________
TC[6]           //发送完成(Transmission complete)
                //当包含有数据的一帧发送完成后，并且“TXE=1”时， 由硬件将该位置“1”。
                //如果USART_CR1中的“TCIE=1”，则产生中断。 由软件序列清除该位（先读
                //USART_SR, 然后写入USART_DR）. TC位也可以通过写“0”来清除，只有在多
                //缓冲通讯中才推荐这种清除程序。
    0           //发送未完成
    1           //发送完成
___________________________________________________________
RXNE[5]         //读数据寄存器非空(Read data register not empty)
                //当RDR移位寄存器中的数据被转移到USART_DR寄存器中，该被硬件置“1”。
                //如果USART_CR1寄存器中的“RXNEIE=1”，则产生中断。 对USART_DR的
                //读操作可以将该清“0”。 RXNE位也可以通过写入“0”来清除， 只有在多缓存
                //通信中才推荐这种清除程序的方式
    0           //数据没有到
    1           //收到数据， 可以读出
___________________________________________________________
IDLE[4]         //监测到总线空闲(IDLE line detected)
                //当监测到总线空闲时，该位被硬件置“1”。 如果USART_CR1中的“IDLEIE=1”，
                //则产生中断。 由软件序列清除该位（先读USART_SR，然后读USART_DR）
    0           //没有检测到空闲总线
    1           //检测到空闲总线
！IDLE位不会再次被置高，直到RXNE位被置起（即又检测到一次空闲总线）
___________________________________________________________
ORE[3]          //过载错误（Overrun error）
                //当RXNE仍然是“1”的时候，当前被接收在移位寄存器中的数据，需要传送至RDR寄存器
                //时， 硬件将该位置“1”。 如果USART_CR1中的“RXNEIE=1”的话，则产生中断。
                //由软件序列将其清零（先读USART_SR, 再读USART_DR）
    0           //没有过载错误
    1           //检测到过载错误
！该位被置位时， RDR寄存器中的值不会丢失，但是移位寄存器中的数据会被覆盖。
如果设置了“EIE”位， 在多缓冲器通信模式下，ORE标志置位会产生中断。
___________________________________________________________
NE[2]           //噪声错误标志（Noise error flag）
                //在接收到的帧检测到噪音时，由硬件对该位置位。 由软件序列对其清零（
                //先读USART_SR， 再读USART_DR）
    0           //没有检测到噪声
    1           //检测到噪声
！该位不会产生中断， 因为它和RXNE一起出现， 硬件会在设置RXNE标志时产生中断。
在多缓冲区通信模式下， 如果设置了“EIE=1”，则设置NE标志时会产生中断。
___________________________________________________________
FE[1]           //帧错误（Framing error）
                //当检测到同步错位， 过多的噪声或者检测到断开符，该位被硬件置“1”。
                //由软件序列将其清零（先读USART_SR， 再读USART_DR）
    0           //没有检测帧错误
    1           //检测到帧错误或者break符
！该位不会产生中断，因为它和RXNE一起出现，硬件会在设置RXNE标志时产生中断。
如果当前传输的数据即产生了帧错误，又产生了过载错误，硬件是会继续该数据传输，
并且只设置ORE标志位。 在多缓冲区通信模式下，如果设置了EIE位，则设置FE标志时会产生中断。
___________________________________________________________
PE[0]           //校验错误（Parity error）
                //在接收模式下，如果出现奇偶校验错误，硬件对该位置“1”。 由软件序列对其清零（
                //先读USART_SR， 再读USART_DR）。 在清除PE位之前，软件必须等待RXNE标志
                //位被置“1”。 如果USART_CR1中的“PEIE=1”， 则产生中断。
    0           //没有奇偶错误
    1           //奇偶校验错误



/*******************************************************************************
        => USART_BRR_波特率寄存器
*******************************************************************************/
|________________________________________|
| 15-4               | 3-0               |
| DIV_Mantissa[11:0] | DIV_Fraction[3:0] |
|____________________|___________________|
DIV_Mantissa[15:4]  //USARTDIV整数部分
                    //这12位定义了USART分频器除法因了（USARTDIV）的整数部分
___________________________________________________________
DIV_Fraction[3:0]   //USARTDIV小数部分
                    //这3位定义了USART分频器除法因了（USARTDIV）的小数部分




/*******************************************************************************
  函数名称: usart1_setup()
  输入参数: 无
  输出参数: 无
  函数功能: USART1初始化设置 72MHz@115200 1N8
*******************************************************************************/
void usart1_setup(void)
{
        GPIOA_CLOCK_ENABLE();
        USART1_CLOCK_ENABLE();
	//TX(PA.09)复用推挽输出(50MHz); RX(PA.10)浮空输入
	GPIOA->CRH  &= (uint32_t)(0xFFFFF00F);
	GPIOA->CRH  |= (uint32_t)(0x000004B0);
	USART1->CR1 |= BIT_13;                  //USART模块使能
	USART1->CR1 &= ~BIT_12;                 //1个起始位, 8个数据位
	USART1->CR2 &= ~(BIT_13 + BIT_12);      //1个停止位(bit13=0, bit12=0)
	USART1->CR1 |= BIT_03 + BIT_02;         //发送使能 | 接收使能 
	USART1->BRR  = 0x0271;                  //72MHz@115200 			
}
/*******************************************************************************
  函数名称: main()
  输入参数: 无
  输出参数: 无
  函数功能: 以'A'为起始， 发送发送30个字符到USART的DR寄存器
*******************************************************************************/
int main(void)
{
        int i, data,;
        data = 'A';
        for (i = 0; i < 30; i++) {
	        USART1->DR = data;
	        data++;
	        //等待数据发送完成标志置“1”
	        while ((USART1->SR & (1 << 6) == 0);
        }
        return 0;
}
