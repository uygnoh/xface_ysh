ARM Cortex-M3内核永远从0x00000000启动，STM32在这里取了个巧，
它在0x00000000开始的一段地址空间是虚拟的，可以通过设置BOOT[1:0]管脚状态，
在启动时动态将另外一段地址空间映射到这部分上面去。

当arm复位之后，读到的0x00000000内容已经是被STM32重映射之后的了，
所以它可以system boot模式启动、还是Flash启动、还是内存启动。
如果是正常的Flash启动，则会将0x08000000映射到0x00000000，
因此arm以为自己还在操作0x00000000，其实是在操作0x08000000，
已经被STM32偷梁换柱了，当然，此时直接操作0x08000000也是可以的，二者完全等价。




############################################################
### % https://eclipse-embed-cdt.github.io/tutorials/blinky-arm/
############################################################
/* % Memories definition */
% 定义了一个RO存储和一个RAM存储，地址空间和Soc硬件手册一致
MEMORY
{
    RAM     (xrw)   : ORIGIN = 0x20000000,  LENGTH = 20K
    FLASH   (rx)    : ORIGIN = 0x08000000,  LENGTH = 64K
}





############################################################
### % data段
############################################################
.data : ALIGN(4)
{
    FILL(0xFF)
    /* This is used by the startup code to initialise the .data section */
    _sdata = . ;            /* STM specific definition */
    __data_start__ = . ;
    *(.data_begin .data_begin.*)

    *(.data .data.*)

    *(.data_end .data_end.*)
    . = ALIGN(4);

    /* This is used by the startup code to initialise the .data section */
    _edata = . ;            /* STM specific definition */
    __data_end__ = . ;

} >RAM AT>FLASH
上面的脚本定义了一个段叫data，里面包含了所有Objects文件中的data段，
不同文件中定义的全局变量和静态变量全部汇聚到了这一个段中。里面还定义了
一些label，这些label其实就是映像文件中各个数据或者段的地址(Address
/Offset)，主要用于给程序提供这些地址信息，让程序对映像文件中的这些资
源进行处理。你像这个data段，需要在startup初始化阶段将data段从FLASH
 复制到RAM中。既然要复制，那程序就需要知道源地址，目的地址以及要复制的
 长度。开始地址就是data段在整个映像的Offset地址，在这里起了个名字叫
 data_start ，结束地址叫data_end ，知道了开始地址和结束地址也就知
 道了信息源的所有信息(开始地址、结束地址、长度)。那目的地址在哪？别着
 急，目的地址的设置是使用了 AT 这个指令，意思就是告诉链接器这段内容是
 需要搬运的，下载地址和运行地址是不一样的。

% >RAM AT>FLASH
上面的指令意思是这个段的实际链接地址是 RAM 这个Memory Region中定义
的0x20000000开始的地方，根据内容依次往后放。但现在在映像中实际的位置
是FLASH 这个Memory Region中定义的0x08000000开始的地方开始放置的，
根据内容依次顺序放置的。在FLASH中这个内存域中，前面可能已经放置了启动
代码和其他代码段。使用了这个说明后，产生的效果是在映像文件中是连续存放
的内容(以0x08000000作为基地址)，但是data段实际的链接地址都是以0x20
000000作为基地址的。比如你定义了一个全局变量 int A = 88;，它实际运
行的地址在0x20000010这个地址，但是在最开始整个映像都在FLASH中，它可
能在映像中的实际存在位置为0x08000100。在程序最开始(还没用到这个全局
变量之前)的代码中需要将data段整体地从FLASH中移动到RAM中。如果不用AT
 指令的话，映像文件会直接按照链接地址生成，就意味着映像文件会很大，因
 为代码段0x08000000和数据段0x20000000之间有一个Gap，这个Gap需要使
 用大量的0来填充。想想都觉着这个映像很大。实际我们产生映像文件时是要同
 时考虑装载视图和运行视图这两个方面的。 




















