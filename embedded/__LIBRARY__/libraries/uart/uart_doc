/*******************************************************************************
        => 8051-uart 查询方式发送一帧数据
*******************************************************************************/
//UART初始化 11.0592MHz@4800bps
//_________________________________________________________
void uart_init(void)
{
        PCON &= 0x7F;   //波特率不倍速
        SCON  = 0x50;   //8位数据，可变波特率
        TMOD &= 0x0F;   //清除定时器“1”模式位
        TMOD |= 0x20;   //设定定时器1为8位自动重装方式
        TL1   = 0xFA;   //设定定时初值
        TH1   = 0xFA;   //设定定时器重装值
        ET1   = 0;      //禁止定时器1中断
        ES    = 0;      //关闭串行口中断
        TR1   = 1;      //启动定时器1
}

//发送一帧数据
//1位起始位， 1位停止位， 8位数据位， 共10位数据
//_________________________________________________________
void uart_write(uint8_t dat)
{
        SBUF = dat;     //
        while (!TI);    //等待“TI=1”
        TI = 0;         //清除TI状态标志位
}

//发送一串数据
//_________________________________________________________
void send_string(uint8_t *pstr)
{
        while (*pstr != '\0') {
                uart_write(*pstr++);
        }
}

//_________________________________________________________
int main(void)
{
        while (1) {
                //uart_write('8');
                //uart_write('\r');
                //uart_write('\n');
                //delay_ms(1000);
                send_string("Hello world!");
        }
}



/*******************************************************************************
        => 8051-uart 中断方式发送一帧数据
*******************************************************************************/
//UART初始化 11.0592MHz@4800bps
//1位起始位， 1位停止位， 8位数据位， 共10位数据
//_________________________________________________________
void uart_init(void)
{
        PCON &= 0x7F;   //波特率不倍速
        SCON  = 0x50;   //8位数据，可变波特率
        TMOD &= 0x0F;   //清除定时器“1”模式位
        TMOD |= 0x20;   //设定定时器1为8位自动重装方式
        TL1   = 0xFD;   //设定定时初值
        TH1   = 0xFD;   //设定定时器重装值
        ET1   = 0;      //禁止定时器1中断
        ES    = 1;      //打开串行口中断
        TR1   = 1;      //启动定时器1
        EA    = 1;      //打开总中断
}

// 串口中断服务程序
//_________________________________________________________
void UART_ISR(void) interrupt 4
{
        if (TI) {
                TI = 0;
        }
}

//_________________________________________________________
int main(void)
{
        uart_init();
        while (1) {
                SBUF = 0x88;
                delay_ms(2000);
        }
}


// printf重定向(基于Keil IDE) C51 Development Tools
//_________________________________________________________
#include <stdio.h>
char putchar(char c)
{
        uart_write(c);
        return(c);
}
printf("Hello world!\r\n");



/*******************************************************************************
        => 8051-uart 串行口从上位机接收一帧数据的编程实现方法
*******************************************************************************/
uint8_t rx_dat;
uint8_t tx_dat;
uint8_t rx_flag = 0;

 
//UART初始化 11.0592MHz@4800bps
//1位起始位， 1位停止位， 8位数据位， 共10位数据
//_________________________________________________________
void uart_init(void)
{
        PCON &= 0x7F;   //波特率不倍速
        SCON  = 0x50;   //8位数据，可变波特率
        TMOD &= 0x0F;   //清除定时器“1”模式位
        TMOD |= 0x20;   //设定定时器1为8位自动重装方式
        TL1   = 0xFA;   //设定定时初值
        TH1   = 0xFA;   //设定定时器重装值
        ET1   = 0;      //禁止定时器1中断
        ES    = 1;      //串行口中断打开
        EA    = 1;      //打开中断总开关
        TR1   = 1;      //启动定时器1
}

//发送一帧数据
//_________________________________________________________
void uart_write(uint8_t dat)
{
        SBUF = dat;
        while (!TI);
        TI = 0;
}

//发送一串数据
//_________________________________________________________
void send_string(uint8_t *pstr)
{
        while (*pstr != '\0') {
                uart_write(*pstr++);
        }
}




/********************************** 中断方式 **********************************/
//串行口中断服务程序
//UART从上位机接收到一帧数据后, 然后再对该接收到的数据加“1”处理, 最后UART再用串口发送出去
//__________________________________________________________________________
void UART_IST(void) interrupt 4
{
        if (RI) {
                RI = 0;
                rx_dat = SBUF;
                //使用中断方式话，使用下面这两条语句
                rx_dat = rx_dat + 1;
                SBUF   = rx_dat;
        }
        if (TI) {
                TI = 0;
        }
}
//使用中断方式
//_________________________________________________________
int main(void)
{
    while (1) {   
    }
}



/********************************** 查询方式 **********************************/
//串行口中断服务程序
//__________________________________________________________________________
void UART_IST(void) interrupt 4
{
        if (RI) {
                RI = 0;
                rx_dat = SBUF;
                //使用查询方式的话，使用rx_flag = 1;
                rx_flag = 1;
        }
        if (TI) {
                TI = 0;
        }
}

//使用查询方式
//使用查询方式，把接收到的数据加一， 并发送出去
//UART从上位机接收到一帧数据后, 然后再对该接收到的数据加“1”处理, 最后UART再用串口发送出去
//__________________________________________________________________________
int main(void)
{
        while (1) {   
                if (rx_flag == 1) {
                        rx_flag = 0;
                        rx_dat = rx_dat + 1;
                        uart_write(rx_dat);
                }
        }
}



/*******************************************************************************
        => 8051-uart 查询方式控制LED（ON OFF）
*******************************************************************************/
//上位机发送 0x01, 打开LED
//上位机发送 0x00, 关闭LED

//串行口中断服务程序//使用查询方式的话，使用rx_flag = 1;
//_________________________________________________________
void UART_IST(void) interrupt 4
{
        if (RI) {
                RI = 0;
                rx_dat = SBUF;
                rx_flag = 1;
        }
        if (TI) {
                TI = 0;
        }
}

//使用查询方式
//_________________________________________________________
int main(void)
{
        while (1) {   
                if (rx_flag == 1) {
                        rx_flag = 0;
                        switch (rx_dat) {
                        case 0x00: LED = 1; //LED灭
                        case 0x01: LED = 0; //LED亮
                        default: break;
                        }
                }
        }
}



/*******************************************************************************
        => 单片机串行口从上位机接收一串数据的编程实现
        => 只能接收回定长度的数据( 只接收8个字节数据 )
*******************************************************************************/
uint8_t rx_buf[8];      //接收缓冲区，接收到的数据放到此数组中
uint8_t rx_flag;        //接收到8字节数据，rx_flag = 1


//UART初始化 11.0592MHz@4800bps
//1位起始位， 1位停止位， 8位数据位， 共10位数据
//_________________________________________________________
void uart_init(void)
{
        PCON &= 0x7F;   //波特率不倍速
        SCON  = 0x50;   //8位数据，可变波特率
        TMOD &= 0x0F;   //清除定时器“1”模式位
        TMOD |= 0x20;   //设定定时器1为8位自动重装方式
        TL1   = 0xFA;   //设定定时初值
        TH1   = 0xFA;   //设定定时器重装值
        ET1   = 0;      //禁止定时器1中断
        ES    = 1;      //串行口中断打开
        EA    = 1;      //打开中断总开关
        TR1   = 1;      //启动定时器1
}

//串行口中断服务程序
//_________________________________________________________
void UART_IST(void) interrupt 4
{
        static uint8_t rx_cnt = 0;
        if (RI) {
                RI = 0;
                rx_bur[rx_cnt] = SBUF;
                rx_cnt++;
                if (rx_cnt == 8) {
                        rx_flag = 1;
                        rx_cnt  = 0;
                }
        }
}

//发送接收到的“8字节数据”
//_________________________________________________________
int main(void)
{
        printf("Wait for Serial communication Test Start ...");
        printf("Please Send a String of Data:");
        while (1) {
                rx_flag = 0;
                send_string(rx_buf);
        }
}



/*******************************************************************************
        => 单片机串行口从上位机接收一串数据的编程实现
        => 可以接收不定长度的数据
        => 增加一个数据的结束符“0x0D”来实现一串数据的结束
*******************************************************************************/
#define RX_BUF_SIZE  10          //定义接收数据数组大小
uint8_t rx_buf[RX_BUF_SIZE];     //接收缓冲区，接收到的数据放到此数组中
uint8_t rx_flag;                //接收数据完成状态标志位
uint8_t rx_len;                 //接收到字节数据实际的长度


//串行口中断服务程序
//_________________________________________________________
void UART_IST(void) interrupt 4
{
        static uint8_t rx_cnt = 0;
        uint8_t tmp;

        //处理接收到的数据
        if (RI) {
                RI = 0;
                tmp = SBUF;
                
                //如果接收的不是回车符“0x0D”, 则继续接收数据
                //_________________________________________________________
                if (tmp != 0x0D) {
                        rx_buf[rx_cnt] = tmp;
                        rx_cnt++;
                        if (rx_cnt > RX_BUF_SIZE) {
                                rx_cnt = RX_BUF_SIZE;
                        }
                }
                //如果接收的是回车符“0x0D”, 则说明接收数据已完成
                //_________________________________________________________
                else {
                        //接收数据已完成， 通知主程序处理，把标志位置“1”
                        rx_flag = 1;
                        //把接收到数据的长度给“rx_len”
                        rx_len = rx_cnt;
                        //清除rx_cnt， 方便下一次数据的接收
                        rx_cnt = 0;
                }
        }
}

//MCS8051向上位机发送接收到的数据
//_________________________________________________________
int main(void)
{
        uint8_t i;
        printf("Wait for Serial communication Test Start ...\r\n");
        printf("Please Send a String of Data:\r\n");
        while (1) {
                if (rx_flag == 1) {
                        rx_flag = 0;
                        for (i = 0; i < rx_len; i++) {
                                uart_write(rx_buf[i]);
                        }
                }
        }
}



/*******************************************************************************
        => 单片机串行口定时中断实现超时接收一串数据的编程实现
        => 上位机向下位机发送一串位数据，也没有固定长度，也没有结束标志符
           1)根据接收时间来判断一帧数据的长度
           2)如果接收时间大于一定的时间还没有新的数据来
           3)那么就表示这一帧数据接收完成
*******************************************************************************/
#define RX_BUF_SIZE 10           //定义接收数据缓冲区数组个数
#define RX_TIMEOUT 3             //定义接收超时的最大时间为3个毫秒

uint8_t start_soft_timer = 0;   //定义软件定时器
uint8_t rx_soft_timer_cnt;      //每接收到一帧数据后，就开始计时
uint8_t rx_flag;                //定义一包数据接收完成标志
uint8_t rx_buf[RX_BUF_SIZE];    //定义一个接收缓冲区数据大小
uint8_t rx_dat_index = 0;       //定义接收缓冲区数组索引值


//11.0592MHz@9600bps
//1位起始位， 1位停止位， 8位数据位， 共10位数据
//使用定时器1，做为串行口的波特率发生器
//_________________________________________________________
void uart_init(void)
{
        PCON &= 0x7F;   //波特率不倍速
        SCON  = 0x50;   //8位数据，可变波特率
        TMOD &= 0x0F;   //清除定时器“1”模式位
        TMOD |= 0x20;   //设定定时器1为8位自动重装方式
        TL1   = 0xFD;   //设定定时初值
        TH1   = 0xFD;   //设定定时器重装值
        ET1   = 0;      //禁止定时器1中断
        ES    = 1;      //串行口中断打开
        TR1   = 1;      //启动定时器1
}

//串行口中断服务程序
//_________________________________________________________
void UART_ISR(void) interrupt 4
{
        if (RI) {
                RI = 0; 
                // @ 每接收一帧数据时，打开软件计数器，去计数
                start_soft_timer = 1;
                
                //如果rx_dat_index的值小于数据缓冲区的最大值
                //把接收到的数据放入rx_buf[]数据缓冲区中
                if (rx_dat_index < RX_BUF_SIZE) {
                        rx_buf[rx_dat_index] = SBUF;
                        rx_dat_index++;
                } else {
                //否则，超过了缓冲区中最大的值，就不在接收了
                        rx_dat_index = RX_BUF_SIZE;
                }

                // @ 每接收一帧数据，记得把软件定时计数清零，相当于喂狗
                // @ 虽然我们在这边把它清零了，但是在定时中断里面会不断的累加
                rx_soft_timer_cnt = 0;
        }
        if (TI) {
                TI = 0;
        }
}

//1ms @11.05926MHz
//定时器0，16位的定时方式
//_________________________________________________________
void timer0_init(void)
{
        TMOD &= 0xF0;   //设置定时器模式
        TMOD |= 0x01;   //设置定时器模式
        TL0   = 0x66;   //设置定时初值
        TH0   = 0xFC;   //设置定时初值
        TF0   = 0;      //清除TF0标志
        ET0   = 1;      //打开定时器0中断
        TR0   = 1;      //定时器0开始计时
}

//定时器0中断服务程序
//_________________________________________________________
void TIMER0_ISR(void) interrupt 1
{
        TR0   = 0;      //关闭定时器0
        // @ 如果打开了软件定时器
        if (start_soft_timer == 1) {
                // 1 @ 累加定时时间计数器
                rx_soft_timer_cnt++;
                // 2 @ 判断定时时间是否超过了设定的的最大阈值，
                //   @ 如果超过了，则说明等待一段时间后没有新的数据到来
                //   @ 我们判断一包数据接收完成
                if (rx_soft_timer_cnt > RX_TIMEOUT) {
                        //软件定时器清零
                        rx_soft_timer_cnt = 0;
                        //数据缓冲区计数个清零
                        rx_dat_index = 0;
                        //接收标志置“1”，表示这一包数据接收完成
                        rx_flag = 1;
                }
        }
        TL0   = 0x66;   //设置定时器0初值
        TH0   = 0xFC;   //设置定时器0初值
        TR0   = 1;      //打开定时器0
}

//发送一帧数据
//_________________________________________________________
void uart_write(uint8_t dat)
{
        SBUF = dat;
        while(!TI);
        TI = 0;
}

//发送一串数据
//_________________________________________________________
void send_string(uint8_t *pstr)
{
        while (*pstr != '\0')
                uart_write(*pstr++);
}

//清除数据缓冲区中的所有数据
//_________________________________________________________
void clr_rx_buf(uint8_t *pbuf)
{
        uint8_t i;
        for (i = 0; i < RX_BUF_SIZE; i++)
                rx_buf[i] = 0;
}


int main(void)
{
        timer0_init();
        uart_init();
        EA = 1; //打开中断总开关
        printf("Wait for Serial communication Test Start ...\r\n");
        printf("Please Send a String of Data:\r\n");
        while (1) {   
                if (rx_flag) {                  //如果接收到一包数据了
                        rx_flag = 0;            //清除接收状态标志位
                        start_soft_timer = 0;   //关闭软件定时器
                        send_string(rx_buf);    //处理数据接收到的数据
                        clr_rx_buf(rx_buf);     //清除缓冲区
                }
        }
}



/*******************************************************************************
        => 判读数据帧头来接收一串数据的串口通信程序编写
           @ [55 AA 55]为帧头 （只接收带有[55 AA 55]为帧头的数据）
           @ [01 02]命令1，LED亮   |  [02 01]命令2，LED灭
           
        => 数据包编码格式（帧头码 + 命令码）
           @ 55 AA 55 01 02  （LED亮）
           @ 55 AA 55 02 01  （LED灭）
*******************************************************************************/
#define RX_BUF_SIZE  10         //定义接收数据缓冲区数组个数
#define RX_TIMEOUT 3            //定义接收超时的最大时间为3个毫秒

uint8_t start_soft_timer = 0;   //定义软件定时器
uint8_t rx_soft_timer_cnt;      //每接收到一帧数据后，就开始计时
uint8_t rx_flag;                //定义一包数据接收完成标志
uint8_t rx_buf[RX_BUF_SIZE];    //定义一个接收缓冲区
uint8_t rx_dat_index = 0;       //定义接收数据缓冲区数组的索引值


// 11.0592MHz@9600bps
//1位起始位， 1位停止位， 8位数据位， 共10位数据
//使用定时器1，做为串行口的波特率发生器
//_________________________________________________________
void uart_init(void)
{
        PCON &= 0x7F;   //波特率不倍速
        SCON  = 0x50;   //8位数据，可变波特率
        TMOD &= 0x0F;   //清除定时器“1”模式位
        TMOD |= 0x20;   //设定定时器1为8位自动重装方式
        TL1   = 0xFD;   //设定定时初值
        TH1   = 0xFD;   //设定定时器重装值
        ET1   = 0;      //禁止定时器1中断
        ES    = 1;      //串行口中断打开
        TR1   = 1;      //启动定时器1
}

//串行口中断服务程序
//_________________________________________________________
void UART_ISR(void) interrupt 4
{
        if (RI) {
                RI = 0;
                
                // @ 每接收一帧数据时，打开软件计数器，去计数
                start_soft_timer = 1;

                //如果rx_dat_index的值小于数据缓冲区的最大值
                //把接收到的数据放入rx_buf[]数据缓冲区中
                if (rx_dat_index < RX_BUF_SIZE) {
                        // @ 接收到数据存储到数据缓冲区，注意缓冲区的大小范围
                        rx_buf[rx_dat_index] = SBUF;
                        rx_dat_index++;
                } else {
                //否则，超过了缓冲区中最大的值，就不在接收了
                        rx_dat_index = RX_BUF_SIZE;
                }

                // @ 每接收一帧数据，记得把软件定时计数清零，相当于喂狗
                // @ 虽然我们在这边把它清零了，但是在定时中断里面会不断的累加
                rx_soft_timer_cnt = 0;
        }
        if (TI) {
                TI = 0;
        }
}


//定时器0，16位的定时方式
//1ms @11.05926MHz
//_________________________________________________________
void timer0_init(void)
{
        TMOD &= 0xF0;   //设置定时器模式
        TMOD |= 0x01;   //设置定时器模式
        TL0   = 0x66;   //设置定时初值
        TH0   = 0xFC;   //设置定时初值
        TF0   = 0;      //清除TF0标志
        ET0   = 1;      //打开定时器0中断
        TR0   = 1;      //定时器0开始计时
}

//定时器0中断服务程序
//_________________________________________________________
void TIMER0_ISR(void) interrupt 1
{
        TR0 = 0;      //关闭定时器0
        //如果打开了软件定时器
        if (start_soft_timer == 1) { 
                // 1 @ 累加定时时间计数器
                rx_soft_timer_cnt++;
                // 2 @ 判断定时时间是否超过了设定的的最大阈值，
                //   @ 如果超过了，则说明等待一段时间后没有新的数据到来
                //   @ 我们判断一包数据接收完成
                if (rx_soft_timer_cnt > RX_TIMEOUT) {
                        //软件定时器清零
                        rx_soft_timer_cnt = 0;
                        //接收标志置“1”，表示这一包数据接收完成
                        rx_flag = 1;
                }
        }
        TL0   = 0x66;   //设置定时器0初值
        TH0   = 0xFC;   //设置定时器0初值
        TR0   = 1;      //打开定时器0
}

//处理接收到数据的帧头和后面两字节数据
//_________________________________________________________
void uart_service(uint8_t *pbuf)
{
        uint8_t index;
        if (rx_flag) {
                rx_flag = 0;
                start_soft_timer = 0;   //关闭软件定时器
                send_string(pbuf);      //处理数据
                //判断接收到的数据是不是[55 AA 55 01 02] 或者是 [55 AA 55 02 01]
                while (rx_dat_index >= 5) && (index <= rx_dat_index)) {
                        if ((rx_buf[index + 0] == 0x55)          && \
                            (rx_buf[index + 1] == 0xAA)          && \
                            (rx_buf[index + 2] == 0x55)) {      
                                if ((rx_buf[index + 3] == 0x01)  && \
                                    (rx_buf[index + 4] == 0x02)) {
                                        LED = ON;
                                }
                                if ((rx_buf[index + 3] == 0x02)  && \
                                    (rx_buf[index + 4] == 0x01)) {
                                        LED = OFF;
                                }
                                //如果查找成功，退出while循环
                                break;
                        }
                        index++;
                }

                //清除数据缓冲区
                clr_rx_buf(pbuf);     
                //数据缓冲区计数个数
                rx_dat_index = 0;
        }
}

//_________________________________________________________
int main(void)
{
        timer0_init();
        uart_init();
        EA = 1; //打开中断总开关
        printf("Wait for Serial communication Test Start ...\r\n");
        printf("Please Send a String of Data:\r\n");
        while (1) {
                uart_service(rx_buf);
        }
}



/*******************************************************************************
        => 串口中断中即时解析数据帧头的通信程序(6Bytes), 可以进行实时处理
           +________________+
           |  [0xAA 0x55]   | ->(帧头占2个字节) 
           |  [0x01]        | ->(数据类型占1个字节) 
           |  [0x22 0x33]   | ->(2字节数据)
           |  [0x0D]        | ->(帧尾)
           |________________|
        => 0xAA 0x55 0x01 0x22 0x33 0x0D
*******************************************************************************/

#define RX_BUF_SIZE  10         //定义接收数据缓冲区数组个数
#define RX_TIMEOUT 3            //定义接收数据最大超时时间为3个毫秒

uint8_t start_soft_timer = 0;   //定义软件定时器
uint8_t rx_soft_timer_cnt;      //每接收到一帧数据后，就开始计时
uint8_t rx_flag;                //定义一包数据接收完成标志
uint8_t rx_buf[RX_BUF_SIZE];    //定义一个接收缓冲区
uint8_t rx_counter = 0;         //定义接收缓冲区的数据计数器
uint8_t machine_step = 0;       //定义一个状态机步骤变量

uint16_t led_data;              //定义LED亮度
uint16_t beep_data;             //定义蜂鸣器响的时间
uint16_t led_cnt;
uint16_t beep_cnt;

//串行口中断服务程序
//使用状态机方式 ->machine_step
=> 0xAA 0x55 0x01 0x22 0x33 0x0D
//_________________________________________________________
void UART_ISR(void) interrupt 4
{
        //接收到数据中断处理
        //_________________________________________________________
        if (RI) {
                RI = 0;
                switch (machine_step) {
                case 0: 
                        rx_buf[0] = SBUF;       //先把数据接收过来
                        if (rx_buf[0] == 0xAA) {//判断是不是帧头的第一个字符
                                machine_step = 1;//切换到下一个状态
                        } else {                //不是“0xAA”，把它清零
                                machine_step = 0;
                        }
                        break;
                case 1: 
                        rx_buf[1] = SBUF;         //先把数据接收过来
                        if (rx_buf[1] == 0x55) {  //判断是不是帧头的第二个字符
                                machine_step = 2; //切换到下一个状态
                                rx_counter = 2; //表示已经接收到“2帧数据了”0xAA 0x55
                        } else {
                                machine_step = 0;
                        }
                        break;
                case 2:                       
                        rx_buf[rx_counter] = SBUF; 
                        rx_counter++;            //“0xAA 0x55 0x01 0x22 0x33”//
                        if (rx_counter > 4) {    // @ 表示“0x01 0x22 0x33”接收完成
                                machine_step = 3;  // @ 切换到下一个状态
                        } else {                   // @ 否则继续接收数据
                                machine_step = 2;
                        }
                        break;
                case 3: 
                        rx_buf[rx_counter] = SBUF;       //接收到“0x0D”
                        if (rx_buf[rx_counter] == 0x0D) {//判断是不是接收到了帧尾?
                                switch (rx_buf[2]) {
                                case 0x00:          //如果rx_buf[2]=0x00(功能码)
                                        led_data = rx_buf[3];
                                        led_data = led_data << 8;
                                        led_data = led_data + rx_buf[4];
                                        //led_data=LED点亮时间
                                        led_cnt = 0;
                                        break;
                                case 0x01:          //如果rx_buf[2]=0x01(功能码)
                                        deep_data = rx_buf[3];
                                        deep_data = deep_data << 8;
                                        deep_data = deep_data + rx_buf[4];
                                        //deep_data=蜂鸣器响的时间
                                        beep_cnt = deep_data;
                                        break;
                                default: 
                                        break;
                                }
                                machine_step = 0;//清除状态机数据
                                rx_counter   = 0;//清除数据缓冲区个数
                                rx_flag      = 1;//接收完成一包数据，标志位置“1”
                        }
                        break;
                default: break;     
                }
        }
        //发送数据中断处理
        //_________________________________________________________
        if (TI) {
                TI = 0;
        }
}

// 11.0592MHz@9600bp
//1位起始位， 1位停止位， 8位数据位， 共10位数据
//使用定时器1，做为串行口的波特率发生器
//_________________________________________________________
void uart_init(void)
{
        PCON &= 0x7F;   //波特率不倍速
        SCON  = 0x50;   //8位数据，可变波特率
        TMOD &= 0x0F;   //清除定时器“1”模式位
        TMOD |= 0x20;   //设定定时器1为8位自动重装方式
        TL1   = 0xFD;   //设定定时初值
        TH1   = 0xFD;   //设定定时器重装值
        ET1   = 0;      //禁止定时器1中断
        ES    = 1;      //串行口中断打开
        TR1   = 1;      //启动定时器1
}

//定时器0， 16位的定时方式
//11.05926MHz@1MS （定时器0，1毫秒定时）
//_________________________________________________________
void timer0_init(void)
{
        TMOD &= 0xF0;   //设置定时器模式
        TMOD |= 0x01;   //设置定时器模式
        TL0   = 0x66;   //设置定时初值
        TH0   = 0xFC;   //设置定时初值
        TF0   = 0;      //清除TF0标志
        ET0   = 1;      //打开定时器0中断
        TR0   = 1;      //定时器0开始计时
}

//定时器0中断服务程序
//_________________________________________________________
void TIMER0_ISR(void) interrupt 1
{
        TR0   = 0;      //关闭定时器0
        if (led_cnt < led_data) {
                led_cnt++;
                LED = ON;
        } else {
                LED = OFF;
        }
        if (beep_cnt != 0) {
                beep_cnt--;
                BEEP = ~BEEP;
        }
        TL0   = 0x66;   //设置定时器0初值
        TH0   = 0xFC;   //设置定时器0初值
        TR0   = 1;      //打开定时器0
}

//发送一帧数据
//_________________________________________________________
void uart_write(uint8_t dat)
{
        SBUF = dat;
        while(!TI);
                TI = 0;
}

//发送一串数据
//_________________________________________________________
void send_string(uint8_t *pstr)
{
        while (*pstr != '\0')
                uart_write(*pstr++);
}

//清除数据缓冲区中的所有数据
//_________________________________________________________
void clr_rx_buf(uint8_t *pbuf)
{
    uint8_t i;
    for (i = 0; i < RX_BUF_SIZE; i++)
        rx_buf[i] = 0;
}

//_________________________________________________________
int main(void)
{
        timer0_init();
        uart_init();
        EA = 1;         //打开中断总开关
        printf("Wait for Serial communication Test Start ...\r\n");
        printf("Please Send a String of Data:\r\n");
        while (1) {
                //如果接收到一包数据，回传到上位机
                if (rx_flag == 1) {
                        rx_flag = 0;
                        send_sting(rx_buf);
                }
        }
}



/*******************************************************************************
应用串口中断 + 定时器中断实现超时检测的串口数据接收方法
______________________________________________


CRC校验码由发送设备计算，并添加到发送信息帧的尾部。 接收设备接收到信息后再重新计算CRC校验码。
然后接收设备再比较计算出的CRC校验码和接收到的CRC校验码。 如果不符，发送错误应答。 接收设备再
进行处理。
___________________________________________________________________________


        => 串口超时接收 + CRC16校验  https://blog.csdn.net/weixin_41542513/
        
        
        => ip33.com CRC（循环冗余校验）在线计算
        ________________________________________________________________
        [01 01 20 20]                   //需要校验的数据 ->Hex
        CRC-16/MODBUS   x16+x15+x2+1    //参数模型 NAME:
        0x00   0x48                     //计算结果
        高位在左低位在右，使用时请注意高低位顺序！！！（高位在前， 低位在后）      
        ________________________________________________________________
        
        
        
        => 我们这里发送为： 0x01 0x02 0x20 0x20 0x48 0x00 （低位在前，高位在后）
        ________________________________________________________________
        [0x01]          ->地址信息(第一帧数据)， 代表从机地址
        [0x01]          ->数据类型(第二帧数据->控制LED灯)
        [0x20 0x20]     ->数据(第三帧数据，第四帧数据)
        [0x48 0x00]     ->CRC(Low字节低位 + High字节高位)
        ________________________________________________________________

*******************************************************************************/
#defind LOCAL_ADDRESS 0x01


#define RX_BUF_SIZE  10         //定义接收数据缓冲区数组个灵敏
#define RX_TIMEOUT 3            //定义接收数据超时最大时间为3个毫秒

uint8_t start_soft_timer = 0;   //启动软件定时器
uint8_t rx_soft_timer_cnt;      //每接收到一帧数据后，就开始计时
uint8_t rx_flag;                //定义一包数据接收完成标志
uint8_t rx_buf[RX_BUF_SIZE];    //定义一个接收缓冲区
uint8_t rx_dat_index = 0;       //定义接收缓冲区个数


// 11.0592MHz@9600bps
//1位起始位， 1位停止位， 8位数据位， 共10位数据
//使用定时器1，做为串行口的波特率发生器
//_________________________________________________________
void uart_init(void)
{
        PCON &= 0x7F;   //波特率不倍速
        SCON  = 0x50;   //8位数据，可变波特率
        TMOD &= 0x0F;   //清除定时器“1”模式位
        TMOD |= 0x20;   //设定定时器1为8位自动重装方式
        TL1   = 0xFD;   //设定定时初值
        TH1   = 0xFD;   //设定定时器重装值
        ET1   = 0;      //禁止定时器1中断
        ES    = 1;      //串行口中断打开
        TR1   = 1;      //启动定时器1
}

//串行口中断服务程序
//_________________________________________________________
void UART_ISR(void) interrupt 4
{
        if (RI) {
                RI = 0; 
                // 1 @ 每接收一帧数据时，打开软件计数器，去计数
                start_soft_timer = 1;
                //如果rx_dat_index的值小于数据缓冲区的最大值
                //把接收到的数据放入rx_buf[]数据缓冲区中
                if (rx_dat_index < RX_BUF_SIZE) {
                // 2 @ 接收到数据存储到数据缓冲区，注意缓冲区的大小范围
                        rx_buf[rx_dat_index] = SBUF;
                        rx_dat_index++;
                } else {
                //否则，超过了缓冲区中最大的值，就不在接收了
                        rx_dat_index = RX_BUF_SIZE;
                }

                // 3 @ 每接收一帧数据，记得把软件定时计数清零，相当于喂狗
                //   @ 虽然我们在这边把它清零了，但是在定时中断里面会不断的累加
                rx_soft_timer_cnt = 0;
        }
        
        if (TI) {
                TI = 0;
        }
}


//定时器0，16位的定时方式
// 11.05926MHz@1ms
//_________________________________________________________
void timer0_init(void)
{
    TMOD &= 0xF0;   //设置定时器模式
    TMOD |= 0x01;   //设置定时器模式
    TL0   = 0x66;   //设置定时初值
    TH0   = 0xFC;   //设置定时初值
    TF0   = 0;      //清除TF0标志
    ET0   = 1;      //打开定时器0中断
    TR0   = 1;      //定时器0开始计时
}

//定时器0中断服务程序
//_________________________________________________________
void TIMER0_ISR(void) interrupt 1
{
        TR0   = 0;      //关闭定时器0
        //如果打开了软件定时器
        if (start_soft_timer == 1) {
                // 1 @ 累加定时时间计数器
                rx_soft_timer_cnt++;
                // 2 @ 判断定时时间是否超过了设定的的最大阈值，
                //   @ 如果超过了，则说明等待一段时间后没有新的数据到来
                //   @ 我们判断一包数据接收完成
                if (rx_soft_timer_cnt > RX_TIMEOUT) {
                        //软件定时器清零
                        rx_soft_timer_cnt = 0;
                        //接收标志置“1”，表示这一包数据接收完成
                        rx_flag = 1;
                }
        }

        if (led_cnt < led_data) {
                led_cnt++;
                LED = ON;
        } else {
                LED = OFF;
        }
        if (beep_cnt != 0) {
                beep_cnt--;
                BEEP = ~BEEP;
        }
        TL0   = 0x66;   //设置定时器0初值
        TH0   = 0xFC;   //设置定时器0初值
        TR0   = 1;      //打开定时器0
}


//发送一帧数据
//_________________________________________________________
void uart_write(uint8_t dat)
{
        SBUF = dat;
        while(!TI);
        TI = 0;
}
//发送一串数据
//_________________________________________________________
void send_string(uint8_t *pstr)
{
        while (*pstr != '\0')
                uart_write(*pstr++);
}

//清除数据缓冲区中的所有数据
//_________________________________________________________
void clr_rx_buf(uint8_t *pbuf)
{
        uint8_t i;
        for (i = 0; i < RX_BUF_SIZE; i++)
                rx_buf[i] = 0;
}

//_________________________________________________________
int main(void)
{
        uint16_t crc;
        uint8_t crch;
        uint8_t crcl;
        uint8_t i;
        timer0_init();
        uart_init();
        EA = 1; //打开中断总开关
        while (1) {   
                if (rx_flag) {                          //如果接收到一包数了
                        rx_flag = 0;                    //清除状态标志位
                        start_soft_timer = 0;           //关闭软件定时器
                        if (rx_buf[0] == LOCAL_ADDRESS) { //判断是不是本机地址
                                return;
                        }
                        //CRC16校验，校验正确，我们才处理，否则直接返回
                        //如果校验错误，并给出错误码
                        //0x01 0x02 0x20 0x20 （0x48 0x00）
                        //只计算前4个字节数据，后两位CRC校验位
                        crc = crc16(rx_buf, rx_dat_index-2);
                        crch = crc >> 8;
                        crcl = crc & 0xFF;
                        //判断数据的最后2位（CRC校验位）
                        if ((rx_buf[rx_dat_index - 2] != crch) ||  \
                             rx_buf[rx_dat_index - 1] != crcl)) { 
                                //加入错误码，并返回给上位机
                                rx_buf[1] = rx_buf[1] | 0x80;
                                crc = crc16(rx_buf, rx_dat_index-2);
                                rx_buf[4] = crc & 0xFF;
                                rx_buf[5] = crc >> 8;
                                for (i = 0; i < rx_dat_index; i++) {
                                        uart_write(rx_buf[i]);
                                }
                                return;
                        }
                        switch (rx_buf[1]) {    //rx_buf[1]存放的是功能码
                        case 0x01:
                                    led_data = rx_buf[2];
                                    led_data = led_data << 8;
                                    led_data = led_data + rx_buf[3];
                                    led_cnt  = 0;
                                    break;
                        case 0x02:
                                    beep_data = rx_buf[2];
                                    beep_data = beep_data << 8;
                                    beep_data = beep_data + rx_buf[3];
                                    beep_cnt  = beep_data;
                                    break;
                        default: 
                                    break;
                        }
                        for (i = 0; i < rx_dat_index; i++) {
                                uart_write(rx_buf[i]);
                        }
                        clr_rx_buf(rx_buf);             //清除缓冲区           
                        rx_dat_index = 0;               //数据缓冲区计数个清零
                }
        }
}
