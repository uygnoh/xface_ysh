/*******************************************************************************
                => 单总线器件ROM码64-bit唯一的ROM码
*******************************************************************************/
//主机根据ROM码的前56位来计算CRC值，然后与ROM中高8位的CRC
//值比较，判断接收的ROM是否正确，CRC码的多项式函数为：CRC=x8+x5+x4+1
___________________________________________________________
MSB                              LSB
(8位CRC校验码 + 48位串行数据 + 8位家庭码)
___________________________________________________________



/*******************************************************************************
                => DS18B20数字温度计寄存器
*******************************************************************************/
|       //SCRATCHPAD                            |       EEPROM
|_______________________________________________|
| Byte_0  //Temperature LSB(50h)                |
| Byte_1  //Temperature MSB(05h)                |
| Byte_2  //TH Register or User Byte 1*   <===> | TH Register or User Byte 1
| Byte_3  //TL Register or User Byte 2*   <===> | TL Register or User Byte 2
| Byte_4  //Configuration Register*       <===> | Configuration Register
| Byte_5  //Reserved(FFh)                       |
| Byte_6  //Reserved                            |
| Byte_7  //Reserved(10h)                       |
| Byte_8  //CRC*                                |
|_______________________________________________|


//温度寄存器(“S”表示测量温度的正负值)
//温度寄存器16位中的高5位表示符号位（1表示负温度，0表示正温度）
//低4位是温度的小数位，中间的7位是温度整数部分（它是以补码的形式存放）
|__________________________________________________________|
|//         BIT7  BIT6  BIT5  BIT4  BIT3  BIT2  BIT1  BIT0 |
| LSB BYTE  2^3   2^2   2^1   2^0   2^-1  2^-2  2^-3 2^-4  |
|__________________________________________________________|
| MSB BYTE  S     S     S     S     S     2^6   2^5   2^4  |
|__________________________________________________________|
|
|
//TH和TL寄存器(“S”表示设定告警温度的正负值)
|__________________________________________________________|
| BIT7  BIT6  BIT5  BIT4  BIT3  BIT2  BIT1  BIT0           |
| S     2^6   2^5   2^4   2^3   2^2   2^1   2^0            |
|__________________________________________________________|
|
|
|   //配置寄存器(R1,R0用于标识测量温度的精度)(默认12位精度: 0.0625)
|__________________________________________________________|
| BIT7  BIT6  BIT5  BIT4  BIT3  BIT2  BIT1  BIT0           |
| 0     R1    R0    1     1     1     1     1              |
|__________________________________________________________|



/*******************************************************************************
                => DS18B20数字温度计->数据格式
*******************************************************************************/
//DS18B20温度转换(S为“0”温度为“+”， S为“1”温度为“-”)
//它存储数据的格式以“补码”形式存放的
//它的温度为“+”时， 它的“原码”“反码”“补码”都是一样的
//它的温度为“-”时， 需要转换
|__________________________________________________________|
|           BIT7  BIT6  BIT5  BIT4  BIT3  BIT2  BIT1  BIT0 |
| LSB BYTE  2^3   2^2   2^1   2^0   2^-1  2^-2  2^-3  2^-4 |
| MSB BYTE  S     S     S     S     S     2^6   2^5   2^4  |
|__________________________________________________________|


//原码， 反码， 补码
___________________________________________________________
计算机里都是以“补码”的形式存储数据！
___________________________________________________________
最高位为符号位， “0”代表正数据， “1”代表负数，
非符号位为该数字绝对值的二进制。
“+5”原码  (0000 0101)   “-5”原码  (1000 0101)
___________________________________________________________
“+5”反码  (0000 0101)   “-5”反码  (1111 1010)
___________________________________________________________
“+5”补码  (0000 0101)   “-5”补码  (1111 1011)



/*******************************************************************************
                => DS18B20ROM指令和功能指令
*******************************************************************************/
//ROM指令_ROM COMMANDS
___________________________________________________________
1   //搜索ROM指令[ F0H ]
      当系统初始化时，总线控制器通过此指令多次
      循环搜索ROM编码，以确认所有从机器件
2   //读取ROM指令[ 33H ]
      当总线上只有一只DS18B20时才会使用此指令
      允许总线控制器直接读取从机序列码
3   //匹配ROM指令[ 55H ]
      使总线控制器在多点总线上定位一只特定的DS18B20
4   //忽略ROM指令[ CCH ]
      可以不提供64位ROM编码就使用功能指令
5   //报警ROM指令[ ECH ]
      当总线上存在满足报警条件的从机时，该从机响应此指令
    

//功能指令_FUNCTION COMMANDS
___________________________________________________________
//scratchpad功能指令，操作它需要下面的2个步骤
1   //Initialize
2   //ROM Command
3   //Function Command
___________________________________________________________
1   //温度转换指令   [44H]
2   //写暂存器指令   [4EH]
      开始位置在暂存器(TH寄存器，TL寄存器，配置寄存器)
      初始地址为TH寄存器，以最低有效位传送
3   //读暂存器指令   [BEH]
      读取将从地址0开始，直到（CRC）读完
4   //拷贝暂存器指令 [48H]
      将TH,TL，配置寄存器的数据复制到EEPROM中得以保存
5   //召回EEPROM指令[B8H]
      将TH,TL，配置寄存器的数据从EEPROM中复制到暂存器中
6   //读电源模式指令 [B4H]



/*******************************************************************************
                => DS18B20_LCD1602温度显示(低位在前， 高位在后显示)
*******************************************************************************/
//(uint8_t *romcode)      //DS18B20ROM码中的首地址
//(uint8_t num)           //表示要显示的是第几个DS18B20
void show_romcode(uint8_t *romcode, uint8_t num)
{
        uint8_t i;
        uint8_t tmp;
        lcd1602_set_pos(7, 0);
        lcd1602_write_dat('#');
        lcd1602_write_dat(num + '0');
        
        lcd1602_set_pos(0, 1);
        for (i = 0; i < 8; i++) {
                tmp = romcode[i] >> 4;
                if (tmp < 10) {
                        lcd1602_write_dat(tmp + '0');
                } else {
                        lcd1602_write_dat(tmp + '7');
                }
                tmp = romcode[i] & 0x0F;
                if (tmp < 10) {
                        lcd1602_write_dat(tmp + '0');
                } else {
                        lcd1602_write_dat(tmp + '7');
                }
        }
}

//使用串口发送ROM_CODE
uint8_t code romcode[8] = {};
void send_romcode(uint8_t *romcode)
{
        uint8_t i;
        for (i = 0; i < 8; i++) {
                uart_write(romcode[i];
        }
}



/*******************************************************************************
                => DS18B20_LCD1602读取多个DS18B20
                => 使用匹配指令（）
*******************************************************************************/
//(uint8_t number)它的范围1~3, 表示匹配那一个DS18B20
//根据参数匹配不同的DS18B20的64位ROM码（romcode1[1]， romcode1[2]， romcode1[3]）
//___________________________________________________________________________
void ds18b20_match_rom(uint8_t number)
{
        uint8_t i;
        ds18b20_write(MATCH_ROM);
        switch (number) {
        case 1:
                for (i = 0; i < 8; i++) {
                        ds18b20_write(romcode1[i]);
                }
                break;
        case 2:
                for (i = 0; i < 8; i++) {
                        ds18b20_write(romcode2[i]);
                }
                break;
        case 3:
                for (i = 0; i < 8; i++) {
                        ds18b20_write(romcode3[i]);
                }
                break;
        default:
                break;
        }
}

//使用匹配ROM指令， 读取DS18B20温度
//___________________________________________________________________________
void get_ds18b20_temperature(int16_t *temperature, uint8_t number)
{
        uint8_t MSB, LSB;
        if (!ds18b20_init()) {                       //ds18b20初始化
                ds18b20_match_rom(number);           //ds18b20发送匹配ROM指令
                ds18b20_write(CONVERT_TEMPERATURE);  //ds18b20功能指令，启动温度转换
        }
        if (!ds18b20_init()) {                       //ds18b20初始化
                ds18b20_match_rom(number);           //ds18b20发送匹配ROM指令
                ds18b20_write(READ_REGISTER);        //ds18b20功能指令，读取转换结果
                LSB = ds18b20_read();
                MSB = ds18b20_read();
                *temperature = ((int)MSB << 8) + LSB;
        }
}
___________________________________________________________
int16_t pbuf[] = {123, 456, 789};
get_ds18b20_temperature(pbuf, 1);       //第1个DS18B20保存的位置
get_ds18b20_temperature(pbuf+1, 2);     //第2个DS18B20保存的位置
get_ds18b20_temperature(pbuf+2, 3);     //第3个DS18B20保存的位置
___________________________________________________________



/*******************************************************************************
                => DS18B20_LCD1602单个DS18B20读取温度
*******************************************************************************/
//启动DS18B20温度转换
//_________________________________________________________
void start_ds18b20(void)
{
        if (!ds18b20_init()) {
                ds18b20_write(SKIP_ROM);
                ds18b20_write(CONVERT_TEMPERATURE);
        }
}

//_________________________________________________________
int main(void)
{
        int16_t T;                      //保存接收到的温度数据
        int16_t int_temp;               //分离温度的整数部分
        int16_t dec_temp;               //分离温度的小数部分
        uint8_t str[12];                //保存数据转换成的字符串 ASCII
        uint8_t len;                    //返回字符串的长度
        T = ds18b20_temperature_data();
        int_temp = T >> 4;              //保留整数部分
        dec_temp = T & 0x0F;            //保留小数部分
        len = IntegerToStr(int_temp, str);//把整数转换成字符串
        str[len++] = '.';
        dec_temp = (dec_temp * 100) / 16;//*0.0625
        str[len++] = dec_temp / 10 + '0';//小数部分
        str[len++] = dec_temp % 10 + '0';//小数部分
        while (len < 6) {
                str[len++] = ' ';       //不满6个位时，填充满为止
        }
        str[len]   = '\0';              //加入“\0”, 方便数据处理
        lcd1602_show_string(0, 0, str);
        start_ds18b20();//重新启动ds18b20，进行下一次数据的读取
}

//整形数据转换成字符串（len返回字符串长度） （dat = 128）
//_________________________________________________________
uint8_t IntergerToStr(int16_t dat, uint8_t *str)
{
        uint8_t i = 0;          //字符串索引
        uint8_t len = 0;        //字符串长度
        uint8_t buf[6];         //字符串临时缓冲区
        
        //如果是负数，取绝对值
        //__________________________________________________
        if (dat < 0) {
                dat = -dat;
                *str++ = '-';
                len++;
        }
        //反着取字符串（128度） 先取8， 再取2， 最后取1
        //__________________________________________________
        do {                    
                buf[i++] = dat % 10 + '0';    
                dat /= 10;
        } while (dat > 0);
        len += i;
        //再把字符串反过来
        //__________________________________________________
        while (i-- > 0) {       
                *str++ = buf[i];
        }
        *str = '\0';    //字符串结束加入一个“\0”                   
        return len;     //返回字符串长度
}



/*******************************************************************************
                => DS18B20_LCD1602单个DS18B20读取温度使用浮点数处理
*******************************************************************************/
int16_t temperature;
float float_tmp;
if (temperature < 0) {                  //如果当前温度为负数
        lcd1602_write_cmd(0x80);        //写地址（0x80表示初始地址）
        lcd1602_write_dat('-');         //显示负
        temperature = ~temperature;     //补码存放，取反加1求原码
        temperature = temperature + 1;  
        float_tmp   = temperature
        temperature = float_tmp*0.0626*100;   //小数点后保留2位  
} else {
        lcd1602_write_cmd(0x80);        //写地址（0x80表示初始地址）
        lcd1602_write_dat(' ');         //显示空
        float_tmp   = temperature
        temperature = float_tmp*0.0626*100; //小数点后保留2位 
}
if (temperature >= 10000) {             //温度大于等于100度
        lcd1602_write_cmd(0x82);        //写地址（0x82表示初始地址）
        lcd1602_write_dat('0' + temperature/10000);             //显示“百位”
        lcd1602_write_dat('0' + temperature%10000/1000);        //显示“十位”
        lcd1602_write_dat('0' + temperature%1000/100);          //显示“个位”
        lcd1602_write_dat('.');                                 //显示“点”
        lcd1602_write_dat('0' + temperature%100/10);            //显示“小数十位”
        lcd1602_write_dat('0' + temperature%10);                //显示“小数个位”
} else {                                //温度小于100度
        if (temperature >= 1000) {              //判断温度是否大于等于10度
                lcd1602_write_cmd(0x82);        //写地址（0x82表示初始地址）
                lcd1602_write_dat('0' + temperature%10000/1000);  //显示“十位”
                lcd1602_write_dat('0' + temperature%1000/100);    //显示“个位”
                lcd1602_write_dat('.');                           //显示“点”
                lcd1602_write_dat('0' + temperature%100/10);      //显示“小数十位”
                lcd1602_write_dat('0' + temperature%10);          //显示“小数个位”
                lcd1602_write_dat(' ');                   //数据对齐，清除原有的显示
        } else {
                lcd1602_write_cmd(0x82);        //写地址（0x82表示初始地址）
                lcd1602_write_dat('0' + temperature%1000/100);    //显示“个位”
                lcd1602_write_dat('.');                           //显示“点”
                lcd1602_write_dat('0' + temperature%100/10);      //显示“小数十位”
                lcd1602_write_dat('0' + temperature%10);          //显示“小数个位”
                lcd1602_write_dat(' ');                   //数据对齐，清除原有的显示
                lcd1602_write_dat(' ');                   //数据对齐，清除原有的显示
        }
}
