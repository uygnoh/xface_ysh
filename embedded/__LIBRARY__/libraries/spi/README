/******************************************************************************/
        => SPI_25AA020A引脚定义
/******************************************************************************/
        SCK     //SCLK_串行时钟线
        SI      //MISO_串行数据输入
        SO      //MOSI_串行数据输出
        CS      //NSS__片选信号线
        HOLD    //保持输入
        WP      //写保护
 


//SPI_25AA020A引地址定义
___________________________________________________________
0                   //器件地址
1 0x00h~0xffh       //25AA020A内部器件地址范围
___________________________________________________________ 







############################################################
### % SPI_25AA020A 器件操作
############################################################
/* % 置 1写使能锁存器  (使能写操作) */
void eeprom_wrirte_enable(void)
{
    CS = 0;
    spi_write_byte(WREN);
    CS = 1;
}


/* % 向eeprom中读出一个字节数据 */
uint8_t eeprom_read_byte(uint8_t addr)
{
    uint8_t dat;
    CS = 0;                 /* % 片选信号 */
    spi_write_byte(READ);   /* % 写入“读”命令 */
    spi_write_byte(addr);   /* % 写入要读的地址 */
    dat = spi_read_byte();  /* % 返回读出的字节 */
    CS = 1;                 /* % 片选信号 */
}


/* % 向eeprom中写入一个字节数据 */
void eeprom_write_byte(uint8_t addr, uint8_t dat)
{
    uint8_t state;
    eeprom_wrirte_enable(); /* % 在准备写入数据之前，要(使能写操作) */
    
    CS = 0;
    spi_write_byte(WRITE);  /* % 写入“写”命令 */
    spi_write_byte(addr);   /* % 写入地址 */
    spi_write_byte(dat);    /* % 写入数据 */
    
    /* % 在写周期中，也可以读STATUS寄存器的状态 */  
    while (1)
    {
        CS = 0;
        spi_write_byte(RDSR);   /* % 写入的指令，是读状态寄存器的指令 */
        state = spi_read_byte();/* % 读出状态寄存器中的内容 */
        if ((state & 0x01) == 0)/* % 读出状态寄存器中的最低位为“1”，则没有写完 */
        {
            break;
        }
        CS = 1;
    }
              
    CS = 1;
}
