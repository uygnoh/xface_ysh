/*******************************************************************************
                                     RP2040
*******************************************************************************/
BOOTSEL //启动选择按钮
        按键未按下时，MCU复位或上电，则从Flash启动
        如果按键按下，MCU复位或上电，则进入UF2下载模式
        
        
        
/*******************************************************************************
                                   RP2040-GPIO
*******************************************************************************/
machine.Pin(id, mode=None, pull=None, value)
Pin     //对象构造函数
id      //GPIO编号，数值为（0~29）
mode    //模式，可选( None, Pin.IN(0), Pin.OUT(1), Pin.OPEN_DRAIN(2) )
pull    //使用内部上拉或下拉，仅在输入模式下有效( None, Pin.PULL_UP(1), Pin.PULL_DOWN(2) )
value   //0(off), 1(on)


from machine import Pin
import utime
#//初始化GPIO15，配置为输入模式，使用上拉电阻
button_num = 15
button = Pin(button_num, Pin.IN, Pin.PULL_UP)

#//配置GPIO16， 输出模式
external_led_num = 16;
external_led = Pin(external_led_num, Pin.OUT)

#//配置GPIO25，输出模式
led_num = 25
led = Pin(led_num, Pin.OUT)

print("button gpio={0}".format(button_num))

while True:
	#//打开led
	led.off()
	#//读取button的值， 延时10ms，使用软件消抖
	if (button.value() == 0):
		utime.sleep(0.01)
		if (button.value() == 0):
			#//Toggle led
			external_led.toggle()
			#//led turn on
			led.on()
			print("button is pressed")
			while (button.value() == 0):
				utime.sleep(0.01)
				
				
				
/*******************************************************************************
                                   RP2040-PWM
*******************************************************************************/
from machine import Pin, PWM
import utime

#//配置GPIO25为PWM模式
LED = PWM(Pin(25))

#//配置PWM频率为 1000Hz
LED.freq(1000)

LDE_duty = 0
LED_drection = 1
while True:
	LED_duty += LED_direction
	if LED_duty >= 100:
		LED_duty = 100
		LED_direction = -1
	elif LED_duty <= 0:
		LED_duty = 0
		LED_direction = 1
	LED.duty_u16(int(LED_duty * 655.36))
	if LED_duty % 5 == 0:
		print(LED_duty)
	utime.sleep(0.01)
	
	
	
/*******************************************************************************
                                   RP2040-ADC
*******************************************************************************/
1 逐次逼近型ADC
  //根据基准电压生成一系列电压，与输入电压逐个比较，获取最接近输入电压对应的编码值。
  //速度中等，精度较高，较为常见
2 并联比较型ADC
  //根据基准电压生成一系列电压，同时进行比较，获取最接近输入电压对应的编码值
  //速度较快，精度低，适用于高速，低分辨率的场合

3 RP2040 ADC
  //ADC类型：    逐次逼近型ADC
  //转换速率：    500KS/s（使用内部独立48MHz时钟）
  //分辨率：      12Bit
  //ADC输入通道： 通道0~3为GPIO通道（GPIO26~29）
  //            通道4为内部温度传感器通道
  //Pico上GPIO29并未引出至引脚，而是用于检测“VSYS”电压
_________________________________________________________________________
           ADC_AVDD * ReadData            3.3 * ReadData
  Vin = _______________________    =   ____________________
                分辨率                          2^12
                
                
                        ADC_voltage - 0.706
  Temperature = 27 - __________________________
                             0.001721
_________________________________________________________________________


#//这个程序实现每秒读取一次GPIO26上的电压，并使用片内温度传感器采集温度                            
from machine import Pin, ADC
import utime
#//1->通过指定GPIO26初始化ADC通道“0”
#//选择RP2040—ADC通道“0”，使用此通道采集外部输入电压
ADC0 = ADC(Pin(26))
#//2->指定初始化ADC通道“4”，其对应片内温度传感器
#//选择RP2040—ADC通道“4”，此通道为内部温度传感器
sensor_temp = ADC(4)

while True:
	#//通道0
	read_voltage = ADC0.read_u16() * 3.3 / 65535
	#//内部通道4
	read_temp_voltage = sensor_temp.read_u16() * 3.3 / 65535
	temperature = 27 - (read_temp_voltage - 0.706) / 0.001721
	print("ADC0_voltage = {0:.2f}V \t\t temperature = {1:.2f}C \r\n".format(read_voltage, temperature))
	utime.sleep_ms(1000)
	
	
	
/*******************************************************************************
                                   RP2040-UART
*******************************************************************************/
1 收发独立FIFO
2 可编程波特率生成器
3 标准异步通信位，在发送时添加，在接收时删除
4 换行符检测
5 可编程串行接口（5，6，7，8）数据位
6 1位或2位停止位
7 可编程的硬件流量控制（RTS， CTS）

machine.UART
(id, baudrate=115200, bits=8, parity=None, stop=1, tx=None, rx=None)
id			//使用UART通道，“0”或“1”
baudrate	//使用波特率
bits		//数据位长度
parity		//奇偶校验位
stop		//停止位长度
tx			//TXD引脚，应为Pin对象
rx			//RXD引脚，应为Pin对象


from machine import Pin, ADC
import utime

uart = UART(0, baudrate=115200, tx=Pin(0), rx=Pin(1))
led = Pin(25, Pin.OUT)

uart.write("Waveshare Uart Test\r\n")
uart.write("Plase enter charcter 0 or 1 to switch the LED on and off \r\n")

while True:
	if uart.any() == True:
		buf = uart.read(1)
		if buf == b'1':
			led.on()
			print("LED ON")
			uart.write("LED ON\r\n")
		elif buf == b'0':
			led.off()
			print("LED OFF")
			uart.write("LED OFF\r\n")
		else:
			print("Please enter character 0 or 1 switch the LED on an off")
			uart.write("Please enter character 0 or 1 switch the LED on and off\r\n")
	utime.sleep_ms(1)
