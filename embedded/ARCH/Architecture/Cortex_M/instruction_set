############################################################
### % LDREX和STREX =>互斥访问指令
############################################################
1）LDREXB和STREXB：对内存中的一个字节（Byte，8 bit）进行独占访问；
2）LDREXH和STREXH：中的一个半字（Half Word，16 bit）进行独占访问；
3）LDREXD和STREXD：中的一个双字（Double Word，64 bit）进行独占访问。

1） % LDREX用来读取内存中的值，并标记对该段内存的独占访问：
LDREX Rx, [Ry]  

上面的指令意味着，读取寄存器Ry指向的4字节内存值，将其保存到Rx寄存器中，
同时标记对Ry指向内存区域的独占访问。如果执行LDREX指令的时候发现已经被
标记为独占访问了，并不会对指令的执行产生影响。


2） % 而STREX在更新内存数值时，会检查该段内存是否已经被标记为独占访问，
   并以此来决定是否更新内存中的值：
STREX Rx, Ry, [Rz]  

如果执行这条指令的时候发现已经被标记为独占访问了，则将寄存器Ry中的值
更新到寄存器Rz指向的内存，并将寄存器Rx设置成0。指令执行成功后，会将独占访问标记位清除。

而如果执行这条指令的时候发现没有设置独占标记，则不会更新内存，且将寄存器Rx的值设置成1。

一旦某条STREX指令执行成功后，以后再对同一段内存尝试使用STREX指令更新的时候，会发现独
占标记已经被清空了，就不能再更新了，从而实现独占访问的机制。




###########################################################
### % ARM_Cortex_M 指令集
###########################################################
Thumb-2 技术引入了 Thumb指令集的一个新的超集，可以在一种模式下同时
使用16位和32位指令集。
___________________________________________________________
% ARM指令语法格式中，<>中的内容是必须的，{}中的内容是可选的
<opcode>{<cond>}{S} <Rd>, <Rn> {,<operand2>}
1 <opcode>      操作码
2 {<cond>}      决定指令执行的条件域
3 {S}           决定指令执行是否影响状态寄存器xPSR的值
4 <Rd>          目的寄存器
5 <Rn>          第一个操作数为寄存器
6 <operand2>    第二个操作数



###########################################################
###  % ARM寻址方式
###########################################################
1 % 数据处理寻址方式
立即数寻址方式
立即寻址指令中的操作码字段后面的地址码部分是操作数本身,
即数据就包含在指令当中，取出了指令也就取出了可以立即使
用的操作数（这样的数称为立即数）


2 % 立即数可表示为常数表达式。
在立即数寻址方式中，
规定这个立即数必须是一个8bit的常数通过循环右移偶数位得到。
ARM 只提供了12bit 来放数据，其中8位来记录数值的，
另外4位来放移位的位数，以此来形成一个立即数。
% 立即数以“#”开头，16进制在#后面加“0x”或“&”表示。
% MOV R0, #0x800            ;R0⇦将立即数0x800装入R0寄存器中
% SUBS R0, R0, #1           ;R0⇦R0-1,结果放入R0.


2 % 寄存器寻址方式
Rm-----寄存器方式。在寄存器方式下，操作数即为寄存器的数值。
操作数的值在寄存器中，指令中的地址码字段指出的是寄存器编号，
指令执行时直接取出寄存器的值来操作。
% MOV R1, R2                ;r1⇦r2
% SUB R0, R1, R2            ;r0⇦(r1-r2)
注意：第一个是目的寄存器，然后是第一个操作数寄存器，
      最后是第二个操作数寄存器。


3 % 寄存器移位寻址方式
寄存器移位寻址是ARM指令集持有的寻址方式。
当第2个操作数是寄存器移位方式时，第2个寄存器操作数在与第1个操作
数结合之前，选择进行的移位操作。
% MOV R0, R2, LSL #3        ;R2的值左移3位，结果放入R0；即R0⇦(R2*8)
% ANDS R1, R1, R2, LSL R3   ;R2的值左移R3位，与R1 相与，结果放入R1中,\
%                            加了后缀“S”，表示影响标志位。


4 % 普通Load/Store指令的寻址方式
语法格式：
LDR|STR{<cond>}{B}{T} <Rd>, <addressing_mode>

注：B为加载字节数据，T为可选后缀。
若指令有T,那么即使处理器在特权模式下,
存储系统也将访问看成是在用户模式下进行的。
T 在用户模式下无效。


5 %  杂类Load/Store指令的寻址方式
LDR|STR{<cond>}H|SH|SB|D <Rd>, <addressing_mode>
注：B为字节，H为半字，D为双字，S为加载有符号数。
使用该类寻址方式的指令包括：（有符号/无符号）半字Load/Store指令，
有符号字节Load/Store指令和双字Load/Store指令。


6 % 批量Load/Store指令寻址方式 
批量Load/Store指令将一片连续的内存单元的数据加载到通用寄存器组中
或者将一组通用寄存器的数据存储到内存单元中。
它的寻址模式产生一个内存单元的地址范围，
指令寄存器和内存单元在对应关系满足这样的规则：
编号低的寄存器对应于内存中低地址单元，
编号高的寄存器对应于内存中高地址单元。
% LDM|STM{<cond>}<addressing_mode> <Rn> {!}, <registers><^>


7 % 协处理器Load/Store指令寻址方式
<opcode>{<cond>}{L}{<coproc>}, <CRd>, <addressing_mode>

其中：opcode为指令操作码
      coproc为协处理器名称
      addressing_mode为指令寻址模式 


8 % 堆栈操作寻址方式
% 空堆栈，先放数据再调指针  
% 满堆栈，先调指针再放数据
% 递减栈，堆栈向内存地址减小的方向生长
% 递增栈，堆栈向内存地址增加的方向生长
FD(Full Descending)	% 满堆栈，堆栈指针指向栈顶元素(递减栈)
ED(Empty Descending)	% 空堆栈，堆栈指针指向第一个可用元素(递减栈)
FA(Full Ascending)	% 满堆栈，堆栈指针指向栈顶元素(递增栈)
EA(Empty Ascending)	% 空堆栈，堆栈指针指向第一个可用元素(递增栈)
% 如果程序中有对协处理器数据进栈/出栈操作，最好使用FD或FA类型堆栈。
% 例：满递减堆栈：      ;将R1～R7,LR入栈
STMFD SP!, {R1-R7, LR}  
% 例：空递减堆栈：      ;数据出栈放入R1～R7,LR
LDMED SP!, {R-R7, LR}   



###########################################################
###  % 数据传送指令
###########################################################
MOV  R1, R0                     ;将R0中的数据复制到R1
MOVS R1, R0                     ;将R0中的数据复制到R1,需更新APSR中标志
MRS  R2, PRIMASK                ;将PRIMASK中的值复制到R2
MSR  CONTROL, R3                ;将CONTROL中的值复制到R3
MOV  R4, #0x34                  ;将八位数0x34直接存入R4
MOVS R4, #0x34                  ;将八位数0x34直接存入R4,需更新APSR中标志
MOVW R5, #0x1234                ;将16位数#0x1234直接存入R5
MOVT R5, #0x8765                ;将16位数#0x8765直接存入R5的高16位中
MVN  R7, R6                     ;将R6的负值传送至R7
___________________________________________________________
% 浮点单元和内核寄存器之间的数据传送指令
VMOV R0, S0                     ;将浮点寄存器S0的值复制到通用寄存器R0中
VMOV S1, R1                     ;将通用寄存器R1的值复制到浮点寄存器S1中
VMOV S3, S2                     ;将浮点寄存器S2的值复制到浮点寄存器S3中
VMRS.F32 R0, FPSCR              ;将FPSCR中的值复制到R0中
VMRS APSR_nzcv, FPSCR           ;将FPSCR的标志位复制到APSR_nzcv的标志位中
VMSR FPSCR, R3                  ;将R3的值复制到FPSCR中
VMOV.F32 S0, #1.0               ;将单精度值传送至浮点寄存器S0中
由于Cortex-M4处理器包含浮点单元，
所以数据处理类型还包括内核寄存器组中的寄存器和浮点寄存器组之间的数据传送，
浮点寄存器组中的寄存器之间的数据传送，
将数据从浮点寄存器(例如：浮点状态寄存器FPSCR)传送至内核寄存器组中的寄存器，
将立即数加载到浮点寄存器等 。
% 注意：
指令中后缀.F32(或.32),表示指定32位单精度运算，
此外还有指令后缀.F64(或.64),表示指定64位双精度运算。



###########################################################
###  % 存储器访问令
###########################################################
注：LDRSB和LDRSH指令能够自动对加载的数据执行符号扩展操作，
即将数据转换成有符号32位数。
例如： 如果字节数值为0x80,采用LDRSB指令时，则这一数值将被转换成0xFFFFFF80.
       再放置到目的寄存器。
%      位扩展时，如果符号位为“1”时，全部补“1”; 符号位为“0”时，全部补“0”。
___________________________________________________________
% 数据类型                  加载(从存储器中读出)        存储(写入储存器)
8-bit unsigned                  LDRB                        STRB
8-bit signed                    LDRSB                       STRB
16-bit unsigned                 LDRH                        STRH
16-bit signed                   LDRSH                       STRH     
32-bit                          LDR                         STR
Multiple 32-bit                 LDM                         STM
Double-word(64-bit)             LDRD                        STRD
Stack operations(32-bit)        POP                         PUSH   
Single-precision data(32-bit)   VLDR.32                     VSTR.32
Double-precision data(64-bit)   VLDR.64                     VSTR.64
Multiple data                   VLDM                        VSTM
Stack operations                VPOP                        VPUSH

___________________________________________________________
1 立即偏移访问形式

数据传输的存储器地址是一个寄存器的值和一个直接常量(偏移)的总和。
有时候称为“预索引“或”前序“处理。

例如： 
% LDRB R0, [R1, #0x3]           ;从地址R1+0x03处读取一个字节值送到R0.
%                               ;偏移值可正可负，
LDRB Rd, [Rn, #offset]          ;从地址Rn+offset处读取一个字节送到Rd
LDRSB Rd, [Rn, #offset]         ;从地址Rn+offset处读取一个字节,并且对其时行有符扩展后送到Rd
LDRH Rd, [Rn, #offset]          ;从地址Rn+offset处读取一个半字送到Rd
LDRSH Rd, [Rn, #offset]         ;从地址Rn+offset处读取一个半字,并且对其时行有符扩展后送到Rd
LDR Rd, [Rn, #offset]           ;从地址Rn+offset处读取一个字送到Rd
LDRD Rd1, Rd2, [Rn, #offset]    ;从地址Rn+offset处读取一个双字，送到Rd1(低32位)和Rd2(高32位)
STRB Rd, [Rn, #offset]          ;把Rd中的低字节存储到Rn+offset处
STRH Rd, [Rn, #offset]          ;把Rd中的低半字节存储到Rn+offset处
STR Rd, [Rn, #offset]           ;把Rd中的字存储到Rn+offset处
STRD, Rd1, Rd2 [Rn, #offset]    ;把Rd1(低32位)和Rd2(高32位)表达的双字存储到地址Rn+offset处
% 该寻址支持写回基址寄存器
例如：
% LDR R0, [R1, #0x08]!          ;将地址R1+8处的值加载到寄存器R0,
%                               ;然后将R1+8的值存入R1中。
这里的感叹号(!),是指在传送后更新基址寄存器R1的值。
“!”是可选的，如果没有“!”，则该指令就是普通的代偏移量加载指令。
注意：这些指令不能用于R15(PC)或R13(SP)。
此外，只有16位时，这些指令只支持低位寄存器(R0-R7),并且不提供写回。

___________________________________________________________
2 寄存器偏移访问形式

数据传输的存储器地址是基址寄存器的值和变址寄存器值的总和，
其中变址寄存器还可以是移位的寄存器(0~3的移位)。
例如：
% LDR R2, [R1, R0, LSL #3]      ;从存储器地址[R1+(R0<<3)]处读取一个数据送到R2中。

___________________________________________________________
3 后序访问形式

数据传输的存储器地址是寄存器值，
其后立即数常量用于在数据传输结束后更新地址寄存器值。
例如：
% LDR R0, [R1], #0x3            ;从存储器地址[R1]处读取一个字数据送到R0,
%                               ;然后R1被更新为R1+0x3

若使用后序访问形式，由于在数据传输完成后，
基址寄存器都会自动更新，因此无须再使用感叹号“!”

___________________________________________________________
4 文本池访问形式

存储器访问可以从当前PC值和一个偏移值中产生地址值，
常用于将立即数加载到一个寄存器，也可以为常量表的访问。
% PC相关寻址方式的存储器访问指令
LDRB  Rt, [PC, #offset]         ;使用PC偏移将无符号字节加载到Rt
LDRSB Rt, [PC, #offset]         ;使用PC偏移将一字节有符号扩展数据加载到Rt
LDRH  Rt, [PC, #offset]         ;使用PC偏移将无符号半字加载到Rt
LDRSH Rt, [PC, #offset]         ;使用PC偏移将半字有符号扩展数据加载到Rt
LDR   Rt, [PC, #offset]         ;使用PC偏移将一个字数据加载到Rt
LDRD  Rt1, Rt2, [PC, #offset]   ;使用PC偏移将双字数据加载到Rt

___________________________________________________________
5 批量数据访问形式

ARM架构可以实现对存储器中多个连续数据的读写操作，
其批量加载指令LDM和批量存储指令STM仅支持32位数据。
LDMIA Rn, <reg_list>            ;从Rn指向的存储器位置读取多个字，地址在每次读取后增加
LDMDB Rn, <reg_list>            ;从Rn指向的存储器位置读取多个字，地址在每次读取后减小
STMIA Rn, <reg_list>            ;向Rn指向的存储器位置写入多个字，地址在每次写入后增加
STMDB Rn, <reg_list>            ;向Rn指向的存储器位置写入多个字，地址在每次写入后减小

% 批量加载/存储指令的例子
LDR R6, =0x1000                 ;将R6设置其为，0x1000(地址)
LDR R6, {R0, R2-R5, R8}         ;读取6个字数据存入R0, R2-R5, R8中。

% 批量加载/存储指令与普通加载/存储指令一样，支持写回操作符(!), 例如：
LDR R7, =0x40000                ;将R设置其为，0x4000(地址)
STMIA R7, {R0-R3}               ;存储4人字数据进入存储器，R7变为存入0x4010
% 首尾用“{}”标识。
% “-”,表示连续寄存器
% “,”,隔开每个寄存器组
% IA，每次读写后增加地址
% DB，每次读写前减小地址
               


###########################################################
###  % 基本运算指令
###########################################################
% 基本加减法运算指令有4条，分别是，ADD，SUB，ADC，SBC
ADD Rd, Rn, Rm                  ;Rd⇦Rn+Rm
ADD Rd, Rn, #immed              ;Rd⇦Rn+#immed
ADC Rd, Rn, Rm                  ;Rd⇦Rn+Rm+carry
ADC Rd, #immed                  ;Rd⇦Rd+#immed+carry
ADDW Rd, Rn, #immed             ;Rd⇦Rn+#immed       ;ADDW可以扩展到16立即数。
SUB Rd, Rn, Rm                  ;Rd⇦Rn-Rm
SUB Rd, #immed                  ;Rd⇦Rd-#immed
SUB Rd, Rn, #immed              ;Rd⇦Rn=#immed
SBC Rd, Rn, #immed              ;Rd⇦Rn-#immed-borrow
SBC Rd, Rn, Rm                  ;Rd⇦Rn-Rm-borrow
SUBW Rd, Rn, #immed             ;Rd⇦Rn-#immed       ;SUBW可以扩展到16立即数。

            R0      R1          ;第一个双字
        +   R2      R3          ;第二个双字
        ___________________________________
            R4      R5          ;和
% ADDS R5, R1, R3
% ADC  R4, R0, R2



###########################################################
###  % 反向减法指令
###########################################################
% 除此之外还有反向减法指令RSB，乘法指令MUL，除法指令UDIV,SDIV
RSB Rd, Rn, #immed              ;Rd⇦#immed-Rn
RSB Rd, Rn, Rm                  ;Rd⇦Rm-Rn
MUL Rd, Rn, Rm                  ;Rd⇦Rn*Rm
UDIV Rd, Rn, Rm                 ;Rd⇦Rn/Rm           ;无符号除法
SDIV Rd, Rn, Rm                 ;Rd⇦Rn/Rm           ;有符号除法
% Cortex-M4还支持32位乘法指令，乘法累加(MAC)指令，结果为32位或64位。
MLA Rd, Rn, Rm, Ra              ;Rd⇦Ra+(Rn*Rm)      ;32位乘加，32位结果
MLS Rd, Rn, Rm, Ra              ;Rd⇦Ra-(Rn*Rm)      ;32位乘减，32位结果 
SMULL RdLo, RdHi, Rn, Rm        ;{RdLo,RdHi}⇦Rn*Rm  ;32位乘法，64位有符号结果
SMLAL RdLo, RdHi, Rn, Rm        ;{RdLo,RdHi}+=Rn*Rm  ;32位乘加，64位无符号结果
UMULL RdLo, RdHI, Rn, Rm        ;{RdLo,RdHi}⇦Rn*Rm  ;32位乘法，64位有符号结果
UMLAL RdLo, RdHi, Rn, Rm        ;{RdLo,RdHi}+=Rn*Rm  ;32位乘加，64位无符号结果



###########################################################
###  % 逻辑运算指令
###########################################################
AND Rd, Rn                      ;Rd⇦Rd&Rn
AND Rd, Rn, #immed              ;Rd⇦Rn&#immed
AND Rd, Rn, Rm                  ;Rd⇦Rn&Rm
ORR Rd, Rn                      ;Rd⇦Rd|Rn
ORR Rd, Rn, #immed              ;Rd⇦Rd|#immed
ORR Rd, Rn, Rm                  ;Rd⇦Rn|Rm

BIC Rd, Rn                      ;Rd⇦Rd&(wRn)        ;BIC表示位清除指令
BIC Rd, Rn, #immed              ;Rd⇦Rn&(w#immed)
BIC Rd, Rn, Rm                  ;Rd⇦Rn&(wRm)

ORN Rd, Rn, #immed              ;Rd⇦Rn|(w#immed)    ;ORN表示位置位指令
ORN Rd, Rn, Rm                  ;Rd⇦Rn|(w#Rm)

EOR Rd, Rn                      ;Rd⇦Rd^Rn
EOR Rd, Rn, #immed              ;Rd⇦Rn^#immed
EOR Rd, Rn, Rm                  ;Rd⇦Rn^Rm

% R0: ......1111                ;将低4位清零，高28位保留
BIC R0, R0, #0xF                ;它表示为1的位清除，为0的位保留。



###########################################################
###  % 移位循环指令
###########################################################
ASR Rd, Rn, #immed              ;Rd⇦Rn>>immed       ;算术右移
ASR Rd, Rn                      ;Rd⇦Rd>>Rn
ASR Rd, Rn, Rm                  ;Rd⇦Rn>>Rm

LSL Rd, Rn, #immed              ;Rd⇦Rn<<immed       ;逻辑左移
LSL Rd, Rn                      ;Rd⇦Rd<<Rn
LSL Rd, Rn, Rm                  ;Rd⇦Rn<<Rm

LSR Rd, Rn, #immed              ;Rd⇦Rn>>immed       ;逻辑右移
LSR Rd, Rn                      ;Rd⇦Rd>>Rn
LSR Rd, Rn, Rm                  ;Rd⇦Rn>>Rm


ROR Rd, Rn                      ;Rd rot by，循环右移
ROR Rd, Rn, Rm                  ;Rd=Rn rot by Rm

RRX Rd, Rn                      ;{C,Rd}={Rn,C},带进位逻辑右移



###########################################################
###  % 数据转换指令
###########################################################
% 扩展和反转
SXTB Rd, Rm                     ;Rd⇦signed_extend(Rn[7:0)带符号扩展
SXTH Rd, Rm                     ;Rd⇦signed_extend(Rn[15:0)带符号扩展
UXTB Rd, Rm                     ;Rd⇦unsigned_extend(Rn[7:0)无符号扩展
UXTH Rd, Rm                     ;Rd⇦unsigned_extend(Rn[15:0)无符号扩展

REV Rd, Rn                      ;Rd⇦rev(Rn)在字中反转字节序
REV16 Rd, Rn                    ;Rd⇦rev16(Rn)在半字中反转字节序
REVSH Rd, Rn                    ;Rd⇦revsh(Rn)在低半字中反转字节序，并作带符号位扩展。



###########################################################
###  % 位带操作指令
###########################################################
% 为了使Cortex-M4处理器更好地控制应用程序，这些处理器支持位带操作
BFC Rd, #<lsb>, #<width>        ;寄存器位段清零
BFI Rd, Rn, #<lsb>, #<width>    ;将位段插入寄存器
CLZ Rd, Rm                      ;计数前寻置零
RBIT Rd, Rm                     ;反转寄存器中位次序
SBFX Rd, Rn, #<lsb>, #<width>   ;复制源寄存器位段并对其时行有符号扩展

UBFX Rd, Rn, #<lsb>, #<width>   ;复制源寄存器的位段



###########################################################
###  % 饱和运算
###########################################################




###########################################################
###  % 异常相关指令
###########################################################
% SuperVissor Call(SVC)指令是用来生成SVC异常的
通常情况下， 一个运行在非特权执行状态下的应用任务可以向运行在特权执行
状态下的操作系统请求服务，SVC异常机制用来提供非特权级向特权级的转变。
% SVC #<immed>

立即数是8位，值本身不影SVC异常的行为，但SVC处理程序可以从软件中提取一个值，
并把它作为一个输入参数使用，
例如：利用这个值来确定应用任务所请求的服务。

CPSIE I                        	；PRIMASK=0,开中断
CPSID I                         ；PRIMASK=1,关中断
CPSIE F                         ；FAULTMASK=0,开异常
CPSID F                         ；FAULTMASK=1,关异常



###########################################################
###  % 比较测试指令
###########################################################
比较测试指令是不需要加“S”选项的。
% CMP指令
CMP指令在内部作两个数的减法，并根据差来设置标志位，但是不把差写回。
CMP R0, R1                      ;计算R0-R1的差，并且根据结果更新标志位
CMP R0, 0x12                    ;计算R0-0x12的差，并且根据结果更新标志位

% CMN指令
CMN指令在内部做两个数的加法(相当于减去减数的相反数)
CMN R0, R1                      ;计算R0+R1的和，并且根据结果更新标志位
CMN R0, 0x12                    ;计算R0+0x12的和，并且根据结果更新标志位

% TST指令
TST指令的内部其实就是AND指令，只是不写回运算结果，但是它无条件更新标志位
TST R0, R1                      ;计算R0&R1,并且根据结果更新标志位
TST R0, #0x12                   ;计算R0&0x12,并且根据结果更新标志位

% TEQ指令
TST指令的内部其实就是EOR指令，只是不写回运算结果，但是它无条件更新标志位
TEQ R0, R1                      ;计算R0^R1,并且根据结果更新标志位
TEQ R0, #0x12                   ;计算R0^0x12,并且根据结果更新标志位



###########################################################
###  % 程序流程控制指令
###########################################################
% 最基本的无条件跳转指令
B Label                         ;跳转Label处对应的地址
BX reg                          ;跳转到由寄存器reg给出的地址。
在BX中，reg的最低位指示出在跳转后，将进入的状态是ARM(LSB=0)还是Thumb(LSB=1).
因为Cortex-M微处理器只在Thumb中运行，所以必须保证reg的LSB=1,否则会出错。


BL Label                        ;转移到Label处对应的地址，并且把转移前的下一条指令的地址保存到LR。
BLX reg                         ;转移到同寄存器reg给出的地址，根据REG的LSB切换处理器状态，
                                 并且把转移前的下一条地址保存到LR中。
                                 执行跳转的同时将返回地址保存到连接寄存器LR中。
                                 在函数调用完成后，处理器可以返回到程序原来的执行处。



###########################################################
###  % 条件跳转指令 
###########################################################
% 条件跳转基于APSR的四个标志位：N, Z, C, V, 



###########################################################
###  % IF-THEN指令块
###########################################################
IT <cond>                       ;围起1条指令的IF-THEN指令块
IT <x><cond>                    ;围起2条指令的IF-THEN指令块
IT <x><y><cond>                 ;围起3条指令的IF-THEN指令块
IT <x><y><z><cond>              ;围起4条指令的IF-THEN指令块

其中<x>，<y>，<z>的取值可以是“T”或者是“E”。
IT已经代了一个“T”了，因此最多还可以代3个“E”或“T”，且对“T”或“E”的顺序没有要求。
其中“T”对应条件成立时执行的语句。
其中“E”对应条件不成立时执行的语句。




###########################################################
###  % 查表跳转指令
###########################################################
TBB
TBH


###########################################################
###  % 存储器隔离指令
###########################################################
% DMB，数据存储器隔离
% DSB，数据同步隔离
% ISB，指令同步隔离



###########################################################
###  % SIMD指令
###########################################################



