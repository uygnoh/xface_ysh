###########################################################
### stm32存储器地址重映射
###########################################################
% 复位之后总是从地址0x04取复位代码的起始地址
% 以及从0x00取堆栈指针，开始执行复位程序

% 3块可用于启动的存储器的物理地址
1 片上SRAM起始地址                    0x2000,0000
2 片上用户闪存起始地址                 0x0800,0000
3 片上系统闪存(BootLoader)起始地址     0x1FFF,0000
% 由Boot引脚块定以上3块物理存储器中的那块映射到 0x0的起始地址
% Boot引脚在复位后第4个SYSCLK上升沿采样锁定
% 从待机模式(Standby)退出后，会重新采样BOOT引脚电平



###########################################################
### stm32提供了地址重映射寄存器
###########################################################
% SYSCFG_MEMRMP(0x4001_3800)
Bits 31:2   保留
Bits  1:0   MEM_MODE设置存储器地址重映射模式，由软件置位和清除。
            复位之后，这2位的值自动根据Boot引脚选择的启动模式进行设置。
      00    片上用户闪存空间映射到0x0000_0000位置
      01    片上系统闪存空间映射到0x0000_0000位置
      10    FSMC Bank1(NOR/RSRAM 1和2)映射到0x0000_0000位置
      11    片上SRAM映射到0x0000_0000位置
% 复位之后，Boot引脚的值被复制到该寄存器
！唯一例外的是，当Boot1=1 Boot2=0；从片上闪存启动时，寄存器值=0x00



###########################################################
### cortex-m3中断
###########################################################
% 向量表定义了中断的处理例程的入口地址，缺省情况下，CM3认为向量表位于零地址处
% 响应中断时，CM3会根据中断号从表中找出对应的中断处理程序的入口地址
% 每个表项占用4个字节
% 位置0x0000，0000处保存的是MSP的初始值
0x0000_0000     0   MSP初始值
0x0000_0004     1   复位向量地址
0x0000_0008     2   NMI异常处理程序起始地址
0x0000_000C     3   硬fault异常处理程序起始地址
...
0x0000_0040     16  IRQ#0中断处理程序起始地址


% CM3离开复位状态时，首先要做的是读取下面两个值
1 从地址0x0000_0000，取出MSP的值
2 从地址0x0000_0000，取出复位向量(程序开始执行的地址，LSB必须是1)




###########################################################
### cortex-m3向量表重定位
###########################################################
% 可以通过修改“向量表偏移寄存器VTOR”来重定位向量表
% 向量表的起始地址的限制
1 必须先求出系统中有多少个向量，再把该数字向上“圆整”到2的整次幂
2 而起始地址必须对齐到后者的边界上
% 例如，一共有32个中断，则共有32+16=48个向量
向上圆整到2的整次幂后值为64，因此向量表重定位的地址必须能被64x4=256整除，
合法的地址可以是： 0X0, 0X100, 0X200

% 向量表偏移量寄存器VTOR，0xE000_ED08
% 向量表只能放在内部Flash和RAM区
位       名称        类型    复位值     描述
31:30   Reserved            
29      TBLBASE     R/W     0       向量表是在Code区为0，在RAM区为1
28:7    TBLOFF      R/W     0
6 :0    Reserved



###########################################################
###  % 数学中对映射一词的解释 
###########################################################
% “映射”一词首先是在数学中接触到的.
映射的定义：  如果集合A中的每个元素在对应法则f的作用下，在集合B中都
有唯一的一个元素与它对应，那么集合A，B及对应法则f称为集合A到集合B的
一个映射，记作f : A→B。在映射f : A→B中，与A中的元素a对应的B中的
元素b叫做a的象，a叫做b的原象。对应法则f、集合A及集合B称为映射的三要素。
从映射的定义可以看出，映射是“一对一”或“多对一”的对应关系。
微机中的“多对一”关系就是重映射。 



###########################################################
###  % 储器映射的三要素
###########################################################
从数学中映射的定义可以看出，要弄清楚存储器的映射或重映射前，需要找出
存储器映射的三要素


存储器本身并没有地址信息，它的地址是由芯片厂商分配好的，一般不可修改。
给存储器编址的过程（CPU对芯片中或芯片外的FLASH、RAM、外设、
BOOTBLOCK等进行编址，地址统一编入存储器中）称为存储器映射，也称为存
储器地址映射。其中，映射到端口寄存器的存储器单元（或存储器空间）称为
存储器映射寄存器，其地址（或地址空间）称为存储器映射寄存器地址（或存
储器映射寄存器地址空间）。

所以，对应法则f是存储器映射寄存器地址，集合A是存储器，集合B是外设寄存器。
（外设有私有外设、片上外设及片外设备这三种外设，其中，片上外设有GPIO端口 、
ADC、 TIM、 SPI、 USART、CAN、I2C等，私有外设有NVIC等。CPU通过存储器
映射方式对这些功能模块进行统一编址，使得CPU通过访问内存单元达到对外设寄存
器的访问）。所以它们构成的映射为：存储器映射寄存器地址：
存储器存储单元→外设寄存器（或 存储器映射寄存器地址空间：
存储器存储空间→外设寄存器），即存储器到外设寄存器的映射。

那么，重映射就是CPU将外设寄存器重复编址到存储器的过程，也就是某一个外设寄
存器在存储器里被映射了多个地址空间。实际上，真实的外设寄存器在物理上不属于
存储器。由于真实的外设寄存器与其对应的存储器映射寄存器是通过线路相互连接的，
所以，逻辑上外设寄存器属于存储器。并且，真实的外设寄存器中的内容与存储器映
射寄存器中的内容在任何时候都是相同的。

### % 用片上外设中的IO端口寄存器举个例子：
一个IO端口的端口位x在存储器中有2个被映射的存储单元A和B，存储单元A的地址
为m，存储单元B的地址为n。这样，通过地址m访问A可以达到访问B，最终实现访问
IO端口位x。同样地，通过地址n访问B可以达到访问A的目的，最终实现访问IO端
口位x。也就是说存储单元A的内容变化了，那么存储单元B和端口位x的内容也就跟
随着A变化成相同的值，同样地，A和端口位x也会跟随着B变化而变化，并且A、B及
端口位x中的内容始终相同。

在一些内核处理器预定义的存储器映射中，如Cortex-M3/M4内核，有两个内核
预定义存储空间“位带区和位带别名区”就是存储器的重映射的结果。由于通过位
带操作访问位带别名区来访问位带区的单个数据位，所以，常常将它们相互映射
关系称为“位带别名区到位带区的映射”。



###########################################################
###  % 存储器映射的意义
###########################################################
I/O端口有两种编址方式，即I/O端口与存储器统一编址和I/O端口与存储器独立编址。
I/O地址空间和存储器地址空间是两个不同的物理空间，C/C++等高等语言中没有访问
IO端口的指令（除非有专门的访问IO的汇编内核指令或者编译器提供的专门访问IO的函数），
不过C/C++语言具有对绝对地址（或物理地址）的单元内容读写的能力，也就是说具有直接
访问物理地址的能力，它是以指针方式访问物理地址单元内容的。所以，若采用I/O端口与
存储器统一编址的方式，将存储器空间映射给IO空间，那么就可以通过访问存储器实现对IO的访问。
注：物理地址/绝对地址指对存储器编址后存储单元的地址。



