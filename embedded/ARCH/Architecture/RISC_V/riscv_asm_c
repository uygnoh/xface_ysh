###########################################################
### % RISCV汇编器
###########################################################
.text                   :进入代码段。
.align 2                :后续代码按 2 2 字节对齐。
.globl main             :声明全局符号“main”
.section .rodata        :进入只读数据段
.balign 4               :数据段按 4 字节对齐。
.string “Hello, %s!\n”  :创建空字符结尾的字符串。
.string “world”         :创建空字符结尾的字符串。



###########################################################
### % RISCV函数调用中编程的约定
###########################################################
0 有关寄存器的编程约定
寄存器名称+++ABI名(编程用名)+++用途约定
_______________________
x0          zero        % 读取时总为0，写入不起任何效果
_______________________
x1          ra          % 存放函数地址的返回值(return address)
_______________________
x2          sp          % 存放栈指针(stack pointer)
_______________________
x5~x7,      t0~t2,      % 临时寄存器(temporaries),callee(被叫方)可能会使用这些寄存器，
x28~x31     t3~t6       % 所以Callee(被叫方)不能保证这些寄存器中的值在函数调用过程中操持
                        % 不变，这意味着对于Caller(来电者)来说，如果需要的话，Caller需
                        % 在自己在调用Callee之前保存临时寄存器中的值
_______________________
x8, x9      s0, s1,     % 保存寄存器(saved), Callee需要保证这些寄存器的值在函数返回
x18~x27     s2, s11     % 后仍然维持函数调用之前的原值，所以一旦Callee在自己函数中会
                        % 用到这些寄存器则需要在栈中备份并在退出函数时进行恢复。
_______________________
x10, x11    a0, a1      % 参数寄存器(argument), 用于在函数调用过程中保存第1个和第2个
                        % 参数，以及在函数返回时传递返回值。
_______________________
x12~x17     a2~a7       % 参数寄存器(argument), 如果函数调用时需要传递更多的参数，
                        % 则可以用这些寄存器，但是注意用于传递参数的寄存器最多只有
                        % 8个(a0-a7), 如果还有更多参数则要利用栈。
                        
                        
1 函数跳转和返回指令的编程约定
% (伪指令+++++等价指令)
_______________________
% 跳转到“offset”指定位置，返回地址保存在“x1(ra)”
jal offset  jal x1, offset
_______________________
% 跳转到“rs”中值所指定的位置，返回地址保存在“x1(ra)”
jalr rs     jalr x1, 0(rs)
_______________________
% 跳转到“offset”指定位置，不保存返回地址
j offset    jal x0, offset
_______________________
% 跳转到“rs”指定位置，不保存返回地址
jr rs       jalr x0, 0(rs)
_______________________
% 长跳转调用函数
call offset auipc x1, offset[31:12] + offset[11]
            jalr x1, offset[11:0](x1)
_______________________   
% 长跳转尾调用函数
tail offset auipc x6, offset[31:12] + offset[11]
            jalr x0, offset[11:0](x6)
_______________________         
% 从callee(被叫方)返回
ret         jalr x0, 0(x1)


2 实现被调用函数的编程约定
def function()
{
    % 函数起始部分(Prologue)。
    1 % 减少“sp”的值，根据本函数中使用“saved”寄存器的情况
      以及“local”变量的多少开辟栈空间。
    2 % 将“saved”寄存器的值保存到栈中。
    3 % 如果函数中还会调用其它的函数，则将“ra”寄存器的值保存到栈中。
    5 % 函数执行体。
    ___________________
    % 函数退出部分(Epilogue)
    1 % 从栈中恢复“saved”寄存器
    2 % 如果需要的话，从栈中恢复“ra”寄存器
    3 % 增加“sp”的值，恢复到进入本函数之前的状态
    4 % 调用“ret”返回
}



###########################################################
### % RISCV汇编与C语言
###########################################################
0 % 遵守ABI(Abstract Binary Interface)的规定
数据类型的大小，布局和对齐
函数调用约定(Calling Convention)
系统调用约定


1 % RISC-v函数调用约定规定
函数参数采用“a0~a7”传递
函数返回值采用寄存器“a0, a1”传递



###########################################################
### % C函数中嵌入RISC-V汇编
###########################################################
asm [volatile](
    "汇编指令"
    :输出操作数列表(可选)
    :输入操作数列表(可选)
    :可能影响的寄存器或者存储器(可选)
);
0 % volatile加入这个关键字，告诉编译器不对它进行优化。
1 % 汇编指令用双引号括起来，多条指令之间有“;”或者“\n”分隔
2 % “输出操作数列表”和“输入操作数列表”用于将需要操作的“C变量”
  和汇编指令的操作数对应起来，多个操作数之间有“,”分隔。
3 % “可能影响的寄存器或者存储器”用于告诉编译器当前嵌入的汇编
  语句可能修改的寄存器或者内存，方便编译器执行优化。
int foo(int a, int b)
{
    int c;
    asm volatile (                      % 加入“volatile”，不进行优化
        "add %[sum], %[add1], %add2]"   % 此处不指定具体的寄存器，让编译自动分配寄存器
        :[sum]"=r"(c)                   % 输出操作数(sum=c)
        :[add1]"r"(a), [add2]"r"(b)     % 输入操作数(add1=a, add2=b)
    );                                  % "r"表示和寄存对应 
    return c;
}
% 简化写法->
int foo(int a, int b)
{
    int c;
    asm volatile (
        "add %0, %1, %2"
        :"=r"(c)
        :"r"(a), "r"(b)
    );
    return c;
}
