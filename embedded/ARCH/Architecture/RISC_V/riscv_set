/*******************************************************************************
                               register
*******************************************************************************/
x0          zero        //硬编码“0”(Hard-wired zero)
x1          ra          //返回地址值(return address)
x2          sp          //栈指针(stack pointer)
x3          gp          //全局指针(Global pointer)
x4          tp          //线程指针(Thread pointer)
x5~x7       t0~t2       //临时寄存器(temporaries)
x28~x31     t3~t6       //临时寄存器(temporaries)
x8, x9      s0, s1      //保存寄存器(saved)
x18~x27     s2, s11     //保存寄存器(saved)
x10, x11    a0, a1      //参数寄存器(argument)
x12~x17     a2~a7       //参数寄存器(argument)



/*******************************************************************************
                            add sub lw sw
*******************************************************************************/
                                | |
       //C                      | |       //RISC-V
f = (g + h) - (i + j)           | | add t0, s1, s2  //t0 = g  + h
f    <===>    s0                | | add t1, s3, s4  //t1 = i  + j
g    <===>    s1                | | sub s0, t0, t1  //f  = t0 - t1
h    <===>    s2                | |
i    <===>    s3                | |
j    <===>    s4                | |
                                | |
________________________________| |____________________________________
        load word               | |           store word
   lw loads a wod from a        | |      sw stores a word from a
specified memory location into  | |  register in the processor into a
  a register in the processor  |  |     specified memory location
_______________________________|   |___________________________________


add x1, x2, x3          //x1 = x2 + x3
sub x1, x2, x3          //x1 = x2 - x3
lw t0, 8(s1)            //(把“s1寄存器内容 + 8”)以此为地址，读取里面的内容
sw t0, 0(s1)            //把“t0寄存器内容”写入(“s1寄存器内容 + 0”)的地址中


___________________________________________________________
// "LUI(Load Upper Immediate)"指令采用U-type,用于构造20立即数
lui x5, 0x12345     % x5 = (0x12345000)
imm[31:12]      rd[11:7]        opcode[6:0]
20bit           5bit            7bit
// LUI指令会构造一个32bits的立即数，这个立即数的高20位对应指令中的imm，
// 低12位清零。这个立即数作为结果存放在“RD”中。
// 利用LUI+ADDI来为寄存器加载一个大数(0x12345678)
lui  x1, 0x12345        // x1 = 0x12345000
addi x1, x1, 0x678      // x1 = 0x12345678
// 利用LUI+ADDI来为寄存器加载一个大数(0x12345FFF)
lui x1, 0x12346         // x1 = 0x12346000
addi x1, x1, -1         // x1 = 0x12345FFF
// LI(Load Immediate)是一个伪指令
// 汇编器会根据IMM的实际情况自动生成正确的真实指令(instruction)
li x5, 0x12345678       // x5 = 0x2345678


// AUIPC(构造程序的相对地址), AUIPC指令采用“U-type”
auipc x5, 0x12345       // x5 = (0x12345000) + PC
imm[31:12]      rd[11:7]        opcode[6:0]
20bit           5bit            7bit
// 和LUI指令类似，AUIPC指令也会构造一个32bits的立即数，
// 这个立即数的高20位对应指令中的imm，低12位清零。
// 但是和LUI不同的是，AUIPC会先将这个立即数和PC值相加，
// 将相加的结果存放在“RD”中。
// LA(Load Address)是一个伪指令
// 具体编程时给出需要加载的label，编译器会根据实际情况选用
// AUIPC和其它指令自动生成正确的指令序列。
// 常用于加载一个函数或者变量的地址。
___________________________________________________________



/*******************************************************************************
                        RV32I 位运算 | 移位运算
*******************************************************************************/
// AND“与”两个值都为“1”，结果才为“1”
and x5, x6, x7          //x5 = (x6 & x7)
andi x5, x6, 3          //x5 = (x6 & 3)


// XOR“异或”(两个bit值不同(异)则取值为“1”, 两个bit值相同则取值为“0”)
1 0 1 0 1 0 1 0
1 1 1 1 1 1 1 1     (-1)
_______________
0 1 0 1 0 1 0 1


// 逻辑移位运算, 补足的都是“0”
sll  x5, x6, x7         //x5 = (x6 << x7)
srl  x5, x6, x7         //x5 = (x6 >> x7)
slli x5, x6, 3          //x5 = (x6 << 3)
srli x5, x6, 3          //x5 = (x6 >> 3)


// 算术移位运算, 补足的都是“0”
sra x5, x6, x7          //x5 = (x6 >> x7)
_______________
1 0 0 1 0 0 0 0         //(0x90)算术右移1位
1 1 0 0 1 0 0 0         //算术右移1位结果(算术右移按照符号位补足)
_______________
0 0 0 1 0 0 0 0         //(0x40)算术右移1位
0 0 0 0 1 0 0 0         //算术右移1位结果(算术右移按照符号位补足)
// 算术右移立即数(Shift Right Arithmetic Immediate)  
sra x5, x6, 3           //x5 = (x6 >> 3)




/*******************************************************************************
                             RV32I 跳转指令
*******************************************************************************/
// Branch if EQual. 比x5和x6的值,
// 如果相等,则执行路径跳转到一个新的地址
beq  x5, x6, 100

// Branch if Not Equal. 比x5和x6的值, 
// 如果不相等,则执行路径跳转到一个新的地址
bne  x5, x6, 100

// Branch if Greater than or Equal. 按照“有符号方式”
// 比x5和x6的值,如果(x5 < x6), 则执行路径跳转到一个新的地址
blt  x5, x6, 100

// Branch if Greater than or Equal. 按照“无符号方式”
// 比x5和x6的值,如果(x5 < x6), 则执行路径跳转到一个新的地址
bltu x5, x6, 100        



// JAL(Jump And Link)
jal x1, Label
_________________________________________________
31:12                   11:7    6:0
imm[20|10:1|11|19:12]   rd      opcode
_________________________________________________
1 // JAL指令使用J-type编码格式
2 // JAL指令用于调用子程序(subroutine/function)
3 // 子程序的地址计算方法： 首先对“20bits”宽的“IMM*2”后
  // 进行sign-extended，然后将符号扩展后的值和“PC”的值相加。
  // 因此该函数跳转的范围是以“PC”为基准，上下“-1MB, +1MB”
4 // JAL指令的下一条指令的地址写入“x1”，保存为返回地址(ra)
5 // 实际编程时，用Label给出跳转的目标，具体“IMM”值由编译器
  // 和链接器最终负责生成。


// JALR(Jump And Link Register)
jalr x1, 0(x5)
_________________________________________________
31:20       19:15   14:12       11:7    6:0
imm[11:0]   [rs1]   [funct3]    [rd]    [opcode]
_________________________________________________
1 // JALR指令使用I-type编码格式
2 // JALR(subroutine/function)
3 // 子程序地址的计算方法： 首先对“12bits”宽的“IMM”进行
  // sign-extended，然后将符号刘扩展后的值和“x5”的值相加，
  // 得到最终的结果后将其最低位设置为“0”(确保地址按2字节对齐)。
  // 因此该函数跳转地址的范围是以“x5”为基准，上下(+/-2KB).
4 // JALR指令的下一条指令的地址写入“x1”，保存为返回地址(ra)


___________________________________________________
// 判断，如果(i == j)成立，  则 f = g + h;
// 判断，如果(i == j)不成立， 则 f = g -h;
// f->x10, g->x11, h->x12, i->x13, j->x14
___________________________________________________
        bne x13, x14, ELSE
        add x10, x11, x12
        j   EXIT
ELSE:
        sub x10, x11, x12
EXIT:



/*******************************************************************************
                             RV32I 指令扩展
*******************************************************************************/
CSRRW(Atomic Read/Write CSR)
CSRRW RD, CSR, RS1
crrw t6, mscratch, t6       // t6 = mscratch; mscratch = t6
___________________________________________________________
31:0            19:15       14:12   11:7    6:0
csr             rs1         funct3  rd     opcode
12              5           3       5       7
___________________________________________________________
source/dest     source      CSRRW   dest    SYSTEM
1 // CSRRW先读出“CSR”中的值，将其按“XLEN位”的宽度进行
  // “零扩展(zero-extend)”,后写入“RD”； 然后将“RS1”中的值写入“CSR”。
2 // 以上两步操作以“原子性(atomically)”方式完成
3 // 如果“RD”是“x0”，则不对“CSR”执行读的操作。
4 // 伪指令         |   基本指令(写 CSR)
     csrw csr, rs  |   csrrw x0, csr, rs
                   |
                   |
CSRRS(Atomic Read and Set Bits in CSR)
CSRRS RD, CSR, RS1  
csrrs x5, mie, x6           // x5 = mie; mie |= x6;
1 // CSRRS先读出“CSR”中的值，将其按“XLEN位”的宽度进行
  // “零扩展(zero-extend)”后写入“RD”； 然后逐个检查“RS1”中的值，
  // 如果某一位为“1”则对“CSR”的对应位置“1”，否则保持不变。
2 // 以上两步操作以“原子性(atomically)”方式完成
3 //伪指令          |    基本指令(读 CSR)
  csrr rd, csr     |    csrrs rd, csr, x0
                   |



   
/*******************************************************************************
                        32-bit Instruction Formats
*******************************************************************************/
add x5, x23, x21
// 指令码: 0x015B82B3
// 功能码    |源寄存器2  |源寄存器1 |功能码  |目的寄存器 | 操作码   //
|___________|_________|_________|_______|_________|___________|
| func7     |  rs2    |   rs1   | func3 |   rd    |    op     |      
|___________|_________|_________|_______|_________|___________|
|  0x00     |   21    |   23    |  0x2  |    5    |   0x33    |
|___________|_________|_________|_______|_________|___________|
|  0000000  |  10101  |  10111  |  000  |  00101  |  0110011  |
|___________|_________|_________|_______|_________|___________|
|  31~25    |  24~20  |  19~15  | 14~12 |   11~7  |    6~0    |
|___________|_________|_________|_______|_________|___________|


lw x5, 23(x19)
// 指令码: 0x0179A283
//        立即数       |源寄存器1  |功能码  |目的寄存器 | 操作码   //
|_____________________|_________|_______|_________|___________|
|        immediate    |   rs1   | func3 |   rd    |    op     |      
|_____________________|_________|_______|_________|___________|
|         23          |   19    |  0x0  |    5    |   0x03    |
|_____________________|_________|_______|_________|___________|
|     000000010111    |  10011  |  010  |  00101  |  0000011  |
|_____________________|_________|_______|_________|___________|
|        31~20        |  19~15  | 14~12 |   11~7  |    6~0    |
|_____________________|_________|_______|_________|___________|


sw x5, 1200(x6)
// 指令码: 0x4A532823
// 立即数    |源寄存器2  |源寄存器1 |功能码  |  立即数  | 操作码   //
|___________|_________|_________|_______|_________|___________|
|  11:5     |  rs2    |   rs1   | func3 |   4:0   |    op     |      
|___________|_________|_________|_______|_________|___________|
|   37      |    5    |    6    |  0x2  |   16    |   0x23    |
|___________|_________|_________|_______|_________|___________|
|  0100101  |  00101  |  00110  |  010  |  10000  |  0100011  |
|___________|_________|_________|_______|_________|___________|
|  31~25    |  24~20  |  19~15  | 14~12 |   11~7  |    6~0    |
|___________|_________|_________|_______|_________|___________|


// 32-bit Instruction Formats //
|_____|___________|_________|_________|_______|_________|___________|
|32bit|  31~25    |  24~20  |  19~15  | 14~12 |   11~7  |    6~0    |
|_____|___________|_________|_________|_______|_________|___________|
|__R  | func7     |  rs2    |   rs1   | func3 |   rd    |   opcode  |
|_____|___________|_________|_________|_______|_________|___________|
|__I  |        i[11:0]      |   rs1   | func3 |   rd    |   opcode  |
|_____|_____________________|_________|_______|_________|___________|
|__S  |  i[11:5]  |  rs2    |   rs1   | func3 | i[4:0]  |   opcode  |
|_____|___________|_________|_________|_______|_________|___________|
|__B  |i[12|10:5] |  rs2    |   rs1   | func3 |i[4:1|11]|   opcode  |
|_____|___________|_________|_________|_______|_________|___________|
|__U  |               i[31:12]                |   rd    |   opcode  |
|_____|_______________________________________|_________|___________|
|__J  |           i[20|10:1|11|19:12]         |   rd    |   opcode  |
|_____|_______________________________________|_________|___________|
