/*******************************************************************************
        => STM8__时钟寄存器__
*******************************************************************************/
// CLK_CKDIVR 时钟分频寄存器
//_____________________________________________________________
|________________________________________________________________|
|   -   |   -   |   -   |  HSIDIV[4:3]  |      CPUDIV[2:0]       |
|_______|_______|_______|_______________|________________________|
        HSIDIV[4:3]
        //高速内部时钟分频器，由软件写入，用于指定HSI分频因子
                00:  fHSIDIV = fHSI / 1
                01:  fHSIDIV = fHSI / 2
                10:  fHSIDIV = fHSI / 4
                11:  fHSIDIV = fHSI / 8
        CPUDIV[2:0]
        //CPU时钟预分频器，由软件写入，用于指定CPU时钟预分频因子
                000: fCPU = fMASTER / 1
                000: fCPU = fMASTER / 2
                000: fCPU = fMASTER / 4
                000: fCPU = fMASTER / 8
                000: fCPU = fMASTER / 16
                000: fCPU = fMASTER / 32
                000: fCPU = fMASTER / 64
                000: fCPU = fMASTER / 128


// CLK_HSITRIMR //时钟修正寄存器
//_____________________________________________________________
|_______________________________________________________|
|                           |        HSITRIM[3:0]       |
|___________________________|______|______|______|______|
        HSITRIM[3:0]
        //HSI修正值，由软件写入，用于微调 HSI 的校准值
                011     +3
                010     +2
                001     +1
                000     +0
                111     -1
                110     -2
                101     -3
                100     -4


// CLK_SWCR 切换控制寄存器
//_____________________________________________________________
|________________________________________________________
|                         | SWIF | SWIEN | SWEN | SEBSY  |
|_________________________|______|_______|______|________|
                                                       
        SWIF[3]         //在自动切换模式下，代表有没有事件发生 
                        //在手动切换模式下，代表目标时钟源有没有准备好 
        SWIEN[2]        //切换中断使能 
        SWEN[1]         //使能切换 
        SWBSY[0]        //切换状态忙 


// CLK_SWR 主时钟切换寄存器
//_____________________________________________________________
|_______________________________________________________|
|  1   |  1   |  1   |  0   |  0   |  0   |  0   |  1   |
|______|______|______|______|______|______|______|______|
        0xE1            //HSI为主时钟源（复位默认值）
        0xD2            //LSI为主时钟源（仅当“LSI_EN”选项字节位配置为“1”时）
        0xB4            //HSE为主时钟源


// CLK_CMSR 主时钟状态寄存器(只读)
//_____________________________________________________________
|_______________________________________________________|
|  1   |  1   |  1   |  0   |  0   |  0   |  0   |  1   |
|______|______|______|______|______|______|______|______|
        由硬件置“1”或清“0”，用于指示当前所选的主时钟源 
        如果该寄存器中的值为无效值，则产生MCU复位 
        0xE1            //HSI为主时钟源（复位默认值） 
        0xD2            //LSI为主时钟源（仅当“LSI_EN”选项字节位配置为“1”时） 
        0xB4            //HSE为主时钟源 


// CLK_ICKR 内部时钟寄存器
//_____________________________________________________________
|_______________________________________________________|
| - | - | REGAH | LSIRDY | LSIEN | FHW | HSIRDY | HSIEN |
|_______|_______|________|_______|_____|________|_______|


// CLK_ECKR 外部时钟寄存器
//_____________________________________________________________
|_______________________________________________________|
| - | - |   -   |   -    |   -   |  -  | HSERDY | HSEEN |
|_______|_______|________|_______|_____|________|_______|



/*******************************************************************************
        => STM8__时钟切换__
*******************************************************************************/
// 【自动】切换时钟源步骤
//_____________________________________________________________
//1 时钟切换具体过程大多由硬件完成，软件操作只是下达转换和指定时钟
//2 在下达切换和指定切换时钟后，只需等待切换完毕即可
//3 可按用户需求使能中断机制，中断使能并不是必须的
//4 切换时机不是绝对可控，具体时间由硬件状态决定 
        CLK_SWCR        //切换控制寄存器
        CLK_SWR         //主时钟切换寄存器
        CLK_CMSR        //主时钟状态寄存器

[硬件自动]  1  上电复位开始工作
[硬件自动]  2  初始默认配置为HSI内部时钟源的8分频，即16MHz/8=2MHz主时钟频率 
[软件操作]  3  配置切换控制CLK_SWCR寄存器SWEN位为“1”，启动切换时钟源
[软件操作]  4  按照用户需要可配置CLK_SWCR寄存器SWIEN位为“1”使能中断(可选)
[软件操作]  5  将欲设定时钟源值写入主时钟切换CLK_SWR寄存器中
[硬件自动]  6  切换控制CLK_SWCR寄存器的位SWBSY硬件自动置“1”，表示切换状态忙
[硬件自动]  7  预设定目标振荡器使能开始启动
[硬件自动]  8  刚开始启动后经过一段时间趋于稳定，达到就绪状态
[硬件自动]  9  SWBSY硬件自动清“0”，主时钟切换CLK_SWR寄存器中的目标时钟源值
              转入主时钟状态CLK_CMSR寄存器，新旧时钟切换完成
[硬件自动]  10 按照用户需要产生中断，即“SWIF”位硬件自动置“1”，表示有时钟切换
              事件发生。（可选）
[软件操作]  11 程序接收中断，并由程序软件对“SWIF”位清“0” 
[硬件自动]  12 单片机工作在新的时钟频率下。   
                                                 
//【自动】HSI切换到HSE时钟程序                              
//_____________________________________________________________
//如果CLK_CMSR中的主时钟源为HSI, 则CLK_CMSR = 0xE1，上电默认  
//如果CLK_CMSR中的主时钟源为LSI, 则CLK_CMSR = 0xD2 
//如果CLK_CMSR中的主时钟源为HSE, 则CLK_CMSR = 0xB4 
if (CLK_CMSR != 0xB4) { 
        CLK_SWCR |= 0x02; //使能切换，SWEN=1 
        CLK_SWR   = 0xB4; //配置CLK_CMSR中的主时钟源为HSE 
        //等待时钟切换控制寄存器CLK_SWCR中的切换中断标志位SWIF=1 
        while ((CLK_SWCR & 0x08) == 0); 
        CLK_SWCR  = 0x00; //清除相关标志位 
}

                                                                   
//【手动】切换时钟源步骤
//_____________________________________________________________
//单片机软件操作控制整个切换过程
//手动切换不属于“立即”型切换动作，将欲设定时钟源值写入主时钟切换
//CLK_SWR寄存器后并不急于切换，而是等待目标时钟稳定
//整个流程里使能中断将会简化控制，还需编写中断服务函数
//切换时机由用户程序控制，具体时间由硬件状态去决定
在手动切换时钟源过程中，切换过程若遇到某种原因导致切换失败的时候
可以通过程序对切换忙标志位“SWBSY”进行清“0”操作以复位当前的切换
过程，复位过程后主时钟切换寄存器（CK_SWR）的配置会重新恢复到原时钟源。
【硬件自动】  1 上电复位开始工作
【硬件自动】  2 初始默认配置为HSI内部时钟源，即16MHz/8=2MHz主时钟频率
【软件操作】  3 按照用户需要可配置CLK_SWCR寄存SWIEN位为“1”使能中断
【软件操作】  4 将欲设定时钟源值写入主时钟切换CLK_SWR寄存器中
【硬件自动】  5 切换控制CLK_SWCR寄存器的位SWBSY硬件自动置“1”，表示切换状态忙
【硬件自动】  6 预设定目标振荡器使能开始启动
【硬件自动】  7 刚开始启动后经过一段时间趋于稳定，达到就绪状态
【硬件自动】  8 按照用户需要产生中断，即SWIF位硬件自动置“1”，表示目标时钟源准备就绪
【软件操作】  9 程序接收中断，并由程序软件对SWIF位清“0”
【软件操作】 10 用户自行决定执行切换时间点，配置切换控制CLK_SWCR寄存器SWEN位为“1”，
              启动切换时钟源                 
【硬件自动】 11 SWBSY硬件自动清“0”，主时钟切换CLK_SER寄存器中的目标时钟源值转入主时钟 
              状态CLK_CMSR寄存器，新旧时钟切换完成
【硬件自动】 12  单片机工作在新的时钟频率下
//【手动】HSI切换到HSE时钟
//_____________________________________________________________
//如果CLK_CMSR中的主时钟源为HSI, 则CLK_CMSR = 0xE1，上电默认
//如果CLK_CMSR中的主时钟源为LSI, 则CLK_CMSR = 0xD2 
//如果CLK_CMSR中的主时钟源为HSE, 则CLK_CMSR = 0xB4
//首先开启时钟切换中断使能，也就是时钟切换寄存器CLK_SWCR中的SWIEN=1
CLK_SWCR |= 0x04;
//选择主时钟源，对主时钟切换寄存器CLK_SWR写入欲切换时钟
CLK_SWR   = 0xB4;
//开启全局中断
asm("rim");

//中断服务程序, 时钟源切换
#pargma vector=4
__interrupt void CLK_IRQHandler(void)
{
        CLK_SWCR &= 0xF7; //清除SWIF中断标志位
        CLK_SWCR |= 0x02; //对SWEN位置“1”，启动切换
}




 //【自动】HSI切换LSI程序 
//_____________________________________________________________                    
| 如果CLK_CMSR中的主时钟源为HSI, 则CLK_CMSR = 0xE1，上电默认        
| 如果CLK_CMSR中的主时钟源为LSI, 则CLK_CMSR = 0xD2                
| 如果CLK_CMSR中的主时钟源为HSE, 则CLK_CMSR = 0xB4                
|______________________________________________________________
if (CLK_CMSR != 0xD2) {
        //1 首先要配置时钟切换使能位SWEN=1；使能切换过程
        CLK_SWCR |= 0x02; //展开二进制为： 0000 0010 SWEN=1
        //2 选择主时钟源，以主时钟切换寄存器CLK_SWR写入欲切换时钟
        CLK_SWR   = 0xD2; //配置CLK_CMSR中的主时钟源为LSI
        //3 等待时钟切换控制寄存器CLK_SWCR中的切换中断标志位SWIF=1
        while ((CLK_SWCR & 0x08) == 0);
        //4 清除相关标志位
        CLK_SWCR = 0x00;
}
//【手动】HSI与LSI切换程序
//_____________________________________________________________
  如果CLK_CMSR中的主时钟源为HSI, 则CLK_CMSR = 0xE1，上电默认        
  如果CLK_CMSR中的主时钟源为LSI, 则CLK_CMSR = 0xD2                
  如果CLK_CMSR中的主时钟源为HSE, 则CLK_CMSR = 0xB4                
//_____________________________________________________________
//1 首先开启时钟切换中断使能，CLK_SWCR[SWIEN = 1]
CLK_SWCR |= 0x04;
//2 选择主时钟源，对主时钟切换寄存器CLK_SWR写入欲切换时钟
CLK_SWR   = 0xD2; //配置CLK_CMSR中的主时钟源为LSI
//3 开启全局中断
//通过rim指令把main函数的优先级设为最低，让其它中断可以执行
asm("rim")
//******* 中断函数服务程序 ******//
#pargma vector=4
__interrupt void CLK_IRQHandler(void)//时钟切换中断服务函数
{
        CLK_SWCR &= 0xF7;//清除SWIF中断标志位
        CLK_SWCR |= 0x02;//对SWEN位置“1”，启动切换
}



/*******************************************************************************
        => STM8__时钟树__
*******************************************************************************/

// “小而强”的时钟LSI(110KHz~146KHz)                 
//_____________________________________________________________
  LSI时钟源是一个低成休，低功耗的时钟源，可以在停机（Halt） 
  模式下作为独立看门狗（IWDG）和自动唤醒单元（AWU）运行所需的时钟源 
 
  //如果需要启用LSI时钟源作为系统的主时钟源  
 1 配置STM8单片机选项字节“LSI_EN”位为“1”  
 2 后面的时钟源切换以前面的时钟源切换相似 



                //STM8S clock system                  
|______________________________________________________________
|                                                              |
|               HSE             HSI             LSI            |
|                |               |               |             |
|                |               |               |             |
|                |        |______v______|        |             |
|                |        | HSIDIV[1:0] |        |             |
|                |        |______|______|        |             |
|                |               |               |             |
|                |               |               |             |
|                |        |______v______|        |             |
|                |        |   fHSIDIV   |        |             |
|                |        |______|______|        |             |
|                |               |               |             |
|                |               |               |             |
|             |__v_______________v_______________v__|          |
|             |                                     |          |
|             |               fMASTER               |          |
|             |__|_______________|_______________|__|          |
|                |               |               |             |
|                |               |               |             |
|           AWU<-|       |_______v_______|       |->SPI        |  
|           ADC<-|       |  CPUDIV[2:0]  |       |->I2C        |
|         USART<-|       |_______|_______|       |->TIM        |
|                                |                             |
|                                |                             |
|                            |___v___|                         |
|                            | fcpu  |                         |
|                            |___|___|                         |
|                                |                             |
|                                |                             |
|                        |_______v_______|                     |   
|                        |   CPU |  WWDG |                     |
|                        |_______|_______|                     |
|______________________________________________________________|



/*******************************************************************************
        => 时钟门控PCG | 时钟安全CSS | 时钟输出CCO
*******************************************************************************/
//外设时钟门控寄存器1( CLK_PCKENR1) 复位值:0xFF   
//_____________________________________________________________
        PCKEN17       //TIM1
        PCKEN16       //TIM3
        PCKEN15       //TIM2/TIM5
        PCKEN14       //TIM4/TIM6
        PCKEN13       //USART1/2/3/4
        PCKEN12       //USART1/2/3/4
        PCKEN11       //SPI
        PCKEN10       //I2C
                                           
//外设时钟门控寄存器2( CLK_PCKENR2) 复位值:0xFF   
//_____________________________________________________________
        PCKEN27       //CAN(寄存器时钟，而非CAN时钟)
        PCKEN26       //Reserved
        PCKEN25       //Reserved
        PCKEN24       //Reserved
        PCKEN23       //ADC
        PCKEN22       //AWU(寄存器时钟，而非计数器时钟)
        PCKEN21       //Reserved
        PCKEN20       //Reserved

//CSS时钟安全系统
//_____________________________________________________________
//如果启用CSS时钟安全系统要满足的条件 
        1 外部时钟寄存器(CLK_ECKR)中的“HSEEN”位必须为“1” 
        2 HSE时钟源设定为“1至24MHz”高速外部晶体振荡器 
        3 开启时钟安全系统，CLK_CSSR[CSSEN = 1] 
  //CLK_CSSR
   [7:4]        //必须保持清“0”，保留位
   CSSD[3]      //时钟安全系统监测，由硬件置“1”或软清“0”
      0         CSS关闭，或未检测到HSE失效
      1         检测到HSE失效
   CSSDIE[2]    //时钟安全系统监测中断使能
      0         时钟安全系统监测中断禁用
      1         时钟安全系统监测中断使能
   AUX[1]       //辅助振荡器连接至主时钟，由硬件置“1”或清“0”
      0         辅助振荡器关
      1         辅助振荡器开(FHSEI/8),并作为当前主时钟
   CSSEN[0]     //时钟安全系统使能，可读，但只能由软件写一次
      0         时钟安全系统关闭
      1         时钟安全系统打开

//STM8时钟安全系统配置步骤
//_____________________________________________________________
  第 1 步: CSS系统通过时钟安全寄存器（CLK_CSRR）中的“CSSD”位获取 
           当前HSE时钟状态，如果“CSSD”位为“0”则说明HSE时钟未失效
           反之为“1”则可以判断HSE时钟失效或异常了
  第 2 步: 如果HSE时钟“挂掉”了，就要准备向HSI时钟源进行切换，首先
          要把主时钟源状态寄存器（CLK_CMSR） 和主时钟切换寄存器
          （CLK_SWR）同时复位，复位后这两个寄存器的值都是（0xE1）
          默认选择HSI时钟作为主时钟源。而且还要对时钟分频器寄存器
          （CLK_CKDIVR）进行复位，复位后将自动配置HSI时钟的分频
           因子为“8”，即主时钟工作在2MHz频率下 
  第 3 步: 正式启动HSI时钟源，就是对内部时钟寄存器（CLK_ICKR）
           中的“HSIEN”位置“1”，表示使用HSI时钟
  第 4 步: 把已经“挂掉”的时钟HSE彻底关闭，也就是对外部时钟寄存器
           （CLK_ECKR）中的“HSEEN”位清“0”，表示禁止HSE时钟
  第 5 步: 就是“汇报成果”了，要让用户知道现在切换成功了，这个
           结果就是让“AXU”位置“1”。 “AXU”位与“CSSD”位不同，
           “CSSD”位可以通过程序软件清除
           “AXU”位只能由复位方式清除


//CCO时钟输出寄存器(使用CCO功能配置： 配置引脚为推挽输出模式)
//_____________________________________________________________
   [7]          //保留位，必须为“0”
   CCOBSY[6]    //可配置时钟输出忙，由硬件置“1”或清“0”
      0         CCO时钟空闲
      1         CCO时钟忙
   CCORDY[6]    //可配置时钟输出就绪，由硬件置“1”或清“0”
      0         CCO时钟可用
      1         CCO时钟不可用
   CCOSEL[3:0]  //可配置时钟输出源选择，由软件写入
      0000      //f_HSIDIV
      0001      //f_LSI
      0010      //f_HSE
      0011      //Reserved
      0100      //f_CPU
      0101      //f_CPU/2 
      0110      //f_CPU/4
      0111      //f_CPU/8
      1000      //f_CPU/16
      1001      //f_CPU/32
      1010      //f_CPU/64
      1011      //f_HSI
      1100      //f_MASTER
      1101      //f_CPU
      1110      //f_CPU
      1111      //f_CPU
   CCOEN[0]     //可配置时钟输出使能
      0         禁止CCO时钟输出
      1         使能CCO时钟输出




/*******************************************************************************
        => optino_byte
*******************************************************************************/
ICP     //基于电路的更新方式(STLINKV2 + SWIM)，外科手术
IAP     //在单片机内部写一个程序，修改这些选项字节，内科手术


//用户自定义数据区域-IAP方式修改选项字节
//_____________________________________________________________
uint8_t opt_bytes[9] = {0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55};
void opt_config(void)
{
        //输入MASS密匙用于解锁 DATA_EEPROM 的写保护
        do { 
                FLASH_DUKR = 0xAE;        //硬件密匙1
                FLASH_DUKR = 0x56;        //硬件密匙2
        } while (!(FLASH_IAPSR & 0x80));  //等待解锁Flash完成
        FLASH_CR2  = 0x80;  //选项字节进行写操作被使能
        FLASH_NCR2 = 0x7F;  //互补控制寄存器FLASH_NCR2中的NOPT位要为“0”
        *((uint8_t *)0x4800)    =  opt_bytes[0];        //配置ROP选项
        *((uint8_t *)0x4801)    =  opt_bytes[1];        //配置UBC选项
        *((uint8_t *)0x4802)    = ~opt_bytes[2];        //配置UBC选项的互补字节
        *((uint8_t *)0x4803)    =  opt_bytes[3];        //配置AFR选项
        *((uint8_t *)0x4804)    = ~opt_bytes[4];        //配置AFR选项的互补字节
        *((uint8_t *)0x4805)    =  opt_bytes[5];        //配置看门狗选项
        *((uint8_t *)0x4806)    = ~opt_bytes[6];        //配置看门狗选项的互补字节
        *((uint8_t *)0x4807)    =  opt_bytes[7];        //时钟选项
        *((uint8_t *)0x4808)    = ~opt_bytes[8];        //时钟选项的互补字节
}



//_____________________________________________________________
// 选项字节地址               选项名称
//_____________________________________________________________
|   0x4800    |         //读出保护(ROP)
|   0x4801    |         //用户代码启动区(UBC)
|   0x4802    |
|   0x4803    |         //引脚利用功能配置(AFR)
|   0x4804    |
|   0x4805    |         //看门狗选项
|   0x4806    | 
|   0x4807    |         //时钟选项
|   0x4808    | 
|   0x4809    |         //石英晶体振荡器稳定时间
|   0x480A    |
|   0x480B    |         保留
|   0x480C    | 
|   0x480D    |         //等待状态配置
|   0x480E    | 
|   0x487E    |         //启动引导选项字节
|   0x487F    |
|_____________|


// ROP保护选项(Read Out Protection)是读出保护
//_____________________________________________________________
   设定为0xAA(10101010), 读出保护生效。解除保护后单片机内部程序存储区 
   用户启动代码区UBC，  DATA区和Option bytes中的参数和数据都会被擦除， 
   相当于单片机启动“自毁程序”，芯片内部被还原到出厂默认设置。复位值(0x00)
   
// UBC用户代码启动区
//_____________________________________________________________
   用来调整用户启动代码区域的有无与大小，用户代码启动区域“User Boot Code” 
   包含有复位和中断向量表，它可用于存储IAP及通讯程序。  
   UBC[7:0] = 0x00      //不存在UBC区域 
   UBC[7:0] = 0x01      //1个页大小  

// AFR引脚利用功能
//_____________________________________________________________
   AFR重映射选项的第 7 位， 该位为“0”，则PD4备选功能为定时/计数器2的通道1(TIM2_CH1) 
   AFR重映射选项的第 7 位， 该位为“1”，则PD4备选功能为蜂鸣器“BEEP”输出引脚 


   AFR重映射选项的第 6 位， 该位为“0”
        端口PB5备选功能为模拟信号输入通道5“AIN5”
        端口PB4备选功能为模拟信号输入通道4“AIN4”
   AFR重映射选项的第 6 位， 该位为“1” 
        端口PB5备选功能为I2C通信的串行数据引脚“I2C_SDA”
        端口PB4备选功能为I2C通信的串行时钟引脚“I2C_SCL”
 
 
   AFR重映射选项的第 5 位， 该位为“0” 
        端口PB3备选功能为模拟信号输入通道3“AIN3”
        端口PB2备选功能为模拟信号输入通道2“AIN2”
        端口PB1备选功能为模拟信号输入通道1“AIN1”
        端口PB0备选功能为模拟信号输入通道0“AIN0”
   AFR重映射选项的第 5 位， 该位为“1”
        端口PB3备选功能为定时/计数器1的ETR功能引脚“TIM1_ETR”
        端口PB2备选功能为定时/计数器1的互补通道3“TIM1_CH3N”
        端口PB1备选功能为定时/计数器1的互补通道2“TIM1_CH2N”
        端口PB0备选功能为定时/计数器1的互补通道1“TIM1_CH1N”


   AFR重映射选项的第 4 位， 该位为“0”
        端口PD7备选功能为最高等级的外部中断引脚“TLI”
   AFR重映射选项的第 4 位， 该位为“1”
        端口PD7备选功能为定时/计数器1的通道4“TIM1_CH4”


   AFR重映射选项的第 3 位， 该位为“0”
        端口PD0备选功能为定时/计数器3的通道2“TIM3_CH2”
   AFR重映射选项的第 3 位， 该位为“1”
        端口PD0备选功能为定时/计数器1的刹车输入引脚“TIM1_BKIN”


   AFR重映射选项的第 2 位， 该位为“0”
        端口PD0备选功能为定时/计数器3的通道2“TIM3_CH2”
   AFR重映射选项的第 2 位， 该位为“1”
        端口PD0备选功能为系统时钟输出引脚“CLK_CCO”


   AFR重映射选项的第 1 位， 该位为“0”
        端口PA3备选功能为定时/计数器2的通道3“TIM2_CH3”
        端口PD2备选功能为定时/计数器3的通道1“TIM3_CH1”
   AFR重映射选项的第 1 位， 该位为“1”
        端口PA3备选功能为定时/计数器3的通道1“TIM3_CH1”
        端口PD2备选功能为定时/计数器2的通道3“TIM2_CH3”


   AFR重映射选项的第 0 位， 该位为“0”
        端口PD3备选功能为定时/计数器2的通道2“TIM2_CH2”
   AFR重映射选项的第 0 位， 该位为“1”
        端口PD3备选功能为模拟数字转换ADC单元的专用外部触发引脚“ADC_ETR”


// 看门狗选项字节(复位值: 0x00)
//_____________________________________________________________
   看门狗选项可以对STM8单片机内部低速时钟“LSI”进行使能，激活独立看门狗，
   激活窗口看门狗和配置芯片进入暂停模式时窗口看门狗的复位动作。 
   //LSI_EN[3] 位作用为
        LSI_EN    = 0, 内部低速128KHz频率不能作为CPU时钟源
        LSI_EN    = 1, 内部低速128KHz频率可以作为CPU时钟源 
   //IWDG_HW[2] 位作用为独立看门狗激活方式
        IWDG_HW   = 0, 则独立看门狗由软件激活
        IWDG_HW   = 1, 则独立看门狗由硬件激活
   //WWDG_HW[1] 位作用为窗口看门狗激活方式
        IWDG_HW   = 0, 则窗口看门狗由软件激活
        IWDG_HW   = 1, 则窗口看门狗由硬件激活
   //WWDG_HALT[0] 位作用为配置芯片进入暂停模式时窗口看门狗的复位动作 
        WWDG_HALT = 0, 如果窗口看门狗使能，则当芯片进入暂停模式时不产生复位
        WWDG_HALT = 1; 如果窗口看门狗使能，则当芯片进入暂停模式时可以产生复位 


// 时钟选项(复位值: 0x00)
//_____________________________________________________________
   时钟选项可以对STM8单片机的外部时钟选择，自动唤醒单元/时钟，自动唤醒单元的
   时钟分进行配置。
   //EXT_CLK[3] 位作为外部时钟选择位
        EXT_CLK   = 0, 则外部晶体振荡器连接到OSCIN/OSCOUT引脚上
        EXT_CLK   = 1, 则外部时钟信号连接到OSCIN引脚上
   //CKAWUSEL[2] 位作用是自动唤醒单元/时钟选择位 
        CKAWUSEL  = 0, 则128KHz频率的LSI的低频时钟源作为自动唤醒单元的时钟
        CKAWUSEL  = 1, 则外部晶体振荡器时钟源HSE分频后的时钟作为自动唤醒单元的时钟
   //PRSC[1:0]  把外部时钟分频到128KHz
        PRSC[1:0] = 00, 则配置为24MHz到128KHz
        PRSC[1:0] = 01, 则配置为16MHz到128KHz
        PRSC[1:0] = 10, 则配置为 8MHz到128KHz
        PRSC[1:0] = 11, 则配置为 4MHz到128KHz

// 石英晶体振荡器稳定时间选项(复位值: 0x00) 
//_____________________________________________________________
   可以对STM8单片机外部晶体振荡器时钟源（HSE）的稳定时间进行配置。在时钟稳定时间
   选项中有8个位，即HSECNT[7:0]，通过对其进行赋值可以配置不同的外部晶体振荡器时
   钟源（HSE）的稳定时间 
        若配置为“0x00”， 则配置为2048个HSE周期
        若配置为“0xB4”， 则配置为 128个HSE周期
        若配置为“0xD2”， 则配置为   8个HSE周期
        若配置为“0xE1”， 则配置为 0.5个HSE周期

               
// 等待状态含义及作用(复位值: 0x00)
//_____________________________________________________________
   //WAITSTATE[0]        
   WAITSTATE作为等待状态配置位，这个选项用于设置FLASH或EEPROM存储器中读取数据时插入 
   的等待周期。当 “fCPU > 16MHz” 时需要一个等待周期， 该位为“0”则无等待周期，该位 
   为“1”时则等待周期为“1”。需要注意的是若在实际的单片机开系统开发中使用的晶体振荡器
   超过了16MHz，则应配置该选项位为“1”，否则单片机无法正常工作。 


// 启动引导选项(复位值: 0x00) 
//_____________________________________________________________
   启动引导选项可以决定STM8单片机启动引导区（BOOT ROM）是否启动
   该选项中的BL[7:0]是系统启动引导选项字节，复位后启动引导区（BOOT ROM）
   看的程序会检查这个选项，同时根据复位向量中的内容决定CPU跑到引导程序还是 
   复位向量运行|
   //使用串口下载程序: BL[7:0] = 0x55;



/*******************************************************************************
        => interrupt
*******************************************************************************/
//_____________________________________________________________
//      STM8中断向量表
//_____________________________________________________________
0x8000                  RESET   //单片机复位(8000H)不可屏蔽 
0x8004                  TRAP    //软件中断(8004H)不可屏蔽 
0x8008          0       TLI     //外部最高级中断(8008)不可屏蔽  
0x800C          1       AWU     //自动唤醒停机模式中断(800C) 
0x8010          2       CLK     //时钟控制器
0x8014          3       EXTI0   //端口（A）外部中断
0x8018          4       EXTI1   //端口（B）外部中断
0x801C          5       EXTI2   //端口（C）外部中断
0x8020          6       EXTI3   //端口（D）外部中断
0x8024          7       EXTI4   //端口（E）外部中断
0x8028          8       CAN     //CAN RX 中断
0x802C          9       CAN     //CAN TX/ER/SC 中断
0x8030          10      SPI     //发送完成
0x8034          11      TM1     //更新、上溢出、下溢出、触发、刹车
0x8038          12      TM1     //捕获、比较



int main(void)
{
        RIM     //执行RIM指令，将它软件优先级降为0级，间接地开启了中断
}



//_____________________________________________________________
// CCR__CPU-条件代码寄存器
//_____________________________________________________________
|_______________________________________________________|
|  V   |  -   |  I1  |   H  |  I0  |   N  |   Z  |   C  |
|______|______|______|______|______|______|______|______|____
| 溢出标志位“V”， 负数标志位“N”, 零标志位“Z”， 半进位标志位“H”， 进位标志位“C” 
| I[bit_5 bit_3]
|       //软件中断优先级位
|       //这2位表明当前中断请求的优先级。当一个中断请求发生时，相应
|       //的中断向量的软件优先级自动从(ITC_SPRx) 载入 CCR_I[1:0]
|       //I[1:0]可以通过 RIM, SIM, HALT, WFI, IRET 或者
|       //PUSH/POP等指令来软件置位和清零
//_____________________________________________________________
|               I1   I0       优先级                  级别      |
|               1     0       级别0(主程序)            最低      |
|               0     1       级别1                   次低      |
|               0     0       级别2                   次高      |
|               1     1       级别3                   最高      |
//_____________________________________________________________


//_____________________________________________________________
// ITC_SPRx__这个寄存器暂存的是配置数据 
//_____________________________________________________________
| //软件优先级寄存器,复位值（0xFF）, 写入对应值，它会自动配置到CCR寄存器的I[1:0]中
|  Bytes   |    7  |    6  |    5  |    4  |    3   |   2  |   1   |    0  |
|__________|_______|_______|_______|_______|________|______|_______|_______|
| ITC_SPR1 | VECT3SPR[1:0] | VECT2SPR[1:0] | VECT1SRP[1:0] | VECT0SPR[1:0] |
|__________|_______________|_______________|_______________|_______________|
| ITC_SPR2 | VECT7SPR[1:0] | VECT6SPR[1:0] | VECT5SRP[1:0] | VECT4SPR[1:0] |
|__________|_______________|_______________|_______________|_______________|
| ITC_SPR3 |VECT11SPR[1:0] |VECT10SPR[1:0] | VECT9SRP[1:0] | VECT8SPR[1:0] |
|__________|_______________|_______________|_______________|_______________|
| ITC_SPR4 |VECT15SPR[1:0] |VECT14SPR[1:0] |VECT13SRP[1:0] |VECT12SPR[1:0] |
|__________|_______________|_______________|_______________|_______________|
| ITC_SPR5 |VECT19SPR[1:0] |VECT218PR[1:0] |VECT17SRP[1:0] |VECT16SPR[1:0] |
|__________|_______________|_______________|_______________|_______________|
| ITC_SPR6 |VECT23SPR[1:0] |VECT22SPR[1:0] |VECT21SRP[1:0] |VECT20SPR[1:0] |
|__________|_______________|_______________|_______________|_______________|
| ITC_SPR7 |VECT27SPR[1:0] |VECT26SPR[1:0] |VECT25SRP[1:0] |VECT24SPR[1:0] |
|__________|_______________|_______________|_______________|_______________|
| ITC_SPR8 |                               |VECT29SRP[1:0] |VECT28SPR[1:0] |
|__________|_______________|_______________|_______________|_______________|
|                                                         |
|                                                         | 
|   //STM8S为外部中断专门分配了五个中断向量                   |
|_________________________________________________________|
|       Port A 端口的5个引脚: PA[6:2]                       |
|       Port B 端口的8个引脚: PB[7:0]                       |
|       Port C 端口的8个引脚: PC[7:0]                       |
|       Port D 端口的7个引脚: PD[6:0]                       |
|       Port E 端口的8个引脚: PE[7:0]                       |
|_________________________________________________________|___________________|
|                                                                             |
|    //STM8S产生外部中断条件                                                     |
|______________________________________________________________________________|
  1) 相应的GPIO端口必须通过端口数据寄存器(Px_DDR), 端口控制寄存器1(Px_CR1) 
     端口控制寄存器2(Px_CR2)配置为带中断功能的上拉输入接口。
  2) 中断的触发方式由外部中断控制寄存器1(EXTI_CR1)和外部中断控制寄存器2(EXTI_CR2)所配置 
  3) 中断软件优先级寄存器(ITC_SPRX)配置
  4) 外部中断服务子程序入口函数
  5) 开启和关闭总中断
     汇编指令asm("sim") 禁止总中断(3级中断优先设置) 
     汇编指令asm("rim") 使能总中断(0级中断优先设置)



//_____________________________________________________________
//      STM8外部中断设置
//_____________________________________________________________
asm("sim");             //main程序的优先级配置为3级(关总中断)
EXTI_CR1 = 0xE4;        //配置PA为下降沿和低电平触发，PB为上升沿触发
                        //PC为仅下降沿触发， PD为上升沿和下降沿触发
ITC_SPR2 = 0x73;        //0111 0011
			GPIO_C为“2”级，    GPIO_E为“1”级
                        VECT5SPR[1:0]=00, VECT7SPR[1:0]=01
PA_DDR_DDR5 = 0;        //配置 PA5 端口为输入模式
PA_CR1_C15  = 1;        //配置 PA5 端口为弱上拉输入模式
PA_CR1_C25  = 1;        //配置 PA5 端口为外部中断功能
asm("rim");             //main程序的优先级由3级降低至0级(开总中断)





/*******************************************************************************
        => interrupt_register
*******************************************************************************/
| EXTI_CR1  //外部中断控制寄存器1
|_______________________________________________________|
|  PDIS[1:0]  |  PCIS[1:0]  |  PBIS[1:0]  |  PAIS[1:0]  |
|______|______|______|______|______|______|______|______|_
|  PDIS[7:6]                                              |
|       //PORT_D 端口的中断触发位                            |
|       //这些位仅在CC寄存器的I1和I0位都为“1”(级别1)时才可以写入  |
|               00: 下降沿和低电平触发                        |
|               01: 仅上升沿触发                             |
|               10: 仅下降沿触发                             |
|               11: 上升沿和下降沿触发                        |
|__________________________________________________________|
|  PCIS[5:4]                                              |
|       //PORT_C 端口的中断触发位                            |
|       //这些位仅在CC寄存器的I1和I0位都为“1”(级别1)时才可以写入  |
|               00: 下降沿和低电平触发                        |
|               01: 仅上升沿触发                             |
|               10: 仅下降沿触发                             |
|               11: 上升沿和下降沿触发                        |
|__________________________________________________________|
|  PBIS[3:2]                                              |
|       //PORT_B 端口的中断触发位                            |
|       //这些位仅在CC寄存器的I1和I0位都为“1”(级别1)时才可以写入  |
|               00: 下降沿和低电平触发                        |
|               01: 仅上升沿触发                             |
|               10: 仅下降沿触发                             |
|               11: 上升沿和下降沿触发                        |
|__________________________________________________________|
|  PAIS[1:0]                                              |
|       //PORT_A 端口的中断触发位                            |
|       //这些位仅在CC寄存器的I1和I0位都为“1”(级别1)时才可以写入  |
|               00: 下降沿和低电平触发                        |
|               01: 仅上升沿触发                             |
|               10: 仅下降沿触发                             |
|               11: 上升沿和下降沿触发                        |
|__________________________________________________________|
|
|
| EXTI_CR2  //外部中断控制寄存器2
|_______________________________________________________|
|  -   |  -   |  -   |  -   |  -   | TLIS |  PEIS[1:0]  |
|______|______|______|______|______|______|______|______|__
|  TLIS[3]                                                 |
|       //高级中断触发位, 此位由软件设置。                      |
|       //此位仅在外部相应的中断引脚PD7禁止中断时才能写入          |
|               0: 下降沿触发                                |
|               1: 上升没触发                                |
|__________________________________________________________|
|  PEIS[1:0]                                               |
|       //PORT_E端口的中断触发位                              |
|       //这些位仅仅在CC寄存器的I1和I0位都为1(级别3)时才可以写入   |
|               00: 下降沿和低电平触发                         |
|               01: 仅上升沿触发                              |
|               10: 仅下降沿触发                              |
|               11: 上升沿和下降沿触发                         |
|___________________________________________________________|



/*******************************************************************************
        => AWU 自动唤醒功能
*******************************************************************************/
|  //STM8低功耗模式
|_____________________________________________________________________________|
|   Mode   | 主电压调节器 | 时钟振荡 | CPU  |    外设         | 唤醒/触发事件        |
|__________|____________|_________|______|________________|____________________|
|          |            |         |      |      开启       |  所有的内部中断，AWU |
|          |            |         |      | 需要确保外设时钟  |  或者是外部中断（包含 |
|  Wait    |   开启      |   开启   | 关闭  | 未被PGC（外设时钟 |  通信外设中断），复位|
|          |            |         |      |  门控）功能禁用    |  事件             |
|__________|____________|_________|______|_________________|__________________|
|          |           |  关闭    |      |                |  AWU或者是外部中断  |
|  Active  |   开启     |  LSI或   | 关闭 |    仅（AWU）     | (包含通信外设中断)  |
|   Halt   |          |  HSI除外  |     |                 |      复位事件     |
|__________|__________|___________|______|_________________|_________________|
| 活跃停机   |          |          |       |                |                 |  
| 模式主电压 |  关闭     |  关闭     |      |                | AWU或者是外部中断  |
| 调节器自动 |  低功耗   | 仅LSI除外  | 关闭  |   仅（AWU）     | (包含通信外设中断) |
|   关机    | 电压调节器 |          |       |                |    复位事件      |
|__________|___________|__________|_______|_______________|_________________|
| 停机模式  | 关闭低功耗 |   关闭    |  关闭  |   关闭         | 外部中断(包含通信外 |
|          |电压调节器  |          |       |               | 设中断)复位事件    |
|__________|___________|__________|_______|_______________|___________________|
|                                                                   
| // AWU自动唤醒功能, AWU本身是一个计数器 
|________________________________________________________________________|
|  //CKAWUSEL[2] 位作用是自动唤醒单元/时钟选择位                               |
|       CKAWUSEL  = 0, 则128KHz频率的LSI的低频时钟源作为自动唤醒单元的时钟       |
|       CKAWUSEL  = 1, 则外部晶体振荡器时钟源HSE分频后的时钟作为自动唤醒单元的时钟  |
|  //PRSC[1:0]   把外部时钟分频到128KHz                                      |
|       PRSC[1:0] = 00, 则配置为24MHz到128KHz分频                            |
|       PRSC[1:0] = 01, 则配置为16MHz到128KHz分频                            |
|       PRSC[1:0] = 10, 则配置为 8MHz到128KHz分频                            |
|       PRSC[1:0] = 11, 则配置为 4MHz到128KHz分频                            |
____________________________________|________________________________________
                                    |
                                    |
                            |_______v________|
                            |   fLS-128KHz   |
                            |_______|________|    
                                    |
                                    |
|___________________________________v___________________________________|                       
| 第 1 步: 使用控制/状态寄存器（AWU_CSR）中的“MSR”位和TIM3或TIM1的输入捕获通道1  
|         来检测fLS时钟的频率，测量若发现误差则可以通过重新配置异步预分频寄存器（）                              
|         （AWU_APR）中的“APR[5:0]”来进行定时时间修正                       
| 第 2 步: 通过写异步预分频寄存器（AWU_APR）中的“APR[5:0]”位来配置适当的预分频值
|         它表示沙漏的口有多细
| 第 3 步: 通过写时基选择寄存器（AWU_TBR）中的“AWUTB[3:0]”来选择需要自动唤醒延时
|         时间间隔， 它表示沙漏的沙有多少                                                        
| 第 4 步: 置位控制/状态寄存器（AWU_CSR）中的“AWUEN”位，沙漏底朝天
|         如果AWU的功能打开，它是活跃停机模式， 否则它是停机模式
| 第 5 步: 执行“HALT”指令，使得单片机进入活跃停机状态
|_______________________________________________________________________



|//AWU_CSR 控制/状态寄存器
|______________________________________________________________________
|  AWUF[5]      //AWU标志位
|  AWUEN[4]     //AWU使能位
|  MSR[0]       //
|
|//AWU_APR 异步预分频寄存器，它支持的分频系数 2~64
|  APR[5:0]     //上电复位值：0x3F
|  APRdiv = 2
|  APRdiv = 3
|  ...
|  APRdiv = 64
|  APRdiv = 0x3F = 65 不可配置
|_____________________________________________________________________
|
|//AWU_TBR时基寄存器，它表示沙有多少
|  AWUTB[3:0]   //自动唤醒进基选择
|  此位由软件设置自动唤醒的时基，用来定义AWU唤醒的中断间隔时间，
|  AWU自动唤醒中断由控制/状态寄存器（AWU_CSR）中的“AWUEN”位置“1”来使能
|  0000         //无自动唤醒中断
|  0001         //APRdiv / fLs
|  0000         //2 * APRdiv / fLs
|  0000         //2^2 * APRdiv / fLs
|  0000         //2^3 * APRdiv / fLs
|_____________________________________________________________________
// 如果当前fLS时钟频率为128KHz，设定唤醒时间为6ms
// 计算： AWUTB[3:0]和APR[5:0]位配置数值
1 找时间间隔
2 确定AWUTB[3:0]
3 确定计算公式
4 反推APPdiv数值
5 查表配置APR{5:0}
//AWU_TBR = 0x05;  (2^4 * APRdiv /fLS)
_____________________________________________________________________
//设定唤醒时间为6ms
T唤醒时间 = 2^4 * APRdiv / fLS
APRdiv = (T唤醒时间 * fLS) / 2^4
APRdiv = (6 * (10^-3) * 128000) / 2^4 = (48)D
_____________________________________________________________________
                2E APRdiv = 48 
//设定唤醒时间为6ms
AWU_APR  = 0x2E;        //配置预分频值
AWU_TBR  = 0x05;        //配置AWU唤醒时间间隔
AWU_CSR |= 0x10;        //使能“AWUEN”位，启动AWU
asm("HALT");            //执行专用中断指令，进入活跃停机模式
_____________________________________________________________________



/*******************************************************************************
        => BEEP 蜂鸣器
*******************************************************************************/
|____________________________________________________________________
|                           |_______|________|
|                           |   fLS-128KHz   |
|                           |_______|________|    
|                                   |
|                                   |
|                      |____________v______________|
|                      | 5位蜂鸣器计数器BEEPDIV[4:0] |   
|                      |____________|______________|
|                                   |
|                                   |
|                      |____________v_______________|
|                      | 蜂鸣器输出频率选择BEEPSEL[1:0]|   
|                      |____________|_______________|
|                                   |
|                                   |
|                      |____________v_______________|
|                      |    (配置参数)与(BEEP使能位)   |   
|                      |____________|_______________|            
|                                   |
|                                   v
|___________________________________________________________________
|//BEEP_CSR 蜂鸣器控制/状态寄存器
|  BEEPSEL[7:6]         //蜂鸣器输出频率选择
|       00              //输出 fLS / (8 * BEEPdiv)KHz
|       01              //输出 fLS / (4 * BEEPdiv)KHz
|       1x              //输出 fLS / (2 * BEEPdiv)KHz
|  BEEPEN[5]            //BEEP使能位
|  BEEPEDIV[4:0]        //BEEP分频系数
|___________________________________________________________________
void main(void)
{
        CLK_ICKR |= 0x08;  //启用LSI时钟源作为fLS时钟
        while ((CLK_ICKR & 0x10) = 0); //等待LSI时钟准备好
        while (1) {
                BEEP_CSR = 0x2E; //输出1KHz信号
        }
}



/*******************************************************************************
        => IWDG 独立看门狗
*******************************************************************************/

1) 程序配置法
___________________________________________________________________
   IWDG_KR = 0xCC; //1 启用独立看门狗
   IWDG_KR = 0x55; //2 解锁
   //3 再配置IWDG_PR寄存器和IWDG_RLR寄存器的值
   IWDG_KR = 0xAA; //3 刷新功能 
   当STM8单片机上电复位后，假设用户没有自行修改过选项字节参数，那么IWDG资源
   默认由软件程序启用。如果使用软件程序启用独立看门狗，需要通过向键寄存器（IWDG_KR）
   中写入（0xCC）来启用，一旦使能了独立看门狗资源，除了复位之外，不能被关闭。
2) 硬件选项法（选项字节）
___________________________________________________________________
   若用户需要硬件启用独立看门狗，可以通过修改选项字节OPT3选项中的“IWDG_HW”位来
   实现，如果用户配置“IWDG_HW”位为硬件启用后，在单片机上电时独立看门狗资源就已
   经被启动，不再需要用户向键寄存器（IWDG_KR）中写入（0xCC）了
   
   IWDG_KR = 0xCC; //软件程序启用IWDG
   IWDG_KR = 0x55; //解除IWDG_PR写保护以允许对其进行操作
   IWDG_PR = 0x02; //设定预分频因了为16分频
   IWDG_PR = 0xAA; //刷新IWDG
   
___________________________________________________________________
//IWDG_KR 键寄存器, 键值设定
该寄存器的 8 位数据可以由软件写入，写入不同的配置值会有不同的操作含义，软件必须
在规定的时间内（独立看门狗计数溢出即将启动看门狗复位动作之前）写入（0xAA），否
则当向下计数器数值达到“0”（计数器下溢出）时，独立看门狗会产生一个复位动作。
     0xCC       //启动独立看门狗
     0xAA       //刷新独立看门狗
     0x55       //允许对受保护的IWDG_PR寄存器和IWDG_RLR寄存器进行操作
_____________________________________________________________________
//IWDG_PR 分频系数寄存器
PR[2:0]这三个位是用于指定计数器时钟的分频系数。需要注意的是这个寄存器具有写保护
功能，如果需要修改该寄存器中的分频系数，首先要向键寄存器（IWDG_KR）中写入（0x55）
以允许对受保护的IWDG_PR寄存器进行操作。操作完毕后再向键寄存器（IWDG_KR）中写入
（0xAA）刷新独立看门狗，此时IWDG_PR寄存器以会恢复到写保护状态。
        000     计数器时钟 4   分频
        001     计数器时钟 8   分频
        010     计数器时钟 16  分频
        011     计数器时钟 32  分频
        100     计数器时钟 64  分频
        101     计数器时钟 128 分频
        110     计数器时钟 256 分频
        111     保留
_____________________________________________________________________
//IWDG程序
IWDG_KR  = 0xCC; //1 软件程序启用IWDG
IWDG_KR  = 0x55; //2 解除写保护
IWDG_PR  = 0x02; //3 设定预分频因子为16分频
IWDG_RLR = 0x8C; //4 设定重装载数值为0x8C
IWDG_KR  = 0xAA; //5 刷新IWDG

//超时溢出之前“喂狗”!!!!!!!!!!!!!!
IWDG_KR  = 0xAA; 
_____________________________________________________________________




/*******************************************************************************
        => WWDG 窗口看门狗
*******************************************************************************/
//WWDG硬件启用方法(修改选项字节)
//WWDG软件启用方法(修改WWDG_CR寄存器的“WDGA位为1”)

//WWDG_CR控制寄存器
_______________________________________________________________
WDGA[7] //窗口看门狗开启位
        //该位由软件设置，只能由硬件在复位后清除，当“WDGA”位为“1”时，
        //窗口看门狗开启，可以产生复位。如果在选项字节中使能了硬件窗口
        //看门狗功能，则此们不起作用
T[6:0]  //7位计数器( 111_1111 )
        //这些位包含窗口看门狗计数器的数值，每过12288个fCPU周期后递减
        //一次。“T[6:0]”是一个7位向下计数器，取值范围为（0x7F）至（0x40）
        //之间，如果当它的数值从（0x40）变为（0x30）时，即“T6”位为“0”时
        //则产生一个窗口看门狗复位。
_______________________________________________________________


//WWDG_WR窗口寄存器
_______________________________________________________________
W[7]    //保留位，必须保持清“0”
看门狗窗口值“W[6:]” 用来与 WWDG_CR寄存器中向下逐次递减计数器单元的“T[6:0]”
进行比较，若 (“T[6:0]”   >  “W[6:0]”)，则比较结果为“1”，反之为“0”
_______________________________________________________________


//WWDG 喂狗
_______________________________________________________________
【情况 1】 不能喂狗太晚
//T6位递减至“0”的事件动作(是指WWDG_CR寄存器的T6被借位了)
//要注意WWDG_CR有个取值范围: (0xFF) ~ (0xC0)之间，考虑WDGA为“1”的时候
        1111 1111 --- 1100 0000
//若除去最高位WDGA位不看，则T[6:0]取值范围: (0x7F) ~ (0x40)之间
        0111 1111 --- 0100 0000

【情况 1】 不能喂狗太早
//如果 T[6:0] > W[6:0] 时刷新WWDG_CR寄存器，看门狗就会复位

【什么时机喂狗？】
//(T[6:0] < W[6:0])   &&   (T[6:0] >= (0x40))
_______________________________________________________________



/*******************************************************************************
        => gpio
*******************************************************************************/
| DDR | CR1 | CR2 |     配置模式    | 上拉电阻  | 
|_____|_____|_____|________________|_________|
|  0  |  0  |  0  |   悬浮输入      |   关闭   |
|  0  |  1  |  0  |   上拉输入      |   开启   |
|  0  |  0  |  1  |  中断悬浮输入    |   关闭   |
|  0  |  1  |  1  |  中断上拉输入    |   开启   |
|_____|_____|_____|________________|_________|
|  1  |  0  |  0  |    开漏输出     |   关闭   |
|  1  |  1  |  0  |    推挽输出     |   关闭   |
|  1  |  0  |  1  |  开漏输出快速模式 |   关闭   |
|  1  |  1  |  1  |  推挽输出快速模式 |   关闭   |
|_____|_____|_____|________________|__________|



| Px_DDR  //端口数据方向寄存器(x = A, B, C, D, E, F, G, H, I)
|_______________________________________________________|
| DDR7 | DDR6 | DDR5 | DDR4 | DDR3 | DDR2 | DDR1 | DDR0 |
|______|______|______|______|______|______|______|______|
|  0    Input                                           |
|  1    Output                                          |
|_______________________________________________________|
|
|
| Px_CR1  //端口控制寄存器1
|_______________________________________________________|
|  C17 |  C16 | C15  |  C14 |  C13 |  C12 |  C11 |  C10 |
|______|______|______|______|______|______|______|______|
| 输入模式(DDR=0)                                        |
|  0    //浮空输入                                       |
|  1    //带上拉电阻输入                                  |
|_______________________________________________________|
| 输出模式(DDR=1)                                        |
|  0    //模拟开漏输出（不是真正的开漏输出）                 |
|  1    //推挽输出（由CR2相应的位做输出摆率控制）             |
|_______________________________________________________|
|
|
| Px_CR2  //端口控制寄存器2
|_______________________________________________________|
|  C27 |  C26 | C25  |  C24 |  C23 |  C22 |  C21 |  C20 |
|______|______|______|______|______|______|______|______|
| 输入模式(DDR=0)                                        |
|  0    //禁止外部中断                                    |
|  1    //使能外部中断                                    |
|_______________________________________________________|
| 输出模式(DDR=1)                                        |
|  0    //输出最大速度为2MHz                              |
|  1    //输出最大速度为10MHz                             |
|_______________________________________________________|
|
|
| Px_ODR  //端口输出数据寄存器
|_______________________________________________________|
| ODR7 | ODR6 | ODR5 | ODR4 | ODR3 | ODR2 | ODR1 | ODR0 |
|______|______|______|______|______|______|______|______|
| 输出模式，写入寄存器的数值通过锁存器加到相应的引脚上           |
| 输入模式，写入ODR的值将被锁存到寄存器中，但不会改变引脚状态     |
|_______________________________________________________|
|
|
| Px_IDR  //端口输入数据寄存器(只读寄存器)
|_______________________________________________________|
| IDR7 | IDR6 | IDR5 | IDR4 | IDR3 | IDR2 | IDR1 | IDR0 |
|______|______|______|______|______|______|______|______|
| 不论引脚是输入还是输出模式，都可以通过该寄存器读入引脚状态值    |
| 该引脚为只读寄存器（0 表示逻辑低电平， 1 表示逻辑高电平 ）    |
|_______________________________________________________|


//设置PE端口
PE_DDR_DDR0 = 1;        //第0位为输出模式
PE_CR1_C10  = 0;        //第0位为推挽输出
PE_ODR_ODR0 = 1;        //第0位为“逻辑1”
