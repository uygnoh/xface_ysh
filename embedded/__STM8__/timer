/*******************************************************************************
                          UEV(更新事件) -> UIF(更新中断)
*******************************************************************************/
【1】更新事件发生后自动重装载寄存器(TIMX_ARR)中的配置数据会存放进入
    自动重装载寄存器的影子寄存器
【2】更新事件发生后预分频器寄存器(TIMX_PSCR)中的预分频值会写入到预
     分频器的缓冲器中
【3】更新事件发生后状态寄存器(TIMX_SR)中的“UIF”位(更新中断标志)会
    被硬件自动置为“1”
【4】//更新事件的作用: 刷新相关寄存器配置值
    若用户欲启用更新事件中断，则配置中断使能寄存器(TIMX_IER)中的
    “UIE”位为“1”即可


  
/*******************************************************************************
                             TIMER_4基本定时器 程序框架
*******************************************************************************/
void timer4_init(void)
{
        TIM4_PSCR = 0xXX; //设置预分频寄存器数值
        TIM4_ARR  = 0xXX; //设置自动重装载寄存器
        TIM4_IER  = 0x01; //开启TIM4更新事件中断
        TIM4_CNTR = 0xXX; //配置TIM4定时器初值
}
int main(void)
{
        timer4_init();
        asm("rim");       //打开总中断，即降低主程序优先级别
        TIM4_CR1 |= 0x01; //使能计数器
}



/*******************************************************************************
                             TIMER_4 寄存器
*******************************************************************************/
|
| //TIM4_PSCR 预分频寄存器
|______________________________________________________________
|  [7:3]        //保留，必须保持清“0”
|  PSC[2:0]     //预分频值
|               用户配置预分频值后需要等待更新事件的发生，所设定的预分频
|               值才会生效，CK_PSC的时钟经过分频后得到CK_CNT时钟用于计
|               数
|______________________________________________________________
|
|
| //TIM4_CNTR 计数器(向上计数)
|______________________________________________________________
|  [7:0]        //计数器值
|______________________________________________________________
|
|
| //TIM4_ARR 自动重装载寄存器
|______________________________________________________________
|  [7:6]        //装载用户设定的计数最大值
|______________________________________________________________
|
|
| //TIM4_SR 状态寄存器
|______________________________________________________________
|  [7:1]        //保留，必须保持清“0”
|  UIF[0]       //更新中断标志位（只读）
|               //此位在更新事件发生时由硬件置“1”，可以软件清“0”
|               反应出是否发生了更新事件，在TIM4发生“计数溢出”后，可以
|               产生更新事件，若用户需要在更新事件产生的同时产生一个更新
|               中断信号，则可以通过配置该寄存器的“UIE”位为“1”  
|______________________________________________________________
|
|
| //TIM4_IER 中断使能寄存器
|______________________________________________________________
|  [7:1]        //保留，必须保持清“0”
|  UIE[0]       //更新中断使能
|    0          //更新事件发生时禁止更新中断
|    1          //更新事件发生时使能更新中断
|______________________________________________________________
|
|
| //TIM4_EGR 事件产生寄存器
|______________________________________________________________
|  [7:1]        //保留，必须保持清“0”
|  UG[0]        //更新事件产生
|    0          //当UDIS位为“1”（禁止产生更新事件）时，置位“UG”位为“0”
|               则不产生更新事件，但是计数器和预分步器分被初始化
|    1          //当UDIS位为“0”（禁止产生更新事件）时，置位“UG”位为“1”
|               则产生软件更新事件
|______________________________________________________________
|
|
| //TIM4_CR1 控制寄存器1
|______________________________________________________________
|  ARPE[7]      //自动预装载使能位
|    0          //自动重装载寄存器(TIM4_ARR)的配置值立即写入自动重装载
|               影子寄存器，不必等待更新事件发生
|    1          //在下一次更新事件发生时自动重装载(TIM4_ARR)的配置都会
|               写入自动重装载影子寄存器
|______________________________________________________________
|  [6:4]        //保留，必须保持清“0”
|______________________________________________________________
|  OP[3]        //单脉冲模式位
|    0          //计数器在更新事件时不停止
|    1          //在下一次更新事件时计数器停止计数（“CEN”位被硬件清“0”）
|______________________________________________________________
|  URS[2]       //更新中断请求位
|______________________________________________________________
|    0          //当更新中断使能(“UIE”位为“1”)，寄存器发生更新事件（
|               计数器向上溢出或者软件更新置位“UG”位为“1”）时立即发送
|               一个更新中断请求
|    1          //当更新中断使能(“UIE”位为“1”)，仅当计数器达到向上溢
|               出时才发送一个更新中断请求
|______________________________________________________________
|  UDIS[1]      //禁止更新位
|    0          //当计数器向上溢出或者软件更新置位“UG”位为“1”时，立即
|               产生一次更新事件，自动重装载寄存器(TIM4_ARR)中的值立即
|               加载到自动重装载影子寄存器中
|    1          //禁止产生更新事件，自动重装载寄存器(TIM4_ARR)的影子
|               寄存器和预分频器(TIM4_PSC)的缓冲器保持当前的值，如果
|               如果此时“UG”位置“1”，则计数器和预分频器被重新初始化
|______________________________________________________________
|  CEN[0]       //计数器使能位
|______________________________________________________________



//timer4自定义 1Hz信号输出
_______________________________________________________________
void timer4_init(void)
{
        TIM4_PSCR = 0x03; //设置预分频寄存器数值得到 250KHz计数频率
        TIM4_ARR  = 0xFA; //设置自动重装载寄存器为 250，得到定时时间为 1ms
        TIM4_IER  = 0x01; //开启 TIM4 更新事件中断使能
        TIM4_CNTR = 0xFA; //配置 TIM4 定时器初值  
}
#pragma vector=0x19
__interrupt void TIM4_UPD_OVF_IRQHandler(void)
{
        num++;
        TIM4_SR = 0;
        if (num == 500) {
                led1 = !led1;
                num = 0;
        }
}



/*******************************************************************************
                               TIMER1 高级定时器1寄存器
*******************************************************************************/
|
|
| //TIM1_CR1 控制寄存器1
|______________________________________________________________
|  ARPE[7]      //自动预装载使能位
|  CMS[6:5]     //
|  DIR[4]       //计数方向选择位
|  OPM[3]       //单脉冲模式位
|  URS[2]       //更新中断请求位
|  UDIS[1]      //禁止更新位
|  CEN[0]       //使能计数器
|______________________________________________________________
|
|
| //TIM1_IER 中断使能寄存器
|______________________________________________________________
|  BIE[7]       //刹车中断
|  TIE[6]       //触发中断
|  COMIE[5]     //允许COM中断
|  CC4IE[4]     //允许捕获/比较4中断
|  CC3IE[3]     //允许捕获/比较3中断
|  CC2IE[2]     //允许捕获/比较2中断
|  CC1IE[1]     //允许捕获/比较1中断
|  UIE[0]       //允许更新中断
|______________________________________________________________




| //TIM1_SMCR 从模式控制器
|______________________________________________________________
|  MSM[7]       //
|______________________________________________________________
|  TS[6:4]      //触发选择
|               这3位用于选择同步计数器的触发输入，这位哟能在未用到（
|               如“SMS[2:0]”位为“000”时被改变，以避免在改变时产生
|               错误的边沿检测）
|    000        //内部触发ITR0连接到TIM6定时器的TRGO
|    001        //保留
|    010        //内部触发ITR2连接到TIM5定时器的TRGO
|    011        //保留
|    100        //TI1的边沿检测器（TI1F_ED）
|    101        //滤波后的定时器输入1（TI1FP1）
|    110        //滤波后的定时器输入2（TI2FP2）
|    111        //外部触发输入
|______________________________________________________________
|  [3]          //保留
|______________________________________________________________
|  SMS[2:0]     //时钟/从模式选择   
|               当选择了外部信号，触发信号（TRGI）的有效边沿与选中的外部
|               输入极性相关。需要注意的是，如果TI1F_ED被选为触发输入（
|               “TS[2:0]”位为“100”）时，不要使用门控模式，这是因为TI1F_ED
|               在每次TI1F变化时，只是输出一个脉冲，然而门控模式是要检查
|               触发输入的电平    
|    000        //时钟/触发控制器禁止位
|               如果控制寄存器1（TIM_1CR1）中的“CEN”（计数器使能）位
|               为“1”，则预分频器直接由内部时钟驱动
|    001        //编码器模式1：
|               根据TI1FP1的电平，计数器在TI2FP2的边沿向上/下计数
|    010        //编码器模式2：
|               根据TI2FP2的电平，计数器在TI1FP1的边沿向上/下计数
|    011        //编码器模式3：
|               根据另一个输入的电平，计数器在TI1FP1和TI2FP2的边沿向上/下计数
|    100        //复位模式
|               在选中的触发输入（TRGI）的上升沿时重新初始化计数器
|               并且产生一个更新寄存器的信号
|    101        //门控模式
|               当触发输入（TRGI）为高时，计数器的时钟开启，一旦触发
|               输入变化为低，则计数器停止（但不复位），计数器的启动
|               和停止都是受控的
|    110        //触发模式
|               计数器在触发输入TRGI的上升沿启动（但不复位），只有
|               计数器的启动是受控的
|    111        //外部时钟模式1
|               选中的触发输入（TRGI）上升沿驱动计数器
|_____________________________________________________________|
|                                                             |
|                                                             |
| //TIM1_ETR                                                  |
|_____________________________________________________________|
|  ETP[7]       //外部时钟源触发极性
|    0          //ETP不反向
|    1          //ETP反向
|_____________________________________________________________
|  ECE[6]       //外部时钟源使能位
|    0          //禁止外部时钟模式“2”
|    1          //使能外部时钟模式“2”，计数器的时钟为“ETRF”的有效沿
|               需要注意的是，如果“ECE”位置“1”的效果与选择把“TRGI”
|               连接到“ETRF”的外部时钟源模式1是相同的，即配置从模式
|               控制器（TIM1_SMCR）中的“SM[2:0]”位为“111”和
|               “TS[2:0]”位为“111”
|  外部时钟源模式2可以触发标准模式，触发复位模式，触发门控模式同时使用，
|  但是，此时TRGI绝对不能与ETRF相连，也就是说从模式控制寄存器（TIM1_CMCR）
|  中的“TS[2:0]”位不能为“111”。
|  //外部时钟源模式1与外部时钟源模式2同时使能，外部时钟源输入为“ETRF”信号
|______________________________________________________________
|  ETPS[5:4]    //外部触发预分频
|  外部触发信号“ETRP”的频率最大不能超过 fMASTER/4, 可用预分频器来降低
|  “ETRP”信号的频率，当“ETRP”信号的频率很高时，它非常有用
|    00         预分频器关闭
|    01         “ETRP”信号的频率 / 2
|    10         “ETRP”信号的频率 / 4
|    11         “ETRP”信号的频率 / 8
|______________________________________________________________
|  ETF[3:0]    //外部触发滤波器选择
|  这4位定义了“ETRP”信号采样频率及数字滤波器的长度，数字滤波器是由一个
|  事件计数器组成，只有发生了N个事件后输出的跳变才被认为有效。
|    0000        无滤波器采样
|    0001        采样频率 fSAMPLING = fMASTER, (N = 2)
|    0010        采样频率 fSAMPLING = fMASTER, (N = 4)
|    0011        采样频率 fSAMPLING = fMASTER, (N = 8)
|    0100        采样频率 fSAMPLING = fMASTER / 2, (N = 6)
|    0101        采样频率 fSAMPLING = fMASTER / 4, (N = 8)
|    0110        采样频率 fSAMPLING = fMASTER / 8, (N = 6)
|_____________________________________________________________|



| //TIM1_CCMRx 双面侠（输入捕获 输出比较 ）
|_____________________________________________________________
|  STM8单片机TIM1_CCMR1捕获/比较模式寄存器1（输入捕获模式）
|  IC1F[7:4]    //特定通道采样率及滤波器
|  IC1PSC[3:2]  //
|  IC1S[1:1]    //
|____________________________________________________________|
|____________________________________________________________|
|  STM8单片机TIM1_CCMR1捕获/比较模式寄存器1（输出比较模式）
|  OC1CE[7]     //
|  OC1M[6:5]    //
|  OC1PE[3]     //
|  OC1FE[2]     //
|  OC1S[1:0]    //
|_____________________________________________________________




/*******************************************************************************
                             timer1 高级定时器模式选择
*******************************************************************************/
|
| //TIM1高级定【普通模式】 计数功能初始化 
| 如果是“禁止了触发模式控制器”和“外部触发输入”的情况即（从模式式控制器
| TIM1_SMCR寄存器中的“SMS”位为“000”， 外部触发寄存器TIM1_ETR中的
| “ECE”位为“0”）。这种情况下TIM1资源就是“普通模式”
|【1】 配置预分频寄存器TIM1_PSCR[15:0]
|【2】 配置自动重装载寄存器TIM1_ARR[15:0]
|【3】 配置计数寄存器TIM1_CNTR[15:0]
|【4】 开启TIM1更新事件中断使能，即TIM1_IER寄存器UIE位为“1”
|【5】 使能计数器功能，即配置TIM1_CR1寄存器CEN位为“1”
|【6】 在主程序中“开启总中断”，即降低主程序软件优先级asm("rim")
|______________________________________________________________
// th   TIM1_PSCR预分频寄存器高8位
// tl   TIM1_PSCR预分频寄存器低8位
// arr  TIM1_ARR[15:0]自动重装载寄存器
void timer1(uint8_t th, uint8_t tl, uint16_t arr)
{
        TIM1_PSCRH = th;                //配置预分频系数高位
        TIM1_PSCRL = tl;                //配置预分频系数低位
        TIM1_IER   = 0x01;              //开启溢出中断
        TIM1_ARRH  = (arr >> 8);        //配置自动重装载寄存器
        TIM1_ARRL  = (arr & 0x00FF);
        TIM1_CNTRH = (arr >> 8);        //配置计数寄存器初值
        TIM1_CNTRL = (arr & 0x00FF);
}
|______________________________________________________________
|                                                             |
|                                                             |
|                //TIM1高级定时器【模式1】 计数功能初始化           |
|_____________________________________________________________|
|【1】 设置特定通道采样率及滤波器，即TIM1_CCMR寄存器“ICiF[3:0]”      |
|【2】 设置外部信号边沿极性，即TIM1_CCER寄存器“CCiP”                |
|【3】 设置同步计数器触发输入源，即TIM1_SMCR寄存器“TS[2:0]”          |
|【4】 设置外部时钟源模式式1方式计数，即TIM1_SMCR寄存器“SMS[2:0]      |
|【5】 使能计数器，即配置TIM1_CR1寄存器的“CEN”位                    |
|_____________________________________________________________|
|               //TIM1_CH1(定时器1输入捕获通道1)
//TIM1高级定时器【模式1】
//设置输入捕获的引脚为“上拉输入方式”
void timer1_init(void)
{
        //配置输入捕获通道CH1滤波参数“IC1F[3:0]=0011”
        TIM1_CCMR1 |= 0x30;
        //配置边沿检测器极性（低电平或下降沿）“CC1P=1”
        TIM1_CCER1  = 0x02;
        //配置同步计数器的触发输入“TS[2:0]=101”
        TIM1_SMCR  |= 0x50;
        //配置从模式选择“SMS[2:0]=111”
        TIM1_SMCR  |= 0x07;
        //使能TIM1计数器功能“CEN=1”
        TIM1_CR1   |= 0x01;
}

|_____________________________________________________________|
|                                                             |
|                                                             |
|                //TIM1高级定时器【模式2】 计数功能初始化           |
|_____________________________________________________________|
|【1】 设置外部信号触发极性，即配置TIM1_ETR寄存器的“ETP”位           |
|【2】 设置信号预分频，即配置TIM1_ETR寄存器的“ETPS[1:0]”位          |
|【3】 设置信号采样率及滤波器，即配置TIM1_ETR寄存器的“ETF[3:0]”位    |
|【4】 使能外部时钟源模式2方式计数，即配置TIM1_ETR寄存器的“ECE”位     |
|【5】 使能计数器，即配置TIM1_CR1寄存器的“CEN”位                   |
|_____________________________________________________________|





/*******************************************************************************
                            timer1 输入捕获之周期测量
*******************************************************************************/
TRC     //来源于TIM5或TIM6级连的同步信号 
当发生捕获事件，状态寄存器1（TIM1_SR1）中相应的“CCxIF”标志位被置“1”，表示计数值已经被捕获（
复制）到捕获/比较寄存器（TIM1_CCRx）中了。 如果中断使能寄存器（TIM1_IER）中的“CCxIE”位被置
“1”，也就是使能相关捕获/比较事件的中断，就会主生中断请求。状态寄存器1（TIM1_SR1）中的“CCxIF”
标志位置“1”后，如果又发生了一次捕获事件，那么此时状态寄存器2（TIM1_SR2）中的“CCxOF”标志位会被 
置“1”，以表示 发生了“重复”捕获事件。



                     //STM8测量脉冲宽度
_______________________________________________________________
【1】设置具体的输入通道
//CC1通道被配置为输入，IC1映射在TI1FP1上“CC1S[1:0]=01”
        TIM1_CCMR1 |= 0x01;
【2】设置信号采样率及滤波器
//配置采样率为主时钟频率，无滤波器“IC1F[3:0]=0000”
        TIM1_CCMR1 &= 0x0F;
【3】设置信号边沿极性
//配置信号边沿极性为TI1F或TI2F的低电平或下降沿“CC1P=1”
        TIM1_CCER1 |= 0x02;
【4】设置信号预分频因子
//配置输入捕获1通道预分频因子为8分频“IC1PSC=11”
        TIM1_CCMR1 |= 0x0C;

             预分频因子 * 计数器时钟频率
f外部信号  = _________________________
              二次捕获值 - 一次捕获值

【5】使能捕获功能和计数器
//如果用户需要可以开启捕获中断，配置方法是将中断使能寄存器（TIM1_IER）
//中的“CCxIE”位置“1”即可。
        TIM1_CCER1 |= 0x01;     //使能TIM1_CH1输入捕获功能“CC1E=1”
        TIM1_CR1   |= 0x01;     //使能TIM1计数器功能“CEN=1”
【6】状态标志位：CCxIF
//如果选定TIM1_CH1通道作为信号的输入通道，则对应的捕获标志位就是“CC1IF”，
//以查询法为例，要获取当前的捕获状态就是对“CC1IF”位取值进行判断，这个关键
//的寄存器就在TIM1的状态寄存器中（TIM1_SR1），当捕获事件发生时该位由硬件
//置“1”，它由软件清“0”或通过读取捕获/比较寄存器1（TIM1_CCR1L）清“0”
TIM1_CCR1H  = 0x00;                     //清除捕获/比较寄存器1高 8 位
TIM1_CCR1L  = 0x00;                     //清除捕获/比较寄存器1低 8 位
TIM1_CCER1 |= 0x01;                     //使能捕获功能 
while ((TIM1_SR1 & 0x02) == 0);         //等待捕获寄存器1标志位“CC1IF”变为“1”
frist_val   = (uint16_t)TIM1_CCR1H << 8;//取回捕获/比较寄存器的高8位
frist_val  |= TIM1_CCR1H;               //取回捕获/比较寄存器的低8位+高8位
while ((TIM1_SR1 & 0x02) == 0);         //等待捕获寄存器1标志位“CC1IF”变为“1”
second_val  = (uint16_t)TIM1_CCR1L << 8;//取回捕获/比较寄存器的高8位
second_val  = TIM1_CCR1L;               //取回捕获/比较寄存器的低8位+高8位
TIM1_CCER1 &= 0xFE;                     //禁止捕获/比较寄存器
SYS_NUM     = second_val - first_val;   //得到信号周期计数值
frequency   = (8 * SYS_CLOCK) / SYS_NUM;//计算频率值



/*******************************************************************************
                            timer1 输入捕获之占空比测量
*******************************************************************************/
SMS[2:0] = 100		//复位触发模式，用于占空比的测量
TS       = TI1FP        //
 //占空比测量功能配置流程
___________________________________________________________________
【1】 设置具体的输入信号通道，TIM1_CCMRx寄存器CCiS[1:0]
【2】 设置A路信号的边沿极性，TIM1_CCERx寄存器CCiP位
【3】 设置另一路输入信号通道，TIM1_CCMRx寄存器CCiS[1:0]
【4】 设置B路信号的边沿极性，TIM1_CCERx寄存器CCiP位
【5】 选择复位触发信号及复位触发模式，TIM1_SMCR寄存器的“TS=TI1FP”和“SMS=100”位
【6】 按需使能两路信号的输入捕获功能，即TIM1_CCERx寄存器的“CCiE”
【7】 使能计数器
___________________________________________________________________
//CC1通道被配置为输入，IC1映射在TI1FP1上“CC1S[1:0]=01”
TIM1_CCMR1      |= 0x01;
//配置TI1FP1信号边沿极性为上升沿“CC1P=0x0”
TIM1_CCER1      &= FD;


//CC2通道被配置为输入，IC2映射在TI1FP2上“CC2S[1:0]=10”
TIM1_CCMR2      |= 0x02;
//配置TI1FP2信号边沿极性为下降沿“CC2P=0x1”
TIM1_CCER1      |= 20;


//配置触发输入信号为TI1FP1， “TS【2：0】=101”
TIM1_SMCR       |= 0x50;
//配置触发模式为，复位触发，“SMS【2：0】=100”
TIM1_SMCR       |= 0x04;


//使能捕获功能“CC1E=1，CC2E=1”
TIM1_CCER1      |= 0x11;
//使能TIM1计数器功能“CEN=1”
TIM1_CR1        |= 0x01;
___________________________________________________________________
TIM1_SR1        &= 0xF9;                        //清除 CC1IF, CC2IF 标志位
TIM1_SR2        &= 0xFD;                        //清除 CC1OF 标志位
TIM1_CCER1      |= 0x11;                        //捕获功能使能“CC1E=1，CC2E=1”
while ((TIM1_SR1 & 0x02) == 0);                 //等待捕获比较 1 标志位 CC1IF变为“1”（第1个上升沿）A点
while ((TIM1_SR1 & 0x04) == 0);                 //等待捕获比较 2 标志位 CC2IF变为“1”（第1个下降沿）B点
A_NUM            = (uint16_t)TIM1_CCR2H << 8;   //取回捕获/比较寄存器 2 高 8位
A_NUM           |= TIM1_CCR2L;                  //取回捕获/比较寄存器 2 低 8位与高8位合并
while ((TIM1_SR2 & 0x02) == 0);                 //等待重复捕获比较 1 标志位 CC1OF变为“1”（第2个上升沿）C点
B_NUM            = (uint16_t)TIM1_CCR1H << 8;   //取回捕获/比较寄存器 1 高 8位
B_NUM           |= CCR1L;                       //取回捕获/比较寄存器 1 低 8位与高8位合并
TIM1_CCER1      &= 0xEE;                        //捕获功能禁止“CC1E=0，CC2E=0”
F_NUM            = SYS_CLOCK / B_NUM;           //计算实则频率
DUTY             = (A_NUM * 10000 / B_NUM);     //计算占空比

