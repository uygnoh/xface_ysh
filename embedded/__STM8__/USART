/*******************************************************************************
        => STM8S__UART__
*******************************************************************************/
UART1_CR1     = 0x00;
//_______________________________________________________//
R8    = 0       //接收数据不存在第9位
T8    = 0       //发送数据不存在第9位
UARTD = 0       //使能UART
M     = 0       //一个起始位，8个数据位，n个停止位
                //n取决于UART1_CR3中的（STOP[1:0]）位
WAKE  = 0       //UART被空闲总线唤醒
PCEN  = 0       //奇偶校验控制被禁用（UART模式）
PS    = 0       //偶校验（校验功能未启用）
PIEN  = 0       //校验中断被禁止
//_______________________________________________________//


UART1_CR2     = 0x00;
//_______________________________________________________//
TIEN[7]         //数据发送到移位寄存器上了，但是还没有发送到总线上
TCIEN[6]        //数据已经发送到总线上了，数据发送完成（一般只配置这一位）
RIEN[5]         //接收中断使能
TEN[3]          //接收使能
REN[2]          //发送使能


UART1_CR3     = 0x00;
//_______________________________________________________//
bit[7]          //保留
LINEN           //
STOP[5:4]       //00,1个停止位 （01,保留） （10,2个停止位） （11,1.5个停止位）
CLKEN           //用于同步通信
CPOL            //时钟极性
CPHA            //时钟相位
LBCL            //时钟脉冲
//_______________________________________________________//



UART1_SR
//_______________________________________________________//
TXE             //1_表示数据已经被转移到了移位寄存器中（容易发生首字节丢失！！！）
TC              //1_表示数据已经发送到总线上了（发送完成）
RXNE            //
IDLE            //
OR/LHE          //
NF              //
FE              //
PE              //在接收模式下，如果出现奇偶校验错误，硬件对该位置“1”
                //在清除“PE”位之前，软件必须等待“RXNE”标志位被置“1”             
                //0（未发生校验错误）
//_______________________________________________________//




/*******************************************************************************
        => STM8S__UART程序__
*******************************************************************************/
void uart_tx(uint8_t dat)
{
        UART1_SR &= 0xBF;               //清零发送完成标志位（TC）
        UART1_DR = dat;                 //发送数据到UART1数据寄存器
        while (!(UART1_SR & 0x40));     //等待发送完成（判断TC位）
        UART1_SR &= 0xBF;               //清零发送完成标志位（TC）
}

uint8_t uart_rx(void)
{
        uint8_t rx_buf;                 //定义数据暂存变量
        while (!(UART1_SR & 0x20));     //主动查询“RXNE”位状态是否为1
        UART1_SR &= 0xDF;               //清零“RXNE”状态标志位
        rx_buf = UART1_DR;              //从数据寄存器中取回数据
        return rx_buf;                  //将取出数据作为返回参数
}

#pragma vector=0x17
__interrupt void UART1_RX_IRQHandler(void)
{
        if (UART1 & 0x20) {             //判断“RXNE”位状态是否为1
                UART1_SR &= 0xDF;       //清零“RXNE”状态标志位
                rx_buf = UART1_DR;      //把接收到的数据保存到rx_buf中
        }
}
