############################################################
### % SPI_25AA020A_2Kbit(Microchip)
############################################################
// % SPI_25AA020A引脚定义
______________________________________
SCK                 % 串行时钟线
SI                  % 串行数据输入
SO                  % 串行数据输出
CS                  % 片选信号线
HOLD                % 保持输入
WP                  % 写保护
______________________________________ 


// % SPI_25AA020A引地址定义
______________________________________ 
0                   % 器件地址
1 0x00h~0xffh       % 25AA020A内部器件地址范围
______________________________________ 


// % SPI_25AA020A指令集 宏定义
__________________________________________________________ 
#define READ    0x03    /* % 从所选地址开始 从存储器陈列读数据 */
#define WRITE   0x02    /* % 从所选地址开始 向存储器陈列写数据 */
#define WREN    0x06    /* % 置 1写使能锁存器    (使能写操作) */
#define WRDI    0x04    /* % 复位写使能使能锁存器 (禁止写操作) */
#define RDSR    0x05    /* % 读STATUS寄存器 */
#define WRSR    0x01    /* % 写STATUS寄存器 */
__________________________________________________________ 



############################################################
### % SPI_25AA020A 底层驱动
############################################################
/* % 高位在前， 低位在后 */
/* % 写入一个字节数据， 从机在上升没采样， 在上升沿之前“主机”要把数据准备好 */
void spi_write_byte(uint8_t dat)
{
    for (i = 0; i < 8; i++)
    {
        SCK = 0;                    /* % 时钟线拉低 */
        if ((dat & 0x80) == 0x80)   /* % 判断当前传输位是“1”还是“0” */
        {                            /* % 从最高位开始 */   
            DI = 1;                 /* % 先把数据准备好 */
        }
        else
        {
            DI = 0;                 /* % 先把数据准备好 */
        }
        dat <<= 1;                  /* % 准备下一个数据位 */
        SCK = 1;                    /* % 上升沿，数据采样 */
    }
}


/* % 高位在前， 低位在后 */
/* % 读入一个字节数据， 主机在上升沿采样， 在上升沿之前“从机”要把数据准备好 */
uint8_t spi_read_byte(void)
{
    uint8_t i, dat;
    for (i = 0; i < 8; i++)
    {
        SCK = 0;        /* % 时钟下降沿期间，从机准备好数据 */
        SCK = 1;        /* % 来一个上升沿，主机采样总线上的数据 */
        dat <<= 1;
        if (DO == 1)
        {
            dat |= 0x01;
        }
        else
        {
            dat &= ~0x01;
        }
    }
    return dat;  
}



############################################################
### % SPI_25AA020A 器件操作
############################################################
/* % 置 1写使能锁存器  (使能写操作) */
void eeprom_wrirte_enable(void)
{
    CS = 0;
    spi_write_byte(WREN);
    CS = 1;
}


/* % 向eeprom中读出一个字节数据 */
uint8_t eeprom_read_byte(uint8_t addr)
{
    uint8_t dat;
    CS = 0;                 /* % 片选信号 */
    spi_write_byte(READ);   /* % 写入“读”命令 */
    spi_write_byte(addr);   /* % 写入要读的地址 */
    dat = spi_read_byte();  /* % 返回读出的字节 */
    CS = 1;                 /* % 片选信号 */
}


/* % 向eeprom中写入一个字节数据 */
void eeprom_write_byte(uint8_t addr, uint8_t dat)
{
    uint8_t state;
    eeprom_wrirte_enable(); /* % 在准备写入数据之前，要(使能写操作) */
    
    CS = 0;
    spi_write_byte(WRITE);  /* % 写入“写”命令 */
    spi_write_byte(addr);   /* % 写入地址 */
    spi_write_byte(dat);    /* % 写入数据 */
    
    /* % 在写周期中，也可以读STATUS寄存器的状态 */  
    while (1)
    {
        CS = 0;
        spi_write_byte(RDSR);   /* % 写入的指令，是读状态寄存器的指令 */
        state = spi_read_byte();/* % 读出状态寄存器中的内容 */
        if ((state & 0x01) == 0)/* % 读出状态寄存器中的最低位为“1”，则没有写完 */
        {
            break;
        }
        CS = 1;
    }
              
    CS = 1;
}



