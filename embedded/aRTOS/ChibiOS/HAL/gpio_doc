/*******************************************************************************
        => chibios__PAL__
        http://wiki.csie.ncku.edu.tw/embedded/chibios
*******************************************************************************/
//_____________________________________________________________
// 推挽输出
//_____________________________________________________________
推挽输出能够输出大的电流，可以实现亮灯、驱动外部芯片等功能，下面我们以连接在
板子上PA9上的LED为例子，通过配置该IO为输出并设置输出电平为高电平来点亮这个
LED，需要用到的有palSetPad和palClearPad：
        palSetPadMode(GPIOA, 9, PAL_MODE_OUTPUT_PUSHPULL);
        palSetPad(GPIOA, 9);
        palClearPad(GPIOA, 9);

//_____________________________________________________________
// 上拉输入
//_____________________________________________________________
上拉输入常常用于检测外部按键，这里我们以链接了外部按键的PC13为例，通过配置该
IO为上拉输入并读取该IO口来检测按键，需要用到的函数是palReadPad这个宏函数：
        palSetPadMode(GPIOC, 13, PAL_MODE_INPUT_PULLUP);
        if (palReadPad(GPIOC, 13) == PAL_LOW) {
                printf("按钮被按下！\r\n");
                //等待按键释放
                while (padReadPad(GPIOC, 13) == PAL_LOW;
        }
//_____________________________________________________________
// 复用设置
//_____________________________________________________________   
对于使用硬件的I2C、SPI等设备，需要进行AF配置的，那么就需要配置为复用模式，这
里以串口为例，比如PA0和PA1作为UART4的TX和RX复用，那么可以配置如下：
        palSetPadMode(GPIOA, 0, PAL_MODE_ALTERNATE(8));
        palSetPadMode(GPIOA, 1, PAL_MODE_ALTERNATE(8));


        
/*******************************************************************************
        => ChibiOS__pal__端口抽象层（）
*******************************************************************************/
//PAL驱动程序的每个API都以前缀“pal”开头。 函数名称为驼峰式，预处理器常量为大写，变量为小写。
//在这里，我们必须花一些关于模式的话。 PAL设计用于许多微控制器，并带有一组适用于每个微控制器
//的通用模式。 ______微控制器通用模式______
        PAL_MODE_RESET                  //表示重置后状态。 请注意，此状态取决于硬件;
        PAL_MODE_UNCONNECTED            //表示未连接焊盘的安全状态，取决于硬件;
        PAL_MODE_INPUT                  //代表输入，没有上拉\下电阻;
        PAL_MODE_INPUT_PULLUP           //表示带上拉电阻的输入;
        PAL_MODE_INPUT_PULLDOWN         //表示带下拉电阻的输入;
        PAL_MODE_INPUT_ANALOG           //代表适合模拟采样的输入;
        PAL_MODE_OUTPUT_PUSHPULL        //代表具有推挽网络的输出;
        PAL_MODE_OUTPUT_OPENDRAIN       //用于带开漏网络的输出;
//当然这些模式是通用的，不能映射STM32微控制器的所有模式。因此，STM32还有一些额外的特定模式，
//可以混合到之前以获得所有需要的模式。 例如，我们有一个额外的模式来处理备用函数：
        PAL_MODE_ALTERNATE（n）。

//对于端口速度：
        PAL_STM32_OSPEED_LOWEST
        PAL_STM32_OSPEED_MID1
        PAL_STM32_OSPEED_MID2
        PAL_STM32_OSPEED_HIGHEST

//对于上拉\下行配置：
        PAL_STM32_PUPDR_FLOATING
        PAL_STM32_PUPDR_PULLUP
        PAL_STM32_PUPDR_PULLDOWN
