/*
 * FreeRTOS Kernel V10.4.6
 * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * https://www.FreeRTOS.org
 * https://github.com/FreeRTOS
 *
 */

/*
 * This is the list implementation used by the scheduler.  While it is tailored
 * heavily for the schedulers needs, it is also available for use by
 * application code.
 *
 * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
 * numeric value (xItemValue).  Most of the time the lists are sorted in
 * ascending item value order.
 *
 * Lists are created already containing one list item.  The value of this
 * item is the maximum possible that can be stored, it is therefore always at
 * the end of the list and acts as a marker.  The list member pxHead always
 * points to this marker - even though it is at the tail of the list.  This
 * is because the tail contains a wrap back pointer to the true head of
 * the list.
 *
 * In addition to it's value, each list item contains a pointer to the next
 * item in the list (pxNext), a pointer to the list it is in (pxContainer)
 * and a pointer to back to the object that contains it.  These later two
 * pointers are included for efficiency of list manipulation.  There is
 * effectively a two way link between the object containing the list item and
 * the list item itself.
 *
 *
 * \page ListIntroduction List Implementation
 * \ingroup FreeRTOSIntro
 */


#ifndef LIST_H
#define LIST_H

#ifndef INC_FREERTOS_H
    #error "FreeRTOS.h must be included before list.h"
#endif

/*
 * The list structure members are modified from within interrupts, and therefore
 * by rights should be declared volatile.  However, they are only modified in a
 * functionally atomic way (within critical sections of with the scheduler
 * suspended) and are either passed by reference into a function or indexed via
 * a volatile variable.  Therefore, in all use cases tested so far, the volatile
 * qualifier can be omitted in order to provide a moderate performance
 * improvement without adversely affecting functional behaviour.  The assembly
 * instructions generated by the IAR, ARM and GCC compilers when the respective
 * compiler's options were set for maximum optimisation has been inspected and
 * deemed to be as intended.  That said, as compiler technology advances, and
 * especially if aggressive cross module optimisation is used (a use case that
 * has not been exercised to any great extend) then it is feasible that the
 * volatile qualifier will be needed for correct optimisation.  It is expected
 * that a compiler removing essential code because, without the volatile
 * qualifier on the list structure members and with aggressive cross module
 * optimisation, the compiler deemed the code unnecessary will result in
 * complete and obvious failure of the scheduler.  If this is ever experienced
 * then the volatile qualifier can be inserted in the relevant places within the
 * list structures by simply defining configLIST_VOLATILE to volatile in
 * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
 * If configLIST_VOLATILE is not defined then the preprocessor directives below
 * will simply #define configLIST_VOLATILE away completely.
 *
 * To use volatile list structure members then add the following line to
 * FreeRTOSConfig.h (without the quotes):
 * "#define configLIST_VOLATILE volatile"
 */
#ifndef configLIST_VOLATILE
    #define configLIST_VOLATILE
#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */

/* *INDENT-OFF* */
#ifdef __cplusplus
    extern "C" {
#endif
/* *INDENT-ON* */

/* Macros that can be used to place known values within the list structures,
 * then check that the known values do not get corrupted during the execution of
 * the application.   These may catch the list data structures being overwritten in
 * memory.  They will not catch data errors caused by incorrect configuration or
 * use of FreeRTOS.*/
#if ( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
        /* Define the macros to do nothing. */
        #define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
        #define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
        #define listFIRST_LIST_INTEGRITY_CHECK_VALUE
        #define listSECOND_LIST_INTEGRITY_CHECK_VALUE
        #define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
        #define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
        #define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
        #define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
        #define listTEST_LIST_ITEM_INTEGRITY( pxItem )
        #define listTEST_LIST_INTEGRITY( pxList )
#else /* if ( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 ) */


        /* Define macros that add new members into the list structures. */
        #define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE                      \
                                        (TickType_t xListItemIntegrityValue1;)
        #define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE                     \
                                        (TickType_t xListItemIntegrityValue2;)
        #define listFIRST_LIST_INTEGRITY_CHECK_VALUE                           \
                                        (TickType_t xListIntegrityValue1;)
        #define listSECOND_LIST_INTEGRITY_CHECK_VALUE                          \
                                        (TickType_t xListIntegrityValue2;)
                                        
        /* Define macros that set the new structure members to known values. */
        #define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )        \
                (pxItem)->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
        #define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )       \
                ( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
        #define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )                 \
                ( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
        #define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )                 \
                ( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE

/* Define macros that will assert if one of the structure members does not
 * contain its expected value. */
    #define listTEST_LIST_ITEM_INTEGRITY( pxItem )    configASSERT(            \
    ((pxItem)->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE) &&         \
    ((pxItem)->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE) )
    #define listTEST_LIST_INTEGRITY( pxList )         configASSERT(            \
    ((pxList)->xListIntegrityValue1     == pdINTEGRITY_CHECK_VALUE) &&         \
    ((pxList)->xListIntegrityValue2     == pdINTEGRITY_CHECK_VALUE) )          \
#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */


/*
 * Definition of the only type of object that a list can contain.
 */
struct xLIST;
struct xLIST_ITEM {

        listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE   
        configLIST_VOLATILE TickType_t xItemValue;
                 
        struct xLIST_ITEM * configLIST_VOLATILE         pxNext;
        struct xLIST_ITEM * configLIST_VOLATILE         pxPrevious;
        void *                                          pvOwner; 
        struct xLIST * configLIST_VOLATILE              pxContainer;
        
        listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
};
typedef struct xLIST_ITEM ListItem_t;

struct xMINI_LIST_ITEM {
        listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
        configLIST_VOLATILE TickType_t                  xItemValue;
        struct xLIST_ITEM * configLIST_VOLATILE         pxNext;
        struct xLIST_ITEM * configLIST_VOLATILE         pxPrevious;
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;


typedef struct xLIST {
        listFIRST_LIST_INTEGRITY_CHECK_VALUE
        volatile UBaseType_t                            uxNumberOfItems;
        ListItem_t * configLIST_VOLATILE                pxIndex; 
        MiniListItem_t                                  xListEnd;
        listSECOND_LIST_INTEGRITY_CHECK_VALUE
} List_t;


//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listSET_LIST_ITEM_OWNER(pxListItem, pxOwner)          \
                ((pxListItem)->pvOwner = (void *)(pxOwner))

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listGET_LIST_ITEM_OWNER(pxListItem)                   \
                ((pxListItem)->pvOwner)

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listSET_LIST_ITEM_VALUE(pxListItem, xValue)           \
                ((pxListItem)->xItemValue = (xValue))

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listGET_LIST_ITEM_VALUE(pxListItem)                   \
                ((pxListItem)->xItemValue)

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxList)              \
                (((pxList)->xListEnd).pxNext->xItemValue)

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listGET_HEAD_ENTRY( pxList )                          \
                (((pxList)->xListEnd).pxNext)

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listGET_NEXT(pxListItem)                              \
                ((pxListItem)->pxNext)

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listGET_END_MARKER(pxList)                            \
                ((ListItem_t const *)(&((pxList)->xListEnd)))

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listLIST_IS_EMPTY(pxList)                             \
             (((pxList)->uxNumberOfItems == (UBaseType_t)0) ? pdTRUE : pdFALSE)

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listCURRENT_LIST_LENGTH(pxList)                       \
                ((pxList)->uxNumberOfItems)

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listGET_OWNER_OF_HEAD_ENTRY(pxList)                   \
                ((&((pxList)->xListEnd))->pxNext->pvOwner)

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listIS_CONTAINED_WITHIN(pxList, pxListItem)           \
                (((pxListItem)->pxContainer == (pxList)) ? (pdTRUE) : (pdFALSE))

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listLIST_ITEM_CONTAINER(pxListItem)                   \
                ((pxListItem)->pxContainer)

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listLIST_IS_INITIALISED(pxList)                       \
                ((pxList)->xListEnd.xItemValue == portMAX_DELAY)



//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listINSERT_END(pxList, pxNewListItem)                 \
{                                                               \
        ListItem_t * const pxIndex = (pxList)->pxIndex;         \
                                                                \
        listTEST_LIST_INTEGRITY((pxList));                      \
        listTEST_LIST_ITEM_INTEGRITY((pxNewListItem));          \
                                                                \
        (pxNewListItem)->pxNext = pxIndex;                      \
        (pxNewListItem)->pxPrevious = pxIndex->pxPrevious;      \
                                                                \
        pxIndex->pxPrevious->pxNext = (pxNewListItem);          \
        pxIndex->pxPrevious = (pxNewListItem);                  \
                                                                \
        (pxNewListItem)->pxContainer = (pxList);                \
                                                                \
        ((pxList)->uxNumberOfItems)++;                          \
}

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listREMOVE_ITEM( pxItemToRemove )                     \
{                                                                              \
        List_t * const pxList = (pxItemToRemove)->pxContainer;                 \
        (pxItemToRemove)->pxNext->pxPrevious = (pxItemToRemove)->pxPrevious;   \
        (pxItemToRemove)->pxPrevious->pxNext = (pxItemToRemove)->pxNext;       \
        if (pxList->pxIndex == (pxItemToRemove))                               \
        {                                                                      \
                pxList->pxIndex = (pxItemToRemove)->pxPrevious;                \
        }                                                                      \
                                                                               \
        (pxItemToRemove)->pxContainer = NULL;                                  \
        (pxList->uxNumberOfItems)--;                                           \
}

//_____________________________________________________________
//      =>
//_____________________________________________________________
#define listGET_OWNER_OF_NEXT_ENTRY(pxTCB, pxList)            \
{                                                                                 \
        List_t * const pxConstList = (pxList);                                    \
        (pxConstList)->pxIndex = (pxConstList)->pxIndex->pxNext;                  \
        if ((void *)(pxConstList)->pxIndex == (void *)&((pxConstList)->xListEnd)) \
        {                                                                         \
                (pxConstList)->pxIndex = (pxConstList)->pxIndex->pxNext;          \
        }                                                                         \
        (pxTCB) = (pxConstList)->pxIndex->pvOwner;                                \
}



//______________________________________________________________________________
//      =>
//______________________________________________________________________________
void vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;

void vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;

void vListInsert( List_t * const pxList,
                ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;


void vListInsertEnd( List_t * const pxList,
                ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;


UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;


/* *INDENT-OFF* */
#ifdef __cplusplus
    }
#endif
/* *INDENT-ON* */

#endif /* ifndef LIST_H */
