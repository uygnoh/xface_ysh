/*******************************************************************************
        => https://www.silabs.com/       (freeysh)(weihong)
*******************************************************************************/
        Assingned               // 分配
        Resume                  // 恢复
        Pending                 // 请求
        OSTCBFreeList           // 它指向TCB的_空闲链表(单链表结构)
        OSTCBList               // 它指向TCB的_就绪链表(双链表结构)
        OSLockNesting           // 调度器锁
        OSIntNesting            // 中断嵌套层数
        Mutex PIP               // 互斥信号量的进程提升优先级


// uCOS-II 全局变量 //
OS_EXT  INT32U  OSCtxSwCtr;     // Counter of number of context switches
OS_EXT  INT8U   OSIntNesting;   // 中断嵌套层数
OS_EXT  INT8U   OSLockNesting;  // Multitasking lock nesting level
OS_EXT  INT8U   OSPrioCur;      // 当前任务的优先级
OS_EXT  INT8U   OSPrioHighRdy;  // 在就绪列表中最高的优先级任务
OS_EXT  OS_PRIO OSRdyGrp;       // 就绪组
OS_EXT  OS_PRIO OSRdyTbl[Y];    // 就绪表
OS_EXT  OS_TCB  *OSTCBCur;      // Pointer to currently running TCB 
OS_EXT  OS_TCB  *OSTCBFreeList; // Pointer to list of free TCBs 
OS_EXT  OS_TCB  *OSTCBHighRdy;  // Pointer to highest priority TCB R-to-R
OS_EXT  OS_TCB  *OSTCBList;     // Pointer to doubly linked list of TCBs 


        // 所有的任务控制块TCB都是存放在 任务控制块列表数组OSTCBTbl[] 中，
        // 系统通过任务控制块优先级表OSTCBPrioTbl[]  查询到任务控制块的地址
        
        // 任务控制块优先级表OSTCBPrioTbl[]   是以任务为索引，里面保存的
        // 是任务0到最大任务的任务控制块的首地址，据此可以通过任务优先级号快
        // 速找到当前任务在任务控制块中的首地址，而不必到任务控制块链表中去一
        // 步一步查找，加快了任务的切换时间，提高了操作系统的效率.

        //  任务控制块优先级表
        OS_EXT  OS_TCB  *OSTCBPrioTbl[OS_LOWEST_PRIO + 1u];
        // 任务控制块表
        OS_EXT  OS_TCB   OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];



/*******************************************************************************
        => uCOS-II 中奇怪的对称代码
*******************************************************************************/
        // 是为了防止长时间的关中断，影响操作系统的实时性
        // 任务上锁是为了让别的任务不能获得执行权
        // 调度器上锁
        if (OSLockNesting < 255) {
                OSLockNesting++;
        }
        OS_EXIT_CRITICAL();     
        OS_Dummy();
        OS_ENTRY_CRITICAL();
        // 调度器开锁
        if (OSLockNesting > 0) {
                OSLockNesting--;
        }



/*******************************************************************************
        => uCOS-II 任务状态
*******************************************************************************/
1 // __睡眠态__
任务已经被装入内存了，可是并没有准备好运行。 例如上面给出的usertask
代码，以代码的形式存在于内存中，在调用OSTaskCreate()任务创建函数之
前，处于睡眠态。 睡眠态的任务不会得到运行的，操作系统也不会给其设置为
运行而准务的数据结构。


2 // __就绪态__
当操作系统调用OSTaskCreate创建一任务后，任务就进入就绪态。从图中
可以看出，任务也可以从其它状态转换到就绪态。处于就绪态的任务操作系统
已经为其运行配置好了任务控制块等数据结构，当没有比其更高优先级的任务
或比其更高的任务处于阻塞状态的时候，就能被操作系统调度而进入运行态。
从就绪态到运行态，操作系统调用任务切换函数完成。


3 // __运行态__
任务真正占有CPU使用权，得到运行。这时运行的代码就是任务的代码。如
usertask。处于运行态的任务如果运行完成，就会转为睡眠态。如果有更
高优先级的任务抢占了CPU，就会转到就绪态。如果因为等待某一事件，例
如等待1秒钟的时间，如OSTimeDly(OS_TICKS_PER_SEC)，需要暂时放
弃CPU的使用权而让其它任务得以运行，就进入了阻塞态。当由于中断的到
来而使用CPU进入中断服务程序(ISR)，必然例正在运行的任务放弃CPU而
转入中断服务程序，这时被中断的任务就被挂起而进入挂起态。


4 // __阻塞态__
阻塞对于操作系统的调度，任务的协调运行是非常重要的。我们能看到图中
的运行结果，而不是只有一个高优先级的任务得到运行，就是因为usertask
在没有事情可做，等待1秒钟的时候，不是强行运行代码，而是把自己阻塞
起来，使操作系统可以调度其它的任务。当任务在等待某些还没有被释放的
资源，等待一定的赶时间等时候，要阻塞起来，等到条件满足的时候再重新
回到就绪态，以能被操作系统调度以进入运行态，这是实时系统必须要实现
的功能之一。


5 // __挂起态__
当任务在运行时，因为中断的发生，例如定时器中断每个时钟滴答(clock tick)
中断一次，而被剥夺CPU使用权，而进入挂起态。在中断返回的时候，若该任务还是
最高优先级的任务，就恢复运行，如果不是这样，只能回到就绪态。



/*******************************************************************************
        => uCOS-II任务切换
*******************************************************************************/
任务切换就是context switch， 是任务调度的重要部分。从字面上是上下文
切换。 任务切换是暂停一个任务的运行， 运行另一个就绪的任务。暂停一个任
务，以后以能恢复运行，必须考虑将这个任务运行的信息保存，而恢复运行的时
候需要将这些信息恢复到运行环境。
任务切换必须做环境的保存和恢复的操作。



/*******************************************************************************
        => uCOS-II 函数可重入性
*******************************************************************************/
1 // 函数可生重入性
函数可重入是指一个函数可以被多个任务调用，而不需要担心在任务切换的过程
中，代码的执行会产生错误。


2 // 函数不可生重入性
如果函数被多个任务调用，可能产生错误的结果，就是不可重入函数。


3 // 在多任务环境中，保证函数的可重入性
!不要使用           全局变量
!不要使用           静态变量
!不要使用           浮点运算库函数
!不要使用           C语言中的标准IO库函数



/*******************************************************************************
        => uCOS-II 内核
*******************************************************************************/
0 // 内核是操作系统最核心的部分，其主要的功能就是进行任务调度

1 // uCOS-II使用的是一种基于优先级的可剥型内核

3 // uCOS-II同时可以有 64 个就绪任务，每个任务都有各自的优先级



/*******************************************************************************
        => uCOS-II 同步-互斥-临界区
*******************************************************************************/
1 // 同步
任务是独立的，但是任务之间又有着各种各样的关系，以成为一个整体，来完成
某一项工作。有时候一个任务完成的前提是需要另一个任务给出一个结果，任务
之间的这种制约性的合作运行机制叫做任务间的同步。


2 // 互斥
A和B两个任务都要访问计算结果这个共享资源，但是在A写这个资源的同时，B
必须等待，而不能在A写到一半的时候结束A，而让B来读，这样会产生灾难性后
果。这样的共享资源称为临界资源( Critical Resource ).
这种访问共享资源的排它性就是互斥。


3 // 临界区
每个任务中访问共享资源的那段程序称为临界区( Critical section )，因为
共享资源的访问要互斥的。在临界区不允许任务切换，这是最根本的原则。回为如
果在访问共享资源的时候进行任务切换，这可能发生前面提到灾难性后果。因此，
在进入临界区访问共享资源之前，采用关中断，给调度器上锁或使用信号量的方法
达到互斥的目的。



/*******************************************************************************
        => uCOS-II 信号量-互斥信号量
*******************************************************************************/
1 // 信号量
在一个时刻，有些共享任务资源只可以被一个任务所占有，而有些可以被至多N个
任务所共享。前一种共享资源就好比有一把钥匙，钥匙发出去了，得到钥匙的任务
可以访问共享资源，其它请求该资源的任务必须等得到钥匙的任务把钥匙归还。
后者则可以有N把钥匙，如果N把钥匙都发完了，第N+1个请求访问共享资源的任务
就必须等待。这些钥匙就可以用信号量(semaphore)来表示。
信号量标志了共享资源的有效可被访问数量，于是要获得共享资源的访问权，就首
先要得到信号量这把钥匙。


2 // 互斥信号量
互斥信号量是一种特殊的信号量。



/*******************************************************************************
        => uCOS-II 事件-事件标志组
*******************************************************************************/
1 // 事件(Event)
事件(event)就是在操作系统运行过程中发生的事情。例如，任务被挂起，唤醒，
创建等。uCOS-II操作系统在处理任务的同步一通信等环节，大量使用了事件这
一概念，创建了事件控制块这样的数据结构以进行事件的管理。

2 // 事件标志组
在信号量和互斥信号量的管理中，任务请求资源，如果资源未被占用就可以继续
运行，否则只能阻塞，等待资源释放的事件发生。这种事件是单一的事件。如果
任务要等待多个事件发生，或多个事件中的某一个事件的发生就可以继续运行，
那么就应该采用事件标志组管理。
事件标志组管理的条件组合可以是多个事件都发生，也可以是多个事件中有任何
一个事件发生。尤其特别的是，还可以是多个事件都没有发生或多个事件中有任
何一相事件没有发生。



/*******************************************************************************
        => uCOS-II 消息邮箱 消息队列
*******************************************************************************/
0 // 邮箱(MailBox)，操作系统通过邮箱来管理任务间通信与同步
邮箱中的内容却不是信件本身，而是指向消息内容的地址！ 这个指针是 void类型
的，可以指向任何的数据结构。因而这样的设计更经济，所发送的信息范围也就更宽
邮箱中可以容纳下任何长度的数据了。


1 // 消息队列(message queue)
也用于给任务发送消息，但是这它是由多个消息组合形成的，是消息邮箱的集合，
实质上是消息邮箱的队列。一个消息邮箱可以容纳一条消息，采用消息队列，一
是可容纳多条消息，二是消息是有序的。
