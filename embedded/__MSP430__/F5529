/*******************************************************************************
                           UCS(Unified Clock System) 时钟系统
*******************************************************************************/
//MSP430-F5529有“5个时钟来源
___________________________________________________________
1 XT1CLK        //低频振荡器(外部)
                //MSP430F5xx/6xx系列单片机的“XT1振荡器”
                //支持LF（低频模式）和HF（高频模式）
2 VLOCLK        //内部超低功耗低频振荡器， 典型值为“12KHz”
3 REFOCLK       //内部调整低频参考振荡器， 典型值为“32768Hz”
                //REFO可以作为高精度时钟，并且可以为“FLL模块”
                //提供一个稳定的时钟源. “REFOCLK + FLL” 组合，
                //在无须外部晶振的情况下，提供了灵活的大范围系统时钟
4 DCOCLK        //内部数字时钟振荡器，可由PLL稳定后得到
5 XT2CLK        //高频振荡器(外部)


//MSP430-F5529有“5个时钟来源可以产生“3个时钟信号”
___________________________________________________________
1 ACLK          //辅助系统时钟信号
2 MCLK          //主系统时钟信号
3 SMCLK         //子系统时钟信号


//FLL“锁频环”
___________________________________________________________
FLL的参考时钟“FLLREFCLK”可以来自： XT1CLK, REFOCLK, XT2CLK 的任何
一个时钟源，通过“SELREF”控制位进行选择。 由于这3种时钟的精确度都很高，倍频
后仍然能够等到准确的频率。 FLL能够产生2种时钟信号：DCOCLK和DCOCLKDIV，其中
DCOCLKDIV信号为DCOCLK时钟经 /1/2/4/8/16/32 分频后得到（分频系数为D）
|_________________________________________________________|
|                                                         |
|                f_DCOCLK        f_FLLREFCLK              |
|              ____________  =  ______________            |
|                 D*(N+1)              n                  |
|                                                         |
|                                                         |
|      f_DCOCLK = D * (N+1) * f_FLLREFCLK/n               |
|_________________________________________________________|



//内部模块振荡器（MODOSC）
___________________________________________________________
UCS时钟模块还包含一个内部模块振荡器“MODOSC”，能够产生约“4.8MHz”的
MODCLK时钟。 Flash控制器模块，ADC_12模块等处内外设都可以使用“MODOSC”
作为内部参考时钟源。


//MSP430单片机时钟模块失效检测（XT1, XT2, DCO），可以查询这些标志位
___________________________________________________________
1 XT1LFOFFG             //XT1振荡器在低频模式（LF）失效
2 XT1HFOFFG             //XT1振荡器在高频模式（HF）失效
3 XT2OFFG               //XT2振荡器失效
4 DCOFFG                //DCO振荡器失效



//振荡器失效保护机制
___________________________________________________________
//第一种情况：
LFXT1   => MCLK/SMCLK/ACLK 
        => LFXT1自动切换到REFOCLK
//第二种情况：
XT2     => MCLK/SMCLK/ACLK 
        => XT2自动切换到DCOCLKDIV



//MSP430-UCS 时钟系统上电默认状态
___________________________________________________________
ACLK            //选择XT1CLK， XT1处于“LF模式”
                =>XT1禁用 =>ACLK的时钟源自动切换到REFOCLK(32768Hz)
___________________________________________________________
FLL默认开启      //参考时钟“FLLREFCLK”默认来自XT1CLK（LFXT1外接32768，
                //当前不工作，来自REFOCLK，也是32768Hz）          
f_DCOCLK    = D * (N+1) * (f_FLLREFCLK / n)
F_DCOCLKDIV = (N+1) * (f_FLLREFCLK / n)  
其中， D=1/2/4/8/16/32; 默认值为“2”;
      N=1~1024, 默认值为“31”;
      n=1/2/4/8/16; 默认值为“1”;
//FLL将DCO稳定到 f_DCOCLK = 2 * (31+1) * (32768 / 1) = 2097152Hz
//f_DCOCLKDIV = 2097152 / D = 2097152 / 2 = 1048576Hz
___________________________________________________________             
MCLK            //选择DCOCLKDIV = 1.048576MHz
SMCLK           //选择DCOCLKDIV = 1.048576MHz
___________________________________________________________
//启用FLL，并且将XT1CLK作为FLL参考时钟，即FLLREFCLK的时钟来自XT1CLK
XIN, XOUT       //引脚为通用IO口时， XT1保持禁用
XT2IN, XT2OUT   //引脚为通用IO口时， XT2保持禁用





//使用内部振荡器时钟源“VLO”，配置ACKL为VLOCLK（约10KHz），且将
//ACLK通过P1.0端口输出（MSP430F5529单片机中引脚P1.0和ACLK利用）
___________________________________________________________
//P1.0 --->ACLK = ~10KHz
int main(void)
{
        WDTCTL   = WDTPW + WDTHOLD;     //Stop watchdog timer
        UCSCTL4 |= SELA_1;              //VLO clock Sources ACLK
        P1DIR   |= BIT0;                //ACLK set out to pin
        P1SEL   |= BIT0;
       __bis_SR_register(LPM3_bits);    //Enter LPM3
}


//XIN和XOUT引脚接32768低频晶振，将ACLK配置为32768Hz，且将ACLK通过
//P1.0端口输出
___________________________________________________________
int main(void)
{
        WDTCTL   = WDTPW + WDTHOLD;     //Stop watchdog timer
        P1DIR   |= BIT0;                //ACLK set out to pin
        P1SEL   |= BIT0;                
        PSSEL   |= BIT4 + BIT5;         //Select XT1
        
        UCSCTL6 &= ~(XT1OFF);           //XT1 On
        UCSCTL6 |= XCAP_3;              //Internal load cap
        UCSCTL3  = 0;                   //FLL Reference clock = XT1
        //Loop until XT1, XT2 & DCO stailizes - In this case loop until XT1 and DCO settle
        do {
                UCSCTL7 &= ~(XT2OFFG + XT1LFOFFG + DCOFFG);
                                        //Clear XT2, XT1, DCO fault flags
                SERIFG1 &= ~OFIFG;      //Clear fault flags        
        } while (SFRIFG1 & OFIFG);      //Test oscillator fault flag
        
        UCSCTL6 &= ~(XT1DRIVE_3);       //Xtal is now stable, rduce drive strength
        UCSCTL4 |= SELA_0;              //ACLK = LFXT1 (by default)
        
        __bis_SR_register(LPM3_bits);   //Enter LPM3
}



/*******************************************************************************
                               MSP430-F5529 中断
*******************************************************************************/
//MSP430单片机默认是“不支持中断嵌套”。
//如果需要支持中断嵌套，则需要在所有的中断入口处加一句开中断语句“_EINT()”， 恢复总的中断允许。 
______________________________________________________________________________
#pragma vector=ADC12_VECTOR
__interrupt void ADC12_ISR(void)
{
        _EINT();                //允许中断嵌套
        switch (__even_in_range(ADC12IV, 34)) {
        case 0:  break;         //向量“0”，没有中断
        case 2:  break;         //向量“2”，ADC overflow
        case 4:  break;         //向量“4”，ADC timing overflow
        case 6:  break;         //向量“6”，ADC12IFG0
        ......
        case 32: break;         //向量“32”，ADC12IFG13
        case 34: break;         //向量“33”，ADC12IFG14
        default: break;
        }
}


/*******************************************************************************
                                UART 波特率配置
*******************************************************************************/
//初始化USCI模块分为五步
【1】 置位“UCSWRST”控制位
【2】 在“UCSWRST=1”时，初始化所有USCI寄存器（包括UCTxCTL1）
【3】 将相应的引脚端口配置为UART通信功能
【4】 软件清除“UCSWRST=0”控制位
【5】 通过设置接收或发送中断使能控制寄存器（UCRXIE和UCTXIE）或两者之一


//UCSI低频波特率
_________________________________________________________________________
【1】 “UCOS16=0”产生低频波特率模式
使用“ACLK”作为串口时钟源，波特率设置为4800bps， 在ACLK=32768Hz时产生4800波特率，
则需要的分频系数是（32768/4800）=6.83 因此整数部分为“6”，小数部分断“0.83”，将整数
部分赋给UCA0BR寄存器，调制器分频余数为（0.83 * 8）=6.64，取得接近的整数为“7”，因此
将“7”赋给UCBRS控制位。
UCA0CTL1 |= UCSSEL_1;           //串口时钟源为ACLK
UCA0BR0   = 0x06;               //整数分频系数为6
UCA0BR1   = 0x00;
UCA0MCTL |= UCBRS_7 + UCBRF_0;  //调制器分频UCBRSx=7，UCBRFx=0


//UCSI高频波特率
_________________________________________________________________________
【2】“UCOS16=1”产生高频波特率模式
使用SMCLK作为串口时钟源，波特率设置为9600bps，在SMCLK=1048576Hz时产生9600bps
需要分频系数N=104857/9600=109.23, 大于16分频，因此选择高频波特率模式，预分频
UCBR应设置为INT（N/16）=INT(6.83)=6. 调制器UCBRF应设置为（0.83*16）=13.28
取近似的整数“13”，因此将13赋给UCBRF控制位。
UCA0CTL1 |= UCSSEL_2;   //SMCLK
UCA0BR0   = 0x06;       //整数分频系数为6
UCA0BR1   = 0x00;
//调制器分频UCBRFx=13，选择高频波特率模式
UCA0MCTL  = UCBRS_0 + UCBRF_13 +UCOS16;



//采用查询方法发送和接收数据
_________________________________________________________________________
void uart_tx(char chr)
{
        UCA0TXBUF = chr;
        //等待该字节发送完成
        while (!(UCA0IFG & UCTXIFG));
}
char uart_rx(void)
{
        while (!(UCA0IFG & UCRXIFG)); //等待接收1个字节
        return(UCA0RXBUF);            //返回接收到的数据
}


//采用中断方法发送和接收数据
_________________________________________________________________________
#include <msp430f5529.h>
int main(void)
{
        P3SEL     = BIT3 + BIT4;        //P3.3， p3.4 选择串口收发功能 
        UCA0CTL1 |= UCSWRST;            //** 复位寄存器配置 **
        UCA0CTL1 |= UCSSEL_1;           //波特率发生器参考时钟选择ACLK
        UCA0BR0   = 0x0D;               //波特率设置为2400bps
        UCA0BR1   = 0x00;
        UCA0MCTL |= UCBRS_6 + UCBRF_0;  //调制器配置
        UCA0CTL1 &= ~UCSWRST;           //** 完成UCSI初始化 **
        UCA0IE    = UCRXIE + UXTXIE;    //使能接收和发送中断
        _EINT();                        //打开全局中断
        while (1) {
        }
        
        return 0;
}
#pragma vector=USCI_A0_VECTOR
__interrupt void UCSI_A0_ISR(void)
{
        switch (__even_in_range(UCA0IV, 4)) {
        case 0:
                /* 中断向量0，无中断 */
                break;
        case 2:
                /* 中断向量2，接收中断 */
                break;
        case 4:
                /* 中断向量4，发送中断 */
                break;
         default:
                break;
        }
}



/*******************************************************************************
                          MSP430F5529-UART
*******************************************************************************/
MSP430与PC上位机通信的波特率为9600bps，无校验位，数据位为8位，停止位1位，采用低频波特率模式
#include <msp430.h>
int main(void)
{
        unsigned char i;
        WDTCTL    = WDTPW + WDTHOLD;    //stop WDT
        P3SEL     = BIT3 + BIT4;        //P3.3, P3.4 = USCI_A0 TXD/RXD
        
        UCA0CTL1 |= UCSWRST;            //** Put state machine in reset **
        UCA0CTL1 |= UCSSEL_1;           //CLK = ACLK
        UCA0BR0   = 0x03;               //32KHz/9600=3.41 (see User's Guide)
        UCA0BR1   = 0x00;
        UCA0MCTL  = UCBRS_3 + UCBRF_0;  //Modulation UCBRSx=3, UCBRFx=0
        UCA0CTL  &= ~UCSWRST;           //** Initialize USCI state machine **
        UCA0IE   |= UCRXIE;             //Enable USCI_A0 interrupt
        
        __bis_SR_register(LPM3_bits + GIE);//Enter LPM3, interrupts enabled
        __no_operation();               //For debugger
}
// Echo back RXed character, cofirm TX buffer is ready first
#pragma vector=USCI_A0_VECTOR
__interrupt void USCI_A0_ISR(void)
{
        switch (__even_in_range(UCA0IV, 4) {
        case 0:
                break;
        case 2:                                 //Vector 2 ->RXIFG
                while (!(UCA0IFG & UCTXIFG));   //USCI_A0 TX buffer ready?
                UCA0TXBUF = UCA0RXBUF;          //TX -> RXed character
                break;
        case 4:                                 //Vector 4 ->TXIFG
                break;
        default:
                break;
        }
}




/*******************************************************************************
                             MSP430F5529-IIC
*******************************************************************************/
A单片机作为“主机，工作在主接收模式”， B单片机为为“从机，工作在从发送模式”。
从机接收到起始信号后，从“0x00”开始发送缓冲器中的数据，当单字节发送完毕后，会接收到主机发送的停止
信号。 在停止条件中断服务程序中，将下次发送的单字节数据自动加“1”，这样从机会不断发递增单字节数据。
主机接收从机发送的单字节数据，并且判断接收到的数据是否正确。 若正确一直接收，直到数据接收错误为止。
在数据接收错误后，置高P1.0引脚，程序while()死循环。

p3.0 sda
p3.1 scl



//程序B， 从机处于发送模式
___________________________________________________________
unsigned char TXData;
unsigned char i = 0;
int main(void)
{
        WDTCTL     = WDTPW + WDTHOLD;   //stop WDT
        
        P3SEL     |= 0x03;              //Assign IIC pins to USCI_B0
        UCB0CTL1  |= UCSWRST;           //** Enable SW reset **
        UCB0CTL0   = UCMODE_3 + UCSYNC; //IIC Slave, synchronous mode
        UCB0I2COA  = 0x48;              //Own Address is 048H
        UCB0CTL1  &= ~UCSWRST;          //** Clear SW reset, resume operation **
        UCB0IE    |= UCTXIE + UCSTTIE + UCSTPIE; //Enable TX interrupt
                                        //Enable Start condition interrupt
                                        //Enable Stop condition interrupt
                                        
        TXData     = 0;                 //Used to hold TX data
        
        __bit_SR_register(LPM0_bits + GIE);//Enter LPM0 w/ interrupts
        __no_operation();               //for debugger                                    
}
//USCI_B0 State ISR
#pragma vector=USCI_B0_VECTOR
__interrupt void USCI_B0_ISR(void)
{
        switch (__even_in_range(UCB0IV, 12) {
        case 0: break;                  //Vector 0: No interrupts
        case 2: break;                  //Vector 2: ALIFG
        case 4: break;                  //Vector 4: NACKIFG
        case 6:                         //Vector 6: STTIFG
                UCB0IFG &= ~UCSTTIFG;   //Clear start condition int flag
                break;
        case 8:                         //Vector 8: STPIFG
                TXData++;               //Increment TXData
                UCB0IFG &= ~UCSTPIFG;   //Clear stop condition int flag
                break;
        case 10: break;                //Vector 10: RXIFG
        case 12:                        //Vecotr 12: TXIFG
                UCB0TXBUF = TXData;     //TX data
                break;
        default: break;
        }
}




//程序A， 主机处于接收模式
___________________________________________________________
unsigned char RXData;
unsigned char RXCompare;
int main(void)
{
        WDTCTL    = WDTPW + PDTHOLD;    //Stop WDT
        P1OUT    &= ~0x01;              //P1.0=0
        P1DIR    |= 0x01;               //P1.0 output
        P3SEL    |= 0x03;               //Assign I2C pins to USCI_B0( P3.0, P3.1)
        UCB0CTL1 |= UCSWRST;            //** Enable SW reset **
        UCB0CTL0  = UCMST + UCMODE_3 + UCSYNC;//I2C Master, synchronous mode
        UCB0CTL1  = UCSSEL_2 + UCSWRST; //Use SMCLK
        UCB0BR0   = 12;                 //fsCL = SMCLK/12=~~100KHz
        UCB0BR1   = 0;
        UCB0I2CSA = 0x48;               //Slave Address is 048H
        UCB0CTL1 &= ~UCSWRST;           //** Clear SW reset, resume operation **
        UCB0IE   |= UCRXIE;             //Enable RX interrupt
        RXCompare = 0x00;               //Used to check incoming data
        while (1) {
                while (UCB0CTL1 & UCTXSTP);     //等待上一次停止位是否发送完成
                UCB0CTL1 |= UCTXSTT;            //IIC start condition
                while (UCB0CTL1 & UCTXSTT);     //Start condition sent?
                UCB0CTL1 |= UCTXSTP;            //I2C stop condition
                
                __bis_SR_register(LPM0_bits + GIE);//Enter LPM0, enable interrupts
                __no_operation();               //For debugger
                
                if (RXData != RXCompare) {      //Trap CPU if wrong
                        P1OUT |= 0x01;          //P1.0 = 1
                        while (1);
                }
                RXCompare++;                    //Increment correct RX value
        }
}
//USCI_B0 Data ISR
#pragma vector=USCI_B0_VECTOR
__interrupt void USCI_B0_ISR(void)
{
        switch (__even_in_range(UCB0IV, 12) {
        case 0: break;  //Vector 0: No interrupts
        case 2: break;  //Vector 2: ALIFG
        case 4: break;  //Vector 4: NACKIFG
        case 6: break;  //Vector 6: STTIFG
        case 8: break;  //Vector 8: STPIFG
        case 10:
                RXData = UCB0RXBUF; //Get RX data
                __bic_SR_register_on_exit(LPM0_bits); //Exit active CPU
                break;
        case 12: break; //Vector 12: TXIFG
        default: break;
        }
        
}



/*******************************************************************************
                             MSP430F5529-SPI
*******************************************************************************/
编程实现两块MSP430F5529单片机之间的三线制SPI通信。 其中一块单片机作为主机，另一块单片机作为从机。
主机从“0x01”开始发送递增字节，从机接收到的字节再原封不动地发送给主机，主机判断接收到的字节与之前
发送的字节是否一致。 若一致表示接收正确，使P1.0输出高电平，若接收错误，则使P1.0输出低电平。


//主机程序
___________________________________________________________
unsigned char MST_Data, SLV_Data;
unsigned char temp;
int main(void)
{
        volatile unsigned int i;
        WDTCTL  = WDTPW + WDTHOLD;      //Stop watchdog timer
        
        P1OUT   |= 0x04;                //Set p1.0 for LED
                                        //Set P1.2 for slave reset(控制从机的复位)
        P1DIR   |= 0x05;                //Set P1.0-2 to output direction
        P3SEL   |= BIT3 + BIT4;         //P3.3, P3.4 option select
        P2SEL   |= BIT7;                //P2.7 option select SPI时钟
        
        UCA0CTL1 |= UCSWRST;            //** Put state machine in reset **
        UCA0CTL0 |= UCMST + UCSYNC + UCCKPL + UCMSB; //3-pin, 8-bit SPI master
                                        //clock polarity high, MSB
        UCA0CTL1 |= UCSSEL_2;           //SMCLK
        UCA0BR0   = 0x02;               // /2
        UCA0BR1   = 0x00;
        UCA0MCTL  = 0x00;               //No modulation
        UCA0CTL1 &= ~UCSWRST;           //** Initialize USCI state machine **
        UCA0IE   |= UCRXIE;             //Enable USCI_A0 RX interrupt
        
        P1OUT    &= ~0x04;              //Now with SPI signals initialized     
        P1OUT    |= 0x04;               //reset slave
        
        for (i = 50; i > 0; i--);       //Wait for slave to initialize
        
        MST_Data = 0x01;                //Initialize data values
        SLV_Data = 0x00;                //
        
        while (!(UCA0IFG & UCTXIFG));   //USCI_A0 TX buffer ready?
        UCA0TXBUF = MST_Data;           //Transmit first character
        
        __bis_SR_register(LPM0_bits + GIE);//CPU off, enable interrupt
}
#pragma vector=USCI_A0_VECTOR
__interrupt void USCI_A0_ISR(void)
{
        volatile unsigned int i;
        switch (__even_in_range(UCA0IV, 4) {
        case 0: break; //Vector 0 - no interrupt
        case 2:        //Vector 2 - RXIFG
                while (!(UCA0IFG & UCTXIFG));   //USCI_A0 TX buffer ready?
                if (UCA0RXBUF == SLV_Data)      //Test for correct character RX'd
                        P1OUT |= 0x01;          //If correct, light LED
                else
                        P1OUT &= ~0x01;         //If incorrect, clear LED
                
                MST_Data++;
                SLV_Data++;
                UCA0TXBUF = MST_Data;           //Send next value
                
                for (i = 20; i > 0; i--);       //Add time between transmissions 
                                                //to make sure slave can process
                                                // information
                break;
        case 4: break; //Vector 4 - TXIFG
        default: break;
        }
        
}



//从机程序
___________________________________________________________
int main(void)
{
        WDTCTL      = WDTPW + WDTHOLD;  //Stop watchdog timer
        
        while (!(P2IN & 0x80));         //等待spi时钟信号到来 P2.7
        
        P3SEL   |= BIT3 + BIT4;         //P3.3, P3.4 option select
        P2SEL   |= BIT7;                //P2.7 option select, 设置为时钟线
        
        UCA0CTL1   |= UCSWRST;          //** Put state machine in reset **
        
                                        //3-pin, 8-bit SPI slave
                                        //Clock polarity high, MSB
        UCA0CTL0   |= UCSYNC + UCCKPL + UCMSB;
        
        UCA0CTL1   &= ~UCSWRST;         //**Initialize USCI state machine **
        UCA0IE     |= UCRXIE;           //Enable USCI_A0 RX interrupt
        
        __bis_SR_register(LPM4_bits + GIE);//进入低功耗模式4，使能全局中断
}
//Echo character
#pragma vector=USCI_A0_VECTOR
__interrupt void USCI_A0_ISR(void)
{
        switch (__even_in_range(UCA0IV, 4) {
        case 0: break;                       //Vector 0 - no interrupt
        case 2:                               //Vector 2 - RXIFG
                while (!(UCA0IFG & UCTXIFG)); //USCI_A0 TX buffer ready?
                UCA0TXBUF = UCA0RXBUF;
                break;
        }
        case 4: break;                        //Vector 4 - TXIFG
        default: break;
}
