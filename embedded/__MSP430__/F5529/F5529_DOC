/*******************************************************************************
        => UCS(Unified Clock System) 时钟系统
*******************************************************************************/
//MSP430-F5529有“5”个时钟来源
___________________________________________________________
1 XT1CLK        //低频振荡器(外部)
                //MSP430F5xx/6xx系列单片机的“XT1振荡器”
                //支持LF（低频模式）和HF（高频模式）
2 VLOCLK        //内部超低功耗低频振荡器， 典型值为“12KHz”
3 REFOCLK       //内部调整低频参考振荡器， 典型值为“32768Hz”
                //REFO可以作为高精度时钟，并且可以为“FLL模块”
                //提供一个稳定的时钟源. “REFOCLK + FLL” 组合，
                //在无须外部晶振的情况下，提供了灵活的大范围系统时钟
4 DCOCLK        //内部数字时钟振荡器，可由PLL稳定后得到
5 XT2CLK        //高频振荡器(外部)



//MSP430-F5529有“5个时钟来源可以产生“3个时钟信号”
___________________________________________________________
1 ACLK          //辅助系统时钟信号
2 MCLK          //主系统时钟信号
3 SMCLK         //子系统时钟信号



//FLL“锁频环”
___________________________________________________________
FLL的参考时钟“FLLREFCLK”可以来自： XT1CLK, REFOCLK, XT2CLK 的任何
一个时钟源，通过“SELREF”控制位进行选择。 由于这3种时钟的精确度都很高，倍频
后仍然能够等到准确的频率。 FLL能够产生2种时钟信号：DCOCLK和DCOCLKDIV，其中
DCOCLKDIV信号为DCOCLK时钟经 /1/2/4/8/16/32 分频后得到（分频系数为D）
|_________________________________________________________|
|                                                         |
|                f_DCOCLK        f_FLLREFCLK              |
|              ____________  =  ______________            |
|                 D*(N+1)              n                  |
|                                                         |
|                                                         |
|      f_DCOCLK = D * (N+1) * f_FLLREFCLK/n               |
|_________________________________________________________|



//内部模块振荡器（MODOSC）
___________________________________________________________
UCS时钟模块还包含一个内部模块振荡器“MODOSC”，能够产生约“4.8MHz”的
MODCLK时钟。 Flash控制器模块，ADC_12模块等处内外设都可以使用“MODOSC”
作为内部参考时钟源。



//MSP430单片机时钟模块失效检测（XT1, XT2, DCO），可以查询这些标志位
___________________________________________________________
1 XT1LFOFFG             //XT1振荡器在低频模式（LF）失效
2 XT1HFOFFG             //XT1振荡器在高频模式（HF）失效
3 XT2OFFG               //XT2振荡器失效
4 DCOFFG                //DCO振荡器失效



//振荡器失效保护机制
___________________________________________________________
//第一种情况：
LFXT1   => MCLK/SMCLK/ACLK 
        => LFXT1自动切换到REFOCLK
//第二种情况：
XT2     => MCLK/SMCLK/ACLK 
        => XT2自动切换到DCOCLKDIV



//MSP430-UCS 时钟系统上电默认状态
___________________________________________________________
ACLK            //选择XT1CLK， XT1处于“LF模式”
                =>XT1禁用 =>ACLK的时钟源自动切换到REFOCLK(32768Hz)
___________________________________________________________
FLL默认开启      //参考时钟“FLLREFCLK”默认来自XT1CLK（LFXT1外接32768，
                //当前不工作，来自REFOCLK，也是32768Hz）          
f_DCOCLK    = D * (N+1) * (f_FLLREFCLK / n)
F_DCOCLKDIV = (N+1) * (f_FLLREFCLK / n)  
      “D”   = 1/2/4/8/16/32;        默认值为（2） 
      “N”   = 1~1024,               默认值为（31） 
      “n”   = 1/2/4/8/16;           默认值为（1） 
//FLL将DCO稳定到 f_DCOCLK = 2 * (31+1) * (32768 / 1) = 2097152Hz
//f_DCOCLKDIV = 2097152 / D = 2097152 / 2 = 1048576Hz
___________________________________________________________             
MCLK            //选择DCOCLKDIV = 1.048576MHz
SMCLK           //选择DCOCLKDIV = 1.048576MHz
___________________________________________________________
//启用FLL，并且将XT1CLK作为FLL参考时钟，即FLLREFCLK的时钟来自XT1CLK
XIN, XOUT       //引脚为通用IO口时， XT1保持禁用（默认状态）
XT2IN, XT2OUT   //引脚为通用IO口时， XT2保持禁用（默认状态）




___________________________________________________________
//使用内部振荡器时钟源“VLO”，配置ACKL为VLOCLK（约10KHz），且将
//ACLK通过P1.0端口输出（MSP430F5529单片机中引脚P1.0和ACLK利用）
___________________________________________________________
//P1.0 --->ACLK = ~10KHz
int main(void)
{
        WDTCTL   = WDTPW + WDTHOLD;     //Stop watchdog timer
        UCSCTL4 |= SELA_1;              //VLO clock Sources ACLK
        P1DIR   |= BIT0;                //ACLK set out to pin
        P1SEL   |= BIT0;
       __bis_SR_register(LPM3_bits);    //Enter LPM3
}



___________________________________________________________
//XIN和XOUT引脚接32768低频晶振，将ACLK配置为32768Hz，
//且将ACLK通过P1.0端口输出
___________________________________________________________
int main(void)
{
        WDTCTL   = WDTPW + WDTHOLD;     //Stop watchdog timer
        P1DIR   |= BIT0;                //ACLK set out to pin
        P1SEL   |= BIT0;                
        PSSEL   |= BIT4 + BIT5;         //Select XT1
        
        UCSCTL6 &= ~(XT1OFF);           //XT1 On
        UCSCTL6 |= XCAP_3;              //Internal load cap
        UCSCTL3  = 0;                   //FLL Reference clock = XT1
        
        //检测外部晶振
        //Loop until XT1, XT2 & DCO stailizes - In this case loop until XT1 and DCO settle
        do {
                UCSCTL7 &= ~(XT2OFFG + XT1LFOFFG + DCOFFG);
                                        //Clear XT2, XT1, DCO fault flags
                SERIFG1 &= ~OFIFG;      //Clear fault flags        
        } while (SFRIFG1 & OFIFG);      //Test oscillator fault flag
        
        UCSCTL6 &= ~(XT1DRIVE_3);       //Xtal is now stable, rduce drive strength
        UCSCTL4 |= SELA_0;              //ACLK = LFXT1 (by default)
        
        __bis_SR_register(LPM3_bits);   //Enter LPM3
}


_______________________________________________________________
XT2IN和XT2OUT引脚接高频晶振，晶振频率范围为（455KHz ~ 16MHz）
将SMCLK和MCLK配置为（XT2CLK），且将MCLK通过（P7.7）端口输出
将SMCLK通过（P2.2）端口输出
_______________________________________________________________
int main(void)
{
        WDTCTL  = WDTPW + WDTHOLD;      // stop watchdog timer
        
        P2DIR  |= BIT2;                 // SMCLK set out to pins
        P2SEL  |= BIT2;
        P7DIR  |= BIT7;                 // MCLK set out to pins
        P7SEL  |= BIT7;
        
        P5SEL  |= BIT2 + BIT3;          // Port select XT2 
        
        UCSCTL6 &= ~XT2OFF;             // Enable XT2
        UCSCTL3 |= SELREF_2;            // FLLref = REFO
        
        UCSCTL4 |= SELA_2;              //ACLK=REFO, SMCLK=DCO, MCLK=DCO
        
        // Loop until XT1, XT2 & dCO stabilizes - in this case loop until XT2 settles
        do {
                UCSCTL7 &= ~(XT2OFFG + XT1LFOFFG + DCOFFG);
                                        // clear XT2, XT1, DCO fault flags
                SFRIFG1 &= ~OFIFG;      // clear fault flags
        } while (SFRIFG1 & OFIFG);      // Test oscillator fault flag
        
        UCSCTL6 &= ~XT2DRIVE0;          // Decrease XT2 Drive according to
                                        // expected frequency
                                        
        UCSCTL4 |= SELS_5 + SELM_5;     // SMCLK = MCLK = XT2
}



_______________________________________________________________
使用内部振荡器（REFO），配置ACLK为（32KHz）， SMCLK和MCLK为（8）MHz
利用软件延时反转（P1.1）端口状态，并将ACLK，SMCLK和MCLK通过相应端口输出
_______________________________________________________________
int main(void)
{
        WDTCTL  = WDTPW + WDTHOLD;      // stop watchdog timer
        P1DIR  |= BIT1;                 // p1.1 output
        
        P1DIR  |= BIT0;                 // ACLK set out to pins
        P1SEL  |= BIT0;
        P2DIR  |= BIT2;                 // SMCLK set out to pins
        P2SEL  |= BIT2;
        P7DIR  |= BIT7;                 // MCLK set out to pins
        P7SEL  |= BIT7;
        
        UCSCTL3 = SELREF_2;             // Set DCO FLL reference = REFO
        UCSCTL4 |= SELA_2;              // Set ACLK = REFO
        UCSCTL0 = 0x0000;               // Set lowest possible DCOx, MODx
        
        // Loop until XT1, XT2 & DCO stabilizes - in this case only DCO has to stabilize
        do {
                UCSCTL7 &= ~(XT2OFFG + XT1LFOFFG + DCOFFG);
                                        // clear XT2, XT1, DCO fault flags
                SFRIFG1 &= ~OFIFG;      // clear fault flags
        } while (SFRIFG1 & OFIFG);      // Test oscillator fault flag
        
        __bis_SR_register(SCG0);        // Disable the FLL control loop
        UCSCTL1  = DCORSEL_5;           // select DCO range 16MHz operation
        UCSCTL2 |= 249;                 // Set DCO Multiplier for 8MHz
                                        // (N + 1) * FLLRef = Fdco
                                        // (249 + 1) * 32768 = 8MHz
        __bis_SR_register(SCG0);        // Disable the FLL control loop
        __delay_cycles(250000);
        
        while (1) {
                P1OUT ^= BIT1;          // Toggle P1.1
                __delay_cycles(600000);
        }
}



/*******************************************************************************
        => MSP430-F5529 中断
*******************************************************************************/
//MSP430单片机默认是“不支持中断嵌套”。
//如果需要支持中断嵌套，则需要在所有的中断入口处加一句开中断语句“_EINT()”， 恢复总的中断允许
______________________________________________________________________________
#pragma vector=ADC12_VECTOR
__interrupt void ADC12_ISR(void)
{
        _EINT();                //允许中断嵌套
        switch (__even_in_range(ADC12IV, 34)) {
        case 0:  break;         //向量“0”，没有中断
        case 2:  break;         //向量“2”，ADC overflow
        case 4:  break;         //向量“4”，ADC timing overflow
        case 6:  break;         //向量“6”，ADC12IFG0
        ......
        case 32: break;         //向量“32”，ADC12IFG13
        case 34: break;         //向量“34”，ADC12IFG14
        default: break;
        }
}



/*******************************************************************************
        => MSP430-F5529 低功耗模式
*******************************************************************************/
        AM(活动模式) 
//_____________________________________________________________
控制位
        //( SCG1   =0    SCG0 =0 ) 
        //( OSCOFF =0            )
        //( CPUOFF =0            )

CPU和时钟状态
        //CPU   (活动)
        //MCLK  (活动)
        //SMCLK (活动)
        //ACLK  (活动)
        //DCO   (可用)
        //FLL   (可用)
唤醒中断源
        //定时器， ADC， DMA， UART， WDT， I/O
        //比较器， RTC， 外部中断， 串行通信， 其它外设


        LPM0(低功耗模式“0”)
//_____________________________________________________________
控制位
        //( SCG1   =0    SCG0 =0 )
        //( OSCOFF =0            )
        //( CPUOFF =1            )
CPU和时钟状态
        //CPU   (禁止)
        //MCLK  (禁止)
        //SMCLK (活动)
        //ACLK  (活动)
        //DCO   (可用)
        //FLL   (可用)
唤醒中断源
        //定时器， ADC， DMA， UART， WDT， I/O
        //比较器， RTC， 外部中断， 串行通信， 其它外设


        LPM1(低功耗模式“1”)
//_____________________________________________________________
控制位
        //( SCG1   =0    SCG0 =1 )
        //( OSCOFF =0            )
        //( CPUOFF =1            )
CPU和时钟状态   
        //CPU   (禁止) 
        //MCLK  (禁止)
        //SMCLK (活动)
        //ACLK  (活动)
        //DCO   (可用)
        //FLL   (禁止)
唤醒中断源
        //定时器， ADC， DMA， UART， WDT， I/O
        //比较器， RTC， 外部中断， 串行通信， 其它外设


        LPM2(低功耗模式“2”)
//_____________________________________________________________
控制位 
        //( SCG1   =1    SCG0 =0 ) 
        //( OSCOFF =0            )
        //( CPUOFF =1            )
CPU和时钟状态 
        //CPU   (禁止)
        //MCLK  (禁止)
        //SMCLK (禁止)
        //ACLK  (活动)
        //DCO   (可用)
        //FLL   (禁止)
唤醒中断源
        //定时器， ADC， DMA， UART， WDT， I/O 
        //比较器， RTC， 外部中断， 串行通信， 其它外设


        LPM3(低功耗模式“3”)
//_____________________________________________________________
控制位 
        //( SCG1   =1    SCG0 =1 ) 
        //( OSCOFF =0            ) 
        //( CPUOFF =1            ) 
CPU和时钟状态
        //CPU   (禁止) 
        //MCLK  (禁止) 
        //SMCLK (禁止)
        //ACLK  (活动) 
        //DCO   (可用)
        //FLL   (禁止) 
唤醒中断源
        //定时器， ADC， DMA， UART， WDT， I/O
        //比较器， RTC， 外部中断， 串行通信， 其它外设


        LPM3.5(低功耗模式“3.5”)
//_____________________________________________________________
控制位 
        //( SCG1   =1    SCG0 =1 ) 
        //( OSCOFF =1            ) 
        //( CPUOFF =1            ) 
CPU和时钟状态
        //CPU   (禁止) 
        //MCLK  (禁止)  
        //SMCLK (禁止)  
        //ACLK  (活动) 
        //DCO   (可用) 
        //FLL   (禁止) 
        //当“PMMERGOFF=1”, 无RAM保持 
        //RTC可以启用  
唤醒中断源  
        //复位信号， 外部中断源， RTC
        
        
        LPM4(低功耗模式“4”)
//_____________________________________________________________
控制位 
        //( SCG1   =1    SCG0 =1 )  
        //( OSCOFF =1            )   
        //( CPUOFF =1            )  
CPU和时钟状态  
        //CPU   (禁止)
        //MCLK  (禁止) 
        //SMCLK (禁止)
        //ACLK  (禁止)
        //DCO   (禁止)
        //FLL   (禁止) 
        //CPU禁止 
        //所有时钟禁止 
唤醒中断源 
        //复位信号， 外部中断源 


        LPM4.5(低功耗模式“4.5”)
//_____________________________________________________________
控制位
        //( SCG1   =1    SCG0 =1 ) 
        //( OSCOFF =1            )
        //( CPUOFF =1            )
CPU和时钟状态
        //CPU   (禁止)
        //MCLK  (禁止)
        //SMCLK (禁止)
        //ACLK  (禁止)
        //DCO   (禁止)
        //FLL   (禁止)
        //当“PMMERGOFF=1”, 无RAM保持
        //RTC禁止        
唤醒中断源 
        //复位信号， 外部中断源




/*******************************************************************************
        => MSP430-F5529-GPIO
*******************************************************************************/
MSP430F5xx/6xx系列单片机最多可以提供“12”个通用IO端口（P1~P11和PJ）， 每个IO引脚都可以被
独立地设置为“输入或输出”， 并且每个IO引脚都可以被独立地读取或者写入。 所有的端口寄存器都可能以
被独立地置位或者清零。  端口“P1和P2”具有“输入/输出， 外部中断， 外部模块功能”， 其余端口不具有
【外部中断功能】， 其余功能和P1，P2端口功能一样。



//GPIO端口配置寄存器
___________________________________________________________
PxSEl           //功能选择寄存器
PxDIR           //方向寄存器
PxIE            //中断使能寄存器
PxIES           //中断触发沿选择寄存器
P1IV            //P1端口的8位共用一个中断向量
P2IV            //P2端口的8位共用一个中断向量


#pragma vector=PORT1_VECTOR     //P1端口中断源
__interrupt void PORT1(void)    //声明一个中断服务程序，起名为“PORT1”
{
        if (P1IFG & BIT7) {     //判断P1端口中断标志的第“7”位
        }
        if (P1IFG & BIT6) {     //判断P1端口中断标志的第“6”位
        }
        P1IFG = 0;              //清除P1端口上的所有中断标志位
}




