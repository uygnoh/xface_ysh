//______________________________________________________________________________
//      => GPIO
//______________________________________________________________________________
                参考资料： RT正点原子.pdf 第 131 页
// 整个GPIO结构主要有三个部分，分别是 IOMUXC  IOMUX  IORING  三个部分
// RT1052 的 IO 口总共分成 5 组:   GPIO1  GPIO2  GPIO3  GPIO4  GPIO5
// 其中:
                GPIO1   32 个 IO
                GPIO2   32 个 IO
                GPIO4   32 个 IO
                GPIO3   28 个 IO
                GPIO5    3 个 IO
                     = 127 个 IO



        IORING
//_____________________________________________________________
// 这个部分可以理解成为GPIO的模拟硬件部分，接收来自其他模块的控制数据以及
// 具体通道信号。除了我们常见的方向控制、输出控制等， 具体还包括其他的各种电
// 气属性配置，具体包括
// 输出部分 ////////////////////////////////////////////////////
a) DSE 驱动能力
        // DSE 可以调整芯片内部与引脚串联电阻R0 的大小，从而改变引脚的
        // 驱动能力。 例如，R0 的初始值为260 欧姆，在3.3V 电压下其电流
        // 驱动能力为12.69mA，通过DSE 可以把R0 的值配置为原值的1/2、1/3…1/7 等。
b) SRE 压摆率配置
        // 压摆率是指电压转换速率，可理解为电压由波谷升到波峰的时间。
        // 增大压摆率可减少输出电压的上升时间。RT1052 的引脚通过SRE 
        // 支持低速和高速压摆率这两种配置。
c) SPEED 带宽配置
        // 通过SPEED 可以设置IO 的带宽，分别可设置为50MHz、100MHz 
        // 以及200MHz。带宽的意思是能通过这个IO 口最高的信号频率，通俗点
        // 讲就是方波不失真，如果超过这个频率方波就变正弦波。 但是这个带宽
        // 要区别于IO 的翻转速率，IO 的翻转速率的信号来自于GPIO 这个外设，
        // 而IO 的带宽只是限制了IO 口引脚的物理特性，IO 口的信号可以来自于
        // 内部定时器输出的PWM信号，也可以来自于GPIO 翻转输出的信号，两者
        // 相比之下，PWM信号的频率是远远高于GPIO 翻转输出的信号频率。
d) ODE 开漏输出配置
        // 通过ODE 可以设置引脚是否工作在开漏输出模式。 在该模式时引脚可
        // 以输出高阻态和低电平，输出高阻态时可由外部上拉电阻拉至高电平。
        // 开漏输出模式常用在一些通讯总线中，如I2C。
// 输入部分 ////////////////////////////////////////////////////
a) HYS 滞后使能
        // RT1052 的输入检测可以使用普通的CMOS 检测或施密特触发器模式
        //（滞后模式）。施密特触发器具有滞后效应，对正向和负向变化的输入
        // 信号有不同的阈值电压，常被用于电子开关、波形变换等场合。
b) 上下拉 、 保持器的功能
        // 芯片内部的上拉和下拉电阻可以将不确定的信号钳位在高、低电平，
        // 或小幅提高的电流输出能力，上拉提供输出电流，下拉提供输入电流。
        // 注意这些上下拉配置只是弱拉，对于类似I2C 之类的总线，还是必须
        // 使用外部上拉电阻。RT1052 芯片的电源模块中包含转换器，当转换器
        // 停止工作时，保持器会保持输入输出电压。
        // 上下拉、保持器可以通过如下属性配置：
                                        PUS 上下拉配置
        // PUS 可配置项可选为100K 欧下拉以及22K 欧、47K 欧及100K 欧上拉。
                                         PUE 上下拉、保持器选择
        // 上下拉功能和保持器功能是二选一的，可以通过PUE 来选择。
                                         PKE 上下拉、保持器配置
        // 上下拉功能和保持器还通过PKE 来控制是否使能



        IOMUX
//_____________________________________________________________
// IOMUX是RT1050的多路复用器，它控制着每个引脚的信号通道切换。 
// RT1052的芯片每个GPIO都通过IOMUX 支持多种功能， 例如一个IO 
// 可用于网络外设ENET 的数据接收引脚， 也可以被配置成PWM外设的
// 输出引脚，这样的设计大大增加了芯片的适用性， 这样可选的功能就
// 是由IOMUX实现的。 IOMUX 相当于增加了多根内部信号线与IO 引脚
// 相连，最多有8 根，也就是说一个IO 最多可支持8 种可选的功能。



        IOMUXC
//_____________________________________________________________
// IOMUXC是整个IO系统的核心部分，不仅控制着IOMUX的信号通道开关，
// 而且还控制着IORING中的各种电气属性。不同于一般MCU，一个寄存器
// 可能控制很多IO口, 对于RT1050，每一个IO口都有两个寄存器，分别
// 是负责配置复用功能的MUX寄存器和负责配置IO电气属性的PAD寄存器。
// 命名规则如下：
控制类型	        寄存器名称
MUX Mode	IOMUXC_SW_MUX_CTL_PAD_XXXX      // 复用功能
Pad Settings	IOMUXC_SW_PAD_CTL_PAD_XXXX      // 电气属性
// XXXX代表具体IO的引脚名字         
// 例如在NXP官网DEMO板中，使用引脚GPIO_AD_B0_09驱动LED灯
IOMUXC_SW_MUX_CTL_PAD_XXXX              // 配置复用功能的 MUX寄存器
IOMUXC_SW_PAD_CTL_PAD_XXXX              // 配置电气属性的 PAD寄存器



        IOMCXC配置
//_____________________________________________________________
        IOMUXC_SW_MUX_CTL_PAD_ GPIO_AD_B0_09
        // 该寄存器主要有两个可配置项，分别是SION 和 MUX_MODE，其中SION用于设置引脚在
        // 输出模式下同时开启输入通道； MUX_MODE 可配置该引脚为ALT0~ALT7 这8 个复用功能，
        // 其中就包括了接下来我们所用的GPIO1_IO09功能，也就是GPIO功能
        IOMUXC_SW_PAD_CTL_PAD_ GPIO_AD_B0_09
        // 可以看出通过配置PAD寄存器就可以配置这个IO的具体电气属性，也就是之前说到的各种属性
        // RT-1050-GPIO 电气属性寄存器配置
                HYS             // 滞后配置
                PUS             // 上下拉电阻配置
                PUE             // 选择上下拉，还是保持
                PKE             // 上下拉和保持使能位
                ODE             // 开漏使能位
                SPEED           // 工作速度
                DSE             // 输出驱动能力
                SRE             // 压摆率配置



//______________________________________________________________________________
//      => GPIO 程序
//______________________________________________________________________________
// 
// IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09
// SW_MUX_CTL Register MUX-复用寄存器
// ALT5 — Select mux mode: ALT5 mux port: GPIO1_IO09 of instance: gpio1
#define LED_MUX_CTL     *(volatile uint32_t)(0x401F80E0)
//
// IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09
// SW_PAD_CTL Register PAD-控制寄存器
#define LED_PAD_CTL     *(volatile uint32_t)(0x401F82D0)
// 
//
// GPIO register descriptions
// GPIO memory map
#define LED_GPIO_DR     *(volatile uint32_t)(0x401B8000)        // GPIO数据寄存器
#define LED_GPIO_DIR    *(volatile uint32_t)(0x401B8000 + 0x04) // GPIO方向寄存器
#define LED_GPIO_PSR    *(volatile uint32_t)(0x401B8000 + 0x08) // GPIO-PAD状态
#define LED_GPIO_SET    *(volatile uint32_t)(0x401B8000 + 0x84) // GPIO设置寄存器
#define LED_GPIO_CLEAR  *(volatile uint32_t)(0x401B8000 + 0x88) // GPIO清除寄存器
#define LED_GPIO_TOGGLE *(volatile uint32_t)(0x401B8000 + 0x8C) // GPIO翻转寄存器
//
//
// CCM Memory Map/Register Definition
// CCM Clock Gating Register 1 (CCM_CCGR1)
#define CCM_CCGR1       *(volatile uint32_t)(0x400FC06C)        // GPIO1时钟寄存器
//
// 
void led_init(void)
{
        // 配置时钟
        CCM_CCGR1       &= ~(uint32_t)(3 << 26);
        CCM_CCGR1       |=  (uint32_t)(1 << 26);
        
        // 配置PAD，复用模式，GPIO1_IO09
        LED_MUX_CTL      = 0x
        // 输出配置
        LED_PAD_CTL      = 0x08;
        // 配置为输出
        LED_GPIO_DIR    |= (uint32_t)(1 << 9);
}
void led_on(void)
{
        LED_GPIO_SET    |= (uint32_t)(1 << 9);
}
void led_off(void)
{
        LED_GPIO_CLEAR  |= (uint32_t)(1 << 9);
}
void led_toggle(void)
{
        LED_GPIO_TOGGLE |= (uint32_t)(1 << 9);
}
