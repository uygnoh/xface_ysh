/*******************************************************************************
                              OS_FlagInit()
*******************************************************************************/
//构建一个数组形式的单链表结构，相当于任务中的空闲链表
void OS_Init(void)
{
        #if OS_MAX_FLAGS == 1u
        OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];
        OSFlagFreeList->OSFlagType     = OS_EVENT_TYPT_UNUSED;
        OSFlagFreeList->OSFlagWaitList = (void *)0;
        OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
        #if OS_FLAG_NAME_EN > 0u
        OSFlagFreeList->OSFlagName     = (INT8U *)"?";
        #endif
        #endif
        
        #if OS_MAX_FLAGS >= 2u
        INT16U          ix;
        INT16U          ix_next;
        OS_FLAG_GRP    *pgrp1;
        OS_FLAG_GRP    *pgrp2;
        
        OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));
        for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {
                ix_next                 = ix + 1u;
                pgrp1                   = &OSFlagTbl[ix];
                pgrp2                   = &OSFlagTbl[ix_next];
                pgrp1->OSFlagType       = OS_EVENT_TYPE_UNUSED;
                pgrp1->OSFlagWaitList   = (void *)pgrp2;
                
                #if OS_FLAG_NAME_EN > 0u
                pgrp1->OSFlagName      = (INT8U *)"?";
                #endif
        }
        pgrp1                   = &OSFlagTbl[ix];
        pgrp1->OSFlagType       = OS_EVENT_TYPE_UNUSED;
        pgrp1->OSFlagWaitList   = (void *)0;

        #if OS_FLAG_NAME_EN > 0u
        pgrp1->OSFlagName       = (INT8U *)"?";
        #endif
        
        OSFlagFreeList          = &OSFlagTbl[0];
        #endif
}



/*******************************************************************************
                              OS_FlagUnlink() 解除连接
*******************************************************************************/
//从事件标志节点中摘出一个节点
//此处的摘出并不有摘出干净
void OS_FlagUnlink(OS_FLAG_NODE *pnode)
{
        #if OS_TASK_DEL_EN > 0u
        OS_TCB          *ptcb;
        #endif
        
        OS_FLAG_GRP     *pgrp;          //事件标志组指针
        OS_FLAG_NODE    *pnode_prev;    //事件节点prev
        OS_FLAG_NODE    *pnode_next;    //事件节点next
        
        pnode_prev      = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
        pnode_next      = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
        
        //要摘除的节点是第一个节点。它是第一个
        if (pnode_prev == (OS_FLAG_NODE *)0) {
                pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
                pgrp->OSFlagWaitList = (void *)pnode_next;
                if (pnode_next != (OS_FLAG_NODE *)0) {
                        pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;
                }
        //要摘除的节点不是第一个
        } else {
                pnode_prev->OSFlagNodeNext = pnode_next;
                if (pnode_next != (OS_FLAG_NODE *)0) {
                        pnode_next->OSFlagNodePrev = pnode_prev;
                }
        }
        #if OS_TASK_DEL_EN > 0u
        ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
        ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
        #endif
}



/*******************************************************************************
                               OS_FlagTaskRdy()
*******************************************************************************/
static BOOLEAN OS_FlagTaskRdy(OS_FLAG_NODE *pnode,
                               OS_FLAGS     flags_rdy)
{
        OS_TCB  *ptcb;
        BOOLEAN  sched;
        
        ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
        ptcb->OSTCBDly      = 0u;
        ptcb->OSTCBFlagsRdy = flags_rdy;
        ptcb->OSTCBStat    &= (INT8U)~(INT8U)OS_STAT_FLAG;
        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
        if (ptcb->OSTCBStat == OS_STAT_RDY) {
                OSRdyGrp               |= ptcb->OSTCBBitY;
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
                sched                   = OS_TRUE;
        } else {
                sched                   = OS_FALSE;
        }
        OS_FlagUnlink(pnode);
        return (sched);
}



/*******************************************************************************
                              OS_FlagBlock()
*******************************************************************************/

static void OS_FlagBlock(
        OS_FLAG_GRP    *pgrp,
        OS_FLAG_NODE   *pnode,
        OA_FLAGS        flags,
        INT8U           wait_type,
        INT32u          timeout)
{
        OS_FLAG_NODE    *pnode_next;
        INT8U           y;
        
        OSTCBCur->OSTCBStat     |= OS_STAT_FLAG;
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
        OSTCBCur->OSTCBDly       = timeout;
        #if OS_TASK_DEL_EN > 0u
        OSTCBCur->OSTCBFlagNode  = pnode;
        #endif
        pnode->OSFlagNodeFlags   = flags;
        pnode->OSFlagNodeWaitType= wait_type;
        pnode->OSFlagNodeTCB     = (void *)OSTCBCur;
        pnode->OSFlagNodeNext    = pgrp->OSFlagWaitList;
        pnode->OSFlagNodePrve    = (void *)0;
        pnode->OSFlagNodeFlagGrp = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
        if (pnode_next != (void *)0) {
                pnode_next->OSFlsgNodePrev = (void *)0;
        }
        pgrp->OSFlagWaitList = (void *)pnode;
        
        y            = OSTCBCur_>OSTCBY;
        OSRDyTbl[y] &= (OS_PRIO)~OSTCBBitX;
        if (OSRdyTbl[y] == 0x00u) {
                OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
        }
}













