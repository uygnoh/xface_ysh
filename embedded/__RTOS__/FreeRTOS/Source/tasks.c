/*
 * FreeRTOS Kernel V10.4.6
 * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 * SPDX-License-Identifier: MIT
 * https://www.FreeRTOS.org
 * https://github.com/FreeRTOS
 *
 */

/* Standard includes. */
#include <stdlib.h>
#include <string.h>

/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
 * all the API functions to use the MPU wrappers.  That should only be done when
 * task.h is included from an application file. */
#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"
#include "stack_macros.h"

/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
 * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
 * for the header files above, but not in this file, in order to generate the
 * correct privileged Vs unprivileged linkage and placement. */
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */

/* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
 * functions but without including stdio.h here. */
#if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )

/* At the bottom of this file are two optional functions that can be used
 * to generate human readable text from the raw data generated by the
 * uxTaskGetSystemState() function.  Note the formatting functions are provided
 * for convenience only, and are NOT considered part of the kernel. */
    #include <stdio.h>
#endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */

#if ( configUSE_PREEMPTION == 0 )

/* If the cooperative scheduler is being used then a yield should not be
 * performed just because a higher priority task has been woken. */
    #define taskYIELD_IF_USING_PREEMPTION()
#else
    #define taskYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
#endif

/* Values that can be assigned to the ucNotifyState member of the TCB. */
#define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 ) /* Must be zero as it is the initialised value. */
#define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )
#define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )

/*
 * The value used to fill the stack of a task when the task is created.  This
 * is used purely for checking the high water mark for tasks.
 */
#define tskSTACK_FILL_BYTE                        ( 0xa5U )

/* Bits used to record how a task's stack and TCB were allocated. */
#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB    ( ( uint8_t ) 0 )
#define tskSTATICALLY_ALLOCATED_STACK_ONLY        ( ( uint8_t ) 1 )
#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB     ( ( uint8_t ) 2 )

/* If any of the following are set then task stacks are filled with a known
 * value so the high water mark can be determined.  If none of the following are
 * set then don't fill the stack so there is no unnecessary dependency on memset. */
#if ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
    #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    1
#else
    #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    0
#endif

/*
 * Macros used by vListTask to indicate which state a task is in.
 */
#define tskRUNNING_CHAR      ( 'X' )
#define tskBLOCKED_CHAR      ( 'B' )
#define tskREADY_CHAR        ( 'R' )
#define tskDELETED_CHAR      ( 'D' )
#define tskSUSPENDED_CHAR    ( 'S' )

/*
 * Some kernel aware debuggers require the data the debugger needs access to to
 * be global, rather than file scope.
 */
#ifdef portREMOVE_STATIC_QUALIFIER
    #define static
#endif

/* The name allocated to the Idle task.  This can be overridden by defining
 * configIDLE_TASK_NAME in FreeRTOSConfig.h. */
#ifndef configIDLE_TASK_NAME
    #define configIDLE_TASK_NAME    "IDLE"
#endif


#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
//=============================================================
        #define taskRECORD_READY_PRIORITY(uxPriority)           \
        {                                                       \
                if ((uxPriority) > uxTopReadyPriority)          \
                {                                               \
                        uxTopReadyPriority = (uxPriority);      \
                }                                               \
        } /* taskRECORD_READY_PRIORITY */



        #define taskSELECT_HIGHEST_PRIORITY_TASK()                            \
        {                                                                     \
        UBaseType_t uxTopPriority = uxTopReadyPriority;                       \
                                                                              \
        /* Find the highest priority queue that contains ready tasks. */      \
        while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) ) \
        {                                                                     \
            configASSERT( uxTopPriority );                                    \
            --uxTopPriority;                                                  \
        }                                                                     \
                                                                              \
        /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of             \
         * the  same priority get an equal share of the processor time. */                    \
        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) ); \
        uxTopReadyPriority = uxTopPriority;                                                   \
        } /* taskSELECT_HIGHEST_PRIORITY_TASK */

        #define taskRESET_READY_PRIORITY( uxPriority )
        #define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )

#else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
//=============================================================

/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 * performed in a way that is tailored to the particular microcontroller
 * architecture being used. */

/* A port optimised version is provided.  Call the port defined macros. */
    #define taskRECORD_READY_PRIORITY( uxPriority )    \
        portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )

/*-----------------------------------------------------------*/

    #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \
    {                                                                                           \
        UBaseType_t uxTopPriority;                                                              \
                                                                                                \
        /* Find the highest priority list that contains ready tasks. */                         \
        portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \
        configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 ); \
        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );   \
    } /* taskSELECT_HIGHEST_PRIORITY_TASK() */

/*-----------------------------------------------------------*/

/* A port optimised version is provided, call it only if the TCB being reset
 * is being referenced from a ready list.  If it is referenced from a delayed
 * or suspended list then it won't be in a ready list. */
    #define taskRESET_READY_PRIORITY( uxPriority )                                                     \
    {                                                                                                  \
        if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 ) \
        {                                                                                              \
            portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                        \
        }                                                                                              \
    }
#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */



/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 * count overflows. */
#define taskSWITCH_DELAYED_LISTS()                                                \
{                                                                                 \
        List_t * pxTemp;                                                          \
                                                                                  \
        /* The delayed tasks list should be empty when the lists are switched. */ \
        configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \
                                                                                  \
        pxTemp = pxDelayedTaskList;                                               \
        pxDelayedTaskList = pxOverflowDelayedTaskList;                            \
        pxOverflowDelayedTaskList = pxTemp;                                       \
        xNumOfOverflows++;                                                        \
        prvResetNextTaskUnblockTime();                                            \
}



/*
 * Place the task represented by pxTCB into the appropriate ready list for
 * the task.  It is inserted at the end of the list.
 */
#define prvAddTaskToReadyList( pxTCB )                                  \
traceMOVED_TASK_TO_READY_STATE( pxTCB );                                \
taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                     \
        listINSERT_END( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ),\
                &( ( pxTCB )->xStateListItem ) );                       \
tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )


/*
 * Several functions take a TaskHandle_t parameter that can optionally be NULL,
 * where NULL is used to indicate that the handle of the currently executing
 * task should be used in place of the parameter.  This macro simply checks to
 * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 */
#define prvGetTCBFromHandle( pxHandle )    \
                ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )



/* The item value of the event list item is normally used to hold the priority
 * of the task to which it belongs (coded to allow it to be held in reverse
 * priority order).  However, it is occasionally borrowed for other purposes.  It
 * is important its value is not updated due to a task priority change while it is
 * being used for another purpose.  The following bit definition is used to inform
 * the scheduler that the value should not be changed - in which case it is the
 * responsibility of whichever module is using the value to ensure it gets set back
 * to its original value when it is released. */
#if ( configUSE_16_BIT_TICKS == 1 )
        #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x8000U
#else
        #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x80000000UL
#endif

/*
 * Task control block.  A task control block (TCB) is allocated for each task,
 * and stores task state information, including a pointer to the task's context
 * (the task's run time environment, including register values)
 */
typedef struct tskTaskControlBlock {
        volatile StackType_t * pxTopOfStack;

        #if ( portUSING_MPU_WRAPPERS == 1 )
        xMPU_SETTINGS xMPUSettings;
        #endif

        ListItem_t xStateListItem;
        ListItem_t xEventListItem;
        UBaseType_t uxPriority;
        StackType_t * pxStack;
        char pcTaskName[ configMAX_TASK_NAME_LEN ];

        #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
        StackType_t * pxEndOfStack; /*< Points to the highest valid address for the stack. */
        #endif

        #if ( portCRITICAL_NESTING_IN_TCB == 1 )
        UBaseType_t uxCriticalNesting; 
        #endif

        #if ( configUSE_TRACE_FACILITY == 1 )
        UBaseType_t uxTCBNumber;
        UBaseType_t uxTaskNumber;
        #endif

        #if ( configUSE_MUTEXES == 1 )
        UBaseType_t uxBasePriority;
        UBaseType_t uxMutexesHeld;
        #endif

        #if ( configUSE_APPLICATION_TASK_TAG == 1 )
        TaskHookFunction_t pxTaskTag;
        #endif

        #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
        void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
        #endif

        #if ( configGENERATE_RUN_TIME_STATS == 1 )
        configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; 
        #endif

        #if ( configUSE_NEWLIB_REENTRANT == 1 )
        /* Allocate a Newlib reent structure that is specific to this task.
         * Note Newlib support has been included by popular demand, but is not
         * used by the FreeRTOS maintainers themselves.  FreeRTOS is not
         * responsible for resulting newlib operation.  User must be familiar with
         * newlib and must provide system-wide implementations of the necessary
         * stubs. Be warned that (at the time of writing) the current newlib design
         * implements a system-wide malloc() that must be provided with locks.
         *
         * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
         * for additional information. */
        struct  _reent xNewLib_reent;
        #endif

        #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
        volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
        #endif

        /* See the comments in FreeRTOS.h with the definition of
        * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
        #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
        uint8_t ucStaticallyAllocated;
        #endif

        #if ( INCLUDE_xTaskAbortDelay == 1 )
        uint8_t ucDelayAborted;
        #endif

        #if ( configUSE_POSIX_ERRNO == 1 )
        int iTaskErrno;
        #endif
} tskTCB;



typedef tskTCB TCB_t;


PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;

PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];
PRIVILEGED_DATA static List_t xDelayedTaskList1;
PRIVILEGED_DATA static List_t xDelayedTaskList2;
PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;
PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;
PRIVILEGED_DATA static List_t xPendingReadyList;


#if ( INCLUDE_vTaskDelete == 1 )
PRIVILEGED_DATA static List_t xTasksWaitingTermination;
PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
#endif

#if ( INCLUDE_vTaskSuspend == 1 )
PRIVILEGED_DATA static List_t xSuspendedTaskList;
#endif


#if ( configUSE_POSIX_ERRNO == 1 )
int FreeRTOS_errno = 0;
#endif

/* Other file private variables. --------------------------------*/
PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
PRIVILEGED_DATA static volatile TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;
PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;
PRIVILEGED_DATA static volatile TickType_t xPendedTicks = ( TickType_t ) 0U;
PRIVILEGED_DATA static volatile BaseType_t xYieldPending = pdFALSE;
PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = ( BaseType_t ) 0;
PRIVILEGED_DATA static UBaseType_t uxTaskNumber = ( UBaseType_t ) 0U;
PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = ( TickType_t ) 0U;
PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;

const volatile UBaseType_t uxTopUsedPriority = configMAX_PRIORITIES - 1U;


PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;

#if ( configGENERATE_RUN_TIME_STATS == 1 )
PRIVILEGED_DATA static configRUN_TIME_COUNTER_TYPE ulTaskSwitchedInTime = 0UL;
PRIVILEGED_DATA static volatile configRUN_TIME_COUNTER_TYPE ulTotalRunTime = 0UL;
#endif



#if ( INCLUDE_vTaskSuspend == 1 )
static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
#endif /* INCLUDE_vTaskSuspend */


static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters ) PRIVILEGED_FUNCTION;


#if ( INCLUDE_vTaskDelete == 1 )
static void prvDeleteTCB( TCB_t * pxTCB ) PRIVILEGED_FUNCTION;
#endif

static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
        const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;


#if ( configUSE_TRACE_FACILITY == 1 )
static UBaseType_t prvListTasksWithinSingleList( 
                        TaskStatus_t * pxTaskStatusArray,
                        List_t * pxList,
                        eTaskState eState ) PRIVILEGED_FUNCTION;
#endif


#if ( INCLUDE_xTaskGetHandle == 1 )
static TCB_t * prvSearchForNameWithinSingleList( 
                        List_t * pxList,
                        const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
#endif



#if (              ( configUSE_TRACE_FACILITY  == 1 ) || 
        ( INCLUDE_uxTaskGetStackHighWaterMark  == 1 ) || 
        ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( 
                        const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;

#endif


#if ( configUSE_TICKLESS_IDLE != 0 )
static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
#endif


static void prvResetNextTaskUnblockTime( void ) PRIVILEGED_FUNCTION;


#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
static char * prvWriteNameToBuffer( 
                        char * pcBuffer,
                        const char * pcTaskName ) PRIVILEGED_FUNCTION;
#endif


static void prvInitialiseNewTask( 
                        TaskFunction_t pxTaskCode,
                        const char * const pcName,
                        const uint32_t ulStackDepth,
                        void * const pvParameters,
                        UBaseType_t uxPriority,
                        TaskHandle_t * const pxCreatedTask,
                        TCB_t * pxNewTCB,
                        const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;


static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB ) PRIVILEGED_FUNCTION;


#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
#endif




// 使用静态方法创建任务
#if (configSUPPORT_STATIC_ALLOCATION == 1)
//______________________________________________________________________________
TaskHandle_t xTaskCreateStatic( 
                TaskFunction_t          pxTaskCode,
                const char * const      pcName,
                const uint32_t          ulStackDepth,
                void * const            pvParameters,
                UBaseType_t             uxPriority,
                StackType_t * const     puxStackBuffer,
                StaticTask_t * const    pxTaskBuffer )
{
        TCB_t * pxNewTCB;
        TaskHandle_t xReturn;

        configASSERT( puxStackBuffer != NULL );
        configASSERT( pxTaskBuffer != NULL );

        #if ( configASSERT_DEFINED == 1 )
        /* Sanity check that the size of the structure used to declare a
         * variable of type StaticTask_t equals the size of the real task
         * structure. */
                volatile size_t xSize = sizeof( StaticTask_t );
                configASSERT( xSize == sizeof( TCB_t ) );
                ( void ) xSize;
        #endif /* configASSERT_DEFINED */

        if ( (pxTaskBuffer != NULL) && (puxStackBuffer != NULL) ) {
                pxNewTCB = ( TCB_t * ) pxTaskBuffer;
                pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;

                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                prvInitialiseNewTask( 
                                        pxTaskCode, pcName, ulStackDepth, 
                                        pvParameters, uxPriority, 
                                        &xReturn, pxNewTCB, NULL );
                prvAddNewTaskToReadyList( pxNewTCB );
        } else {
                xReturn = NULL;
        }

        return xReturn;
}
#endif /* SUPPORT_STATIC_ALLOCATION */
//______________________________________________________________________________



// 
#if ((portUSING_MPU_WRAPPERS == 1) && (configSUPPORT_STATIC_ALLOCATION == 1))
//______________________________________________________________________________
BaseType_t xTaskCreateRestrictedStatic( 
                const TaskParameters_t * const  pxTaskDefinition,
                TaskHandle_t *                  pxCreatedTask )
{
        TCB_t * pxNewTCB;
        BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;

        configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
        configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );

        if ( (pxTaskDefinition->puxStackBuffer != NULL) && 
                        (pxTaskDefinition->pxTaskBuffer != NULL) ) {

                pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;

                pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;

                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
                /* Tasks can be created statically or dynamically, so note this
                * task was created statically in case the task is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                prvInitialiseNewTask( 
                                pxTaskDefinition->pvTaskCode,
                                pxTaskDefinition->pcName,
                                ( uint32_t ) pxTaskDefinition->usStackDepth,
                                pxTaskDefinition->pvParameters,
                                pxTaskDefinition->uxPriority,
                                pxCreatedTask, pxNewTCB,
                                pxTaskDefinition->xRegions );

                prvAddNewTaskToReadyList( pxNewTCB );
                xReturn = pdPASS;
        }

        return xReturn;
    }
#endif /* (portUSING_MPU_WRAPPERS == 1) && (configSUPPORT_STATIC_ALLOCATION == 1) */
//______________________________________________________________________________



#if ((portUSING_MPU_WRAPPERS == 1) && (configSUPPORT_DYNAMIC_ALLOCATION == 1))
//______________________________________________________________________________
BaseType_t xTaskCreateRestricted( 
                const TaskParameters_t * const  pxTaskDefinition,
                TaskHandle_t *                  pxCreatedTask )
{
        TCB_t * pxNewTCB;
        BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;

        configASSERT( pxTaskDefinition->puxStackBuffer );

        if (pxTaskDefinition->puxStackBuffer != NULL) {
                /* Allocate space for the TCB.  Where the memory comes from depends
                * on the implementation of the port malloc function and whether or
                * not static allocation is being used. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );

                if (pxNewTCB != NULL) {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;

                        #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
                        pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
                        #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                        prvInitialiseNewTask( 
                                        pxTaskDefinition->pvTaskCode,
                                        pxTaskDefinition->pcName,
                                        ( uint32_t ) pxTaskDefinition->usStackDepth,
                                        pxTaskDefinition->pvParameters,
                                        pxTaskDefinition->uxPriority,
                                        pxCreatedTask, pxNewTCB,
                                        pxTaskDefinition->xRegions );

                        prvAddNewTaskToReadyList( pxNewTCB );
                        xReturn = pdPASS;
                }
        }

        return xReturn;
}
#endif /* portUSING_MPU_WRAPPERS */
//______________________________________________________________________________



#if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
//______________________________________________________________________________
BaseType_t xTaskCreate( 
                TaskFunction_t                  pxTaskCode,
                const char * const              pcName,
                const configSTACK_DEPTH_TYPE    usStackDepth,
                void * const                    pvParameters,
                UBaseType_t                     uxPriority,
                TaskHandle_t * const            pxCreatedTask )
{
        TCB_t * pxNewTCB;
        BaseType_t xReturn;

        #if ( portSTACK_GROWTH > 0 )
        //=====================================================
        pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );

        if ( pxNewTCB != NULL ) {
                pxNewTCB->pxStack = (StackType_t *)pvPortMallocStack( 
                        (((size_t)usStackDepth) * sizeof(StackType_t)) );
                if( pxNewTCB->pxStack == NULL ) {
                        vPortFree( pxNewTCB );
                        pxNewTCB = NULL;
                }
        }
        #else /* portSTACK_GROWTH */
        //=====================================================
        StackType_t * pxStack;

        pxStack = pvPortMallocStack((((size_t)usStackDepth) * sizeof(StackType_t)));
        if (pxStack != NULL) {
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );

                if (pxNewTCB != NULL) {
                        pxNewTCB->pxStack = pxStack;
                } else {
                        vPortFreeStack( pxStack );
                }
        } else {
                pxNewTCB = NULL;
        }
        #endif /* portSTACK_GROWTH */
        //=====================================================
        
        if (pxNewTCB != NULL) {
                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                prvInitialiseNewTask(
                                pxTaskCode, pcName, 
                                ( uint32_t ) usStackDepth, 
                                pvParameters, uxPriority, 
                                pxCreatedTask, pxNewTCB, NULL);
                prvAddNewTaskToReadyList( pxNewTCB );
                xReturn = pdPASS;
        } else {
                xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
}

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
//______________________________________________________________________________



static void prvInitialiseNewTask( 
                TaskFunction_t                  pxTaskCode,
                const char * const              pcName,
                const uint32_t                  ulStackDepth,
                void * const                    pvParameters,
                UBaseType_t                     uxPriority,
                TaskHandle_t * const            pxCreatedTask,
                TCB_t *                         pxNewTCB,
                const MemoryRegion_t * const    xRegions )
{
        StackType_t * pxTopOfStack;
        UBaseType_t x;

        #if ( portUSING_MPU_WRAPPERS == 1 )
        /* Should the task be created in privileged mode? */
        BaseType_t xRunPrivileged;

        if ( ( uxPriority & portPRIVILEGE_BIT ) != 0U ) {
                xRunPrivileged = pdTRUE;
        } else {
                xRunPrivileged = pdFALSE;
        }
        uxPriority &= ~portPRIVILEGE_BIT;
        #endif /* portUSING_MPU_WRAPPERS == 1 */

        /* Avoid dependency on memset() if it is not required. */
        #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        /* Fill the stack with a known value to assist debugging. */
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, 
                ( size_t ) ulStackDepth * sizeof( StackType_t ) );
        #endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */


        #if ( portSTACK_GROWTH < 0 )
        //=====================================================
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
        pxTopOfStack = (StackType_t *)( ((portPOINTER_SIZE_TYPE)pxTopOfStack)
                       & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)) );

        /* Check the alignment of the calculated top of stack is correct. */
        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & 
                ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

        #if ( configRECORD_STACK_HIGH_ADDRESS == 1 )
        /* Also record the stack's high address, which may assist
        * debugging. */
        pxNewTCB->pxEndOfStack = pxTopOfStack;
        #endif /* configRECORD_STACK_HIGH_ADDRESS */

        #else /* portSTACK_GROWTH */
        //=====================================================
        
        
        pxTopOfStack = pxNewTCB->pxStack;

        /* Check the alignment of the stack buffer is correct. */
        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & 
                ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

        /* The other extreme of the stack space is required if stack checking is
        * performed. */
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
        #endif /* portSTACK_GROWTH */
        //=====================================================
    

        /* Store the task name in the TCB. */
        if ( pcName != NULL ) {
                for ( x = ( UBaseType_t ) 0; 
                        x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++) {
                        pxNewTCB->pcTaskName[ x ] = pcName[ x ];

                        if ( pcName[ x ] == ( char ) 0x00 ) {
                                break;
                        } else {
                                mtCOVERAGE_TEST_MARKER();
                        }
                }

                pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
        } else {
                /* The task has not been given a name, so just ensure there is a NULL
                 * terminator when it is read out. */
                pxNewTCB->pcTaskName[ 0 ] = 0x00;
        }

        /* This is used as an array index so must ensure it's not too large. */
        configASSERT( uxPriority < configMAX_PRIORITIES );

        if (uxPriority >= (UBaseType_t) configMAX_PRIORITIES) {
                uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        pxNewTCB->uxPriority = uxPriority;
        #if ( configUSE_MUTEXES == 1 )
        pxNewTCB->uxBasePriority = uxPriority;
        pxNewTCB->uxMutexesHeld = 0;
        #endif /* configUSE_MUTEXES */

        vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
        vListInitialiseItem( &( pxNewTCB->xEventListItem ) );

        listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );

        /* Event lists are always in priority order. */
        listSET_LIST_ITEM_VALUE(&(pxNewTCB->xEventListItem), 
                (TickType_t)configMAX_PRIORITIES - (TickType_t)uxPriority);
        listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );

        #if ( portCRITICAL_NESTING_IN_TCB == 1 )
        pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
        #endif /* portCRITICAL_NESTING_IN_TCB */

        #if ( configUSE_APPLICATION_TASK_TAG == 1 )
        pxNewTCB->pxTaskTag = NULL;
        #endif /* configUSE_APPLICATION_TASK_TAG */

        #if ( configGENERATE_RUN_TIME_STATS == 1 )
        pxNewTCB->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
        #endif /* configGENERATE_RUN_TIME_STATS */

        #if ( portUSING_MPU_WRAPPERS == 1 )
                vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), 
                        xRegions, pxNewTCB->pxStack, ulStackDepth );
        #else
                ( void ) xRegions;
        #endif

        #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
        memset( ( void * ) &( pxNewTCB->pvThreadLocalStoragePointers[ 0 ] ), 
                0x00, sizeof( pxNewTCB->pvThreadLocalStoragePointers ) );
        #endif

        #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, 
                sizeof( pxNewTCB->ulNotifiedValue ) );
        memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, 
                sizeof( pxNewTCB->ucNotifyState ) );
        #endif

        #if ( configUSE_NEWLIB_REENTRANT == 1 )
        _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
        #endif

        #if ( INCLUDE_xTaskAbortDelay == 1 )
        pxNewTCB->ucDelayAborted = pdFALSE;
        #endif


        #if ( portUSING_MPU_WRAPPERS == 1 )
        //=====================================================
        {
                #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 ) {
                        #if ( portSTACK_GROWTH < 0 ) {
                                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( 
                                        pxTopOfStack, pxNewTCB->pxStack, 
                                        pxTaskCode, pvParameters, xRunPrivileged );
                        } 
                        #else /* portSTACK_GROWTH */ {
                                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( 
                                        pxTopOfStack, pxNewTCB->pxEndOfStack, 
                                        pxTaskCode, pvParameters, xRunPrivileged );
                        }
                        #endif /* portSTACK_GROWTH */
                }
                #else /* portHAS_STACK_OVERFLOW_CHECKING */ {
                        pxNewTCB->pxTopOfStack = pxPortInitialiseStack( 
                                pxTopOfStack, pxTaskCode, 
                                pvParameters, xRunPrivileged );
                }
                #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
        //=====================================================
        #else /* portUSING_MPU_WRAPPERS */
        {
                #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 ) {
                        #if ( portSTACK_GROWTH < 0 ) {
                                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( 
                                        pxTopOfStack, pxNewTCB->pxStack, 
                                        pxTaskCode, pvParameters );
                        }
                        #else /* portSTACK_GROWTH */ {
                                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( 
                                        pxTopOfStack, pxNewTCB->pxEndOfStack, 
                                        pxTaskCode, pvParameters );
                        }
                        #endif /* portSTACK_GROWTH */
                }
                #else /* portHAS_STACK_OVERFLOW_CHECKING */ {
                        pxNewTCB->pxTopOfStack = pxPortInitialiseStack( 
                                pxTopOfStack, pxTaskCode, pvParameters );
                }
                #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
        #endif /* portUSING_MPU_WRAPPERS */
        //=====================================================
        
        if ( pxCreatedTask != NULL ) {
                *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
}



static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
        taskENTER_CRITICAL();
        //_____________________________________________________
        uxCurrentNumberOfTasks++;

        if (pxCurrentTCB == NULL) {
                pxCurrentTCB = pxNewTCB;
                if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
                        prvInitialiseTaskLists();
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        } else {
                if (xSchedulerRunning == pdFALSE) {
                        if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
                                pxCurrentTCB = pxNewTCB;
                        } else {
                                mtCOVERAGE_TEST_MARKER();
                        }
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        }

        uxTaskNumber++;

        #if ( configUSE_TRACE_FACILITY == 1 )
        /* Add a counter into the TCB for tracing only. */
        pxNewTCB->uxTCBNumber = uxTaskNumber;
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );

        portSETUP_TCB( pxNewTCB );

        taskEXIT_CRITICAL();
        //_____________________________________________________
        
        if (xSchedulerRunning != pdFALSE) {
                if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
                        taskYIELD_IF_USING_PREEMPTION();
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
}



#if (INCLUDE_vTaskDelete == 1)
//______________________________________________________________________________
void vTaskDelete( TaskHandle_t xTaskToDelete ) 
{
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
        //_____________________________________________________
        
        pxTCB = prvGetTCBFromHandle( xTaskToDelete );
        if (uxListRemove( &(pxTCB->xStateListItem)) == (UBaseType_t)0) {
                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        uxTaskNumber++;

        if ( pxTCB == pxCurrentTCB ) {
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
                ++uxDeletedTasksWaitingCleanUp;
                traceTASK_DELETE( pxTCB );
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
        } else {
                --uxCurrentNumberOfTasks;
                traceTASK_DELETE( pxTCB );
                prvResetNextTaskUnblockTime();
        }
        
        taskEXIT_CRITICAL();
        //_____________________________________________________

        if ( pxTCB != pxCurrentTCB ) {
                prvDeleteTCB( pxTCB );
        }

        if ( xSchedulerRunning != pdFALSE ) {
                if ( pxTCB == pxCurrentTCB ) {
                        configASSERT( uxSchedulerSuspended == 0 );
                        portYIELD_WITHIN_API();
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        }
    }
#endif /* INCLUDE_vTaskDelete */
//______________________________________________________________________________



#if (INCLUDE_xTaskDelayUntil == 1)
//______________________________________________________________________________
BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
{
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        //挂起所有任务
        vTaskSuspendAll();

        const TickType_t xConstTickCount = xTickCount;

        xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

        if ( xConstTickCount < *pxPreviousWakeTime ) {
                if ( (xTimeToWake < *pxPreviousWakeTime) && (xTimeToWake > xConstTickCount) ) {
                        xShouldDelay = pdTRUE;
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        } else {
                if ( (xTimeToWake < *pxPreviousWakeTime) || (xTimeToWake > xConstTickCount) ) {
                        xShouldDelay = pdTRUE;
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        }

            
        *pxPreviousWakeTime = xTimeToWake;

        if ( xShouldDelay != pdFALSE ) {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
        
        //恢复所有任务
        xAlreadyYielded = xTaskResumeAll();


        if ( xAlreadyYielded == pdFALSE ) {
                portYIELD_WITHIN_API();
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
}
#endif /* INCLUDE_xTaskDelayUntil */
//______________________________________________________________________________



#if (INCLUDE_vTaskDelay == 1)
//______________________________________________________________________________
void vTaskDelay( const TickType_t xTicksToDelay )
{
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if (xTicksToDelay > (TickType_t)0U) {
                configASSERT( uxSchedulerSuspended == 0 );
                
                //挂起所有任务
                vTaskSuspendAll();

                traceTASK_DELAY();
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
                
                //恢复所有任务
                xAlreadyYielded = xTaskResumeAll();
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        if ( xAlreadyYielded == pdFALSE ) {
                portYIELD_WITHIN_API();
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
}

#endif /* INCLUDE_vTaskDelay */
//______________________________________________________________________________



#if ((INCLUDE_eTaskGetState    == 1)  ||        \
     (configUSE_TRACE_FACILITY == 1)  ||        \
     ( INCLUDE_xTaskAbortDelay == 1))
//______________________________________________________________________________
eTaskState eTaskGetState( TaskHandle_t xTask )
{
        eTaskState eReturn;
        List_t const * pxStateList, * pxDelayedList, * pxOverflowedDelayedList;
        const TCB_t * const pxTCB = xTask;

        configASSERT( pxTCB );

        if ( pxTCB == pxCurrentTCB ) {
                eReturn = eRunning;
        } else {
                taskENTER_CRITICAL();
        {
                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
                pxDelayedList = pxDelayedTaskList;
                pxOverflowedDelayedList = pxOverflowDelayedTaskList;
        }
                taskEXIT_CRITICAL();

                if ( ( pxStateList == pxDelayedList ) || 
                                ( pxStateList == pxOverflowedDelayedList ) ) {
                        eReturn = eBlocked;
                }

                #if ( INCLUDE_vTaskSuspend == 1 )
                else if( pxStateList == &xSuspendedTaskList )
                {
                        if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL) {
                        #if ( configUSE_TASK_NOTIFICATIONS == 1 )
                                BaseType_t x;
                                eReturn = eSuspended;
                                for ( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ ) {
                                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION ) {
                                                eReturn = eBlocked;
                                                break;
                                        }
                                }
                        #else /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                        eReturn = eSuspended;
                        #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                        } else {
                                eReturn = eBlocked;
                        }
                }
                #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */

                #if ( INCLUDE_vTaskDelete == 1 )
                else if ((pxStateList == &xTasksWaitingTermination) || (pxStateList == NULL)) {
                        eReturn = eDeleted;
                }
                #endif

                else {
                        eReturn = eReady;
                }
        }

        return eReturn;
}
#endif /* INCLUDE_eTaskGetState */
//______________________________________________________________________________



#if (INCLUDE_uxTaskPriorityGet == 1)
//______________________________________________________________________________
UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
{
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        taskENTER_CRITICAL();
        pxTCB = prvGetTCBFromHandle( xTask );
        uxReturn = pxTCB->uxPriority;
        taskEXIT_CRITICAL();

        return uxReturn;
}
#endif /* INCLUDE_uxTaskPriorityGet */
//______________________________________________________________________________



#if (INCLUDE_uxTaskPriorityGet == 1)
//______________________________________________________________________________
UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
{
        TCB_t const * pxTCB;
        UBaseType_t uxReturn, uxSavedInterruptState;

        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
        {
                pxTCB = prvGetTCBFromHandle( xTask );
                uxReturn = pxTCB->uxPriority;
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

        return uxReturn;
}
#endif /* INCLUDE_uxTaskPriorityGet */
//______________________________________________________________________________



#if ( INCLUDE_vTaskPrioritySet == 1 )
//______________________________________________________________________________
void vTaskPrioritySet( TaskHandle_t xTask,
                        UBaseType_t uxNewPriority )
{
        TCB_t * pxTCB;
        UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
        BaseType_t xYieldRequired = pdFALSE;

        configASSERT( uxNewPriority < configMAX_PRIORITIES );

        /* Ensure the new priority is valid. */
        if ( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES ) {
                uxNewPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
        {

        pxTCB = prvGetTCBFromHandle( xTask );

        traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

        #if ( configUSE_MUTEXES == 1 )
        uxCurrentBasePriority = pxTCB->uxBasePriority;
        #else
        uxCurrentBasePriority = pxTCB->uxPriority;
        #endif

        if ( uxCurrentBasePriority != uxNewPriority ) {
                if ( uxNewPriority > uxCurrentBasePriority ) {
                        if ( pxTCB != pxCurrentTCB ) {
                                if ( uxNewPriority >= pxCurrentTCB->uxPriority ) {
                                        xYieldRequired = pdTRUE;
                                } else {
                                        mtCOVERAGE_TEST_MARKER();
                                }
                        } else {
                                /* The priority of the running task is being raised,
                                * but the running task must already be the highest
                                * priority task able to run so no yield is required. */
                        }
                } else if ( pxTCB == pxCurrentTCB ) {
                        /* Setting the priority of the running task down means
                        * there may now be another task of higher priority that
                        * is ready to execute. */
                        xYieldRequired = pdTRUE;
                } else {
                        /* Setting the priority of any other task down does not
                        * require a yield as the running task must be above the
                        * new priority of the task being modified. */
                }

                /* Remember the ready list the task might be referenced from
                 * before its uxPriority member is changed so the
                 * taskRESET_READY_PRIORITY() macro can function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;

                #if ( configUSE_MUTEXES == 1 )
                if ( pxTCB->uxBasePriority == pxTCB->uxPriority ) {
                            pxTCB->uxPriority = uxNewPriority;
                } else {
                            mtCOVERAGE_TEST_MARKER();
                }
                pxTCB->uxBasePriority = uxNewPriority;
                #else /* if ( configUSE_MUTEXES == 1 ) */
                pxTCB->uxPriority = uxNewPriority;
                #endif /* if ( configUSE_MUTEXES == 1 ) */


                if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem))  &  
                        taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
                        listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem), 
                        ((TickType_t)configMAX_PRIORITIES - (TickType_t)uxNewPriority));
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }


                if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]), 
                   &( pxTCB->xStateListItem ) ) != pdFALSE ) {
                        if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
                                portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, 
                                        uxTopReadyPriority );
                        } else{
                                mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }

                if ( xYieldRequired != pdFALSE ) {
                        taskYIELD_IF_USING_PREEMPTION();
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }

                /* Remove compiler warning about unused variables when the port
                 * optimised task selection is not being used. */
                ( void ) uxPriorityUsedOnEntry;
        }
        }
        taskEXIT_CRITICAL();
}
#endif /* INCLUDE_vTaskPrioritySet */
//______________________________________________________________________________



#if (INCLUDE_vTaskSuspend == 1)
//______________________________________________________________________________
void vTaskSuspend( TaskHandle_t xTaskToSuspend )
{
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
        {
        pxTCB = prvGetTCBFromHandle( xTaskToSuspend );

        traceTASK_SUSPEND( pxTCB );

        if (uxListRemove(&( pxTCB->xStateListItem)) == (UBaseType_t)0) {
                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
        } else{
                mtCOVERAGE_TEST_MARKER();
        }

        if ( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL ) {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );

        #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        BaseType_t x;
        for ( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ ) {
                if ( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION ) {
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
                }
        }
        #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();


        if ( xSchedulerRunning != pdFALSE ) {
                taskENTER_CRITICAL();
                prvResetNextTaskUnblockTime();
                taskEXIT_CRITICAL();
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB ) {
                if ( xSchedulerRunning != pdFALSE ) {
                        configASSERT( uxSchedulerSuspended == 0 );
                        portYIELD_WITHIN_API();
                } else {
                        if (listCURRENT_LIST_LENGTH( 
                                &xSuspendedTaskList) == uxCurrentNumberOfTasks) {
                                        pxCurrentTCB = NULL;
                        } else {
                                vTaskSwitchContext();
                        }
                }
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
}
#endif /* INCLUDE_vTaskSuspend */
//______________________________________________________________________________



#if ( INCLUDE_vTaskSuspend == 1 )
//______________________________________________________________________________
static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
{
        BaseType_t xReturn = pdFALSE;
        const TCB_t * const pxTCB = xTask;

        /* Accesses xPendingReadyList so must be called from a critical
         * section. */

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, 
                        &(pxTCB->xStateListItem)) != pdFALSE) {
                if ( listIS_CONTAINED_WITHIN( &xPendingReadyList, 
                                &( pxTCB->xEventListItem ) ) == pdFALSE ) {
                        if ( listIS_CONTAINED_WITHIN( NULL, 
                                        &( pxTCB->xEventListItem ) ) != pdFALSE ) {
                                                xReturn = pdTRUE;
                        } else {
                                mtCOVERAGE_TEST_MARKER();
                        }
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
}
#endif /* INCLUDE_vTaskSuspend */
//______________________________________________________________________________



#if ( INCLUDE_vTaskSuspend == 1 )
//______________________________________________________________________________
void vTaskResume( TaskHandle_t xTaskToResume )
{
        TCB_t * const pxTCB = xTaskToResume;

        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if ( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) ) {
                taskENTER_CRITICAL();
                {
                if ( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE ) {
                        traceTASK_RESUME( pxTCB );
                        ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                        prvAddTaskToReadyList( pxTCB );

                        if ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority ) {
                                taskYIELD_IF_USING_PREEMPTION();
                        } else {
                                mtCOVERAGE_TEST_MARKER();
                        }
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
                }
                taskEXIT_CRITICAL();
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
}
#endif /* INCLUDE_vTaskSuspend */
//______________________________________________________________________________



#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
//______________________________________________________________________________
BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
{
        BaseType_t xYieldRequired = pdFALSE;
        TCB_t * const pxTCB = xTaskToResume;
        UBaseType_t uxSavedInterruptStatus;

        configASSERT( xTaskToResume );

        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
        if ( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE ) {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                if ( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE ) {
                        if ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority ) {
                                xYieldRequired = pdTRUE;
                                xYieldPending = pdTRUE;
                        } else {
                                mtCOVERAGE_TEST_MARKER();
                        }

                        ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                        prvAddTaskToReadyList( pxTCB );
                } else {
                        vListInsertEnd(&(xPendingReadyList), &(pxTCB->xEventListItem));
                }
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
}
#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
//______________________________________________________________________________



void vTaskStartScheduler( void )
{
        BaseType_t xReturn;

        /* Add the idle task at the lowest priority. */
        #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
        StaticTask_t * pxIdleTaskTCBBuffer = NULL;
        StackType_t * pxIdleTaskStackBuffer = NULL;
        uint32_t ulIdleTaskStackSize;

        /* The Idle task is created using user provided RAM - obtain the
        * address of the RAM then create the idle task. */
        vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, 
                                       &pxIdleTaskStackBuffer, 
                                       &ulIdleTaskStackSize );
        xIdleTaskHandle = xTaskCreateStatic(    prvIdleTask,
                                                configIDLE_TASK_NAME,
                                                ulIdleTaskStackSize,
                                                ( void * ) NULL,
                                                 portPRIVILEGE_BIT,
                                                 pxIdleTaskStackBuffer,
                                                 pxIdleTaskTCBBuffer );

        if ( xIdleTaskHandle != NULL ) {
                xReturn = pdPASS;
        } else {
                xReturn = pdFAIL;
        }
        #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate(  prvIdleTask,
                                configIDLE_TASK_NAME,
                                configMINIMAL_STACK_SIZE,
                                ( void * ) NULL,
                                portPRIVILEGE_BIT,
                                &xIdleTaskHandle );
        #endif /* configSUPPORT_STATIC_ALLOCATION */


        #if ( configUSE_TIMERS == 1 )
        {
        if ( xReturn == pdPASS ) {
                xReturn = xTimerCreateTimerTask();
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
        }
        #endif /* configUSE_TIMERS */


        if ( xReturn == pdPASS ) {
                #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
                freertos_tasks_c_additions_init();
                #endif

                portDISABLE_INTERRUPTS();

                #if ( configUSE_NEWLIB_REENTRANT == 1 )
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
                #endif /* configUSE_NEWLIB_REENTRANT */

                xNextTaskUnblockTime = portMAX_DELAY;
                xSchedulerRunning = pdTRUE;
                xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;

                portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

                traceTASK_SWITCHED_IN();

                if ( xPortStartScheduler() != pdFALSE ) {
                /* Should not reach here as if the scheduler is running the
                * function will not return. */
                } else {
                /* Should only reach here if a task calls xTaskEndScheduler(). */
                }
        } else {
                configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
        }

        /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
        * meaning xIdleTaskHandle is not used anywhere else. */
        ( void ) xIdleTaskHandle;

        /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
        * from getting optimized out as it is no longer used by the kernel. */
        ( void ) uxTopUsedPriority;
}



void vTaskEndScheduler( void )
{
        portDISABLE_INTERRUPTS();
        xSchedulerRunning = pdFALSE;
        vPortEndScheduler();
}



void vTaskSuspendAll( void )
{
        portSOFTWARE_BARRIER();
        ++uxSchedulerSuspended;
        portMEMORY_BARRIER();
}



#if (configUSE_TICKLESS_IDLE != 0)
//______________________________________________________________________________
static TickType_t prvGetExpectedIdleTime( void )
{
        TickType_t xReturn;
        UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;

        #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
        if (uxTopReadyPriority > tskIDLE_PRIORITY) {
                uxHigherPriorityReadyTasks = pdTRUE;
        }
        #else
        const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
        if ( uxTopReadyPriority > uxLeastSignificantBit ) {
                    uxHigherPriorityReadyTasks = pdTRUE;
        }
        #endif /* if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 ) */

        if ( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY ) {
                xReturn = 0;
        } else if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > 1 ) {
                xReturn = 0;
        } else if ( uxHigherPriorityReadyTasks != pdFALSE ) {
                xReturn = 0;
        } else {
                xReturn = xNextTaskUnblockTime - xTickCount;
        }

        return xReturn;
}
#endif /* configUSE_TICKLESS_IDLE */
//______________________________________________________________________________



BaseType_t xTaskResumeAll( void )
{
        TCB_t * pxTCB = NULL;
        BaseType_t xAlreadyYielded = pdFALSE;

        configASSERT( uxSchedulerSuspended );

        taskENTER_CRITICAL();
        {
        --uxSchedulerSuspended;

        if ( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE ) {
                if ( uxCurrentNumberOfTasks > ( UBaseType_t )0U) {
                        while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
                                pxTCB = listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
                                listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                                portMEMORY_BARRIER();
                                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                                prvAddTaskToReadyList( pxTCB );

                                if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
                                        xYieldPending = pdTRUE;
                                } else {
                                        mtCOVERAGE_TEST_MARKER();
                                }
                        }

                        if ( pxTCB != NULL ) {
                                prvResetNextTaskUnblockTime();
                        }

                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {//_____________________________________________________________
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */

                        if( xPendedCounts > ( TickType_t ) 0U ) {
                                do {
                                        if( xTaskIncrementTick() != pdFALSE ) {
                                                xYieldPending = pdTRUE;
                                        } else {
                                                mtCOVERAGE_TEST_MARKER();
                                        }

                                        --xPendedCounts;
                                } while ( xPendedCounts > ( TickType_t ) 0U );
                                xPendedTicks = 0;
                        } else {
                                mtCOVERAGE_TEST_MARKER();
                        }
                }//_____________________________________________________________

                        if ( xYieldPending != pdFALSE ) {
                                #if ( configUSE_PREEMPTION != 0 )
                                xAlreadyYielded = pdTRUE;
                                #endif
                                taskYIELD_IF_USING_PREEMPTION();
                        } else {
                                mtCOVERAGE_TEST_MARKER();
                        }
                }
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
        }
        taskEXIT_CRITICAL();

        return xAlreadyYielded;
}



TickType_t xTaskGetTickCount( void )
{
        TickType_t xTicks;

        /* Critical section required if running on a 16 bit processor. */
        portTICK_TYPE_ENTER_CRITICAL();
        {
                xTicks = xTickCount;
        }
        portTICK_TYPE_EXIT_CRITICAL();

        return xTicks;
}



TickType_t xTaskGetTickCountFromISR( void )
{
        TickType_t xReturn;
        UBaseType_t uxSavedInterruptStatus;

        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
        {   
                xReturn = xTickCount;
        }
        portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
}



UBaseType_t uxTaskGetNumberOfTasks( void )
{
        /* A critical section is not required because the variables are of type
        * BaseType_t. */
        return uxCurrentNumberOfTasks;
}
/*-----------------------------------------------------------*/



char * pcTaskGetName( TaskHandle_t xTaskToQuery )
{
        TCB_t * pxTCB;

        /* If null is passed in here then the name of the calling task is being
        * queried. */
        pxTCB = prvGetTCBFromHandle( xTaskToQuery );
        configASSERT( pxTCB );
        return &( pxTCB->pcTaskName[ 0 ] );
}



#if (INCLUDE_xTaskGetHandle == 1)
//______________________________________________________________________________
static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
                                                const char pcNameToQuery[] )
{
        TCB_t * pxNextTCB, * pxFirstTCB, * pxReturn = NULL;
        UBaseType_t x;
        char cNextChar;
        BaseType_t xBreakLoop;

        /* This function is called with the scheduler suspended. */

        if ( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 ) {
                listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );

                do {
                        listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
                        xBreakLoop = pdFALSE;

                        for (x = (UBaseType_t)0; 
                                x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
                                cNextChar = pxNextTCB->pcTaskName[ x ];

                                if ( cNextChar != pcNameToQuery[ x ] ) {
                                        /* Characters didn't match. */
                                        xBreakLoop = pdTRUE;
                                } else if ( cNextChar == ( char ) 0x00 ) {
                                        pxReturn = pxNextTCB;
                                        xBreakLoop = pdTRUE;
                                } else {
                                        mtCOVERAGE_TEST_MARKER();
                                }

                                if( xBreakLoop != pdFALSE ) {
                                        break;
                                }
                        }
                        if ( pxReturn != NULL ) {
                                /* The handle has been found. */
                                break;
                        }
                } while ( pxNextTCB != pxFirstTCB );
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        return pxReturn;
}
#endif /* INCLUDE_xTaskGetHandle */
//______________________________________________________________________________



#if ( INCLUDE_xTaskGetHandle == 1 )
//______________________________________________________________________________
TaskHandle_t xTaskGetHandle( const char * pcNameToQuery ) 
{
        UBaseType_t uxQueue = configMAX_PRIORITIES;
        TCB_t * pxTCB;

        /* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
        configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );

        vTaskSuspendAll();
        {
        /* Search the ready lists. */
        do {
                uxQueue--;
                pxTCB = prvSearchForNameWithinSingleList( 
                                ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), 
                                        pcNameToQuery );
                if ( pxTCB != NULL ) {
                        /* Found the handle. */
                        break;
                }
        } while ( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );
        
        /* Search the delayed lists. */
        if ( pxTCB == NULL ) {
                pxTCB = prvSearchForNameWithinSingleList( 
                                ( List_t * ) pxDelayedTaskList, pcNameToQuery );
        }

        if ( pxTCB == NULL ) {
                pxTCB = prvSearchForNameWithinSingleList( 
                        ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
        }

        #if ( INCLUDE_vTaskSuspend == 1 )
        if ( pxTCB == NULL ) {
                /* Search the suspended list. */
                pxTCB = prvSearchForNameWithinSingleList( 
                        &xSuspendedTaskList, pcNameToQuery );
        }
        #endif

        #if ( INCLUDE_vTaskDelete == 1 )
        if ( pxTCB == NULL ) {
                /* Search the deleted list. */
                pxTCB = prvSearchForNameWithinSingleList( 
                        &xTasksWaitingTermination, pcNameToQuery );
        }
        #endif
        }
        ( void ) xTaskResumeAll();

        return pxTCB;
}
#endif /* INCLUDE_xTaskGetHandle */
//______________________________________________________________________________



#if ( configUSE_TRACE_FACILITY == 1 )
//______________________________________________________________________________
UBaseType_t uxTaskGetSystemState( 
                TaskStatus_t * const pxTaskStatusArray,
                const UBaseType_t uxArraySize,
                configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime )
{
        UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;

        vTaskSuspendAll();
        {
        /* Is there a space in the array for each task in the system? */
        if ( uxArraySize >= uxCurrentNumberOfTasks ) {
                /* Fill in an TaskStatus_t structure with information on each
                 * task in the Ready state. */
                do {
                        uxQueue--;
                        uxTask += prvListTasksWithinSingleList( 
                                &( pxTaskStatusArray[ uxTask ] ), 
                                &( pxReadyTasksLists[ uxQueue ] ), 
                                eReady );
                } while ( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );

                /* Fill in an TaskStatus_t structure with information on each
                 * task in the Blocked state. */
                uxTask += prvListTasksWithinSingleList( 
                        &( pxTaskStatusArray[ uxTask ] ), 
                        ( List_t * ) pxDelayedTaskList, 
                        eBlocked );
                uxTask += prvListTasksWithinSingleList( 
                        &( pxTaskStatusArray[ uxTask ] ), 
                        ( List_t * ) pxOverflowDelayedTaskList, 
                        eBlocked );

                #if ( INCLUDE_vTaskDelete == 1 )
                /* Fill in an TaskStatus_t structure with information on
                * each task that has been deleted but not yet cleaned up. */
                uxTask += prvListTasksWithinSingleList( 
                        &( pxTaskStatusArray[ uxTask ] ), 
                        &xTasksWaitingTermination, 
                        eDeleted );
                #endif

                #if ( INCLUDE_vTaskSuspend == 1 )
                /* Fill in an TaskStatus_t structure with information on
                * each task in the Suspended state. */
                uxTask += prvListTasksWithinSingleList( 
                        &( pxTaskStatusArray[ uxTask ] ), 
                        &xSuspendedTaskList, 
                        eSuspended );
                #endif

                #if ( configGENERATE_RUN_TIME_STATS == 1 )
                if( pulTotalRunTime != NULL ) {
                        #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
                        portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
                        #else
                        *pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
                        #endif
                }
                #else /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
                if ( pulTotalRunTime != NULL ) {
                        *pulTotalRunTime = 0;
                }
                #endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
                
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
        }
        ( void ) xTaskResumeAll();

        return uxTask;
}
#endif /* configUSE_TRACE_FACILITY */
//______________________________________________________________________________



#if (INCLUDE_xTaskGetIdleTaskHandle == 1)
//______________________________________________________________________________
TaskHandle_t xTaskGetIdleTaskHandle( void ) {
        /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
         * started, then xIdleTaskHandle will be NULL. */
        configASSERT( ( xIdleTaskHandle != NULL ) );
        return xIdleTaskHandle;
}
#endif /* INCLUDE_xTaskGetIdleTaskHandle */
//______________________________________________________________________________



#if ( configUSE_TICKLESS_IDLE != 0 )
//______________________________________________________________________________
void vTaskStepTick( const TickType_t xTicksToJump )
{
        /* Correct the tick count value after a period during which the tick
         * was suppressed.  Note this does *not* call the tick hook function for
         * each stepped tick. */
        configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
        xTickCount += xTicksToJump;
        traceINCREASE_TICK_COUNT( xTicksToJump );
}
#endif /* configUSE_TICKLESS_IDLE */
//______________________________________________________________________________



BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
        BaseType_t xYieldOccurred;

        /* Must not be called with the scheduler suspended as the implementation
        * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
        configASSERT( uxSchedulerSuspended == 0 );

        /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
        * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
        vTaskSuspendAll();
        xPendedTicks += xTicksToCatchUp;
        xYieldOccurred = xTaskResumeAll();

        return xYieldOccurred;
}



#if (INCLUDE_xTaskAbortDelay == 1)
//______________________________________________________________________________
BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
{
        TCB_t * pxTCB = xTask;
        BaseType_t xReturn;

        configASSERT( pxTCB );

        vTaskSuspendAll();
        {
        /* A task can only be prematurely removed from the Blocked state if
        * it is actually in the Blocked state. */
        if ( eTaskGetState( xTask ) == eBlocked ) {
                xReturn = pdPASS;

                /* Remove the reference to the task from the blocked list.  An
                 * interrupt won't touch the xStateListItem because the
                 * scheduler is suspended. */
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );

                /* Is the task waiting on an event also?  If so remove it from
                 * the event list too.  Interrupts can touch the event list item,
                 * even though the scheduler is suspended, so a critical section
                 * is used. */
                taskENTER_CRITICAL();
                {
                if ( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL ) {
                         ( void ) uxListRemove( &( pxTCB->xEventListItem ) );

                        /* This lets the task know it was forcibly removed from the
                         * blocked state so it should not re-evaluate its block time and
                         * then block again. */
                        pxTCB->ucDelayAborted = pdTRUE;
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
                }
                taskEXIT_CRITICAL();

                /* Place the unblocked task into the appropriate ready list. */
                prvAddTaskToReadyList( pxTCB );

                #if ( configUSE_PREEMPTION == 1 )
                if ( pxTCB->uxPriority > pxCurrentTCB->uxPriority ) {
                        xYieldPending = pdTRUE;
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
                #endif /* configUSE_PREEMPTION */
        } else {
                xReturn = pdFAIL;
        }
        }
        ( void ) xTaskResumeAll();

        return xReturn;
}
#endif /* INCLUDE_xTaskAbortDelay */
//______________________________________________________________________________



BaseType_t xTaskIncrementTick( void )
{
        TCB_t * pxTCB;
        TickType_t xItemValue;
        BaseType_t xSwitchRequired = pdFALSE;

        /* Called by the portable layer each time a tick interrupt occurs.
        * Increments the tick then checks to see if the new tick value will cause any
        * tasks to be unblocked. */
        traceTASK_INCREMENT_TICK( xTickCount );

        if ( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE ) {
                /* Minor optimisation.  The tick count cannot change in this
                * block. */
                const TickType_t xConstTickCount = xTickCount + (TickType_t)1;

                /* Increment the RTOS tick, switching the delayed and overflowed
                * delayed lists if it wraps to 0. */
                xTickCount = xConstTickCount;

                if ( xConstTickCount == ( TickType_t ) 0U ) {
                        taskSWITCH_DELAYED_LISTS();
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }


                if ( xConstTickCount >= xNextTaskUnblockTime ) {
                        for ( ; ; ) {
                                if ( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE ) {
                                        xNextTaskUnblockTime = portMAX_DELAY;
                                        break;
                                } else {
                                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
                                        xItemValue = listGET_LIST_ITEM_VALUE( 
                                                &( pxTCB->xStateListItem ) );

                                        if ( xConstTickCount < xItemValue ) {
                                                xNextTaskUnblockTime = xItemValue;
                                                break;
                                        } else {
                                                mtCOVERAGE_TEST_MARKER();
                                        }

                                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );

                                        if ( listLIST_ITEM_CONTAINER( 
                                                &( pxTCB->xEventListItem ) ) != NULL ) {
                                                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                                        } else {
                                                mtCOVERAGE_TEST_MARKER();
                                        }

                                        prvAddTaskToReadyList( pxTCB );

                                        #if ( configUSE_PREEMPTION == 1 )
                                        if ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority ) {
                                                xSwitchRequired = pdTRUE;
                                        } else {
                                                mtCOVERAGE_TEST_MARKER();
                                        }
                                        #endif /* configUSE_PREEMPTION */
                                }
                        }
                }


                #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
                if( listCURRENT_LIST_LENGTH( 
                        &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 ) {
                                xSwitchRequired = pdTRUE;
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
                #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */


                #if ( configUSE_TICK_HOOK == 1 )
                if ( xPendedTicks == ( TickType_t ) 0 ) {
                        vApplicationTickHook();
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
                #endif /* configUSE_TICK_HOOK */


                #if ( configUSE_PREEMPTION == 1 )
                if ( xYieldPending != pdFALSE ) {
                        xSwitchRequired = pdTRUE;
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
                #endif /* configUSE_PREEMPTION */
        } else {
                ++xPendedTicks;

                /* The tick hook gets called at regular intervals, even if the
                * scheduler is locked. */
                #if ( configUSE_TICK_HOOK == 1 )
                vApplicationTickHook();
                #endif
        }

        return xSwitchRequired;
}



#if ( configUSE_APPLICATION_TASK_TAG == 1 )
//______________________________________________________________________________
void vTaskSetApplicationTaskTag( TaskHandle_t xTask,
                                TaskHookFunction_t pxHookFunction )
{
        TCB_t * xTCB;

        if ( xTask == NULL ) {
                xTCB = ( TCB_t * ) pxCurrentTCB;
        } else {
                xTCB = xTask;
        }

        /* Save the hook function in the TCB.  A critical section is required as
         * the value can be accessed from an interrupt. */
        taskENTER_CRITICAL();
        {
                xTCB->pxTaskTag = pxHookFunction;
        }
        taskEXIT_CRITICAL();
}
#endif /* configUSE_APPLICATION_TASK_TAG */
//______________________________________________________________________________



#if ( configUSE_APPLICATION_TASK_TAG == 1 )
//______________________________________________________________________________
TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
{
        TCB_t * pxTCB;
        TaskHookFunction_t xReturn;

        /* If xTask is NULL then set the calling task's hook. */
        pxTCB = prvGetTCBFromHandle( xTask );

        /* Save the hook function in the TCB.  A critical section is required as
         * the value can be accessed from an interrupt. */
        taskENTER_CRITICAL();
        {
            xReturn = pxTCB->pxTaskTag;
        }
        taskEXIT_CRITICAL();

        return xReturn;
}
#endif /* configUSE_APPLICATION_TASK_TAG */
//______________________________________________________________________________



#if ( configUSE_APPLICATION_TASK_TAG == 1 )
//______________________________________________________________________________
TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
{
        TCB_t * pxTCB;
        TaskHookFunction_t xReturn;
        UBaseType_t uxSavedInterruptStatus;

        /* If xTask is NULL then set the calling task's hook. */
        pxTCB = prvGetTCBFromHandle( xTask );

        /* Save the hook function in the TCB.  A critical section is required as
         * the value can be accessed from an interrupt. */
        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            xReturn = pxTCB->pxTaskTag;
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
}
#endif /* configUSE_APPLICATION_TASK_TAG */
//______________________________________________________________________________



#if ( configUSE_APPLICATION_TASK_TAG == 1 )
//______________________________________________________________________________
BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask,
                                        void * pvParameter )
{
        TCB_t * xTCB;
        BaseType_t xReturn;

        /* If xTask is NULL then we are calling our own task hook. */
        if ( xTask == NULL ) {
                xTCB = pxCurrentTCB;
        } else {
                xTCB = xTask;
        }

        if ( xTCB->pxTaskTag != NULL ) {
                xReturn = xTCB->pxTaskTag( pvParameter );
        } else {
                xReturn = pdFAIL;
        }

        return xReturn;
}
#endif /* configUSE_APPLICATION_TASK_TAG */
//______________________________________________________________________________



void vTaskSwitchContext( void )
{
        if ( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE ) {
                /* The scheduler is currently suspended - do not allow a context
                * switch. */
                xYieldPending = pdTRUE;
        } else {
                xYieldPending = pdFALSE;
                traceTASK_SWITCHED_OUT();

                #if ( configGENERATE_RUN_TIME_STATS == 1 )
                {
                #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
                portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
                #else
                ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
                #endif
                if ( ulTotalRunTime > ulTaskSwitchedInTime ) {
                        pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
                ulTaskSwitchedInTime = ulTotalRunTime;
                }
                #endif /* configGENERATE_RUN_TIME_STATS */

                /* Check for stack overflow, if configured. */
                taskCHECK_FOR_STACK_OVERFLOW();

                /* Before the currently running task is switched out, save its errno. */
                #if ( configUSE_POSIX_ERRNO == 1 )
                pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
                #endif

                /* Select a new task to run using either the generic C or port
                * optimised asm code. */
                taskSELECT_HIGHEST_PRIORITY_TASK(); 
                traceTASK_SWITCHED_IN();

                /* After the new task is switched in, update the global errno. */
                #if ( configUSE_POSIX_ERRNO == 1 )
                FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
                #endif

                #if ( configUSE_NEWLIB_REENTRANT == 1 )
                {
                /* Switch Newlib's _impure_ptr variable to point to the _reent
                 * structure specific to this task.
                 * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
                }
                #endif /* configUSE_NEWLIB_REENTRANT */
        }
}



void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
        configASSERT( pxEventList );

        vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

        prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}



void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
        configASSERT( pxEventList );

        /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
        * the event groups implementation. */
        configASSERT( uxSchedulerSuspended != 0 );

        /* Store the item value in the event list item.  It is safe to access the
        * event list item here as interrupts won't access the event list item of a
        * task that is not in the Blocked state. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), 
        xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );


        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );

        prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}



#if ( configUSE_TIMERS == 1 )
//______________________________________________________________________________
    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
{
        configASSERT( pxEventList );

        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );


        if ( xWaitIndefinitely != pdFALSE ) {
                xTicksToWait = portMAX_DELAY;
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
}
#endif /* configUSE_TIMERS */
//______________________________________________________________________________



BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
        TCB_t * pxUnblockedTCB;
        BaseType_t xReturn;

        pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
        configASSERT( pxUnblockedTCB );
        listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );

        if ( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE ) {
                listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
                prvAddTaskToReadyList( pxUnblockedTCB );

                #if ( configUSE_TICKLESS_IDLE != 0 )
                prvResetNextTaskUnblockTime();
                #endif
        } else {
                listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
        }
        
        if ( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority ) {
                xReturn = pdTRUE;
                xYieldPending = pdTRUE;
        } else {
                xReturn = pdFALSE;
        }

        return xReturn;
}



void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
        TCB_t * pxUnblockedTCB;

        configASSERT( uxSchedulerSuspended != pdFALSE );

        listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );

        pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
        configASSERT( pxUnblockedTCB );
        listREMOVE_ITEM( pxEventListItem );

        #if ( configUSE_TICKLESS_IDLE != 0 )
        prvResetNextTaskUnblockTime();
        #endif


        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
        prvAddTaskToReadyList( pxUnblockedTCB );

        if ( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority ) {
                xYieldPending = pdTRUE;
        }
}



void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
        configASSERT( pxTimeOut );
        taskENTER_CRITICAL();
        {
                pxTimeOut->xOverflowCount = xNumOfOverflows;
                pxTimeOut->xTimeOnEntering = xTickCount;
        }
        taskEXIT_CRITICAL();
}



void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
        /* For internal use only as it does not use a critical section. */
        pxTimeOut->xOverflowCount = xNumOfOverflows;
        pxTimeOut->xTimeOnEntering = xTickCount;
}



BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
        BaseType_t xReturn;

        configASSERT( pxTimeOut );
        configASSERT( pxTicksToWait );

        taskENTER_CRITICAL();
        {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;

        #if ( INCLUDE_xTaskAbortDelay == 1 )
        if ( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE ) {
                /* The delay was aborted, which is not the same as a time out,
                 * but has the same result. */
                pxCurrentTCB->ucDelayAborted = pdFALSE;
                xReturn = pdTRUE;
        } else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
        if ( *pxTicksToWait == portMAX_DELAY ) {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
        }
        else
        #endif

        if ( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) 
                && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) {
                xReturn = pdTRUE;
                *pxTicksToWait = ( TickType_t ) 0;
        } else if ( xElapsedTime < *pxTicksToWait ) {
                *pxTicksToWait -= xElapsedTime;
                vTaskInternalSetTimeOutState( pxTimeOut );
                xReturn = pdFALSE;
        } else {
                *pxTicksToWait = ( TickType_t ) 0;
                xReturn = pdTRUE;
        }
        }
        taskEXIT_CRITICAL();

        return xReturn;
}



void vTaskMissedYield( void )
{
        xYieldPending = pdTRUE;
}



#if ( configUSE_TRACE_FACILITY == 1 )
//______________________________________________________________________________
UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
{
        UBaseType_t uxReturn;
        TCB_t const * pxTCB;

        if ( xTask != NULL ) {
                pxTCB = xTask;
                uxReturn = pxTCB->uxTaskNumber;
        } else {
                uxReturn = 0U;
        }

        return uxReturn;
}
#endif /* configUSE_TRACE_FACILITY */
//______________________________________________________________________________



#if ( configUSE_TRACE_FACILITY == 1 )
//______________________________________________________________________________
void vTaskSetTaskNumber( TaskHandle_t xTask,
                             const UBaseType_t uxHandle )
{
        TCB_t * pxTCB;

        if ( xTask != NULL ) {
                pxTCB = xTask;
                pxTCB->uxTaskNumber = uxHandle;
        }
}
#endif /* configUSE_TRACE_FACILITY */
//______________________________________________________________________________



static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    /* Stop warnings. */
    ( void ) pvParameters;

    /** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
     * SCHEDULER IS STARTED. **/

    /* In case a task that has a secure context deletes itself, in which case
     * the idle task is responsible for deleting the task's secure context, if
     * any. */
    portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();

        #if ( configUSE_PREEMPTION == 0 )
            {
                /* If we are not using preemption we keep forcing a task switch to
                 * see if any other task has become available.  If we are using
                 * preemption we don't need to do this as any task becoming available
                 * will automatically get the processor anyway. */
                taskYIELD();
            }
        #endif /* configUSE_PREEMPTION */

        #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
            {
                /* When using preemption tasks of equal priority will be
                 * timesliced.  If a task that is sharing the idle priority is ready
                 * to run then the idle task should yield before the end of the
                 * timeslice.
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
                {
                    taskYIELD();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */

        #if ( configUSE_IDLE_HOOK == 1 )
            {
                extern void vApplicationIdleHook( void );

                /* Call the user defined function from within the idle task.  This
                 * allows the application designer to add background functionality
                 * without the overhead of a separate task.
                 * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
                 * CALL A FUNCTION THAT MIGHT BLOCK. */
                vApplicationIdleHook();
            }
        #endif /* configUSE_IDLE_HOOK */

        /* This conditional compilation should use inequality to 0, not equality
         * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
         * user defined low power mode  implementations require
         * configUSE_TICKLESS_IDLE to be set to a value other than 1. */
        #if ( configUSE_TICKLESS_IDLE != 0 )
            {
                TickType_t xExpectedIdleTime;

                /* It is not desirable to suspend then resume the scheduler on
                 * each iteration of the idle task.  Therefore, a preliminary
                 * test of the expected idle time is performed without the
                 * scheduler suspended.  The result here is not necessarily
                 * valid. */
                xExpectedIdleTime = prvGetExpectedIdleTime();

                if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
                {
                    vTaskSuspendAll();
                    {
                        /* Now the scheduler is suspended, the expected idle
                         * time can be sampled again, and this time its value can
                         * be used. */
                        configASSERT( xNextTaskUnblockTime >= xTickCount );
                        xExpectedIdleTime = prvGetExpectedIdleTime();

                        /* Define the following macro to set xExpectedIdleTime to 0
                         * if the application does not want
                         * portSUPPRESS_TICKS_AND_SLEEP() to be called. */
                        configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );

                        if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
                        {
                            traceLOW_POWER_IDLE_BEGIN();
                            portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
                            traceLOW_POWER_IDLE_END();
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    ( void ) xTaskResumeAll();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_TICKLESS_IDLE */
    }
}
/*-----------------------------------------------------------*/

#if ( configUSE_TICKLESS_IDLE != 0 )

    eSleepModeStatus eTaskConfirmSleepModeStatus( void )
    {
        /* The idle task exists in addition to the application tasks. */
        const UBaseType_t uxNonApplicationTasks = 1;
        eSleepModeStatus eReturn = eStandardSleep;

        /* This function must be called from a critical section. */

        if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
        {
            /* A task was made ready while the scheduler was suspended. */
            eReturn = eAbortSleep;
        }
        else if( xYieldPending != pdFALSE )
        {
            /* A yield was pended while the scheduler was suspended. */
            eReturn = eAbortSleep;
        }
        else if( xPendedTicks != 0 )
        {
            /* A tick interrupt has already occurred but was held pending
             * because the scheduler is suspended. */
            eReturn = eAbortSleep;
        }
        else
        {
            /* If all the tasks are in the suspended list (which might mean they
             * have an infinite block time rather than actually being suspended)
             * then it is safe to turn all clocks off and just wait for external
             * interrupts. */
            if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
            {
                eReturn = eNoTasksWaitingTimeout;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        return eReturn;
    }

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )

    void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
                                            BaseType_t xIndex,
                                            void * pvValue )
    {
        TCB_t * pxTCB;

        if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
        {
            pxTCB = prvGetTCBFromHandle( xTaskToSet );
            configASSERT( pxTCB != NULL );
            pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
        }
    }

#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
/*-----------------------------------------------------------*/

#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )

    void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
                                               BaseType_t xIndex )
    {
        void * pvReturn = NULL;
        TCB_t * pxTCB;

        if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
        {
            pxTCB = prvGetTCBFromHandle( xTaskToQuery );
            pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
        }
        else
        {
            pvReturn = NULL;
        }

        return pvReturn;
    }

#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
/*-----------------------------------------------------------*/

#if ( portUSING_MPU_WRAPPERS == 1 )

    void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify,
                                  const MemoryRegion_t * const xRegions )
    {
        TCB_t * pxTCB;

        /* If null is passed in here then we are modifying the MPU settings of
         * the calling task. */
        pxTCB = prvGetTCBFromHandle( xTaskToModify );

        vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
    }

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    vListInitialise( &xDelayedTaskList2 );
    vListInitialise( &xPendingReadyList );

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    --uxCurrentNumberOfTasks;
                    --uxDeletedTasksWaitingCleanUp;
                }
                taskEXIT_CRITICAL();

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )
//______________________________________________________________________________
    void vTaskGetInfo( TaskHandle_t xTask,
                       TaskStatus_t * pxTaskStatus,
                       BaseType_t xGetFreeStackSpace,
                       eTaskState eState )
    {
        TCB_t * pxTCB;

        /* xTask is NULL then get the state of the calling task. */
        pxTCB = prvGetTCBFromHandle( xTask );

        pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
        pxTaskStatus->pxStackBase = pxTCB->pxStack;
        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;

        #if ( configUSE_MUTEXES == 1 )
            {
                pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
            }
        #else
            {
                pxTaskStatus->uxBasePriority = 0;
            }
        #endif

        #if ( configGENERATE_RUN_TIME_STATS == 1 )
            {
                pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
            }
        #else
            {
                pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
            }
        #endif

        /* Obtaining the task state is a little fiddly, so is only done if the
         * value of eState passed into this function is eInvalid - otherwise the
         * state is just set to whatever is passed in. */
        if( eState != eInvalid )
        {
            if( pxTCB == pxCurrentTCB )
            {
                pxTaskStatus->eCurrentState = eRunning;
            }
            else
            {
                pxTaskStatus->eCurrentState = eState;

                #if ( INCLUDE_vTaskSuspend == 1 )
                    {
                        /* If the task is in the suspended list then there is a
                         *  chance it is actually just blocked indefinitely - so really
                         *  it should be reported as being in the Blocked state. */
                        if( eState == eSuspended )
                        {
                            vTaskSuspendAll();
                            {
                                if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
                                {
                                    pxTaskStatus->eCurrentState = eBlocked;
                                }
                            }
                            ( void ) xTaskResumeAll();
                        }
                    }
                #endif /* INCLUDE_vTaskSuspend */
            }
        }
        else
        {
            pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
        }

        /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
         * parameter is provided to allow it to be skipped. */
        if( xGetFreeStackSpace != pdFALSE )
        {
            #if ( portSTACK_GROWTH > 0 )
                {
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
                }
            #else
                {
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
                }
            #endif
        }
        else
        {
            pxTaskStatus->usStackHighWaterMark = 0;
        }
    }

#endif /* configUSE_TRACE_FACILITY */
//______________________________________________________________________________



#if ( configUSE_TRACE_FACILITY == 1 )
//______________________________________________________________________________
    static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
                                                     List_t * pxList,
                                                     eTaskState eState )
    {
        configLIST_VOLATILE TCB_t * pxNextTCB, * pxFirstTCB;
        UBaseType_t uxTask = 0;

        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
        {
            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */

            /* Populate an TaskStatus_t structure within the
             * pxTaskStatusArray array for each task that is referenced from
             * pxList.  See the definition of TaskStatus_t in task.h for the
             * meaning of each TaskStatus_t structure member. */
            do
            {
                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
                uxTask++;
            } while( pxNextTCB != pxFirstTCB );
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return uxTask;
    }
#endif /* configUSE_TRACE_FACILITY */
//______________________________________________________________________________


#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
//______________________________________________________________________________
    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
        uint32_t ulCount = 0U;

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
        {
            pucStackByte -= portSTACK_GROWTH;
            ulCount++;
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */

        return ( configSTACK_DEPTH_TYPE ) ulCount;
    }

#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) ) */
//______________________________________________________________________________



#if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
//______________________________________________________________________________
/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
 * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
 * user to determine the return type.  It gets around the problem of the value
 * overflowing on 8-bit types without breaking backward compatibility for
 * applications that expect an 8-bit return type. */
    configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
    {
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        configSTACK_DEPTH_TYPE uxReturn;

        /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
         * the same except for their return type.  Using configSTACK_DEPTH_TYPE
         * allows the user to determine the return type.  It gets around the
         * problem of the value overflowing on 8-bit types without breaking
         * backward compatibility for applications that expect an 8-bit return
         * type. */

        pxTCB = prvGetTCBFromHandle( xTask );

        #if portSTACK_GROWTH < 0
            {
                pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
            }
        #else
            {
                pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
            }
        #endif

        uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );

        return uxReturn;
    }

#endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
//______________________________________________________________________________



#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
//______________________________________________________________________________
    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
    {
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        UBaseType_t uxReturn;

        pxTCB = prvGetTCBFromHandle( xTask );

        #if portSTACK_GROWTH < 0
            {
                pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
            }
        #else
            {
                pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
            }
        #endif

        uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );

        return uxReturn;
    }

#endif /* INCLUDE_uxTaskGetStackHighWaterMark */
//______________________________________________________________________________



#if ( INCLUDE_vTaskDelete == 1 )
//______________________________________________________________________________
    static void prvDeleteTCB( TCB_t * pxTCB )
    {
        /* This call is required specifically for the TriCore port.  It must be
         * above the vPortFree() calls.  The call is also used by ports/demos that
         * want to allocate and clean RAM statically. */
        portCLEAN_UP_TCB( pxTCB );

        /* Free up the memory allocated by the scheduler for the task.  It is up
         * to the task to free any memory allocated at the application level.
         * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
         * for additional information. */
        #if ( configUSE_NEWLIB_REENTRANT == 1 )
            {
                _reclaim_reent( &( pxTCB->xNewLib_reent ) );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
                vPortFree( pxTCB );
            }
        #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
            {
                /* The task could have been allocated statically or dynamically, so
                 * check what was statically allocated before trying to free the
                 * memory. */
                if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
                {
                    /* Both the stack and TCB were allocated dynamically, so both
                     * must be freed. */
                    vPortFreeStack( pxTCB->pxStack );
                    vPortFree( pxTCB );
                }
                else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
                {
                    /* Only the stack was statically allocated, so the TCB is the
                     * only memory that must be freed. */
                    vPortFree( pxTCB );
                }
                else
                {
                    /* Neither the stack nor the TCB were allocated dynamically, so
                     * nothing needs to be freed. */
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }

#endif /* INCLUDE_vTaskDelete */
//______________________________________________________________________________



static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    }
    else
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
//______________________________________________________________________________
    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;

        return xReturn;
    }

#endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
//______________________________________________________________________________

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
            {
                xReturn = taskSCHEDULER_RUNNING;
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
            }
        }

        return xReturn;
    }

#endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
//______________________________________________________________________________



#if ( configUSE_MUTEXES == 1 )
//______________________________________________________________________________
    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
                    {
                        /* It is known that the task is in its ready list so
                         * there is no need to check again and the port level
                         * reset macro can be called directly. */
                        portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
                    prvAddTaskToReadyList( pxMutexHolderTCB );
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
                {
                    /* The base priority of the mutex holder is lower than the
                     * priority of the task attempting to take the mutex, but the
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }

#endif /* configUSE_MUTEXES */
//______________________________________________________________________________



#if ( configUSE_MUTEXES == 1 )
//______________________________________________________________________________
    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
        {
            /* A task can only have an inherited priority if it holds the mutex.
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
                {
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
                    {
                        portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                    prvAddTaskToReadyList( pxTCB );

                    /* Return true to indicate that a context switch is required.
                     * This is only actually required in the corner case whereby
                     * multiple mutexes were held and the mutexes were given back
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }

#endif /* configUSE_MUTEXES */
//______________________________________________________________________________



#if ( configUSE_MUTEXES == 1 )
//______________________________________________________________________________
    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
        TCB_t * const pxTCB = pxMutexHolder;
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

        if( pxMutexHolder != NULL )
        {
            /* If pxMutexHolder is not NULL then the holder must hold at least
             * one mutex. */
            configASSERT( pxTCB->uxMutexesHeld );

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
                {
                    /* If a task has timed out because it already holds the
                     * mutex it was trying to obtain then it cannot of inherited
                     * its own priority. */
                    configASSERT( pxTCB != pxCurrentTCB );

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
                    pxTCB->uxPriority = uxPriorityToUse;

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* If the running task is not the task that holds the mutex
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
                        {
                            /* It is known that the task is in its ready list so
                             * there is no need to check again and the port level
                             * reset macro can be called directly. */
                            portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

#endif /* configUSE_MUTEXES */
//______________________________________________________________________________



#if ( portCRITICAL_NESTING_IN_TCB == 1 )
//______________________________________________________________________________
    void vTaskEnterCritical( void )
    {
        portDISABLE_INTERRUPTS();

        if( xSchedulerRunning != pdFALSE )
        {
            ( pxCurrentTCB->uxCriticalNesting )++;

            /* This is not the interrupt safe version of the enter critical
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( pxCurrentTCB->uxCriticalNesting == 1 )
            {
                portASSERT_IF_IN_ISR();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

#endif /* portCRITICAL_NESTING_IN_TCB */
//______________________________________________________________________________



#if ( portCRITICAL_NESTING_IN_TCB == 1 )
//______________________________________________________________________________
    void vTaskExitCritical( void )
    {
        if( xSchedulerRunning != pdFALSE )
        {
            if( pxCurrentTCB->uxCriticalNesting > 0U )
            {
                ( pxCurrentTCB->uxCriticalNesting )--;

                if( pxCurrentTCB->uxCriticalNesting == 0U )
                {
                    portENABLE_INTERRUPTS();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

#endif /* portCRITICAL_NESTING_IN_TCB */
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

    static char * prvWriteNameToBuffer( char * pcBuffer,
                                        const char * pcTaskName )
    {
        size_t x;

        /* Start by copying the entire string. */
        strcpy( pcBuffer, pcTaskName );

        /* Pad the end of the string with spaces to ensure columns line up when
         * printed out. */
        for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
        {
            pcBuffer[ x ] = ' ';
        }

        /* Terminate. */
        pcBuffer[ x ] = ( char ) 0x00;

        /* Return the new end of string. */
        return &( pcBuffer[ x ] );
    }

#endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    void vTaskList( char * pcWriteBuffer )
    {
        TaskStatus_t * pxTaskStatusArray;
        UBaseType_t uxArraySize, x;
        char cStatus;

        /*
         * PLEASE NOTE:
         *
         * This function is provided for convenience only, and is used by many
         * of the demo applications.  Do not consider it to be part of the
         * scheduler.
         *
         * vTaskList() calls uxTaskGetSystemState(), then formats part of the
         * uxTaskGetSystemState() output into a human readable table that
         * displays task: names, states, priority, stack usage and task number.
         * Stack usage specified as the number of unused StackType_t words stack can hold
         * on top of stack - not the number of bytes.
         *
         * vTaskList() has a dependency on the sprintf() C library function that
         * might bloat the code size, use a lot of stack, and provide different
         * results on different platforms.  An alternative, tiny, third party,
         * and limited functionality implementation of sprintf() is provided in
         * many of the FreeRTOS/Demo sub-directories in a file called
         * printf-stdarg.c (note printf-stdarg.c does not provide a full
         * snprintf() implementation!).
         *
         * It is recommended that production systems call uxTaskGetSystemState()
         * directly to get access to raw stats data, rather than indirectly
         * through a call to vTaskList().
         */


        /* Make sure the write buffer does not contain a string. */
        *pcWriteBuffer = ( char ) 0x00;

        /* Take a snapshot of the number of tasks in case it changes while this
         * function is executing. */
        uxArraySize = uxCurrentNumberOfTasks;

        /* Allocate an array index for each task.  NOTE!  if
         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
         * equate to NULL. */
        pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */

        if( pxTaskStatusArray != NULL )
        {
            /* Generate the (binary) data. */
            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );

            /* Create a human readable table from the binary data. */
            for( x = 0; x < uxArraySize; x++ )
            {
                switch( pxTaskStatusArray[ x ].eCurrentState )
                {
                    case eRunning:
                        cStatus = tskRUNNING_CHAR;
                        break;

                    case eReady:
                        cStatus = tskREADY_CHAR;
                        break;

                    case eBlocked:
                        cStatus = tskBLOCKED_CHAR;
                        break;

                    case eSuspended:
                        cStatus = tskSUSPENDED_CHAR;
                        break;

                    case eDeleted:
                        cStatus = tskDELETED_CHAR;
                        break;

                    case eInvalid: /* Fall through. */
                    default:       /* Should not get here, but it is included
                                    * to prevent static checking errors. */
                        cStatus = ( char ) 0x00;
                        break;
                }

                /* Write the task name to the string, padding with spaces so it
                 * can be printed in tabular form more easily. */
                pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );

                /* Write the rest of the string. */
                sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
                pcWriteBuffer += strlen( pcWriteBuffer );                                                                                                                                                                                                /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
            }

            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
             * is 0 then vPortFree() will be #defined to nothing. */
            vPortFree( pxTaskStatusArray );
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    void vTaskGetRunTimeStats( char * pcWriteBuffer )
    {
        TaskStatus_t * pxTaskStatusArray;
        UBaseType_t uxArraySize, x;
        configRUN_TIME_COUNTER_TYPE ulTotalTime, ulStatsAsPercentage;

        #if ( configUSE_TRACE_FACILITY != 1 )
            {
                #error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
            }
        #endif

        /*
         * PLEASE NOTE:
         *
         * This function is provided for convenience only, and is used by many
         * of the demo applications.  Do not consider it to be part of the
         * scheduler.
         *
         * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
         * of the uxTaskGetSystemState() output into a human readable table that
         * displays the amount of time each task has spent in the Running state
         * in both absolute and percentage terms.
         *
         * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
         * function that might bloat the code size, use a lot of stack, and
         * provide different results on different platforms.  An alternative,
         * tiny, third party, and limited functionality implementation of
         * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
         * a file called printf-stdarg.c (note printf-stdarg.c does not provide
         * a full snprintf() implementation!).
         *
         * It is recommended that production systems call uxTaskGetSystemState()
         * directly to get access to raw stats data, rather than indirectly
         * through a call to vTaskGetRunTimeStats().
         */

        /* Make sure the write buffer does not contain a string. */
        *pcWriteBuffer = ( char ) 0x00;

        /* Take a snapshot of the number of tasks in case it changes while this
         * function is executing. */
        uxArraySize = uxCurrentNumberOfTasks;

        /* Allocate an array index for each task.  NOTE!  If
         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
         * equate to NULL. */
        pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */

        if( pxTaskStatusArray != NULL )
        {
            /* Generate the (binary) data. */
            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );

            /* For percentage calculations. */
            ulTotalTime /= 100UL;

            /* Avoid divide by zero errors. */
            if( ulTotalTime > 0UL )
            {
                /* Create a human readable table from the binary data. */
                for( x = 0; x < uxArraySize; x++ )
                {
                    /* What percentage of the total run time has the task used?
                     * This will always be rounded down to the nearest integer.
                     * ulTotalRunTime has already been divided by 100. */
                    ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;

                    /* Write the task name to the string, padding with
                     * spaces so it can be printed in tabular form more
                     * easily. */
                    pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );

                    if( ulStatsAsPercentage > 0UL )
                    {
                        #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
                            {
                                sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
                            }
                        #else
                            {
                                /* sizeof( int ) == sizeof( long ) so a smaller
                                 * printf() library can be used. */
                                sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
                            }
                        #endif
                    }
                    else
                    {
                        /* If the percentage is zero here then the task has
                         * consumed less than 1% of the total run time. */
                        #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
                            {
                                sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
                            }
                        #else
                            {
                                /* sizeof( int ) == sizeof( long ) so a smaller
                                 * printf() library can be used. */
                                sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
                            }
                        #endif
                    }

                    pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
             * is 0 then vPortFree() will be #defined to nothing. */
            vPortFree( pxTaskStatusArray );
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
        }

        return pxCurrentTCB;
    }

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;

                if( xTicksToWait > ( TickType_t ) 0 )
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
                    traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWait );

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();

        taskENTER_CRITICAL();
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];

            if( ulReturn != 0UL )
            {
                if( xClearCountOnExit != pdFALSE )
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
        }
        taskEXIT_CRITICAL();

        return ulReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;

                if( xTicksToWait > ( TickType_t ) 0 )
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
                    traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWait );

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();

        taskENTER_CRITICAL();
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
            }

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
        }
        taskEXIT_CRITICAL();

        return xReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
        {
            if( pulPreviousNotificationValue != NULL )
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;

                case eNoAction:

                    /* The task is being notified without its notify value being
                     * updated. */
                    break;

                default:

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );

                    break;
            }

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                prvAddTaskToReadyList( pxTCB );

                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                #if ( configUSE_TICKLESS_IDLE != 0 )
                    {
                        /* If a task is blocked waiting for a notification then
                         * xNextTaskUnblockTime might be set to the blocked task's time
                         * out time.  If the task is unblocked for a reason other than
                         * a timeout xNextTaskUnblockTime is normally left unchanged,
                         * because it will automatically get reset to a new value when
                         * the tick count equals xNextTaskUnblockTime.  However if
                         * tickless idling is used it might be more important to enter
                         * sleep mode at the earliest possible time - so reset
                         * xNextTaskUnblockTime here to ensure it is updated at the
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();

        return xReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify,
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
        UBaseType_t uxSavedInterruptStatus;

        configASSERT( xTaskToNotify );
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
         * failure if a FreeRTOS API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;

                case eNoAction:

                    /* The task is being notified without its notify value being
                     * updated. */
                    break;

                default:

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
            }

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        UBaseType_t uxSavedInterruptStatus;

        configASSERT( xTaskToNotify );
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
         * failure if a FreeRTOS API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
        TCB_t * pxTCB;
        BaseType_t xReturn;

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );

        taskENTER_CRITICAL();
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
                xReturn = pdPASS;
            }
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();

        return xReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );

        taskENTER_CRITICAL();
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
        }
        taskEXIT_CRITICAL();

        return ulReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )

    configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void )
    {
        return xIdleTaskHandle->ulRunTimeCounter;
    }

#endif
/*-----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )

    configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void )
    {
        configRUN_TIME_COUNTER_TYPE ulTotalTime, ulReturn;

        ulTotalTime = portGET_RUN_TIME_COUNTER_VALUE();

        /* For percentage calculations. */
        ulTotalTime /= ( configRUN_TIME_COUNTER_TYPE ) 100;

        /* Avoid divide by zero errors. */
        if( ulTotalTime > ( configRUN_TIME_COUNTER_TYPE ) 0 )
        {
            ulReturn = xIdleTaskHandle->ulRunTimeCounter / ulTotalTime;
        }
        else
        {
            ulReturn = 0;
        }

        return ulReturn;
    }

#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
        TickType_t xTimeToWake;
        const TickType_t xConstTickCount = xTickCount;

        #if ( INCLUDE_xTaskAbortDelay == 1 )
        pxCurrentTCB->ucDelayAborted = pdFALSE;
        #endif

        if (uxListRemove( &( pxCurrentTCB->xStateListItem)) == (UBaseType_t) 0) {
                portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); 
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

#if ( INCLUDE_vTaskSuspend == 1 )
        if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
                listINSERT_END(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
        } else {
                xTimeToWake = xConstTickCount + xTicksToWait;
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
                if (xTimeToWake < xConstTickCount) {
                        vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
                } else {
                        vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
                        if ( xTimeToWake < xNextTaskUnblockTime ) {
                                xNextTaskUnblockTime = xTimeToWake;
                        } else {
                                mtCOVERAGE_TEST_MARKER();
                        }
                }
        }
#else /* INCLUDE_vTaskSuspend */
        xTimeToWake = xConstTickCount + xTicksToWait;

        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

        if ( xTimeToWake < xConstTickCount ) {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
        } else {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if ( xTimeToWake < xNextTaskUnblockTime ) {
                        xNextTaskUnblockTime = xTimeToWake;
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        }

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
#endif /* INCLUDE_vTaskSuspend */
}

/* Code below here allows additional code to be inserted into this source file,
 * especially where access to file scope functions and data is needed (for example
 * when performing module tests). */

#ifdef FREERTOS_MODULE_TEST
    #include "tasks_test_access_functions.h"
#endif


#if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )

    #include "freertos_tasks_c_additions.h"

    #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
        static void freertos_tasks_c_additions_init( void )
        {
            FREERTOS_TASKS_C_ADDITIONS_INIT();
        }
    #endif

#endif /* if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 ) */
