//______________________________________________________________________________
//      => 使用静态方法创建任务
//______________________________________________________________________________
#if( configSUPPORT_STATIC_ALLOCATION == 1 )
TaskHandle_t xTaskCreateStatic(
                                TaskFunction_t           pxTaskCode,
                                const char * const      pcName,
                                const uint32_t          ulStackDepth,
                                void * const            pvParameters,
                                UBaseType_t              uxPriority,
                                StackType_t * const     puxStackBuffer,
                                StaticTask_t * const    pxTaskBuffer ) 
{
        TCB_t *pxNewTCB;
        TaskHandle_t xReturn;

        if ((pxTaskBuffer != NULL) && (puxStackBuffer != NULL)) {
                pxNewTCB = ( TCB_t * ) pxTaskBuffer;
                pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;

                #if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
                #endif /* configSUPPORT_DYNAMIC_ALLOCATION */

                prvInitialiseNewTask(   pxTaskCode, pcName, ulStackDepth, 
                                        pvParameters, uxPriority, &xReturn, 
                                        pxNewTCB, NULL  );
                prvAddNewTaskToReadyList( pxNewTCB );
        } else {
                xReturn = NULL;
        }
        return xReturn;
}
#endif /* SUPPORT_STATIC_ALLOCATION */



//______________________________________________________________________________
//      => 使用动态方法创建任务
//______________________________________________________________________________
#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
BaseType_t xTaskCreate(	
                                TaskFunction_t          pxTaskCode,
                                const char * const      pcName,
                                const uint16_t          usStackDepth,
                                void * const            pvParameters,
                                UBaseType_t             uxPriority,
                                TaskHandle_t * const    pxCreatedTask) 
{
        TCB_t *pxNewTCB;
        BaseType_t xReturn;

        #if( portSTACK_GROWTH > 0 )
        //_____________________________________________________
        pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );

        if (pxNewTCB != NULL) {
                pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc(
                        (((size_t)usStackDepth) * sizeof(StackType_t)) );

                if( pxNewTCB->pxStack == NULL ) {
                        vPortFree( pxNewTCB );
                        pxNewTCB = NULL;
                }
        }
        #else /* portSTACK_GROWTH */
        //_____________________________________________________
        StackType_t *pxStack;
        pxStack = (StackType_t *)pvPortMalloc( 
                (((size_t)usStackDepth) * sizeof(StackType_t)) ); 

        if (pxStack != NULL) {
                pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t)); 
                if (pxNewTCB != NULL) {
                        pxNewTCB->pxStack = pxStack;
                } else {
                        vPortFree( pxStack );
                }
        } else {
                pxNewTCB = NULL;
        }
        #endif /* portSTACK_GROWTH */

        if (pxNewTCB != NULL) {
                #if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewTask(   pxTaskCode, pcName, (uint32_t)usStackDepth, 
                                        pvParameters, uxPriority, pxCreatedTask, 
                                        pxNewTCB, NULL  );
                prvAddNewTaskToReadyList( pxNewTCB );
                xReturn = pdPASS;
        } else {
                xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }
        return xReturn;
}
#endif /* configSUPPORT_DYNAMIC_ALLOCATION */



//______________________________________________________________________________
//      => 初始化新的任务
//______________________________________________________________________________
static void prvInitialiseNewTask(
                                TaskFunction_t                  pxTaskCode,
                                const char * const              pcName,
                                const uint32_t                  ulStackDepth,
                                void * const                    pvParameters,
                                UBaseType_t                     uxPriority,
                                TaskHandle_t * const            pxCreatedTask,
                                TCB_t *                         pxNewTCB,
                                const MemoryRegion_t * const    xRegions   )
{
        StackType_t *pxTopOfStack;
        UBaseType_t x;

        #if( portUSING_MPU_WRAPPERS == 1 )
        /* Should the task be created in privileged mode? */
        BaseType_t xRunPrivileged;
        if ((uxPriority & portPRIVILEGE_BIT) != 0U) {
                xRunPrivileged = pdTRUE;
        } else {
                xRunPrivileged = pdFALSE;
        }
        uxPriority &= ~portPRIVILEGE_BIT;
        #endif /* portUSING_MPU_WRAPPERS == 1 */

        /* Avoid dependency on memset() if it is not required. */
        #if (   (configCHECK_FOR_STACK_OVERFLOW > 1)    ||      \
        (configUSE_TRACE_FACILITY == 1)                 ||      \
        (INCLUDE_uxTaskGetStackHighWaterMark == 1)    )
        /* Fill the stack with a known value to assist debugging. */
        (void)memset(   pxNewTCB->pxStack, 
                        (int)tskSTACK_FILL_BYTE, 
                        (size_t)ulStackDepth * sizeof(StackType_t) );
        #endif


        #if( portSTACK_GROWTH < 0 )
        //_____________________________________________________
        pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        pxTopOfStack = (StackType_t *) ( 
                ((portPOINTER_SIZE_TYP) pxTopOfStack) & 
                (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)) );
        /* Check the alignment of the calculated top of stack is correct. */
        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & 
                ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
        
        #else /* portSTACK_GROWTH */
        //_____________________________________________________
        pxTopOfStack = pxNewTCB->pxStack;

        /* Check the alignment of the stack buffer is correct. */
        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & 
                ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

        /* The other extreme of the stack space is required if stack checking is
        performed. */
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        #endif /* portSTACK_GROWTH */


        /* Store the task name in the TCB. */
        for (x = (UBaseType_t) 0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
                pxNewTCB->pcTaskName[ x ] = pcName[ x ];
                if (pcName[ x ] == 0x00) {
                        break;
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        }

        /* Ensure the name string is terminated in the case that the string length
        was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';

        /* This is used as an array index so must ensure it's not too large.  First
        remove the privilege bit if one is present. */
        if (uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES) {
                uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
        } else {
                mtCOVERAGE_TEST_MARKER();
        }

        pxNewTCB->uxPriority = uxPriority;
        
        #if (configUSE_MUTEXES == 1)
        pxNewTCB->uxBasePriority = uxPriority;
        pxNewTCB->uxMutexesHeld = 0;
        #endif /* configUSE_MUTEXES */

        vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
        vListInitialiseItem( &( pxNewTCB->xEventListItem ) );

        /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
        back to	the containing TCB from a generic item in a list. */
        listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );

        /* Event lists are always in priority order. */
        listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), 
                ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); 
        /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
        listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );

        #if ( portCRITICAL_NESTING_IN_TCB == 1 )
        pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
        #endif /* portCRITICAL_NESTING_IN_TCB */

        #if ( configUSE_APPLICATION_TASK_TAG == 1 )
        pxNewTCB->pxTaskTag = NULL;
        #endif /* configUSE_APPLICATION_TASK_TAG */

        #if ( configGENERATE_RUN_TIME_STATS == 1 )
        pxNewTCB->ulRunTimeCounter = 0UL;
        #endif /* configGENERATE_RUN_TIME_STATS */

        #if ( portUSING_MPU_WRAPPERS == 1 )
        vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), 
                xRegions, pxNewTCB->pxStack, ulStackDepth );
        #else
        /* Avoid compiler warning about unreferenced parameter. */
        ( void ) xRegions;
        #endif

        #if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
        for (x = 0; x < (UBaseType_ )configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++) {
                pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
        }
        #endif

        #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        pxNewTCB->ulNotifiedValue = 0;
        pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
        #endif

        #if ( configUSE_NEWLIB_REENTRANT == 1 )
        /* Initialise this task's Newlib reent structure. */
        _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
        #endif

        #if( INCLUDE_xTaskAbortDelay == 1 )
        pxNewTCB->ucDelayAborted = pdFALSE;
        #endif

        /* Initialize the TCB stack to look as if the task was already running,
        but had been interrupted by the scheduler.  The return address is set
        to the start of the task function. Once the stack has been initialised
        the	top of stack variable is updated. */
        #if( portUSING_MPU_WRAPPERS == 1 )
        pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, 
                pxTaskCode, pvParameters, xRunPrivileged );
        #else /* portUSING_MPU_WRAPPERS */
        pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, 
                pxTaskCode, pvParameters );
        #endif /* portUSING_MPU_WRAPPERS */

        if ((void *)pxCreatedTask != NULL) {
                /* Pass the handle out in an anonymous way.  The handle can be used to
                change the created task's priority, delete the created task, etc.*/
                *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
}



//______________________________________________________________________________
//      => 添加新的任务到就绪列表中
//______________________________________________________________________________
static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
        taskENTER_CRITICAL();
        //_____________________________________________________
        uxCurrentNumberOfTasks++;
        if ( pxCurrentTCB == NULL ) {
                /* There are no other tasks, or all the other tasks are in
                the suspended state - make this the current task. */
                pxCurrentTCB = pxNewTCB;

                if (uxCurrentNumberOfTasks == ( UBaseType_t )1) {
                        /* This is the first task to be created so do the preliminary
                        initialisation required.  We will not recover if this call
                        fails, but we will report the failure. */
                        prvInitialiseTaskLists();
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        } else {
                /* If the scheduler is not already running, make this task the
                current task if it is the highest priority task to be created
                so far. */
                if ( xSchedulerRunning == pdFALSE ) {
	                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority ) {
                                pxCurrentTCB = pxNewTCB;
	                } else {
                                mtCOVERAGE_TEST_MARKER();
                        }
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        }

        uxTaskNumber++;

        #if ( configUSE_TRACE_FACILITY == 1 )
        /* Add a counter into the TCB for tracing only. */
        pxNewTCB->uxTCBNumber = uxTaskNumber;
        #endif /* configUSE_TRACE_FACILITY */
        
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );

        portSETUP_TCB( pxNewTCB );
        
        taskEXIT_CRITICAL();
        //_____________________________________________________
        
	if ( xSchedulerRunning != pdFALSE ) {
                /* If the created task is of a higher priority than the current task
                then it should run now. */
                if ( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority ) {
                        taskYIELD_IF_USING_PREEMPTION();
                } else {
                        mtCOVERAGE_TEST_MARKER();
                }
        } else {
                mtCOVERAGE_TEST_MARKER();
        }
}
