/*******************************************************************************
                      Cortex-M NVIC(内嵌向量中断控制器)
*******************************************************************************/
|
| //SCB->AIRC[10:8]    IPR[7:0]     分配结果
|_________________________________________________________________|
|  0     111  ______________________，所有8位用于指定响应优先级        |
|  1     110  最高1位用于指定抢占式优先级，最低7位用于指定响应优先级        |
|  2     101  最高2位用于指定抢占式优先级，最低6位用于指定响应优先级        |
|  3     100  最高3位用于指定抢占式优先级，最低5位用于指定响应优先级        |
|  4     011  最高4位用于指定抢占式优先级，最低4位用于指定响应优先级        |
|  5     010  最高5位用于指定抢占式优先级，最低3位用于指定响应优先级        |
|  6     001  最高6位用于指定抢占式优先级，最低2位用于指定响应优先级        |
|  7     000  最高7位用于指定抢占式优先级，最低1位用于指定响应优先级        |     
|__________________________________________________________________|
|                                                                  |
|                                                                  |
| //Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，       |
| //STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下      |
| 1）抢占优先级越小，优先级越高；相同抢占优先级的中断不能嵌套；                |
| 2）相同抢占优先级N个中断发生时，响应优先级越小的中断首先执行（不能嵌套），     |
|   如果响应优先级也均相同，则根据各中断对应向量表的位置来确定，向量表中越靠     |
|   前的中断先响应。“SCB->AIRCR”寄存器的[10:8]位，决定了IP寄存器[7:4]位     |
|   的抢占与响应位的分配结果。|              |                           |
| 分组  | SCB->AIRC[10:8] |   IPR[7:4]   |       分配结果              |
|______|_________________|______________|____________________________|
|  0   |       111       |     0:4      |  0位抢占优先级, 4位响应优先级  |
|  1   |       110       |     1:3      |  1位抢占优先级, 3位响应优先级  |
|  2   |       101       |     2:2      |  2位抢占优先级, 2位响应优先级  |
|  3   |       100       |     3:1      |  3位抢占优先级, 1位响应优先级  |
|  4   |       011       |     4:0      |  4位抢占优先级, 0位响应优先级  |
|______|_________________|______________|____________________________|
 
_______________________________________________________________
% 微控制器软件接口标准<CMSIS>
% (Cortex Microcontroller Software Interface Standard) 
% 是 Cortex-M 处理器系列的与供应商无关的硬件抽象层
__I     /* defines 'read only' permissions    */定义只读允许位
__O     /* defines 'write only' permissions   */定义只写允许位
__IO    /* defines 'read / write' permissions */定义读/写允许位
 
 
 
############################################################
### % CPUID寄存器 (0xE000_ED00)
############################################################
31:24                       % 实现者代码, ARM=0x41
23:20                       % 实现定义的变种号
19:16                       % 常量
15:4                        % Part编号
3:0                         % 修订号



############################################################
### % 中断控制及状态寄存器ICSR(地址:0xE000_ED04)
############################################################
31      NMIPENDSET(R/W)     % 写 1 以悬起 NMI,因为 NMI 的优先级最高且从
                            % 不掩蔽,在置位此位后将立即进入 NMI 服务例程
28      PENDSVSET(R/W)      % 写 1 以悬起 PendSV
27      PENDSVCLR(W)        % 写 1 以清除 PendSV 悬起状态
26      PENDSTSET(R/W)      % 写 1 以悬起 SysTick。
25      PENDSTCLR(W)        % 写 1 以清除 SysTick 悬起状态
23      ISRPREEMPT(R)       % 为 1 时,则表示一个悬起的中断将在下一步时进
                            % 入活动状态(用于单步执行时的调试目的)
22      ISRPENDING(R)       % 1=当前正有外部中断被悬起(不包括 NMI)
21:12   VECTPENDING(R)      % 悬起的 ISR 的编号。如果不止一个中断悬起,则
                            % 它的值是这引动中断中,优先级最高的那一个。
11      RETTOBASE(R)        % 如果异常返回后将回到基级(base level),并且没有
                            % 其它异常悬起时,此位为 1。若是在线程模式下,
                            % 在某个服务例程中,有不止一级的异常处于活动
                            % 状态,或者在异常没有活动时执行了异常服务例
                            % 程(此时执行返回指令将产生 fault。此乃高危行
                            % 为,大虾也需慎用),则此位为 0
9:0     VECTACTIVE(R)       % 当前活动的ISR编号,该位段指出当前运行中的ISR
                            % 是哪个中断的(提供异常序号),包括NMI和硬
                            % fault。 如果多个异常共享一个服务例程,该例程可根据
                            % 本位段的值来判定是哪一个异常的响应导致它的执行。把
                            % 本位段的值减去16,就得到了外中断的编号,并可以用此
                            % 编号来操作外中断相关的使能/除能等寄存器



############################################################
### % 向量表偏移量寄存器(VTOR) 0xE000_ED08
############################################################ 
 


############################################################
### % 应用程序中断及复位控制寄存器(AIRCR) (0xE000_ED0C)
############################################################ 
31:16       VECTKEY         % 访问钥匙:任何对该寄存器的写操作,都必须
                            同时把 0x05FA 写入此段,否则写操作被忽略。
                            若读取此半字,则 0xFA05
15          ENDIANESS       % 指示端设置。1=大端(BE8),0=小端。此值
                            是在复位时确定的,不能更改。 
10:8        PRIGROUP        % 优先级分组
2           SYSRESETREQ     % 请求芯片控制逻辑产生一次复位
1           VECTCLRACTIVE   % 清零所有异常的活动状态信息。通常只在调试
                            时用,或者在 OS 从错误中恢复时用。
0           VECTRESET       % 复位 CM3 处理器内核(调试逻辑除外),但是
                            此复位不影响芯片上在内核以外的电路
                            
                            
 
############################################################
### % 系统控制寄存器 (0xE000_ED10)
############################################################
4           SEVONPEND       % 发生异常悬起时请发送事件,用于在一个新的中
                            断悬起时从 WFE 指令处唤醒。不管这个中断的
                            优先级是否比当前的高,都唤醒。如果没有 WFE
                            导致睡眠,则下次使用 WFE 时将立即唤醒
                            
2           SLEEPDEEP       % 当进入睡眠模式时,使能外部的 SLEEPDEEP 信号
                            以允许停止系统时钟                            

1           SLEEPONEXIT     % 激活“SleepOnExit”功能



############################################################
### % 配置与控制寄存器 (0xE000_ED14)
############################################################
9       STKALIGN            % 在响应异常的自动入栈操作时,强制 SP 对
                            齐到双字地址上
8       BFHFNMIGN           % 在硬 fault 与 NMI 服务例程中忽略数据总线fault
4       DIV_0_TRP           % 除数为零时陷入用法 fault
3       UNALIGN_TRP         % 访问未对齐时陷入用法 fault
1       USERSETMPEND        % 如果为 1,则允许用户代码设置 STIR
0       NONBASETHRDENA      % 非基于线程模式使能位。如果为 1,则允许异
                            常服务例程通过修改 EXC_RETURN,使其在
                            线程模式下执行



############################################################
### % % 系统异常优先级寄存器阵列(0xE000_ED18 - 0xE000_ED23)
############################################################ 
0xE000_ED18     PRI_4       % 存储器管理 fault 的优先级
0xE000_ED19     PRI_5       % 总线 fault 的优先级
0xE000_ED1A     PRI_6       % 用法 fault 的优先级
0xE000_ED1B     ‐ ‐ ‐ ‐
0xE000_ED1C     ‐ ‐ ‐ ‐
0xE000_ED1D     ‐ ‐ ‐ ‐
0xE000_ED1E     ‐ ‐ ‐ ‐
0xE000_ED1F     PRI_11      % SVC 优先级
0xE000_ED20     PRI_12      % 调试监视器的优先级
0xE000_ED21     ‐ ‐ ‐ ‐
0xE000_ED22     PRI_14      % PendSV 的优先级
0xE000_ED23     PRI_15      % SysTick 的优先级



############################################################
### % 系统Handler控制及状态寄存器SHCSR(地址:0xE000_ED24)
############################################################
[18]    USGFAULTENA(R/W)    % 用法 fault 服务例程使能位
[17]    BUSFAULTENA(R/W)    % 总线 fault 服务例程使能位
[16]    MEMFAULTENA(R/W)    % 存储器管理 fault 服务例程使能位
[15]    SVCALLPENDED(R/W)   % SVC 悬起中
[14]    BUSFAULTPENDED(R/W) % 总线 fault 悬起中,细节同上
[13]    MEMFAULTPENDED(R/W) % 存储器管理 fault 悬起中,细节同上
[12]    USGFAULTPENDED(R/W) % 用法 fault 悬起中,细节同上
[11]    SYSTICKACT(R/W)     % SysTick 异常活动中
[10]    PENDSVACT(R/W)      % PendSV 异常活动中
[9 ]    ---
[8 ]    MONITORACT(R/W)     % Monitor 异常活动中
[7 ]    SVCALLACT(R/W)      % SVC 异常活动中
6:4]    ---
[3 ]    USGFAULTACT(R/W)    % 用法 fault 异常活动中
[2 ]    ---
[1 ]    BUSFAULTACT(R/W)    % 总线 fault 异常活动中
[0 ]    MEMFAULTACT(R/W)    % 存储器管理 fault 异常活动中




############################################################
### % 中断控制器类型寄存器ICTR(地址:0xE000_E004)
############################################################
4:0     INTLINESUM(R)       % 中断输入的数量,以 32 为粒度,如
        0=1  至 32
        1=33 至 64
        2=65 至 96
        ...
        


############################################################
### % SysTick定时器
############################################################
% Cortex‐M3处理器内部包含了一个简单的定时器。
因为所有的CM3芯片都带有这个定时器,软件在不同CM3器件间的移植工作得以化简
该定时器的时钟源可以是内部时钟(FCLK,CM3上的自由运行时钟),或者是外部时钟
( CM3处理器上的STCLK信号 ).不过,STCLK的具体来源则由芯片设计者决定,因此
不同产品之间的时钟频率可能会大不相同, 你需要检视芯片的器件手册来决定选择什
么作为时钟源。
% SysTick控制及状态寄存器(地址:0xE000_E010)
_________________________________________________
[16]    COUNTFLAG(R)    % 如果在上次读取本寄存器后,SysTick已经数到了0, 
                        % 则该位为 1。如果读取该位,该位将自动清零
[2 ]    CLKSOURCE(R/W)  % “0” 外部时钟源(STCLK)/8, “1”内核时钟(FCLK)
[1 ]    TICKINT(R/W)    % “1” SysTick倒数到0时产生SysTick异常请求
                        % “0” 数到0时无动作
[0 ]    ENABLE(R/W)     % SysTick 定时器的使能位


% SysTick重装载数值寄存器(地址:0xE000_E014) 
[23:0]              % 当倒数至零时,将被重装载的值
_________________________________________________    


% SysTick当前数值寄存器(地址:0xE000_E018)    
_________________________________________________
[23:0]              % 读取时返回当前倒计数的值,写它则使之清零,
                    % 同时还会清除在 SysTick 控制及状态寄存器中的
                    % COUNTFLAG 标志


% SysTick校准数值寄存器(地址:0xE000_E01C)
_________________________________________________
[31]                % 1=没有外部参考时钟(STCLK 不可用)
                    % 0=外部参考时钟可用
[30]                % 1=校准值不是准确的 10ms
                    % 0=校准值是准确的 10ms
[23:0]              % 10ms 的时间内倒计数的格数。芯片设计者应该通
                    % 过 Cortex‐M3 的输入信号提供该数值。若该值读
                    % 回零,则表示无法使用校准功能


SCB->SHP[11]=0xF0;  % 设置SYSTICK的优先级为15，注意SYSTICK
                    属于系统异常，所以他的优先级在SCB里设置。
SysTick->CTRL=7;    % 开启中断，开启定时器，时钟设置为HCLK=72mhz



############################################################
### % NVIC(外部中断控制寄存器组)
############################################################
_____________________________________________________________________
/* % 中断使能寄存器 (0xE000_E100 – 0xE000_E11C) */
__IO uint32_t ISER[8]; /* Interrupt Set Enable Register           */
/* % 中断除能寄存器 (0xE000E180 - 0xE000_E19C) */
__IO uint32_t ICER[8]; /* Interrupt Clear Enable Register         */
/* % 悬起寄存器族 (0xE000_E200 – 0xE000_E21C) */
__IO uint32_t ISPR[8]; /* Interrupt Set Pending Register          */
/* % 解悬寄存器族 (0xE000E280 - 0xE000_E29C) */
__IO uint32_t ICPR[8]; /* Interrupt Clear Pending Register        */
/* % 中断活动状态寄存器族 (0xE000_E300_0xE000_E31C) */
__IO uint32_t IABR[8]; /* Interrupt Active bit Register           */
/* % 中断优先级寄存器阵列 (0xE000_E400 – 0xE000_E4EF) */
__IO uint8_t  IP[240]; /* Interrupt Priority Register (8Bit wide) */
/* % 软件触发中断寄存器STIR (0xE000_EF00) */
__O  uint32_t STIR;    /* Software Trigger Interrupt Register     */
_____________________________________________________________________  



/**************************************************************
                   AFIO_EVCR_事件控制寄存器
7       % EVOE位“1”允许事件输出 (Event output enable)
6:4     % 端口选择, 选择用于输出Cortex的EVENTOUT信号的端口
000     选择GPIOA
001     选择GPIOB
010     选择GPIOC
011     选择GPIOD
100     选择GPIOE
3:0     % 引脚选择(x=A…E), 选择用于输出Cortex的EVENTOUT信号的引脚
0000    选择GPIOx_PIN_0
0001    选择GPIOx_PIN_1
0010    选择GPIOx_PIN_2
0011    选择GPIOx_PIN_3
........................
1111    选择GPIOx_PIN_15
**************************************************************/


/**************************************************************
                AFIO_EXTICR1_外部中断配置寄存器 1
EXTIx[3:0]      % EXTIx配置(x = 0 … 3) (EXTI x configuration) 
                % 这些位可由软件读写，用于选择 EXTI0~EXTI3 外部中断的输入源
0000            GPIOA[x]引脚 
0001            GPIOB[x]引脚 
0011            GPIOD[x]引脚
0100            GPIOE[x]引脚
0101            GPIOF[x]引脚
0110            GPIOG[x]引脚
                AFIO_EXTICR2_外部中断配置寄存器 2
EXTIx[3:0]      % EXTIx配置(x = 4 … 7) (EXTI x configuration) 
                % 这些位可由软件读写，用于选择 EXTI4~EXTI7 外部中断的输入源
0000            GPIOA[x]引脚 
0001            GPIOB[x]引脚 
0011            GPIOD[x]引脚
0100            GPIOE[x]引脚
0101            GPIOF[x]引脚
0110            GPIOG[x]引脚
                AFIO_EXTICR3_外部中断配置寄存器 3
EXTIx[3:0]      % EXTIx配置(x = 8 … 11) (EXTI x configuration) 
                % 这些位可由软件读写，用于选择 EXTI8~EXTI11 外部中断的输入源
0000            GPIOA[x]引脚 
0001            GPIOB[x]引脚 
0011            GPIOD[x]引脚
0100            GPIOE[x]引脚
0101            GPIOF[x]引脚
0110            GPIOG[x]引脚
                AFIO_EXTICR4_外部中断配置寄存器 4
EXTIx[3:0]      % EXTIx配置(x = 12 … 15) (EXTI x configuration) 
                % 这些位可由软件读写，用于选择 EXTI12~EXTI15 外部中断的输入源
0000            GPIOA[x]引脚 
0001            GPIOB[x]引脚 
0011            GPIOD[x]引脚
0100            GPIOE[x]引脚
0101            GPIOF[x]引脚
0110            GPIOG[x]引脚
**************************************************************/


/**************************************************************
% EXTI_IMR_中断屏蔽寄存器
31:20           保留,必须始终保持为复位状态(0)
19:0            MR0~MR19 线 0~19上的中断屏蔽
0               屏蔽来自线0~19上的中断请求
1               开放来自线0~19上的中断请求
注:位19只适用于互联型产品,对于其它产品为保留位


% EXTI_EMR_事件屏蔽寄存器
31:20           保留,必须始终保持为复位状态(0)
19:0            MR0~MR19 线 0~19上的事件屏蔽
0               屏蔽来自线0~19上的事件请求
1               开放来自线0~19上的事件请求
注:位19只适用于互联型产品,对于其它产品为保留位


% EXTI_RTSR_上升沿触发选择寄存器
31:20           保留,必须始终保持为复位状态(0)
19:0            TR0~TR19 线 0~19上的上升沿触发事件配置位
0               禁止输入线 0~19上的上升沿触发(中断和事件)
1               允许输入线 0~19上的上升沿触发(中断和事件)
注:位19只适用于互联型产品,对于其它产品为保留位


% EXTI_FTSR_下降沿触发选择寄存器
31:20           保留,必须始终保持为复位状态(0)
19:0            TR0~TR19 线 0~19上的下降沿触发事件配置位
0               禁止输入线 0~19上的下降沿触发(中断和事件)
1               允许输入线 0~19上的下降沿触发(中断和事件)
注:位19只适用于互联型产品,对于其它产品为保留位


% EXTI_SWIER_软件中断事件寄存器
31:20           保留,必须始终保持为复位状态(0)
19:0            SWIER0~SWIER19 线0~19上的软件中断
当该位为“0”时,写“1”将设置 EXTI_PR 中相应的挂起位。
如果在 EXTI_IMR 和 EXTI_EMR中允许产生该中断,则产生中断请求。
通过清除 EXTI_PR 的对应位(写入“1”),可以清除该位为“0”。
注:位19只适用于互联型产品,对于其它产品为保留位


% EXTI_PR_挂起寄存器
31:20           保留,必须始终保持为复位状态(0)
19:0
0		没有发生触发请求
1		发生了选择的触发请求
当在外部中断线上发生了选择的边沿事件,该位被置“1”。在此位中写入“1”可以清除它,
也可以通过改变边沿检测的极性清除。
注:位19只适用于互联型产品,对于其它产品为保留位
**************************************************************/
