/*******************************************************************************
                      Cortex-M0+ NVIC (内嵌向量中断控制器)
*******************************************************************************/
//Cortex-M0+，第一个是NVICPRI一共有8个寄存器，而每个寄存器管理4个IRQ中断
  所以（M0+的IRQ中断源最多只支持 32 个了，再加上 16 个内核中断） = 48 个中断

//Cortex-M0+，//SCB->AIRC[10:8]    IPR[7:6]
  第二个是每个PRIxx的8位中只有最高两位[7:6]有效，也就是说实际
  上M0+的优先级只有四个即 0，1，2，3，4， 其中0的优先级是最高的

//Cortex-M0+，第三个是word-accessible， 也就是说这几个寄存器都只能按字操作

//至于内核中断，其中断优先级则由SCB模块的SCB_SHPR寄存器来管理



/*******************************************************************************
                      Cortex-M3 NVIC (内嵌向量中断控制器)
*******************************************************************************/
|
| //SCB->AIRC[10:8]    IPR[7:0]     分配结果
|_________________________________________________________________|
|  0     111  ______________________，所有8位用于指定响应优先级        |
|  1     110  最高1位用于指定抢占式优先级，最低7位用于指定响应优先级        |
|  2     101  最高2位用于指定抢占式优先级，最低6位用于指定响应优先级        |
|  3     100  最高3位用于指定抢占式优先级，最低5位用于指定响应优先级        |
|  4     011  最高4位用于指定抢占式优先级，最低4位用于指定响应优先级        |
|  5     010  最高5位用于指定抢占式优先级，最低3位用于指定响应优先级        |
|  6     001  最高6位用于指定抢占式优先级，最低2位用于指定响应优先级        |
|  7     000  最高7位用于指定抢占式优先级，最低1位用于指定响应优先级        |     
|__________________________________________________________________|
|                                                                  |
|                                                                  |
| //Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，       |
| //STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下      |
| 1）抢占优先级越小，优先级越高；相同抢占优先级的中断不能嵌套；                |
| 2）相同抢占优先级N个中断发生时，响应优先级越小的中断首先执行（不能嵌套），     |
|   如果响应优先级也均相同，则根据各中断对应向量表的位置来确定，向量表中越靠     |
|   前的中断先响应。“SCB->AIRCR”寄存器的[10:8]位，决定了IP寄存器[7:4]位     |
|   的抢占与响应位的分配结果。|              |                           |
| 分组  | SCB->AIRC[10:8] |   IPR[7:4]   |       分配结果              |
|______|_________________|______________|____________________________|
|  0   |       111       |     0:4      |  0位抢占优先级, 4位响应优先级  |
|  1   |       110       |     1:3      |  1位抢占优先级, 3位响应优先级  |
|  2   |       101       |     2:2      |  2位抢占优先级, 2位响应优先级  |
|  3   |       100       |     3:1      |  3位抢占优先级, 1位响应优先级  |
|  4   |       011       |     4:0      |  4位抢占优先级, 0位响应优先级  |
|______|_________________|______________|____________________________|
 
_______________________________________________________________
//微控制器软件接口标准<CMSIS>
//(Cortex Microcontroller Software Interface Standard) 
//是 Cortex-M 处理器系列的与供应商无关的硬件抽象层
__I     /* defines 'read only' permissions    */定义只读允许位
__O     /* defines 'write only' permissions   */定义只写允许位
__IO    /* defines 'read / write' permissions */定义读/写允许位
 
 

/*******************************************************************************
                      CPUID寄存器 (0xE000_ED00)
*******************************************************************************/
31:24                       //实现者代码, ARM=0x41
23:20                       //实现定义的变种号
19:16                       //常量
15:4                        //Part编号
3:0                         //修订号



/*******************************************************************************
                     中断控制及状态寄存器ICSR(地址:0xE000_ED04)
*******************************************************************************/
31      NMIPENDSET(R/W)     //写 1 以悬起 NMI,因为 NMI 的优先级最高且从
                            //不掩蔽,在置位此位后将立即进入 NMI 服务例程
28      PENDSVSET(R/W)      //写 1 以悬起 PendSV
27      PENDSVCLR(W)        //写 1 以清除 PendSV 悬起状态
26      PENDSTSET(R/W)      //写 1 以悬起 SysTick。
25      PENDSTCLR(W)        //写 1 以清除 SysTick 悬起状态
23      ISRPREEMPT(R)       //为 1 时,则表示一个悬起的中断将在下一步时进
                            //入活动状态(用于单步执行时的调试目的)
22      ISRPENDING(R)       //1=当前正有外部中断被悬起(不包括 NMI)
21:12   VECTPENDING(R)      //悬起的 ISR 的编号。如果不止一个中断悬起,则
                            //它的值是这引动中断中,优先级最高的那一个。
11      RETTOBASE(R)        //如果异常返回后将回到基级(base level),并且没有
                            //其它异常悬起时,此位为 1。若是在线程模式下,
                            //在某个服务例程中,有不止一级的异常处于活动
                            //状态,或者在异常没有活动时执行了异常服务例
                            //程(此时执行返回指令将产生 fault。此乃高危行
                            //为,大虾也需慎用),则此位为 0
9:0     VECTACTIVE(R)       //当前活动的ISR编号,该位段指出当前运行中的ISR
                            //是哪个中断的(提供异常序号),包括NMI和硬
                            //fault。 如果多个异常共享一个服务例程,该例程可根据
                            //本位段的值来判定是哪一个异常的响应导致它的执行。把
                            //本位段的值减去16,就得到了外中断的编号,并可以用此
                            //编号来操作外中断相关的使能/除能等寄存器



/*******************************************************************************
                      向量表偏移量寄存器(VTOR) 0xE000_ED08
*******************************************************************************/
 



/*******************************************************************************
                    应用程序中断及复位控制寄存器(AIRCR) (0xE000_ED0C)
*******************************************************************************/
31:16       VECTKEY         //访问钥匙:任何对该寄存器的写操作,都必须
                            同时把 0x05FA 写入此段,否则写操作被忽略。
                            若读取此半字,则 0xFA05
15          ENDIANESS       //指示端设置。1=大端(BE8),0=小端。此值
                            是在复位时确定的,不能更改。 
10:8        PRIGROUP        //优先级分组
2           SYSRESETREQ     //请求芯片控制逻辑产生一次复位
1           VECTCLRACTIVE   //清零所有异常的活动状态信息。通常只在调试
                            时用,或者在 OS 从错误中恢复时用。
0           VECTRESET       //复位 CM3 处理器内核(调试逻辑除外),但是
                            此复位不影响芯片上在内核以外的电路
                            
                            
                            
/*******************************************************************************
                       系统控制寄存器 (0xE000_ED10)
*******************************************************************************/ 
4           SEVONPEND       //发生异常悬起时请发送事件,用于在一个新的中
                            断悬起时从 WFE 指令处唤醒。不管这个中断的
                            优先级是否比当前的高,都唤醒。如果没有 WFE
                            导致睡眠,则下次使用 WFE 时将立即唤醒
                            
2           SLEEPDEEP       //当进入睡眠模式时,使能外部的 SLEEPDEEP 信号
                            以允许停止系统时钟                            

1           SLEEPONEXIT     //激活“SleepOnExit”功能



/*******************************************************************************
                       配置与控制寄存器 (0xE000_ED14)
*******************************************************************************/
9       STKALIGN            //在响应异常的自动入栈操作时,强制 SP 对
                            齐到双字地址上
8       BFHFNMIGN           //在硬 fault 与 NMI 服务例程中忽略数据总线fault
4       DIV_0_TRP           //除数为零时陷入用法 fault
3       UNALIGN_TRP         //访问未对齐时陷入用法 fault
1       USERSETMPEND        //如果为 1,则允许用户代码设置 STIR
0       NONBASETHRDENA      //非基于线程模式使能位。如果为 1,则允许异
                            常服务例程通过修改 EXC_RETURN,使其在
                            线程模式下执行



/*******************************************************************************
                 系统异常优先级寄存器阵列(0xE000_ED18 - 0xE000_ED23)
*******************************************************************************/ 
0xE000_ED18     PRI_4       //存储器管理 fault 的优先级
0xE000_ED19     PRI_5       //总线 fault 的优先级
0xE000_ED1A     PRI_6       //用法 fault 的优先级
0xE000_ED1B     ‐ ‐ ‐ ‐
0xE000_ED1C     ‐ ‐ ‐ ‐
0xE000_ED1D     ‐ ‐ ‐ ‐
0xE000_ED1E     ‐ ‐ ‐ ‐
0xE000_ED1F     PRI_11      //SVC 优先级
0xE000_ED20     PRI_12      //调试监视器的优先级
0xE000_ED21     ‐ ‐ ‐ ‐
0xE000_ED22     PRI_14      //PendSV 的优先级
0xE000_ED23     PRI_15      //SysTick 的优先级


/*******************************************************************************
                   系统Handler控制及状态寄存器SHCSR(地址:0xE000_ED24)
*******************************************************************************/
[18]    USGFAULTENA(R/W)    //用法 fault 服务例程使能位
[17]    BUSFAULTENA(R/W)    //总线 fault 服务例程使能位
[16]    MEMFAULTENA(R/W)    //存储器管理 fault 服务例程使能位
[15]    SVCALLPENDED(R/W)   //SVC 悬起中
[14]    BUSFAULTPENDED(R/W) //总线 fault 悬起中,细节同上
[13]    MEMFAULTPENDED(R/W) //存储器管理 fault 悬起中,细节同上
[12]    USGFAULTPENDED(R/W) //用法 fault 悬起中,细节同上
[11]    SYSTICKACT(R/W)     //SysTick 异常活动中
[10]    PENDSVACT(R/W)      //PendSV 异常活动中
[9 ]    ---
[8 ]    MONITORACT(R/W)     //Monitor 异常活动中
[7 ]    SVCALLACT(R/W)      //SVC 异常活动中
6:4]    ---
[3 ]    USGFAULTACT(R/W)    //用法 fault 异常活动中
[2 ]    ---
[1 ]    BUSFAULTACT(R/W)    //总线 fault 异常活动中
[0 ]    MEMFAULTACT(R/W)    //存储器管理 fault 异常活动中



/*******************************************************************************
                       中断控制器类型寄存器ICTR(地址:0xE000_E004)
*******************************************************************************/
4:0     INTLINESUM(R)       //中断输入的数量,以 32 为粒度,如
        0=1  至 32
        1=33 至 64
        2=65 至 96
        ...
        
        
        
/*******************************************************************************
                                SysTick定时器
*******************************************************************************/
//Cortex‐M3处理器内部包含了一个简单的定时器。
因为所有的CM3芯片都带有这个定时器,软件在不同CM3器件间的移植工作得以化简
该定时器的时钟源可以是内部时钟(FCLK,CM3上的自由运行时钟),或者是外部时钟
( CM3处理器上的STCLK信号 ).不过,STCLK的具体来源则由芯片设计者决定,因此
不同产品之间的时钟频率可能会大不相同, 你需要检视芯片的器件手册来决定选择什
么作为时钟源。
//SysTick控制及状态寄存器(地址:0xE000_E010)
_________________________________________________
[16]    COUNTFLAG(R)    //如果在上次读取本寄存器后,SysTick已经数到了0, 
                        //则该位为 1。如果读取该位,该位将自动清零
[2 ]    CLKSOURCE(R/W)  //“0” 外部时钟源(STCLK)/8, “1”内核时钟(FCLK)
[1 ]    TICKINT(R/W)    //“1” SysTick倒数到0时产生SysTick异常请求
                        //“0” 数到0时无动作
[0 ]    ENABLE(R/W)     //SysTick 定时器的使能位


//SysTick重装载数值寄存器(地址:0xE000_E014) 
[23:0]              //当倒数至零时,将被重装载的值
_________________________________________________    


//SysTick当前数值寄存器(地址:0xE000_E018)    
_________________________________________________
[23:0]              //读取时返回当前倒计数的值,写它则使之清零,
                    //同时还会清除在 SysTick 控制及状态寄存器中的
                    //COUNTFLAG 标志


//SysTick校准数值寄存器(地址:0xE000_E01C)
_________________________________________________
[31]                //1=没有外部参考时钟(STCLK 不可用)
                    //0=外部参考时钟可用
[30]                //1=校准值不是准确的 10ms
                    //0=校准值是准确的 10ms
[23:0]              //10ms 的时间内倒计数的格数。芯片设计者应该通
                    //过 Cortex‐M3 的输入信号提供该数值。若该值读
                    //回零,则表示无法使用校准功能


SCB->SHP[11]=0xF0;  //设置SYSTICK的优先级为15，注意SYSTICK
                    属于系统异常，所以他的优先级在SCB里设置。
SysTick->CTRL=7;    //开启中断，开启定时器，时钟设置为HCLK=72mhz



/*******************************************************************************
                          NVIC(外部中断控制寄存器组)
*******************************************************************************/
/* //中断使能寄存器 (0xE000_E100 – 0xE000_E11C) */
__IO uint32_t ISER[8]; /* Interrupt Set Enable Register           */
/* //中断除能寄存器 (0xE000E180 - 0xE000_E19C) */
__IO uint32_t ICER[8]; /* Interrupt Clear Enable Register         */
/* //悬起寄存器族 (0xE000_E200 – 0xE000_E21C) */
__IO uint32_t ISPR[8]; /* Interrupt Set Pending Register          */
/* //解悬寄存器族 (0xE000E280 - 0xE000_E29C) */
__IO uint32_t ICPR[8]; /* Interrupt Clear Pending Register        */
/* //中断活动状态寄存器族 (0xE000_E300_0xE000_E31C) */
__IO uint32_t IABR[8]; /* Interrupt Active bit Register           */
/* //中断优先级寄存器阵列 (0xE000_E400 – 0xE000_E4EF) */
__IO uint8_t  IP[240]; /* Interrupt Priority Register (8Bit wide) */
/* //软件触发中断寄存器STIR (0xE000_EF00) */
__O  uint32_t STIR;    /* Software Trigger Interrupt Register     */

