/*******************************************************************************
                => MDK-ARM__编译原理__
*******************************************************************************/
        => 编译过程
____________________________________________________________________________
源文件（Source Code） =>对象代码（Object） =>映像文件（Image） =>FLASH格式文件（Hex）
____________________________________________________________________________
0. （ARM_ASM）    //编译汇编文件
1. （ARM_CC）     //编译C/C++文件
2. （ARM_AR）     //打包文件
3. （ARM_LINK）   //链接文件
4. （FROMELF）    //生成下载格式文件



/*******************************************************************************
                => MDK-ARM__数据__
*******************************************************************************/
        => MDK-ARM数据域
//___________________________________________________________________
（CODE）          //即代码域，它指的是编译器生成的机器指令，这些内容被存储到ROM区
（RO-data）       //即只读数据域， 它指的是程序中用到的只读数据，这些数据被存储在
                 //ROM区，因而程序不能修改。 例如C语言中“const关键字”定义的数据
（RW-data）       //即可读写数据域，初始化为“非0值”的可读写数据，它们会常驻在RAM区
（ZI-data）       //Zero Initialize data， 初始化为“0值”的可读写数据
                 //它与RW-dat的区别是程序刚运行时这些数据初始值全都为“0”，而后续
                 //运行过程与RW-data的性质一样，它们也是常驻RAM区。
（CODE）          //机器代码指令
（RO-data）       //常量
（RW-data）       //初值非0的全局变量
（ZI-data）       //初值为0的全局变量
（ZI-data）Stack  //局部变量（栈空间）
（ZI-data）Heap   //使用malloc动态分配的空间（堆空间）



        => 应用程序在各个状态时各区域的组成
//___________________________________________________________________
（CODE + RO-data）                //程序执行时的只读区域（RO）  
（RW-data + ZI-data）             //程序执行时可读写区域（RW）
（CODE + RO-data + RW-data）      //程序存储时占用的ROM区



        => ROM RAM
//___________________________________________________________________
      起始地址            存储大小         字节转换成“KByte”
ROM1: 0x08000000        0x80000         (80000/1024=512)K
RAM1: 0x20000000        0x10000         (10000/1024=64 )K



/*******************************************************************************
        => ELF__Executable and Linking Format__ELF文件格式
*******************************************************************************/
（Relocatable File）      //可重定位文件
                         //它包含基础代码和数据，但它的代码及数据都没有指定绝对地址，因此
                         //它适合于与其它目标文件链接来创建可执行文件或共享目标文件。 这种
                         //文件一般由编译器根据源代码生成。 例如“.o文件”
（Executable File）       //可执行文件 
                         //它包含适合于执行的程序，它内部组织的代码数据都有固定的地址（或
                         //相对于基地址的偏移），系统可根据这些地址信息把程序加载到内存执行
                         //这种文件一般由链接器根据可重定位文件链接而成。 例如“.elf文件”
（Share Object File）     //Linux下的“.so文件”， Windows下的“.DLL文件”



/*******************************************************************************
        => （htm文件）栈空间
*******************************************************************************/
Stack_Size      EQU     0x00000400      //1024_Byte（静态栈空间）



/*******************************************************************************
        => sct__分散加载文件__
        => 加载域可以有多个执行域
*******************************************************************************/
LR      //load region__加载域__
ER      //execution region__执行域__
//___________________________________________________________________
LR_IROM1 0x08000000 0x00080000 {                //加载域__基地址_空间大小
        ER_IROM1 0x08000000 0x00080000 {        //加载地址 = 执行地址
                *.o (RESET, +First)
                *(InRoot$$Sections)
                .ANY (+RO)
        }
        RW_IRAM1 0x20000000 0x00010000 {        //可读写数据
                .ANY (+RW +ZI)
        }
}
//模块选择样式
        模块选择样式可以用于选择（.o及lib目标文件）作为输入节区， 它可以直接使用目标文件名
        或“*”通配符，也可以使用“.ANY”。 例如：使用语句“bsp_led.o”可以选择bsp_led.o文件
        使用“.o”可以选择所有o文件， 使用“.lib”可以选择所有lib文件， 使用“*”或“ANY”可以
        选择所有的o文件及lib文件。 其中“.ANY”选择语句的优先级最低的， 所有其它选择语句选择
        完剩下的数据才会被“.ANY”语句选中。
//输入节区特性
        （RESET, +First）语句的RESET就是输入节区样式， 它选择了名为RESET的节区， 并使用
        后面介绍的节区特性控制字“+First”表示它要存储到本区域的第一个地址。     示例文件中的
        “（InRoot$$Sections）”是一个链接器支持的特殊选择符号， 它可以选择所有标准库里要求
        存储到root区域的节区， 如__main.o __scatter*.o
//输入节区属性
        通过在模块选择样式后面加入输入节区属性， 可以选择样式中的不同内容， 每个节区属性描述
        符前要写一个“+”号， 使用空格或分号分隔。
RO-CODE及CODE    //只读代码段
RO-DATA及CONST   //只读数据段
RO及TEXT         //包括RO-CODE及RO-DATA
RW-DATA         //可读写数据段
RW-CODE         //可读写代码段
RW及DATA         //包括RW-CODE及RW-DATA
ZI及BSS          //初始化为0的可读写数据段
XO              //只可执行的区域
ENTRY           //节区的入口点



/*******************************************************************************
        => 存储器分配
*******************************************************************************/
//___________________________________________________________________
        => 把栈的空间放置到（RW_IRAM1）中
        => 其余的变量放置到（RW_ERAM1）中
//___________________________________________________________________
LR_IROM1 0x08000000 0x00080000 {                //加载域__基地址_空间大小
        ER_IROM1 0x08000000 0x00080000 {        //加载地址 = 执行地址
                *.o (RESET, +First)
                *(InRoot$$Sections)
                .ANY (+RO)
        }
        RW_IRAM1 0x20000000 0x00005000 {        //定义为内部__IRAM1(20K)
                *.o(STACK)                      //局部变量放置到IRAM1空间
                .ANY (+RW +ZI)
        }
        RW_ERAM1 0x20005000 0x00007000 {        //定义为外部__ERAM1(28K)
                *.o(HEAP)                       //使用malloc函数分配的空间放置处
                .ANY (+RW +ZI)
        }
}


//___________________________________________________________________
        => 优先把局部变量分配到内部RW_IRAM1空间中
        => 只把使用malloc函数分配的空间放置到（RW_ERAM1）中
//___________________________________________________________________
LR_IROM1 0x08000000 0x00080000 {                //加载域__基地址_空间大小
        ER_IROM1 0x08000000 0x00080000 {        //加载地址 = 执行地址
                *.o (RESET, +First)
                *(InRoot$$Sections)
                .ANY (+RO)
        }
        RW_IRAM1 0x20000000 0x00005000 {        //定义为内部__IRAM1(20K)
                *.o(STACK)                      //局部变量放置到IRAM1空间
                .ANY (+RW +ZI)
        }
        RW_ERAM1 0x20005000 0x00007000 {        //定义为外部__ERAM1(28K)
                *.o(HEAP)                       //使用malloc函数分配的空间放置处
        }
}



/*******************************************************************************
        => 优先把局部变量分配到内部RW_IRAM1空间中
        => exRAM_tmp这个变量会使用指定的RAM空间地址
*******************************************************************************/
//使用__attribute__关键字指定节区("EXRAM")分配到外部RW_EXRAM中
//也就是说exRAM_tmp这个变量会分配到RW_ERAM1（外部RAM中）
uint8_t exRAM_tmp[1024] __attribute__(section("EXRAM")) = {1, 2, 3};
//___________________________________________________________________
LR_IROM1 0x08000000 0x00080000 {                //加载域__基地址_空间大小
        ER_IROM1 0x08000000 0x00080000 {        //加载地址 = 执行地址
                *.o (RESET, +First)
                *(InRoot$$Sections)
                .ANY (+RO)
        }
        RW_IRAM1 0x20000000 0x00005000 {        //定义为内部__IRAM1(20K)
                *.o(STACK)                      //局部变量放置到__IRAM1空间
                .ANY (+RW +ZI)                  //全局变量放置到__IRAM1空间
        }
        RW_ERAM1 0x20005000 0x00007000 {        //定义为外部__ERAM1(28K)
                *.o(EXRAM)                      //指定节区
                *.o(HEAP)                       //使用malloc函数分配的空间放置处
        }
}


//___________________________________________________________________
        => 使用外部扩展SRAM
//___________________________________________________________________
LR_IROM1 0x08000000 0x00080000 {                //加载域__基地址_空间大小
        ER_IROM1 0x08000000 0x00080000 {        //加载地址 = 执行地址
                *.o (RESET, +First)
                *(InRoot$$Sections)
                .ANY (+RO)
        }
        RW_IRAM1 0x20000000 0x00010000 {        //定义为内部__IRAM1(64K)
                *.o(STACK)                      //选择STACK节区（栈）
                stm32f10x_rcc.o(+RW)            //选择stm32f10x_rcc的RW内容
                .ANY (+RW +ZI)
        }
        RW_ERAM1 0x68000000 0x00100000 {        //使用外部RAM空间
                .ANY (+RW +ZI)                  //其余的RW、ZI-data都分配到这里
        }
}
//汇编代码部分
LDR     R0, =SystemInit
BLX     R0
//初始化FSMC_SRAM，确保RW变量能被正常复制
LDR     R0, = FSMC_SRAM_Init
BLX     R0
//进入main函数，进入C语世界
LDR     R0, =__main
Bx      R0
