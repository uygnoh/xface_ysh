/*******************************************************************************
                      Cortex-M3 NVIC (内嵌向量中断控制器)
*******************************************************************************/
|
| //SCB->AIRC[10:8]       分配结果
|_________________________________________________________________|
|  7     111  ______________________，所有8位用于指定响应优先级        |
|  6     110  最高1位用于指定抢占式优先级，最低7位用于指定响应优先级        |
|  5     101  最高2位用于指定抢占式优先级，最低6位用于指定响应优先级        |
|  4     100  最高3位用于指定抢占式优先级，最低5位用于指定响应优先级        |
|  3     011  最高4位用于指定抢占式优先级，最低4位用于指定响应优先级        |
|  2     010  最高5位用于指定抢占式优先级，最低3位用于指定响应优先级        |
|  1     001  最高6位用于指定抢占式优先级，最低2位用于指定响应优先级        |
|  0     000  最高7位用于指定抢占式优先级，最低1位用于指定响应优先级        |     
|__________________________________________________________________|
|                                                                  |
|                                                                  |
| //Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，       |
| //STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下      |
| 1）抢占优先级越小，优先级越高；相同抢占优先级的中断不能嵌套；                |
| 2）相同抢占优先级N个中断发生时，响应优先级越小的中断首先执行（不能嵌套），     |
|   如果响应优先级也均相同，则根据各中断对应向量表的位置来确定，向量表中越靠     |
|   前的中断先响应。“SCB->AIRCR”寄存器的[10:8]位，决定了IP寄存器[7:4]位     |
|   的抢占与响应位的分配结果。                                           |
|__________________________________________________________________|_
| 分组  | SCB->AIRC[10:8] |   IPR[7:4]   |       分配结果              |
|______|_________________|______________|____________________________|
|  0   |       111       |     0:4      |  0位抢占优先级, 4位响应优先级  |
|  1   |       110       |     1:3      |  1位抢占优先级, 3位响应优先级  |
|  2   |       101       |     2:2      |  2位抢占优先级, 2位响应优先级  |
|  3   |       100       |     3:1      |  3位抢占优先级, 1位响应优先级  |
|  4   |       011       |     4:0      |  4位抢占优先级, 0位响应优先级  |
|______|_________________|______________|____________________________|

 //SCB_AIRCR 中断优先级分组配置
|__________________________________________________________ 
| //Application Interrupt and Reset Control Register
|_________________________________________________________|
|    Address         0xE000ED0C                           |
|    Reset state     0x00000000                           |
|_________________________________________________________|
|  31:16
|       //(访问钥匙密)任何对该寄存器的写操作,都必须同时写入“0x05FA”
|  10:8 
|       //(优先级分组)指定中断源的抢占优先级,响应优先级
|
| //设置Cortex-M3为( 3位抢占优先级, 1位响应优先级 )
|________________________________________________
//清除高16位和(10,9,8位) 
SCB->AIRCR &= uint32_t(0x0000F8FF);
//写入访问钥匙，并设置优先级分组(3位抢占优先级, 1位响应优先级)
SCB->AIRCR |= uint32_t(0x05FA0000 | 0x00000400);


//SysTick_Cortex-M3内部滴答定时器优先级设置
___________________________________________________________
SCB->SHP[11]=0xF0;      //设置SYSTICK的优先级为15，注意SYSTICK
                        //属于系统异常，所以他的优先级在SCB里设置


//NVIC_外部中断号优先级配置
___________________________________________________________
NVIC->IP[28] = uint8_t(0xF0);   //TIM2, 中断优先级设置
NVIC->IP[50] = uint8_t(0xF0);   //TIM5, 中断优先级设置


//NVIC_外部中断使能
___________________________________________________________ 
NVIC->ISER[0] = uint32_t(0x10000000); //TIM2, 中断使能
NVIC->ISER[1] = uint32_t(0x00020000); //TIM5, 中断使能


//微控制器软件接口标准<CMSIS>
_______________________________________________________________
(Cortex Microcontroller Software Interface Standard) 
//是 Cortex-M 处理器系列的与供应商无关的硬件抽象层
__I     /* defines 'read only' permissions    */定义只读允许位
__O     /* defines 'write only' permissions   */定义只写允许位
__IO    /* defines 'read / write' permissions */定义读/写允许位
 
 

/*******************************************************************************
                  SCB_AIRCR_应用程序中断及复位控制寄存器 (0xE000_ED0C)
*******************************************************************************/
VECTKEY[31:16]          //访问钥匙:任何对该寄存器的写操作,都必须同时把“0x05FA”写入此段,
                        否则写操作被忽略。 若读取此半字,则 0xFA05
ENDIANESS[15]           //指示端设置， 此值是在复位时确定的,不能更改。
    0                   、、小端
    1                   、、大端               
PRIGROUP[10:8]          //优先级分组
SYSRESETREQ[2]          //请求芯片控制逻辑产生一次复位
VECTCLRACTIVE[1]        //清零所有异常的活动状态信息。
                        通常只在调试时用,或者在 OS 从错误中恢复时用。
VECTRESET[0]            //复位 CM3 处理器内核(调试逻辑除外),
                        但是此复位不影响芯片上在内核以外的电路



/*******************************************************************************
                     中断控制及状态寄存器ICSR(地址:0xE000_ED04)
*******************************************************************************/
NMIPENDSET[31]          //写 1 以悬起 NMI,因为 NMI 的优先级最高且从
                        //不掩蔽,在置位此位后将立即进入 NMI 服务例程
PENDSVSET[28]           //写 1 以悬起 PendSV
PENDSVCLR[27]           //写 1 以清除 PendSV 悬起状态
PENDSTSET[26]           //写 1 以悬起 SysTick。
PENDSTCLR[25]           //写 1 以清除 SysTick 悬起状态
ISRPREEMPT[23]          //为 1 时,则表示一个悬起的中断将在下一步时进
                        //入活动状态(用于单步执行时的调试目的)
ISRPENDING[22]          //为 1 时,当前正有外部中断被悬起(不包括 NMI)
VECTPENDING[21:12]      //悬起的 ISR 的编号。如果不止一个中断悬起,则
                        //它的值是这引动中断中,优先级最高的那一个。
RETTOBASE[11]           //如果异常返回后将回到基级(base level),并且没有其它异常悬起时,
                        此位为 1。若是在线程模式下,在某个服务例程中,有不止一级的异常处于活动
                        状态,或者在异常没有活动时执行了异常服务例程(此时执行返回指令将产生 
                        fault。 此乃高危行为,大虾也需慎用), 则此位为 0
VECTACTIVE[9:0]         //当前活动的ISR编号,该位段指出当前运行中的ISR是哪个中断的
                        (提供异常序号),包括NMI和硬fault。 如果多个异常共享一个服务例程,
                        该例程可根据本位段的值来判定是哪一个异常的响应导致它的执行。 把
                            本位段的值减去16,就得到了外中断的编号,并可以用此
                                编号来操作外中断相关的使能/除能等寄存器



/*******************************************************************************
                      向量表偏移量寄存器(VTOR) 0xE000_ED08
*******************************************************************************/
//向量表重定位
因为地址0 处应该存储引导代码，所以它通常是Flash 或者是ROM 器件，并且它们的值不得在运行时改变。
然而，为了动态重分发中断，CM3 允许向量表重定位——从其它地址处开始定位各异常向量。这些地址对应的区
域可以是代码区，但也可以是RAM 区。在RAM区就可以修改向量的入口地址了。为了实现这个功能，NVIC 中有
一个寄存器，称为“向量表偏移量寄存器”（在地址0xE000_ED08 处），通过修改它的值就能定位向量表。 但
必须注意的是：向量表的起始地址是有要求的：必须先求出系统中共有多少个向量，再把这个数字向上增大到是
2的整次幂，而起始地址必须对齐到后者的边界上。
例如，如果一共有32 个中断，则共有32+16（系统异常）=48 个向量，向上增大到2 的整次幂后值为64，
因此地址地址必须能被64*4=256 整除，从而合法的起始地址可以是：0x0, 0x100, 0x200 等。



/*******************************************************************************
                 系统异常优先级寄存器阵列(0xE000_ED18 - 0xE000_ED23)
*******************************************************************************/ 
0xE000_ED18     PRI_4       //存储器管理 fault 的优先级
0xE000_ED19     PRI_5       //总线 fault 的优先级
0xE000_ED1A     PRI_6       //用法 fault 的优先级
0xE000_ED1B     ‐ ‐ ‐ ‐
0xE000_ED1C     ‐ ‐ ‐ ‐
0xE000_ED1D     ‐ ‐ ‐ ‐
0xE000_ED1E     ‐ ‐ ‐ ‐
0xE000_ED1F     PRI_11      //SVC 优先级
0xE000_ED20     PRI_12      //调试监视器的优先级
0xE000_ED21     ‐ ‐ ‐ ‐
0xE000_ED22     PRI_14      //PendSV 的优先级
0xE000_ED23     PRI_15      //SysTick 的优先级



/*******************************************************************************
                                SysTick定时器
SysTick 是一个 24 位的倒计数定时器,当计到 0 时,将从 RELOAD 寄存器中自动重装载定时初值
*******************************************************************************/
//Cortex‐M3处理器内部包含了一个简单的定时器。
因为所有的CM3芯片都带有这个定时器,软件在不同CM3器件间的移植工作得以化简
该定时器的时钟源可以是内部时钟(FCLK,CM3上的自由运行时钟),或者是外部时钟
( CM3处理器上的STCLK信号 ).不过,STCLK的具体来源则由芯片设计者决定,因此
不同产品之间的时钟频率可能会大不相同, 你需要检视芯片的器件手册来决定选择什
么作为时钟源。


//SysTick控制及状态寄存器(地址:0xE000_E010)
___________________________________________________________
COUNTFLAG[16]           //如果在上次读取本寄存器后,SysTick已经数到了0, 
                        //则该位为“1”。 如果读取该位,该位将自动清零
CLKSOURCE[2]            //SysTick时钟源选择
    0                   ..外部时钟源(STCLK)/8
    1                   ..内核时钟(FCLK)
TICKINT[1]              //SysTick定时器中断
    0                   ..SysTick 倒数到 0 时无动作
    1                   ..SysTick 倒数到 0 时产生 SysTick 异常请求
ENABLE[0]               //SysTick 定时器的使能位


//SysTick重装载数值寄存器(地址:0xE000_E014) 
___________________________________________________________
RELOAD[23:0]            //当倒数至零时,将被重装载的值
    

//SysTick当前数值寄存器(地址:0xE000_E018)    
_________________________________________________
CURRENT[23:0]           //读取时返回当前倒计数的值,写它则使之清零,
                        //同时还会清除在 SysTick 控制及状态寄存器中的
                        //COUNTFLAG 标志


//SysTick校准数值寄存器(地址:0xE000_E01C)
___________________________________________________________
NOREF[31]               //1=没有外部参考时钟(STCLK 不可用)
                        //0=外部参考时钟可用
SKEW[30]                //1=校准值不是准确的 10ms
                        //0=校准值是准确的 10ms
TENMS[23:0]             //10ms 的时间内倒计数的格数。芯片设计者应该通
                        //过 Cortex‐M3 的输入信号提供该数值。若该值读
                        //回零,则表示无法使用校准功能
                        
                        
//SysTick定时优先级设置
___________________________________________________________
SCB->SHP[11]=0xF0;  //设置SYSTICK的优先级为15，注意SYSTICK
                    属于系统异常，所以他的优先级在SCB里设置。
SysTick->CTRL=7;    //开启中断，开启定时器，时钟设置为HCLK=72mhz
___________________________________________________________



/*******************************************************************************
                          NVIC(外部中断控制寄存器组)
*******************************************************************************/
//中断使能寄存器 (0xE000_E100 – 0xE000_E11C)
___________________________________________________________
__IO uint32_t ISER[8];  //Interrupt Set Enable Register

//中断除能寄存器 (0xE000E180 - 0xE000_E19C)
___________________________________________________________
__IO uint32_t ICER[8];  //Interrupt Clear Enable Register

//悬起寄存器族 (0xE000_E200 – 0xE000_E21C)
___________________________________________________________
__IO uint32_t ISPR[8];  //Interrupt Set Pending Register

//解悬寄存器族 (0xE000E280 - 0xE000_E29C)
___________________________________________________________
__IO uint32_t ICPR[8];  //Interrupt Clear Pending Register

//中断活动状态寄存器族 (0xE000_E300_0xE000_E31C) 
___________________________________________________________
__IO uint32_t IABR[8];  //Interrupt Active bit Register

//中断优先级寄存器阵列 (0xE000_E400 – 0xE000_E4EF)
___________________________________________________________
__IO uint8_t  IP[240];  //Interrupt Priority Register (8Bit wide)

//软件触发中断寄存器STIR (0xE000_EF00) 
___________________________________________________________
__O  uint32_t STIR;     //Software Trigger Interrupt Register
INTID[8:0]              //影响编号为INTID的外部中断， 其悬起位被置位。
                        例如: 写入8， 则悬起 IRQ#8
















/*******************************************************************************
                   系统Handler控制及状态寄存器SHCSR(地址:0xE000_ED24)
*******************************************************************************/
[18]    USGFAULTENA(R/W)    //用法 fault 服务例程使能位
[17]    BUSFAULTENA(R/W)    //总线 fault 服务例程使能位
[16]    MEMFAULTENA(R/W)    //存储器管理 fault 服务例程使能位
[15]    SVCALLPENDED(R/W)   //SVC 悬起中
[14]    BUSFAULTPENDED(R/W) //总线 fault 悬起中,细节同上
[13]    MEMFAULTPENDED(R/W) //存储器管理 fault 悬起中,细节同上
[12]    USGFAULTPENDED(R/W) //用法 fault 悬起中,细节同上
[11]    SYSTICKACT(R/W)     //SysTick 异常活动中
[10]    PENDSVACT(R/W)      //PendSV 异常活动中
[9 ]    ---
[8 ]    MONITORACT(R/W)     //Monitor 异常活动中
[7 ]    SVCALLACT(R/W)      //SVC 异常活动中
6:4]    ---
[3 ]    USGFAULTACT(R/W)    //用法 fault 异常活动中
[2 ]    ---
[1 ]    BUSFAULTACT(R/W)    //总线 fault 异常活动中
[0 ]    MEMFAULTACT(R/W)    //存储器管理 fault 异常活动中
/*******************************************************************************
                       中断控制器类型寄存器ICTR(地址:0xE000_E004)
*******************************************************************************/
4:0     INTLINESUM(R)       //中断输入的数量,以 32 为粒度,如
        0=1  至 32
        1=33 至 64
        2=65 至 96
        ...      
/*******************************************************************************
                       系统控制寄存器 (0xE000_ED10)
*******************************************************************************/ 
4           SEVONPEND       //发生异常悬起时请发送事件,用于在一个新的中
                            断悬起时从 WFE 指令处唤醒。不管这个中断的
                            优先级是否比当前的高,都唤醒。如果没有 WFE
                            导致睡眠,则下次使用 WFE 时将立即唤醒
                            
2           SLEEPDEEP       //当进入睡眠模式时,使能外部的 SLEEPDEEP 信号
                            以允许停止系统时钟                            

1           SLEEPONEXIT     //激活“SleepOnExit”功能
/*******************************************************************************
                       配置与控制寄存器 (0xE000_ED14)
*******************************************************************************/
9       STKALIGN            //在响应异常的自动入栈操作时,强制 SP 对
                            齐到双字地址上
8       BFHFNMIGN           //在硬 fault 与 NMI 服务例程中忽略数据总线fault
4       DIV_0_TRP           //除数为零时陷入用法 fault
3       UNALIGN_TRP         //访问未对齐时陷入用法 fault
1       USERSETMPEND        //如果为 1,则允许用户代码设置 STIR
0       NONBASETHRDENA      //非基于线程模式使能位。如果为 1,则允许异
                            常服务例程通过修改 EXC_RETURN,使其在
                            线程模式下执行
/*******************************************************************************
                      CPUID寄存器 (0xE000_ED00)
*******************************************************************************/
31:24                       //实现者代码, ARM=0x41
23:20                       //实现定义的变种号
19:16                       //常量
15:4                        //Part编号
3:0                         //修订号
