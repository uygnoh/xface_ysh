/*******************************************************************************
                               stm32存储器地址重映射
*******************************************************************************/
//复位之后总是从地址0x04取复位代码的起始地址, 以及从0x00取堆栈指针，开始执行复位程序

// 3 块可用于启动的存储器的物理地址
___________________________________________________________
  由Boot引脚块定以上3块物理存储器中的那块映射到 0x0 的起始地址
  Boot引脚在复位后第4个SYSCLK上升沿采样锁定, 从待机模式(Standby)退出后，会重新采样BOOT引脚电平
    0x2000 0000                 //(1)片上SRAM起始地址                    
    0x0800 0000                 //(2)片上用户闪存起始地址                 
    0x1FFF 0000                 //(3)片上系统闪存(BootLoader)起始地址     



| //stm32提供了地址重映射寄存器 => SYSCFG_MEMRMP(0x4001_3800)
|_________________________________________________________________|
| [31: 2]      | //Reserved                                       |
|______________|__________________________________________________|
| [1 : 0]      //MEM_MODE设置存储器地址重映射模式，由软件置位和清除      |
|              复位之后，这2位的值自动根据Boot引脚选择的启动模式进行设置   |
|    00        =>//片上用户闪存空间映射到0x0000_0000位置              |
|    01        =>//片上系统闪存空间映射到0x0000_0000位置              |
|    10        =>//FSMC Bank1(NOR/RSRAM 1和2)映射到0x0000_0000位置 |
|    11        =>//片上SRAM映射到0x0000_0000位置                    |
|______________|__________________________________________________|
// 复位之后，Boot引脚的值被复制到该寄存器
！唯一例外的是，当Boot1=1 Boot2=0；从片上闪存启动时，寄存器值=0x00
// CM3离开复位状态时，首先要做的是读取下面两个值
1 从地址0x0000_0000，取出MSP的值
2 从地址0x0000_0000，取出复位向量(程序开始执行的地址，LSB必须是1)



| //“向量表偏移寄存器VTOR”来重定位向量表(0xE000_ED08)
|          向量表只能放在内部Flash和RAM区
|_________________________________________________________|
|  [31:30]         Reserved                               |
|_________________________________________________________|
|  [29   ]         TBLBASE     R/W     0  //Code=>0, RAM=>1
|_________________________________________________________|
|  [28: 7]         TBLOFF      R/W     0                  |
|_________________________________________________________|
|  [6 : 0]         Reserved                               |
|_________________________________________________________|
//向量表的起始地址的限制
1 必须先求出系统中有多少个向量，再把该数字向上“圆整”到2的整次幂
2 而起始地址必须对齐到后者的边界上
//例如，一共有32个中断，则共有32+16=48个向量
//向上圆整到2的整次幂后值为64，因此向量表重定位的地址必须能被64x4=256整除，
//合法的地址可以是： 0X0, 0X100, 0X200




/*******************************************************************************
                              stm32_startup_ARMCC
*******************************************************************************/ 
stack       //程序运行时用于存放局部变量，可向下延伸空间
heap        //程序运行时用于分配malloc申请的区域
.data.bss   //用于存入全局变量和静态变量
.txt        //存放程序和常量



|_________________________________________________________|
|  Stack_Size  EQU     0x00000400                         |
|       AREA    STACK, NOINIT,READWRITE, ALING=3          |
|  Stack_Mem   SPACE   Stack_Size                         | 
|  __initial_sp                                           |
|_________________________________________________________|                                      
//EQU  宏定义的伪指令，类似于C语言的#define. 0x00000400表示栈的大小，以字节为单位。
//AREA 伪指令表示定义一个代码段或是数据段， AREA后面的关键字表示这个段的属性。
  1 STACK       //表示这个段的名字，可以是任意命名
  2 NOINIT      //表示这个此数据段不需要填入初始数据
  3 READWRITE   //表示此段可读可写 
  4 ALIGN=3     //表示首地址按照 2的3次方对齐，也就是按照8字节对齐
// SPACE 这行伪指令告诉编译器给 STACK段分配 0x00000400字节的连续内存空间。
// __initial_sp 紧接着 SPACE语句放置，表示栈顶地址。
  1 __initial_sp只是一个标号
  2 标号的主要作用表示一片内存空间的某个位置，等价于C语言中的“地址”的概念。
  3 地址仅仅表示存储空间的一个位置
  4 从C语言的角度来看，变量的地址，数组的地址，函数的入口地址本质上并无区别。
 
 
  
| //开辟堆空间，主要用于动态内存分配，也就是用 malloc 
| //等函数分配的变量空间在堆上。 这里定义的是数据段
|_________________________________________________________|
|  Heap_Size   EQU     0x00000200                         |
|       AREA    HEAP, NOINIT, READWIRTE, ALIGN=3          |
|  __heap_base                                            |
|  Heap_Mem    SPACE   Heap_Size                          |
|  __heap_limit                                           |
|_________________________________________________________|
//分配堆的空间大小为 0x00000200
// __heap_base 表示堆的开始地址
// __heap_limit表示堆的结束地址 



PRESERVE8       //表示当前文件保持堆栈8字节对齐。
THUMB           //表示后面的指令是THUMB指令集， CM3采用的是 THUMB-2指令集。      
  


//AREA定义一块数据段，只读，段名是RESET
//EXPORT语句将下面 3个标号申明为可被外部引用。主要提供给连接器用于连接库文件或其它文件。
|       //Vector Table Mapped to Address 0 at Reset 
|_________________________________________________________|
|           AREA    RESET, DATA, READONLY                 |
|           EXPORT  __Vectors                             |
|           EXPORT  __Vectors_End                         |
|           EXPORT  __Vectors_size                        |
|_________________________________________________________|
| //此处是真正分配内存空间的地方, 
| //存放的是中断向量表， 它会写入到flash的起始位置上
|_________________________________________________________|
|  __Vectors   DCD     __initial_sp                       |
|              DCD     Reset_Handler                      |
|              DCD     NMI_Handler                        |
|              ...                                        |
|  __Vectors_End                                          |
|  __Vectors_Size EQU __Vectora_End - __Vectros           |
|_________________________________________________________|
//上面的代码是建立中断向量表
    1 中断向量表定义在代码段的最前面
    2 具体的地址由链接器的配置参数(IROM1 的地址)决定
    3 如果程序在Flash中运行，则中断向量表的起始地址 0x08000000
//DCD 表示分配1个4字节的空间
    1 每行DCD都会生成一个 4字节的二进制代码
    2 中断向量表实际上存放的是中断服务程序的入口地址
    3 当异常或中断事件发生时，CPU的中断系统会将相应的入口地址赋值给 PC程序计数器
    4 之后开始执行中断服务程序

    
    
//AREA定义了一个代码段，只读，段名是.text
___________________________________________________________
PROC-ENDP //这一对伪指令把程序段分为若干个过程，使程序结构更加清晰
IMPORT    //伪指令用于通知编译器要使用的标号在其它的源文件中有定义。 
WEAk      //声明其它同名标号优先于该标号被引用，就是说如果外面声明了
          //这个标号的话会被外面先使用
|_________________________________________________________|
|                 AREA    |.text|, CODE, READONLY         |
|  Reset_Handler  PROC                                    |
|                 EXPORT  Reset_Handler   [WEAK]          |
|                 IMPORT  SystemInit                      |
|                 IMPORT  __main                          |
|                 LDR     R0, =SystemInit                 |
|                 BLX     R0                              |
|                 LDR     R0, =__main                     |
|                 BX                                      |
|                 ENDP                                    |
|_________________________________________________________|



| //系统执行的第一条指令
|_________________________________________________________|
|               LDR     R0, =_initial_sp                  |
|               MSR     MSP, R0                           |
|_________________________________________________________|

            
            
//检查系统要从那个位置启动， flash, ram， systems
___________________________________________________________
    LDR R0, =0x00000004
    LDR R1, [R0]            //[R0]存放的就是reset_handler的地址，取出的地址送给R1，
                            //这个地址有可能是0x20000000左右 0x08000004左右。
    LSRS R1, R1, #24        //将reset_handler的地址向右移动24位，就剩高8位移动到低8位。
    LDR R2, =0x1F
    CMP R1, R2              //如果相等， 则说明是串口启动
    BNE ApplicationStart    //不相等则跳转到ApplicationStart处执行。

ApplicationStart
        LDR R0, =SystemInit
        BLX R0   
//将__main的地址加载到寄存器，进入__main， 这里的__main不是我们在用户程序里看到的main.c
//而是编译系统提供的C/C++标准库函数是的一个初始化子程序__main
        1 完成映像文件的初始化工作
        2 调用 _rt_entry库函数进入到用户程序
//__main是一个库函数，在它调用_rt_entry函数的第一条指令就调用本程序 287行代码的
//_usr_initial_stackheap函数。初始化代码的堆和栈，然后初始化C运行库，接下来调用用户的main()函数。
        LDR R0, =__main
        Bx    
278 行代码
//对堆和栈的位置进行标记
__user_initial_stackheap
        LDR R0, = Heap_Mem
        LDR R1, = (Stack_Mem + Stack_Size)
        LDR R2, = (Heap_Mem + Heap_Size)
        LDR R3, = Stack_Mem
        BX LR //从那里调用了，就从那里返回
