#include "i2c.h"


/*******************************************************************************
  函数名称: iic_start_signal()
  输入参数: 无
  输出参数: 无
  函数功能: “主机” 发送起始信号
*******************************************************************************/
void iic_start_signal(void)
{
        IIC_SCL = 1;    //总线空闲，SCL为高
        IIC_SDA = 1;    //总线空闲，SDA为高
        delay_us(5);    //SCL保持4.7us之后
        IIC_SDA = 0;    //拉低SDA产生下降沿，产生起始信号
        delay_us(5);    //SDA保持4.7us之后
        IIC_SCL = 0;    //拉低SCL产生下降沿，告诉从机开始传送数据了
}

/*******************************************************************************
  函数名称: iic_stop_signal()
  输入参数: 无
  输出参数: 无
  函数功能: “主机” 发送停止信号
*******************************************************************************/
void iic_stop_signal(void)
{
        IIC_SCL = 0;    //SCL为低
        IIC_SDA = 0;    //SDA为低
        delay_us(5);    //稍作延时
        IIC_SCL = 1;    //SCL为高
        delay_us(5);    //稍作延时
        IIC_SDA = 1;    //SDA为高
        delay_us(5);    //稍作延时
}

/*******************************************************************************
  函数名称: iic_write()
  输入参数: (uint8_t dat)要写入的数据
  输出参数: 无
  函数功能: 向“I2C总线”中写入一个字节数据，数据传送方向:(高位在前，低位在后)
*******************************************************************************/
uint8_t iic_write(uint8_t dat)
{
        uint8_t tmp;
        uint8_t ack;

        for (tmp = 0x80; tmp != 0; tmp >>= 1) {
                //判断当前位为“0”的话写入“0”, 否则向当前位写入“1”
                if ((tmp & dat) == 0) {
                        IIC_SDA = 0;
                } else {
                        IIC_SDA = 1;
                }
                delay_us(5);    //延时最小要4us，保持SCL为低电平
                IIC_SCL = 1;    //拉高SCL，“器件24C02”读总线上的数据
                delay_us(5);    //延时最小要4us，保持SCL为高
                IIC_SCL = 0;    //拉低SCL
        }
        ack = slave_send_ack(); //保存从机发送的ack信号
        return(ack);            //返回从机的ack信号
}

/*******************************************************************************
  函数名称: iic_read()
  输入参数: 无
  输出参数: 返回从“I2C总线”上读到的一个字节的数据
  函数功能: 从“I2C总线”上读一个字节数据，数据传送方向:(高位在前，低位在后)
*******************************************************************************/
uint8_t iic_read(void)
{
        uint8_t tmp;
        uint8_t dat = 0;
        IIC_SDA = 1;                    //主机释放总线，为接下来的数据作准备
                                        //先传入最高位(MSB)，从最高位开始读
        for (tmp = 0x80; tmp != 0; tmp >>= 1) {                    
                delay_us(5);            //延时最小要4us，保持SCL为低电平
                IIC_SCL = 1;            //拉高SCL，“主机”读数据位
                if (IIC_SDA == 1) {     //判断当前位为“1”的话
                        dat |= tmp;     //tmp中的值保存到“dat”中
                } else {
                        dat &= ~tmp;
                }
                delay_us(5);            //延时最小要4us，保持SCL为高
                IIC_SCL = 0;            //拉低SCL, 为下一次数据传输作准备
        }
        return(dat);
}

/*******************************************************************************
  函数名称: host_send_ack()
  输入参数: 无
  输出参数: 无
  函数功能: “主机” 向总线发送应答信号(“0”应答， “1”非应答)
           在第8个字节后，主机发送“1”位应答信号
*******************************************************************************/
void host_send_ack(void)
{
        IIC_SDA = 0;    //主机送应答信号
        delay_us(5);    //延时最小要4us，保持SCL为低电平
        IIC_SCL = 1;    //拉高SCL，“主机”发送数据位
        delay_us(5);    //延时最小要4us，保持SCL为高
        IIC_SCL = 0;    //拉低SCL
}

/*******************************************************************************
  函数名称: host_send_nack()
  输入参数: 无
  输出参数: 无
  函数功能: “主机” 向总线发送非应答信号(“0”应答， “1”非应答)
           在第8个字节后，主机发送“1”位非应答信号
*******************************************************************************/
void host_send_nack(void)
{
        IIC_SDA = 1;    //主机送非应答信号！！！
        delay_us(5);    //延时最小要4us，保持SCL为低电平
        IIC_SCL = 1;    //拉高SCL，“主机”发送数据位
        delay_us(5);    //延时最小要4us，保持SCL为高
        IIC_SCL = 0;    //拉低SCL
}

/*******************************************************************************
  函数名称: slave_send_ack()
  输入参数: 无
  输出参数: 返回“从机”的应答位状态(“0”应答， “1”非应答)
  函数功能: “从机” 向总线发送应答信号
           在第8个字节后，主机释放总线，从机回应“1”位应答信号
           “主机”在第9个时钟的上升沿读取从机的应答信号
*******************************************************************************/
uint8_t slave_send_ack(void)
{
        uint8_t ack;
        IIC_SDA = 1;    //主机释放“SDA”，为读“ack”做准备
        delay_us(5);    //SCL保持4.7us，SCL为低电平“0”
        IIC_SCL = 1;    //拉高SCL，读取ack */
        ack = IIC_SDA;  //读取ack上的数据 */
        delay_us(5);    //SCL保持4.7us，SCL为高“1”
        IIC_SCL = 0;    //释放SCL，SCL为低“0” 
        return(ack);   //返回应答状态(“0”应答， “1”非应答)
}
