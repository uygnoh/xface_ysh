//_____________________________________________________________
//_____________________________________________________________
sbit ADC0832_CS         =P1^0;  //片选信号
sbit ADC0832_CLK        =P1^1;  //时钟信号
sbit ADC0832_DI         =P1^2;  //数据输入
sbit ADC0832_DO         =P1^2;  //数据输出


void adc0832_init(void)
{
        ADC0832_CS  = 1;
        ADC0832_CLK = 0;
        ADC0832_DI  = 1;
}

uint8_t adc0832_conv(void)
{
        uint8_t ad_res1;
        uint8_t ad_res2;
        
        ADC0832_CS  = 0;        //片选使能
        ADC0832_CLK = 0;        //时钟信号为低电平（0）
        
        //_____________________________________________________________
        // 第一个脉冲（输入的是 1），表示启动ADC转换
        //_____________________________________________________________
        ADC0832_DI  = 1;
        __nop__();
        ADC0832_CLK = 1;
        __nop__();
        ADC0832_CLK = 0;
        
        //_____________________________________________________________
        // 第二个脉冲（输入的是 1），表明是单端输入
        //_____________________________________________________________
        ADC0832_DI  = 1;
        __nop__();
        ADC0832_CLK = 1;
        __nop__();
        ADC0832_CLK = 0;

        //_____________________________________________________________
        // 第三个脉冲（输入的是 0），表明是单端输入，通道__0__
        //_____________________________________________________________
        ADC0832_DI  = 0;
        __nop__();
        ADC0832_CLK = 1;
        __nop__();
        ADC0832_CLK = 0;
        
        //_____________________________________________________________
        // ADC0832_DO = 1 （释放总线）
        // 准备接收 2 个字节数据
        //_____________________________________________________________
        ADC0832_DO  = 1;        //数据线拉高，准备接收数据
        for (i = 0; i < 8; i++) {
                ADC0832_CLK = 1;
                __nop__();
                ADC0832_CLK = 0;        //产生下降沿
                __nop__();
                ad_res1 <<= 1;          //数据是高位在前
                if (ADC0832_DO == 1) {
                        ad_res1 |= 0x01;
                }
        }
        
        for (i = 0; i < 8; i++) {
                ad_res2 >>= 1;          //数据低位在前
                if (ADC0832_DO == 1) {
                        ad_res2 |= 0x80;
                }
                ADC0832_CLK = 1;
                __nop__();
                ADC0832_CLK = 0;        //产生下降沿
                __nop__();
        }
        
        ADC0832_CLK = 1;
        ADC0832_CS  = 1;
        ADC0832_DI  = 1;
        
        return ((ad_res1 == ad_res2) ? ad_res1 : 0);
}
