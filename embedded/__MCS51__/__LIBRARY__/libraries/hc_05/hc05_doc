/*******************************************************************************
        => HC05（蓝牙2.0）
*******************************************************************************/
STATE           //配对状态输出（配对成功输出高电平，未配对则输出低电平）
RX
TX
GND             //电源地
5V              //电源输入（4.5V~6V）
EN              //用于进入AT状态（高电平有效），默认为低电平
//在模块上电的时候，此时状态指示灯（1秒2次）闪，表示模块进入（可配对状态）
//模块配对成功（此时指示灯双闪），一次闪2下， 2秒闪一次
//进入AT指令方式（先把HC05模块电断掉），再按住（按键）不放，在次上电



/*******************************************************************************
        => HC05（蓝牙2.0）__AT指令__
        程序功能：蓝牙传输（主机端）
        KEY_00          发送“A”
        KEY_01          发送“B”
        KEY_02          发送“C”
        KEY_03          发送“D”
        串口配置（9600bps___@11.0592MHz___8N1）
*******************************************************************************/
unsigned char key_cnt = 0;      //key_scan()函数___进入定时器中断的次数
unsigned char key_num = 0;      //返回按键数值

//_____________________________________________________________
//注意：key_scan()函数在定时器中断中处理（定时器中断为1MS）
//_____________________________________________________________
void key_scan(void)
{
        KEY_00 = 1;
        KEY_01 = 1;
        KEY_02 = 1;
        KEY_03 = 1;
        if (!KEY_00 || !KEY_01 || !KEY_02 || !KEY_03) { //如果有按键被按下
                key_cnt++;                              //使用定时器中断延时消抖
                if (key_cnt == 10) {                    //定时器中断计数到（10MS）
                        key_cnt = 0;                    //再次判断按键是否真的被按下了
                        if (!KEY_00 || !KEY_01 || !KEY_02 || !KEY_03) {
                                if (!KEY_00) {          //检测是那一个按键被按下了
                                        key_num = 1;
                                }
                                if (!KEY_01) {
                                        key_num = 2;
                                }
                                if (!KEY_02) {
                                        key_num = 3;
                                }
                                if (!KEY_03) {
                                        key_num = 4;
                                }
                        }//松手检测（如果按键被弹起，则退出循环）
                        while (!KEY_00 || !KEY_01 || !KEY_02 || !KEY_03);
                }
        }
        return key_num;
}


#define BEEP_TIME       100     //蜂鸣器响的时间
unsigned int beep_cnt;         //蜂鸣器
//_____________________________________________________________
// 定时器0初始化
//_____________________________________________________________
void timer0_init(void)
{
        TMOD &= 0xF0;   //设置定时器模式
        TMOD |= 0x01;   //设置定时器模式
        TL0   = 0x66;   //设置定时器初值
        TH0   = 0xFC;   //设置定时器初值
        TF0   = 0;      //清除（TF0）标志
        ET0   = 1;      //打开定时器0中断
        TR0   = 1;      //定时器0开始计时
}
//_____________________________________________________________
// 定时器__0__中断处理函数 1MS@11.0592MHZ
//_____________________________________________________________
void TIMER0_ISR(void) interrupt 1
{
        TR0   = 0;              //关闭定时器0
        key_scan();
        if (beep_cnt != 0) {
                beep_cnt--;
                BEEP_00 = 0;    //蜂鸣器发声（低电平）
        } else {
                BEEP_00 = 1;    //蜂鸣器不发声（高电平）
        }
        TL0   = 0x66;           //重新装载定时器0初值
        TH0   = 0xFC;           //重新装载定时器0初值
        TR0   = 1;
}


void key_service(void)
{
        switch (key_num) {
        case 1:
                send_byte('A');
                beep_cnt = BEEP_TIME;
                break;
        case 2:
                send_byte('B');
                beep_cnt = BEEP_TIME;
                break;
        case 3:
                send_byte('C');
                beep_cnt = BEEP_TIME;
                break;   
        case 4:
                send_byte('D');
                beep_cnt = BEEP_TIME;
                break;
        default:
                break;
        }
}


int main(void)
{
        beep_cnt = BEEP_TIME;
        key_service();
        return 0;
}



