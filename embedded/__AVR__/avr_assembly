/*******************************************************************************
Harvard architecture (ATmega328P)
_____________________________________________
        | FLASH ROM  | EEPROM    | SRAM     |
        | 32K Bytes  | 1K Bytes  | 2K Bytes |
        |___________ |___________|__________|
*******************************************************************************/
//_____________________________________________________________
        LDI（Load Immediate）__把数值存储在寄存器中__
        loading values into the general purpose register
//_____________________________________________________________
_________________________________________
| LDI Rd, k                             |
|_______________________________________|
// Rd = k
// where 16 <= d <= 31,  0 <= k <=255
LDI     R16, 53
LDI     R23, 0x30


//_____________________________________________________________
        Instruction - ADD
        add and store values in the general purpose register
//_____________________________________________________________
_________________________________________
| ADD Rd, Rs                            |
|_______________________________________|
// Rd = Rd + Rs
// where 0 <= d <= 31,  0 <= s <=255
        (19 + 95 + 5)
        LDI     R16, 19
        LDI     R17, 95
        LDI     R18, 5
        ADD     R16, R17
        ADD     R16, R18


//_____________________________________________________________
        Instruction - SUB
        subtract and store values in the general purpose register
//_____________________________________________________________
_________________________________________
| SUB Rd, Rs                            |
|_______________________________________|
// Rd = Rd - Rs
// where 0 <= d <= 31,  0 <= s <=255


//_____________________________________________________________
        Instruction - INC
        increment teh contents of a register by one
//_____________________________________________________________
_________________________________________
| INC Rd                                |
|_______________________________________|
// Rd = Rd + 1
// where 0 <= d <= 31



//_____________________________________________________________
        Instruction - IN
        load the reading from an I/O register to a GPR
//_____________________________________________________________
_________________________________________
| IN Rd, IO_A                           |
|_______________________________________|
// Rd = IO_A
// where 0 <= d <= 31, IO_A is the name of an I/O register


//_____________________________________________________________
        Instruction - OUT
        store the reading from a GPR to an I/O register
//_____________________________________________________________
_________________________________________
| OUT IO_A, Rd                          |
|_______________________________________|
// A = Rd
// where 0 <= d <= 31, IO_A is the name of an I/O register


        X = Y + Y;
//_____________________________________________________________
        IN      R1, X
        IN      R2, Y
        ADD     R1, R2
        OUT     X, R1



/*******************************************************************************
        => AVR_ASM__程序__
*******************************************************************************/
// Assembly program code:
// PortD_Pin0 = 1（打开LED灯）
//_____________________________________________________________
        LDI     R16,   0b00000001
        OUT     DDRD,  R16      //配置PORTD.0为输出模式
        OUT     PORTD, R16      //配置PORTD.0为高电平



// LED闪烁程序
//_____________________________________________________________
        LDI  R20,   0b00000001
        LDI  R21,   0b00000000
        OUT  DDRD,  R20
L1:     OUT  PORTD, R20
        CALL DELAY
        OUT  PORTD, R21
        CALL DELAY
        JMP  L1
        
DELAY:  LDI  R17, 12
L2:     LDI  R18, 0xFF
L3:     LDI  R19, 0xFF
L4:     DEC  R19
        BRNE L4
        DEC  R18
        BRNE L3
        DEC  R17
        BRNE L2
        RET



// Example: Input Mode without Pull-up
//_____________________________________________________________
1 Make all the pins of Port B input     //DDRB  = 0x00;（全部为输入）
2 Make all the pins of Port D output    //DDRD  = 0xFF;（全部为输出）
3 Send the reading form Prot B to       //PORTD = PINB + 5;
  Port B to Prot D, after adding a value 5 to it
        LDI     R16,   0x00
        OUT     DDRB,  R16
        LDI     R17,   0xFF
        OUT     DDRD,  R17
        IN      R18,   PINB
        LDI     R19,   0x05
        ADD     R18,   R19
        OUT     PORTD, R18



        DDRB  = 0x00;
        PORTB = 0xFF;
        DDRD  = 0xFF;
        PORTD = PINB;
//_____________________________________________________________
        LDI     R16, 0
        OUT     DDRB, R16
        LDI     R17, 0xFF
        OUT     PORT, R17
        OUT     DDRD, R17
        IN      R18, PINB
        OUT     PORTD, R18



/*******************************************************************************
        => 加载存储指令
        Accessing Data Memory - LDS & STS
*******************************************************************************/
//_____________________________________________________________
        Instruction - LDS     
        load data from space
//_____________________________________________________________
_________________________________________
| LDS Rd, k                             |
|_______________________________________|
// where 0 <= d <= 31, k between $0000 to $FFFF
        LDS  R1,  0x60          、、R1 = [0x60];


//_____________________________________________________________
        Instruction - STS     
        store data to space
//_____________________________________________________________
_________________________________________
| STS k, Rd                             |
|_______________________________________|
// where 0 <= d <= 31, k between $0000 to $FFFF
        STS  0x60,  R15         、、[0x60] = R15;


//_____________________________________________________________
        Assembler Directives - .EQU
        相当于C语言中的宏定义, 只能被定义一次
//_____________________________________________________________
_________________________________________
| .EQU name = value                     |
|_______________________________________|
//Assembler Directives - .SET
//相当于C语言中的宏定义，和EQU的区别在于，还可以在定义
_________________________________________
| .SET name = value                     |
|_______________________________________|
        .EQU    SUM = 0x300     //SRAM loc $300 for SUM
        LDI     R16, 0x25       //R16   = 0x25;
        LDI     R17, $34        //R17   = 0x34;
        LDI     R18, 0b00110001 //R18   = 0x31;
        ADD     R16, R17        //R16   = R16 + R17;
        ADD     R16, R18        //R16   = R16 + R18;
        LDI     R17, 11         //R17   = R17 + 11
        ADD     R16, R17        //R16   = R16 + R17
        STS     SUM, R16        //[SUM] = R16
HERE:   JMP     HERE



/*******************************************************************************
        => Machine code AVR机器码
*******************************************************************************/

        ADD-16bits
|_____________|___|___________|_________|
|15         9 | 8 |           | 3     0 |
|_____________|___|___________|_________|
| 0 0 0 0 1 1 | r | d d d d d | r r r r |
|_____________|___|___________|_________|


        SUBI-16bits
        SUBI Rd, k      //K=0~255  Rd=16~31
_________________________________________
| 0 1 0 1 | k k k k | d d d d | k k k k |
|_________|_________|_________|_________|


OUT-16bits      //a为IO的地址， r为GPR
________________________________________
| 1 0 1 1 1 | a a | r r r r r | a a a a |
|___________|_____|___________|_________|


STS-32bits
_______________________________________
| 1 0 0 1 0 0 1 | d d d d d | 0 0 0 0 |
|_______________|___________|_________|
| a a a a  a a a a   a a a a  a a a a |
|_____________________________________|



//_____________________________________________________________
        AVR - Status Register (SREG)
//_____________________________________________________________
_________________________________
|   |   |   |   |   |   |   |   |
| I | T | H | S | V | N | Z | C |
|___|___|___|___|___|___|___|___|______________________________________________|
|   I   //Interrupt     Enables Global Insterrupt when Set                     |
|   T   //T Flag        Source and Destination for BLD and BST                 |
|   H   //Half carry    Set if an Add/Sub. has Carry between Bits 4&3          |
|   S   //Signd Flag    Used for Signed Tests                                  |
|   V   //oVerflow      Set if an Add/Sub Results in Signed Overflow           |
|   N   //Negative      Set if a Result is Negative                            |
|   Z   //Zero          Set if a Add/Subtract resutl is zero                   |
|   C   //Carry         Set if an Add/Subtract has Carry                       |
|______________________________________________________________________________|
| BREQ    //Branch if Equal               jump if Z = 1                        |
| BRNE    //Branch if Not Equal           jump if Z = 0                        |
| BRCS    //Branch if Carry Set           jump if C = 1                        |
| BRCC    //Branch if Carry Cleard        jump if C = 0                        |
|______________________________________________________________________________|
|
| //if else
|________________________________________
|        |   R21 < R20   |  R21 >= R20  |
|________|_______________|______________|
|   C    |       1       |       0      |
|________|_______________|______________|
|  jmp   |      NO       |      YES     |
|________|_______________|______________|
|                                       |
|  if (R20 > R21)                       |
|          R26++;                       |
|  else                                 |
|          R26--;                       |
|_______________________________________|
|          SUB     R21, R20             |
|          BRCC    L1   //jump if C = 0 |
|          INC     R26                  |
|          JMP     L2                   |
|  L1:                                  |
|          DEC     R26                  |
|  L2:                                  |
|_______________________________________|
|
|
|
| // for
|______________________________________
|       |    R20 = 0    |  R20 != 0    |
|_______|_______________|______________|
|   Z   |      1        |       0      |
|_______|_______________|______________|
|  jmp  |      NO       |      YES     |
|_______|_______________|______________|
|         9+8+7+6+5+4+3+2+1            |
| R30 = 0x00;                          |
| for (i = 9; i >= 0; i--)             |
|         R30 = R30 + i;               |
|______________________________________|
|         LDI     R30, 0x00            |
|         LDI     R20, 0x09            |
| L1:     ADD     R30, R20             |
|         DEC     R20                  |
|         BRNE    L1   //jump if Z = 0 |
|______________________________________|



//switch-case
___________________________________________________________
//SUB   R20, R21        //结果存储到R20中
//CP    R20, R21        //结果不存储， 只是单纯的比较     
//CPI   R20, 23         //一个寄存器的值和一个数作比较

M_LOOP: 
        CPI     ch, 65  //compare
        BREQ    L1      //branch if eq
        
        CPI     ch, 66
        BREQ    L2
L1:
        JMP     EXIT
L2:
        JMP     EXIT
EXIT:



/*******************************************************************************
        => bit
*******************************************************************************/
        Instruction - SBI
//_____________________________________________________________
_________________________________________
| SBI ioReg, bit                        |
|_______________________________________|
//设置寄存器PORTD的第4位 = 1
SBI PORTD, 4
//设置寄存器DDRC的第5位 = 1
SBI DDRC, 5


        Instruction - CBI
//_____________________________________________________________
_________________________________________
| CBI ioReg, bit                        |
|_______________________________________|
//清除寄存器PORTD的第6位 = 0
SBI PORTD, 6
//清除寄存器DDRC的第4位 = 0
CBI DDRC, 4


        Instruction - SBIS
//_____________________________________________________________
//skip the next instruction if bit in I/O register set
_________________________________________
| SBIS ioReg, bit                       |
|_______________________________________|
SBIS    PIND, 5
INC     R20
LDI     R19, 0x23


        Instruction - SBIC
//_____________________________________________________________
//skip the next instruction if bit in I/O register cleared
_________________________________________
| SBIC ioReg, bit                       |
|_______________________________________|
SBIC    PIND, 5
INC     R20
LDI     R19, 23
