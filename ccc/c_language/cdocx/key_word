/*******************************************************************************
                => static inline
*******************************************************************************/
static
    在C语言中，函数默认情况下是global的。函数名前的static关键字使它们
    变成静态。不同于C语言其他的global的函数，访问static函数被限制到声
    明它们的文件。因此，当我们要限制对函数的访问时，我们让它们static。
    此外，在不同的文件中可以允许存在拥有相同函数名的static函数。
inline
    inline是c99的特性。在c99中，inline是向编译器建议，将被inline修饰
    的函数以内联的方式嵌入到调用这个函数的地方。而编译器会判断这样做是否合
    适，以此最终决定是否这么做。
static inline
    根据上面的定义可以知道，如果static inline关键字生效（因为只有编译器
    有最终决定权，我们只有建议权，这点在后面会细讲），static inline会以
    一种类似于宏定义的方式，将调用被static inline修饰的函数的语句替换为
    那个函数体对应的指令，但实际上只是inline的作用，static作用其实是维护
    代码的健壮性，实验中会加以证明。 所以：
// 好处：
   减少调用函数时的开销，如：
   减少传参时可能引起的压栈出栈的开销。
   减少PC跳转时对流水线的破坏。
// 坏处： * 代码所占体积会更大。



// 修饰全局变量, 它就变成了内部链接
static int global;


// static静态函数( 它只能在本文件中使用 )
// 修饰函数，它就变成了内部链接函数
static void fun1(void)
{
	// 修饰局部变量
	static int arr;
}


// inline内联函数( 1,短小精悍 2,频繁调用 )
// inline相当于宏，但是和宏又不一样( 它吸取了宏的快速性，又吸取了函数的易用性 )
// “宏” 它是在编译之前，也就是在预处理阶段，它是直接的文本替换
// “inline” 它是先把fun2()函数编译成二进制文件， 然后把二进制文件插入到被调用处
inline void fun2(void)
{
}


//  _inline函数也称为内联函数或内嵌函数，_inline定义的类的内联函数，
//  函数代码被放入符号调用表，使用时直接展开，不需要调用，即在编译期间
//  将所调用的函数的代码直接嵌入到主调函数中，是一种以空间换时间的函数。
static __INLINE



/*******************************************************************************
                => extern
*******************************************************************************/
// 定义一个全局变量， 使用“global_”前缀


// 声明一个全局变量，这个变量在其它文件 里面定义
// 全局变量， 只能定义一次， 不能定义多次
// 如果“extern”的时候，给了初始化，那么编译器认为是一个新的变量
extern global_size;


// 作用域： 是这个文件(文件作用域)
// 如果需要在其它文件使用这个全局变量，需要“extern”关键字声明( extern int tx_flag; )
int tx_flag = 1;



/*******************************************************************************
                => GCC的一大特色就是 __attribute__ 机制
*******************************************************************************/
//__attribute__ 可以设置
___________________________________________________________
函数属性( Function Attribute )
变量属性( Variable Attribute )
类型属性( Type Attribute )


1 // aligned 指定对象的对齐格式（以字节为单位）
___________________________________________________________
struct book {
	short book1[3]; 
} __attribute__ ((aligned (8)));

typedef int int32_t __attribute__ ((aligned (8)));

该声明将强制编译器确保（尽它所能）,
变量类型为(struct book) 或者 (int32_t)的变量在分配空间时采用8字节对齐方式
aligned 属性使被设置的对象占用更多的空间，相反的，使用packed 可以减小对象占用的空间。
需要注意的是，attribute 属性的效力与你的连接器也有关，如果你的连接器最大只支持16 字节
对齐，那么你此时定义32 字节对齐也是无济于事的



2 // packed 使用该属性对struct 或者union 类型进行定义，
___________________________________________________________
设定其类型的每一个变量的内存约束
就是告诉编译器取消结构在编译过程中的优化对齐（使用1字节对齐）,按照实际占用字节数进行对齐，是
GCC特有的语法。这个功能是跟操作系统没关系，跟编译器有关，gcc编译器不是紧凑模式的，我在windo
ws下，用vc的编译器也不是紧凑的，用tc的编译器就是紧凑的

在TC下：struct my{ char ch; int a;}      sizeof(int)=2;sizeof(my)=3;（紧凑模式）
在GCC下：struct my{ char ch; int a;}     sizeof(int)=4;sizeof(my)=8;（非紧凑模式）
在GCC下：struct my{ char ch; int a;}__attrubte__ ((packed)) \      
sizeof(int)=4;sizeof(my)=5


3 // at 绝对定位，可以把变量或函数绝对定位到Flash中，或者定位到RAM
___________________________________________________________
定位到flash中，一般用于固化的信息，如出厂设置的参数，上位机配置的参数，ID卡的ID号，flash标记等等
const u16 gFlashDefValue[512] __attribute__((at(0x0800F000))) = 
        {0x1111,0x1111,0x1111,0x0111,0x0111,0x0111};    //定位在flash中,其他flash补充为00
const u16 gflashdata__attribute__((at(0x0800F000))) = 0xFFFF;

定位到RAM中，一般用于数据量比较大的缓存，如串口的接收缓存，再就是某个位置的特定变量
u8 USART2_RX_BUF[USART2_REC_LEN] __attribute__ ((at(0X20001000)));//接收缓冲,最大USA


4 // section 提到section，就得说RO RI ZI了，在ARM编译器编译之后，代码被划分为不同的
段，RO Section(ReadOnly)中存放代码段和常量，RW Section(ReadWrite)中存放可读写静态
变量和全局变量，ZI Section(ZeroInit)是存放在RW段中初始化为0的变量。
// 于是本文的大体意思就清晰了，__attribute__((section("section_name")))，
其作用是将作用的函数或数据放入指定名为"section_name"对应的段中。

// 编译时为变量指定段
// 编译时为函数指定段


5 // 多个属性，组合使用
___________________________________________________________
u8 FileAddr[100] __attribute__ ((section ("FILE_RAM"), zero_init,aligned(4))); 



/*******************************************************************************
                => const关键字
*******************************************************************************/
1 // 它表示 p 可以改变， *p 不可以改变, const 修饰 *p
___________________________________________________________
    char a = 'a';
    const char *p = &a;
    char const *p = &a;

2 // 它表示 *p可以改变，但是 p不可改变, const 修饰 p
___________________________________________________________
    char a = 'w';
    char * const p = &a;

3 // 它表示 *p和p都不可以改变，const 修饰 p和*p
  // const即修饰p,又修饰*p;所以p和*p都不可改变
___________________________________________________________
    char a = 'w';
    const char * const p = &a;



/*******************************************************************************
                => volatile关键字
*******************************************************************************/
// volatile 关键字（易失的，可变的）, 此关键字主要用于处理器的寄存器编程！
*((uint32_t volatile *)(0x40032810))



