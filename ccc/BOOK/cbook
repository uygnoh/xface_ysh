/*******************************************************************************
        => C语言
*******************************************************************************/
//_____________________________________________________________
// 声明
//_____________________________________________________________
第一重含义: 告诉编译器, 这个名字已经匹配到一块内存上了。 下面的代码用到变量或
对象是在别的地方定义的。 声明可以出现多次。
第二重含义: 告诉编译器, 我这个名字我先预定了, 别的地方再也不能用它来作为变量
名或对象名。 比如你在图书馆自习室的某个座位上放了一本书,  表明这个座位已经有人
预订,别人再也不允许使用这个座位。 其实这个时候你本人并没有坐在这个座位上。 这种
声明最典型的例子就是函数参数的声明, 例如: void fun(int i, char c);
int i;          //定义变量（创建了对象并为这个对象分配内存）
extern int i;   //声明变量（没有分配内存）


//_____________________________________________________________
// 定义
//_____________________________________________________________
什么是定义: 所谓的定义就是(编译器)创建一个对象, 为这个对象分配一块内存并给它
取上一个名字, 这个名字就是我们经常所说的变量名或对象名。 但注意, 这个名字一旦
和这块内存匹配起来它们就同生共死,终生不离不弃。 并且这块内存的位置也不能被改变。 
一个变量或对象在一定的区域内(比如函数内, 全局等)只能被定义一次, 如果定义多次, 
编译器会提示你重复定义同一个变量或对象。



/*******************************************************************************
        => C语言__关键字__
*******************************************************************************/
// const
//_____________________________________________________________
const int *p;           // p 可变,   *p 指向的对象不可变
int const *p;           // p 可变,   *p 指向的对象不可变
int *const p;           // p 不可变,  *p 指向的对象可变
const int *const p;     // 指针 p 和  *p 指向的对象都不可变

const int *p;           //const 修饰*p, p 是指针, *p 是指针指向的对象,不可变
int const *p;           //const 修饰*p, p 是指针, *p 是指针指向的对象,不可变
int *const p;           //const 修饰 p, p 不可变,  p 指向的对象可变
const int *const p;     //前一个 const 修饰*p, 后一个 const 修饰 p,
                        //指针 p 和 p 指向的对象都不可变



/*******************************************************************************
        => C语言__指针__
*******************************************************************************/
int *ptr = NULL;
//_____________________________________________________________
这时候我们可以通过编译器查看 ptr 的值为 0x00000000。 这句代码的意思是: 
定义一个指针变量 ptr, 其指向的内存里面保存的是 int 类型的数据; 在定义
变量 ptr 的同时把 ptr 的值设置为 0x00000000, 而不是把 *ptr 的值设
置为 0x00000000。 这个过程叫做初始化, 是在编译的时候进行的。


int i = 10;
int *p = &i;
*p = NULL;
//_____________________________________________________________
在编译器上调试一下, 我们发现 p 指向的内存由原来的 10 变为 0 了; 而 p 本身
的值, 即内存地址并没有改变。 经过上面的分析, 相信你已经明白它们之间的区别了。 
不过这里还有一个问题需要注意, 也就是这个 NULL。 初学者往往在这里犯错误。 
注意 NULL 就是 NULL, 它被宏定义为 0:（#define NULL 0）



/*******************************************************************************
        => C语言__数组__指针
*******************************************************************************/
int a[5];
//  这（20个Byte）字节空间的名字为a
//  a[0], a[1], a[2], a[3], a[4], 为a的元素, 但并非元素的名字 
//  编译器只给这20个byte空间（整体）取了一个名字（a），并没有为其元素取名字
//  当（a）为右值时， 代表数组首元素地址， 而非数组的首地址 !!!
//_____________________________________________________________
当我们定义一个数组 a 时, 编译器根据指定的元素个数和元素的类型分配确定大小
(元素类型大小 * 元素个数)的一块内存, 并把这块内存的名字命名为 a.  名字 a 
一旦与这块内存匹配就不能被改变。    a[0], a[1], a[2], a[3], a[4] 为 
a 的元素, 但并非元素的名字。  数组的每一个元素都是没有名字的。 
sizeof(a)       //a的值为    sizeof(int)*5, 32位系统下为__20
sizeof(a[0])    //a[0]的值为 sizeof(int),   32位系统下为__4
sizeof(a[5])    //(a[5])的值在 32 位系统下为 4。 并没有出错,为什么呢? 
我们讲过 sizeof 是关键字不是函数。 函数求值是在运行的时候, 而关键字 sizeof 
求值是在编译的时候。 虽然并不存在a[5]这个元素,但是这里也并没有去真正访问 a[5],
而是仅仅根据数组元素的类型来确定其值。 所以这里使用 a[5]并不会出错


// &a[0] 和 &a 的区别
//_____________________________________________________________
这里 &a[0]和&a 到底有什么区别呢? a[0]是一个元素, a 是整个数组, 虽然&a[0]
和&a的值一样, 但其意义不一样。 前者是数组首元素的首地址, 而后者是数组的首地址
int main(void)
{
        int arr[5] = {1, 2, 3, 4, 5};
        int *ptr = (int *)(&arr+1);
        printf("%d, %d\n", *(arr+1), *(ptr-1));
}
*(arr+1) = 2
*(ptr-1) = 5


// 数组名 a 作为左值和右值的区别
//_____________________________________________________________
出现在赋值符“=”右边的就是右值,出现在赋值符“=”左边的就是左值
x = y;
左值: 在这个上下文环境中,编译器认为 x 的含义是 x 所代表的地址。 这个地址只有
编译器知道, 在编译的时候确定, 编译器在一个特定的区域保存这个地址, 我们完全不
必考虑这个地址保存在哪里
右值: 在这个上下文环境中, 编译器认为 y 的含义是 y 所代表的地址里面的内容。这
个内容是什么, 只有到运行时才知道
// C 语言引入一个术语-----“可修改的左值”。 意思就是,出现在赋值符左边的符号所
//代表的地址上的内容一定是可以被修改的。 换句话说,就是我们只能给非只读变量赋值
当 a 作为右值的时候代表的是什么意思呢? 很多书认为是数组的首地址, 其实这是非常
错误的。 a 作为右值时其意义与 &a[0]是一样, 代表的是数组首元素的首地址, 而不是
数组的首地址。 这是两码事。 但是注意, 这仅仅是代表, 并没有一个地方(这只是简单的
这么认为,其具体实现细节不作过多讨论)来存储这个地址,也就是说编译器并没有为数组 a
分配一块内存来存其地址, 这一点就与指针有很大的差别。
// a 不能作为左值!这个错误几乎每一个学生都犯过。 编译器会认为数组名作为左值代表
的意思是 a 的首元素的首地址,但是这个地址开始的一块内存是一个总体,我们只能访问数
组的某个元素而无法把数组当一个总体进行访问。所以我们可以把 a[i]当左值,而无法把 a
当左值。其实我们完全可以把 a 当一个普通的变量来看,只不过这个变量内部分为很多小块,
我们只能通过分别访问这些小块来达到访问整个变量 a 的目的。


// 数组和指针
//_____________________________________________________________
指针就是指针, 指针变量在 32 位系统下, 永远占 4 个 byte, 其值为某一个内存
的地址。 指针可以指向任何地方, 但是不是任何地方你都能通过这个指针变量访问到。
数组就是数组, 其大小与元素的类型和个数有关。 定义数组时必须指定其元素的类型和
个数。 数组可以存任何类型的数据, 但不能存函数。


char *ptr =  "ABCDEF";
//_____________________________________________________________
定义了一个指针变量 ptr, ptr 本身在栈上占 4 个 byte, ptr 里存储的是一块内存
的首地址。 这块内存在静态区, 其空间大小为 7 个 byte, 这块内存也没有名字。 对这
块内存的访问完全是匿名的访问。  比如现在需要读取字符( 'E' ), 我们有两种方式
//1),以指针的形式: *(ptr+4)。 
先取出 ptr 里存储的地址值,假设为 0x0000FF00,然后加上 4 个字符的偏移量,得到
新的地址 0x0000FF04。 然后取出 0x0000FF04 地址上的值。
//2),以下标的形式: ptr[4]
编译器总是把以下标的形式的操作解析为以指针的形式的操作。 ptr[4]这个操作会被解析成:
先取出 ptr 里存储的地址值,然后加上中括号中 4 个元素的偏移量,计算出新的地址,然后
从新的地址中取出值。也就是说以下标的形式访问在本质上与以指针的形式访问没有区别,只是
写法上不同罢了。


char arr[] = "123456";
//_____________________________________________________________
定义了一个数组 arr, arr 拥有 7 个 char 类型的元素, 其空间大小为 7。数组 a 本身
在栈上面。 对 a 的元素的访问必须先根据数组的名字 a 找到数组首元素的首地址,然后根据
偏移量找到相应的值。 这是一种典型的“具名+匿名”访问。 比如现在需要读取字符‘5’,我们有
两种方式:
//1),以指针的形式: *(a+4)
arr 这时候代表的是数组首元素的首地址, 假设为 0x0000FF00,然后加上 4 个字符的偏
移量,得到新的地址 0x0000FF04。 然后取出 0x0000FF04 地址上的值。
//2),以下标的形式:a[4]
编译器总是把以下标的形式的操作解析为以指针的形式的操作。 arr[4]这个操作会被解析成:
arr 作为数组首元素的首地址,然后加上中括号中 4 个元素的偏移量,计算出新的地址,然后
从新的地址中取出值。


//指针数组 数组指针
//_____________________________________________________________
由上面的分析,我们可以看到,指针和数组根本就是两个完全不一样的东西。只是它们
都可以“以指针形式”或“以下标形式”进行访问。一个是完全的匿名访问,一个是典型
的具名+匿名访问。一定要注意的是这个“以 XXX 的形式的访问”这种表达方式。
int main(void)
{
//  &a 是整个数组的首地址, a是数组首元素的首地址, 其值相同但意义不同。
//  毫无疑问, ptr0 和 ptr1 都是数组指针, 指向的是整个数组。
//  在 C 语言里, 赋值符号 “=” 号两边的数据类型必须是相同的, 如果不同
//  需要显示或隐式的类型转换。
//  ptr0的类型是指向整个数组的指针,  ptr1的数据类型是指向单个字符的指针
        char arr[5] = {'A', 'B', 'C', 'D');
        char (*ptr0)[5] = &arr; //ptr0 这个定义的 “=” 号两边的数据类型完全一致
        char (*ptr1)[5] = arr;  //而 ptr1 这个定义的“=”号两边的数据类型就不一致了
        return (0);
}


// 多维数组与多级指针
//_____________________________________________________________
char a[3][4];
char a[i][j];
以数组下标的方式来访问其中的某个元素: a[i][j]。  编译器总是将二维数组看成是一个
一维数组, 而一维数组的每一个元素又都是一个数组。 a[3]这个一维数组的三个元素分别为:
a[0],a[1],a[2]。 每个元素的大小为 sizeof ( a[0]) , 即 sizof(char)*4。
//由此可以计算出 a[0],a[1],a[2]三个元素的首地址分别为 
&a[0], &a[0] + 1*sizof(char)*4, &a[0] + 2*sizof(char)*4
亦即 a[i] 的首地址为 &a[0] + i*sizof(char)*4
//这时候再考虑 a[i]里面的内容。 
//就本例而言, a[i]内有 4个 char 类型的元素, 其每个元素的首地址分别为 
&a[i], &a[i] + 1*sizeof(char), &a[i] + 2*sizeof(char), &a[i] + 3*sizeof(char),
即 a[i][j] 的首地址为 &a[i] + j*sizof(char)。 再把&a[i]的值用 a 表示,得到 a[i][j]元素的
首地址为: a + i*sizof(char)*4+ j*sizof(char)。 同样,可以换算成以指针的形式表示:*(*(a+i)+j)。

