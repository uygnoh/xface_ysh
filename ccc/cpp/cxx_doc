/*******************************************************************************
                => C++ 内存的分区模型（分为4个区域）
*******************************************************************************/
1 //代码区：存放函数体的二进制代码，由操作系统进行管理的
___________________________________________________________


2 //全局区：存放全局变量和静态变量以及常量
___________________________________________________________


3 //栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
___________________________________________________________


4 //堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
___________________________________________________________



/*******************************************************************************
                => C++ 引用
*******************************************************************************/
___________________________________________________________
引用： 给变量起别名
语法： 数据类型 &别名 = 原名
___________________________________________________________
#include <iostream>
using namespace std;
int main(void)
{
        int a  = 10;
        //创建引用（引用必须初始化，引用在初始化后，不可以改变）
        int &b = a;  
        cout << "Hello, world!" << endl;
        cout << "a = " << a << endl;
        cout << "b = " << a << endl;
        return 0;
}


//3种函数传递方式
___________________________________________________________
#include <iostream>
using namespace std;
//01-值传递
void mySwap01(int a, int b) 
{
        int tmp = a;
        a = b;
        b = tmp;
        cout << "Swap01_值传递" << endl;
        cout << "Swap01_a = " << a << endl;
        cout << "Swap01_b = " << b << endl;
}
//02-地址传递
void mySwap02(int *a, int *b) 
{
        int tmp = *a;
        *a = *b;
        *b = tmp;
        cout << "Swap02_地址传递" << endl;
        cout << "Swap02_*a = " << *a << endl;
        cout << "Swap02_*b = " << *b << endl;
}
//03-引用， 别名和原名可以是一样的
void mySwap03(int &a, int &b) 
{
        int tmp = a;
        a = b;
        b = tmp;
        cout << "Swap03_引用传递" << endl;
        cout << "Swap03_&a = " << a << endl;
        cout << "Swap03_&b = " << b << endl;
}
int main(void)
{
        int a = 10;
        int b = 20;
        //mySwap01(a, b);       //值传递（形参不会修饰实参）
        //mySwap02(&a, &b);     //地址传递（形参会修饰实参）
        mySwap03(a, b);         //引用传递（形参会修饰实参）
        cout << "BASE_A = " << a << endl;
        cout << "BASE_B = " << b << endl;
        return 0;
}



//函数的调用可以作为左值
___________________________________________________________
#include <iostream>
using namespace std;
//引用做函数的返回值
//1 不要返回局部变量的引用, 局部变量存放在栈区
//2 函数的调用可以作为左值
int& test01()
{
        //静态变量，存放在全局区，全局区的数据在程序结束后，系统释放
        static int a = 10;
        return a;
}
int main()
{
        int &ref = test01();
        cout << "ref = " << ref <<endl;
        test01() = 100;                 //a(原名) = 1000; ref(别名) = 1000
        cout << "ref = " << ref <<endl;
}



//引用的本质, 就是一个指针的常量
//引用一旦初始化之后， 不可以改变
___________________________________________________________
using namespace std;
//发现是引用， 转换为 (int * const ref = &a;)
void func(int& ref) {
        ref = 100; //ref是引用，转换为 (*ref = 100;)
}
int main() {
        int a = 10;
        
        //自动转换为 (int * const ref = &a;)
        //指针常量是指针指向不可改，也说明为什么引用不可更改
        int& ref = a;
        //内部发现ref是引用，自动帮我们转换为 (*ref = 20)
        ref = 20; 
        
        cout << "a:" << a << endl;
        cout << "ref:" << ref <<endl;
        func(a);
        return 0;
}



//常量引用
___________________________________________________________
#include <iostream>
using namespace std;
//常量引用
//使用场景：用来修饰形参，防止误操作
void showValue(const int& val) {
        //val = 10;//val值不可修改
        cout << "val = " << val << endl;
}
int main(void) {
        //加上const之后，编译器将代码修改为（int temp = 10; const int& ref = temp;）
        //引用必须引一块合法的内存空间， 此时原名找不到了， 只能使用别名
        //加入const之后，变为只读，不可以修改
        const int & ref = 10;
        
        int a = 100;
        showValue(a);
}



//函数的默认参数
___________________________________________________________
注意事项：
1 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值。
2 如果函数的声明有默认参数，那么函数的实现就不能有默认参数
___________________________________________________________
#include <iostream>
using namespace std;

//如果我们自己传入数据，就用自己的数据，如果没有，那么就用默认值
int func(int a, int b = 20, int c = 30) {
        return a + b + c;
}
int main(void) {
        cout << func(10) << endl;
        return 0;
}



/*******************************************************************************
        => C++ 函数重载
*******************************************************************************/
|                     //函数重载满足条件
|_________________________________________________________|
|       1 同一个作用域下                                     |
|       2 函数名相同                                        |
|       3 函数(参数类型不同) 或者 (个数不同) 或者 (顺序不同)      |
|       //注意：函数的返回值不可以作为函数重载的条件！！           |
|_________________________________________________________|
#include <iostream>
using namespace std;

void func() {
        cout << "func 的调用" << endl;
}

void func(int a) {
        cout << "func(int a) 的调用" << endl;
}

void func(double a) {
        cout << "func(double a) 的调用" << endl;
}
int main(void) {
        func();
        func(12);
        func(3.14);
        return 0;
}



//函数重载注意
1. 引用作为函数重载条件
___________________________________________________________
void fun(int &a) {
        cout << "func(int &a)调用" <<endl;
}

int main(void) {
        int a = 10;
        func(a);        //调用“void fun(int &a)”
        func(10);       //调用“void fun(const int &a)”
}

void fun(const int &a) {
        cout << "func(const int &a)调用" <<endl;
}



/*******************************************************************************
        => 类和对象
*******************************************************************************/
//设计一个圆类，求它的周长， 公式： 2 * PI * R
#include <iostream>
using namespace std;

const double PI = 3.14;

//class代表设计一个类，类后面紧跟着就是类名称
class Circle {
        //访问权限（公共权限）
        public:
                //属性（设置圆的半径）
                int R;
                
                //行为（它是一个函数）
                double calculateZC() {
                        return 2 * PI * R;
                }
        
};

int main(void) {
        //通过圆类创建具体的圆（对象）
        Circle c1;
        //给圆对象的属性进行具体的赋值操作
        c1.R = 10;
        cout << "圆的周长为： " << c1.calculateZC() << endl;
        return 0;
}



/*******************************************************************************
        => 类的权限
*******************************************************************************/
                       //三种访问权限//
___________________________________________________________
1. public       (公共权限)//类可以访问， 类外可以访问
2. protected    (保护权限)//类可以访问， 类外不可以访问（儿子可以访问父亲中的保护的内容）
3. private      (私有权限)//类可以访问， 类外不可以访问（儿子不可以访问父亲中的私人内容）
___________________________________________________________
class Person {
        public:         //公共权限（姓名）
                string name;
        protected:      //保护权限（汽车）
                string car;
        private:        //私有权限（密码）
                int passwd;
        public:
                void fun() {
                        name   = "张三";
                        car    = "奔驰";
                        passwd = "123456";
                }
};



/*******************************************************************************
        => struct 和 class 的区别
*******************************************************************************/
class C1 {
        int i;  //默认是私有权限
};
struct C2 {
        int j;  //默认是公共权限
};



/*******************************************************************************
        => this 指针
*******************************************************************************/
___________________________________________________________
this指针指向被调用的成员函数所属的对象。 
this指针是隐含每一个非静态成员函数的一种指针，
this指针不需要定义，直接使用即可。 （谁调用它，它就指向谁）

//this指针用途
1 当形参和成员变量同名时，可以使用this指针来区分（解决名称冲突）
2 在类的非静态成员函数中返回对象本身，可以使用（return *this）
___________________________________________________________
class Person {
        public:
                Person(int age) {
                        //this指针指向的是： 被调用的成员函数所属的对象
                        this->age = age;
                }
                
                Person& PersonAddAge(Person &p) {
                        this->age += p.age;
                        
                        //this指向p2的指针， 而*this指向的就是p2这个对象的本体
                        return *this;
                }
                
                int age;
};

//解决名称冲突
void test01() {
        Person p1(18);
        cout << "p1的年龄为： " << p1.age << endl;
}

//返回对象本身用（*this）
void test02() {
        Person p1(10);
        Person p2(10);
        //链式编程思想
        p2.PwrsonAddAge(p1).PersonAddAge(p1).PersonAddAge(1);
        cout << "p2的年龄为： " << p2.age << endl;
}
