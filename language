/*******************************************************************************
        => C语言
*******************************************************************************/
//_____________________________________________________________
// 定义
//_____________________________________________________________
什么是定义: 所谓的定义就是(编译器)创建一个对象, 为这个对象分配一块内存并给它
取上一个名字, 这个名字就是我们经常所说的变量名或对象名。 但注意, 这个名字一旦
和这块内存匹配起来它们就同生共死,终生不离不弃。 并且这块内存的位置也不能被改变。 
一个变量或对象在一定的区域内(比如函数内, 全局等)只能被定义一次, 如果定义多次, 
编译器会提示你重复定义同一个变量或对象。
//_____________________________________________________________
// 声明
//_____________________________________________________________
第一重含义: 告诉编译器, 这个名字已经匹配到一块内存上了。 下面的代码用到变量或
对象是在别的地方定义的。 声明可以出现多次。
第二重含义: 告诉编译器, 我这个名字我先预定了, 别的地方再也不能用它来作为变量
名或对象名。 比如你在图书馆自习室的某个座位上放了一本书,  表明这个座位已经有人
预订,别人再也不允许使用这个座位。 其实这个时候你本人并没有坐在这个座位上。 这种
声明最典型的例子就是函数参数的声明, 例如: void fun(int i, char c);
int i;          //定义变量（创建了对象并为这个对象分配内存）
extern int i;   //声明变量（没有分配内存）



/*******************************************************************************
        => C语言__关键字__
*******************************************************************************/
//_____________________________________________________________
// auto
//_____________________________________________________________
auto: 它很宽恒大量的,你就当它不存在吧。 编译器在默认的缺省情况下, 所有变量
都是 auto 的。


//_____________________________________________________________
// register
//_____________________________________________________________
register: 这个关键字请求编译器尽可能的将变量存在 CPU 内部寄存器中而不是通
过内存寻址访问以提高效率。 注意是尽可能,不是绝对。 你想想,一个 CPU 的寄存器也
就那么几个或几十个,你要是定义了很多很多 register 变量,它累死也可能不能全部
把这些变量放入寄存器吧, 轮也可能轮不到你。
虽然寄存器的速度非常快, 但是使用 register 修饰符也有些限制的: register 
变量必须是能被 CPU 寄存器所接受的类型。 意味着 register 变量必须是一个单个
的值, 并且其长度应小于或等于整型的长度。 而且 register 变量可能不存放在内存
中, 所以不能用取址运算符“&”来获取 register 变量的地址。


//_____________________________________________________________
// static
//_____________________________________________________________
第一个作用: 修饰变量。 //变量又分为局部和全局变量, 但它们都存在内存的静态区。
静态全局变量, 作用域仅限于变量被定义的文件中, 其他文件即使用 extern 声明也
没法使用他。 准确地说作用域是从定义之处开始, 到文件结尾处结束, 在定义之处前面
的那些代码行也不能使用它
静态局部变量, 在函数体里面定义的, 就只能在这个函数里用了, 同一个文档中的其他
函数也用不了。 由于被 static 修饰的变量总是存在内存的静态区, 所以即使这个函
数运行结束, 这个静态变量的值还是不会被销毁, 函数下次使用时仍然能用到这个值。
第二个作用: 修饰函数。 函数前加 static 使得函数成为静态函数。 但此处“static”
的含义不是指存储方式, 而是指对函数的作用域仅局限于本文件(所以又称内部函数)。 
使用内部函数的好处是: 不同的人编写不同的函数时, 不用担心自己定义的函数, 是否
会与其它文件中的函数同名。



//_____________________________________________________________
// char short int long float double
//_____________________________________________________________



//_____________________________________________________________
// sizeof signed unsigned
//_____________________________________________________________


//_____________________________________________________________
// const
//_____________________________________________________________
const int *p;           // p 可变, p 指向的对象不可变
int const *p;           // p 可变, p 指向的对象不可变
int *const p;           // p 不可变,p 指向的对象可变
const int *const p;     // 指针 p 和 p 指向的对象都不可变

const int *p;           //const 修饰*p, p 是指针, *p 是指针指向的对象,不可变
int const *p;           //const 修饰*p, p 是指针, *p 是指针指向的对象,不可变
int *const p;           //const 修饰 p, p 不可变,  p 指向的对象可变
const int *const p;     //前一个 const 修饰*p, 后一个 const 修饰 p,
                        //指针 p 和 p 指向的对象都不可变


//_____________________________________________________________
// typedef
//_____________________________________________________________
typedef  的真正意思是给一个已经存在的数据类型(注意:是类型不是变量)取一个别
名, 而非定义一个新的数据类型




/*******************************************************************************
        => C语言__指针__
*******************************************************************************/
int *p = NULL;
这时候我们可以通过编译器查看 p 的值为 0x00000000。 这句代码的意思是: 定义一个指针变量 p, 其
指向的内存里面保存的是 int 类型的数据;在定义变量 p 的同时把 p 的值设置为 0x00000000, 而不
是把*p 的值设置为 0x00000000。 这个过程叫做初始化, 是在编译的时候进行的。


int i = 10;
int *p = &i;
*p = NULL;
在编译器上调试一下, 我们发现 p 指向的内存由原来的 10 变为 0 了; 而 p 本身的值, 即内存地址并
没有改变。 经过上面的分析, 相信你已经明白它们之间的区别了。 不过这里还有一个问题需要注意, 也就是
这个 NULL。初学者往往在这里犯错误。 注意 NULL 就是 NULL, 它被宏定义为 0:（#define NULL 0）



/*******************************************************************************
        => C语言__数组__
*******************************************************************************/
int a[5];
//这20个（Byte）字节空间的名字为a， a[0], a[1], a[2], a[3], a[4], 为a的元素。
//但并非元素的名字， 编译器只给这20个byte空间（整体）取了一个名字（a），并没有为其元素取名字。
//当（a）为右值时， 代表数组首元素地址， 而非数组的首地址！
当我们定义一个数组 a 时,编译器根据指定的元素个数和元素的类型分配确定大小(元素类型大小*元素个数)
的一块内存,并把这块内存的名字命名为 a。 名字 a 一旦与这块内存匹配就不能被改变。 a[0], a[1]等为 
a 的元素, 但并非元素的名字。 数组的每一个元素都是没有名字的
sizeof(a)       //a的值为    sizeof(int)*5, 32位系统下为__20
sizeof(a[0])    //a[0]的值为 sizeof(int),   32位系统下为__4
sizeof(a[5])    //(a[5])的值在 32 位系统下为 4。 并没有出错,为什么呢? 
                我们讲过 sizeof 是关键字不是函数。 函数求值是在运行的时候, 而关键字 sizeof 
                求值是在编译的时候。 虽然并不存在a[5]这个元素,但是这里也并没有去真正访问 a[5],
                而是仅仅根据数组元素的类型来确定其值。 所以这里使用 a[5]并不会出错
//_____________________________________________________________
// &a[0] 和 &a 的区别
//_____________________________________________________________
这里 &a[0]和&a 到底有什么区别呢? a[0]是一个元素, a 是整个数组, 虽然&a[0]
和&a的值一样, 但其意义不一样。 前者是数组首元素的首地址, 而后者是数组的首地址
int main(void)
{
        int arr[5] = {1, 2, 3, 4, 5};
        int *ptr = (int *)(&arr+1);
        printf("%d, %d\n", *(arr+1), *(ptr-1));
}
对指针进行加 1 操作,得到的是下一个元素的地址,而不是原有地址值直接加 1。 所以,
一个类型为 T 的指针的移动,以 sizeof(T) 为移动单位。 因此,对上题来说,arr 是一
个一维数组,数组中有 5 个元素; ptr 是一个 int 型的指针。  
&arr + 1: 取数组 arr 的首地址, 该地址的值加上 sizeof(arr) 的值, 
即 &arr + 5*sizeof(int), 也就是下一个数组的首地址, 显然当前指针已经越过了数组的界限。
// (int *)(&arr+1): 则是把上一步计算出来的地址, 强制转换为 int * 类型,赋值给 ptr
*(arr+1): arr, &arr 的值是一样的, 但意思不一样,arr 是数组首元素的首地址,也就是 arr[0]的
首地址,&arr 是数组的首地址, arr+1 是数组下一元素的首地址, 即 arr[1]的首地址, 所以输出 2
                &arr+1 是下一个数组的首地址（数组越过界限了）
// *(ptr-1): 因为 ptr 是指向 a[5],并且 ptr 是 int * 类型,所以 *(ptr-1) 是指向 a[4] ,
// 输出 5。




//_____________________________________________________________
// 数组名 a 作为左值和右值的区别
//_____________________________________________________________
出现在赋值符“=”右边的就是右值,出现在赋值符“=”左边的就是左值
x = y;
左值: 在这个上下文环境中,编译器认为 x 的含义是 x 所代表的地址。 这个地址只有
编译器知道, 在编译的时候确定, 编译器在一个特定的区域保存这个地址, 我们完全不
必考虑这个地址保存在哪里
右值: 在这个上下文环境中, 编译器认为 y 的含义是 y 所代表的地址里面的内容。这
个内容是什么, 只有到运行时才知道
// C 语言引入一个术语-----“可修改的左值”。 意思就是,出现在赋值符左边的符号所
//代表的地址上的内容一定是可以被修改的。 换句话说,就是我们只能给非只读变量赋值
当 a 作为右值的时候代表的是什么意思呢? 很多书认为是数组的首地址, 其实这是非常
错误的。 a 作为右值时其意义与 &a[0]是一样, 代表的是数组首元素的首地址, 而不是
数组的首地址。 这是两码事。 但是注意, 这仅仅是代表, 并没有一个地方(这只是简单的
这么认为,其具体实现细节不作过多讨论)来存储这个地址,也就是说编译器并没有为数组 a
分配一块内存来存其地址, 这一点就与指针有很大的差别。
// a 不能作为左值!这个错误几乎每一个学生都犯过。 编译器会认为数组名作为左值代表
的意思是 a 的首元素的首地址,但是这个地址开始的一块内存是一个总体,我们只能访问数
组的某个元素而无法把数组当一个总体进行访问。所以我们可以把 a[i]当左值,而无法把 a
当左值。其实我们完全可以把 a 当一个普通的变量来看,只不过这个变量内部分为很多小块,
我们只能通过分别访问这些小块来达到访问整个变量 a 的目的。



//_____________________________________________________________
// 数组和指针
//_____________________________________________________________
指针就是指针, 指针变量在 32 位系统下, 永远占 4 个 byte, 其值为某一个内存的
地址。 指针可以指向任何地方, 但是不是任何地方你都能通过这个指针变量访问到。
数组就是数组, 其大小与元素的类型和个数有关。 定义数组时必须指定其元素的类型和个
数。 数组可以存任何类型的数据, 但不能存函数。


//_____________________________________________________________
char *ptr =  "ABCDEF";
//_____________________________________________________________
定义了一个指针变量 ptr, ptr 本身在栈上占 4 个 byte, ptr 里存储的是一块内存
的首地址。 这块内存在静态区, 其空间大小为 7 个 byte, 这块内存也没有名字。 对这
块内存的访问完全是匿名的访问。  比如现在需要读取字符( 'E' ), 我们有两种方式
//1),以指针的形式: *(ptr+4)。 
先取出 ptr 里存储的地址值,假设为 0x0000FF00,然后加上 4 个字符的偏移量,得到
新的地址 0x0000FF04。 然后取出 0x0000FF04 地址上的值。
//2),以下标的形式: ptr[4]
编译器总是把以下标的形式的操作解析为以指针的形式的操作。 ptr[4]这个操作会被解析成:
先取出 ptr 里存储的地址值,然后加上中括号中 4 个元素的偏移量,计算出新的地址,然后
从新的地址中取出值。也就是说以下标的形式访问在本质上与以指针的形式访问没有区别,只是
写法上不同罢了。


//_____________________________________________________________
char arr[] = "123456";
//_____________________________________________________________
定义了一个数组 arr, arr 拥有 7 个 char 类型的元素, 其空间大小为 7。数组 a 本身
在栈上面。 对 a 的元素的访问必须先根据数组的名字 a 找到数组首元素的首地址,然后根据
偏移量找到相应的值。 这是一种典型的“具名+匿名”访问。 比如现在需要读取字符‘5’,我们有
两种方式:
//1),以指针的形式: *(a+4)
arr 这时候代表的是数组首元素的首地址, 假设为 0x0000FF00,然后加上 4 个字符的偏
移量,得到新的地址 0x0000FF04。 然后取出 0x0000FF04 地址上的值。
//2),以下标的形式:a[4]
编译器总是把以下标的形式的操作解析为以指针的形式的操作。 arr[4]这个操作会被解析成:
arr 作为数组首元素的首地址,然后加上中括号中 4 个元素的偏移量,计算出新的地址,然后
从新的地址中取出值。


//_____________________________________________________________
//指针数组 数组指针
//_____________________________________________________________
由上面的分析,我们可以看到,指针和数组根本就是两个完全不一样的东西。只是它们
都可以“以指针形式”或“以下标形式”进行访问。一个是完全的匿名访问,一个是典型
的具名+匿名访问。一定要注意的是这个“以 XXX 的形式的访问”这种表达方式。

int main(void)
{
        char arr[5] = {'A', 'B', 'C', 'D');
        char (*ptr0)[5] = &arr;
        char (*ptr1)[5] = arr;
        return (0);
}
毫无疑问, ptr0 和 ptr1 都是数组指针, 指向的是整个数组。
// &a 是整个数组的首地址, a是数组首元素的首地址, 其值相同但意义不同。
在 C 语言里, 赋值符号 “=” 号两边的数据类型必须是相同的, 如果不同需要显示或隐式的类型转换。
ptr0 这个定义的 “=” 号两边的数据类型完全一致, 而 ptr1 这个定义的“=”号两边的数据类型就不一致了。
ptr0的类型是指向整个数组的指针,  ptr1的数据类型是指向单个字符的指针


//_____________________________________________________________
// 多维数组与多级指针
//_____________________________________________________________
char a[3][4];
char a[i][j];
以数组下标的方式来访问其中的某个元素: a[i][j]。  编译器总是将二维数组看成是一个
一维数组, 而一维数组的每一个元素又都是一个数组。 a[3]这个一维数组的三个元素分别为:
a[0],a[1],a[2]。 每个元素的大小为 sizeof ( a[0]) , 即 sizof(char)*4。
//由此可以计算出 a[0],a[1],a[2]三个元素的首地址分别为 
&a[0], &a[0] + 1*sizof(char)*4, &a[0] + 2*sizof(char)*4
亦即 a[i] 的首地址为 &a[0] + i*sizof(char)*4
//这时候再考虑 a[i]里面的内容。 
//就本例而言, a[i]内有 4个 char 类型的元素, 其每个元素的首地址分别为 
&a[i], &a[i] + 1*sizeof(char), &a[i] + 2*sizeof(char), &a[i] + 3*sizeof(char),
即 a[i][j] 的首地址为 &a[i] + j*sizof(char)。 再把&a[i]的值用 a 表示,得到 a[i][j]元素的
首地址为: a + i*sizof(char)*4+ j*sizof(char)。 同样,可以换算成以指针的形式表示:*(*(a+i)+j)。

