/*******************************************************************************
        => GPIO
*******************************************************************************/
GPIOx_MODER     //一个端口工作模式寄存器
GPIOx_OTYPER    //一个端口输出类型寄存器
GPIOx_OSPEEDR   //一个端口输出速度寄存器
GPIOx_PUPDR     //一个端口上拉下拉寄存器
GPIOx_IDR       //一个端口输入数据寄存器
GPIOx_ODR       //一个端口输出数据寄存器
GPIOx_BSRR      //一个端口置位复位寄存器
GPIOx_LCKR      //一个端口配置锁存寄存器
GPIOx_AFRL      //两个端口复用功能寄存器
GPIOx_AFRH



/*******************************************************************************
        => GPIO（端口模式寄存器）
        => GPIO port mode register
*******************************************************************************/
MODER_XY[1:0]   //（这些位通过软件写入, 用于配置 I/O 方向模式）
|_________________________________________________________________.
| 0  1  2  3  4  5   6   7   8   9   10  11  12  12  14  15    *2 |
|_________________________________________________________________|
| 0  2  4  6  8  10  12  14  16  18  20  22  24  26  28  30       |
|_________________________________________________________________|
GPIOA->MODER &= ~(3 << PIN*2);  //（首先清除要设置的相应位）
GPIOA->MODER |=  (0 << PIN*2);  //通用输入模式__00__(复位状态)
GPIOA->MODER |=  (1 << PIN*2);  //通用输出模式__01__
GPIOA->MODER |=  (2 << PIN*2);  //复用功能模式__10__
GPIOA->MODER |=  (3 << PIN*2);  //模拟输入模式__11__
//_____________________________________________________________
// prot (GPIOA, GPIOB, GPIOC ...)
// mode ->
//      0__输入__INPUT
//      1__输出__OUTPUT
//      2__复用__ALTERNATE
//      3__模拟__ANALOG
// pin  (0..15)
//      LED_00 = 1
//_____________________________________________________________
#define INPUT           0       //输入模式
#define OUTPUT          1       //输出模式
#define ALTERNATE       2       //复用功能
#define ANALOG          3       //模拟输入
#define __gpio_port_mode(port, mode, pin) {             \
        (port)->MODER &= ~(3    << pin*2);              \
        (port)->MODER |=  (mode << pin*2);              \
}

        __gpio_port_mode(GPIOA, OUTPUT, LED_00);



/*******************************************************************************
        => GPIO（端口输出类型寄存器）
        => GPIO port output type register
*******************************************************************************/
GPIOA->OTYPER &= ~(1 << PIN);   //（首先清除要设置的相应位）
GPIOA->OTYPER |=  (0 << PIN);   //输出推挽__0__(复位状态)
GPIOA->OTYPER |=  (1 << PIN);   //输出开漏__1__


//_____________________________________________________________
// prot (GPIOA, GPIOB, GPIOC ...)
// type ->
//      0__输出推挽__OUTPUT_PUSHPULL
//      1__输出开漏__OUTPUT_OPENDRAIN
// pin  (0..15)
//_____________________________________________________________
#define OUTPUT_PUSHPULL         0
#define OUTPUT_OPENDRAIN        1
#define __gpio_port_output_type(port, type, pin) {      \
        (port)->OTYPER &= ~(1    << pin*2);             \
        (port)->OTYPER |=  (type << pin*2);             \
}
        __gpio_port_output_type(GPIOA, OUTPUT_PUSHPULL, 11)



/*******************************************************************************
        => GPIO（端口输出速度寄存器）
        => GPIO port output speed register
*******************************************************************************/
GPIOA->OSPEEDR &= ~(3 << PIN*2);//（首先清除要设置的相应位）
GPIOA->OSPEEDR |=  (0 << PIN*2);//低速__2MHz__
GPIOA->OSPEEDR |=  (1 << PIN*2);//中速__25MHz__
GPIOA->OSPEEDR |=  (2 << PIN*2);//快速__50MHz__
GPIOA->OSPEEDR |=  (3 << PIN*2);//高速__100MHz__

#define LOW             0       //00_2MHz  (低速)
#define MEDIUM          1       //01_25MHz (中速)
#define FAST            2       //10_50MHZ (快速)
#define HIGH            3       //11_80MHz (高速_15pF时)
                                //11_100MHz(高速_30pF时)
//_____________________________________________________________
// prot  (GPIOA, GPIOB, GPIOC ...)
// speed ->
//       0__低速__LOW
//       1__中速__MEDIUM
//       2__快速__FAST
//       3__高速__HIGH
// pin   (0..15)
//_____________________________________________________________
#define __gpio_port_output_speed(port, speed, pin) {    \
        (port)->OSPEEDR &= ~(3     << PIN*2);           \
        (port)->OSPEEDR |= ~(speed << PIN*2);           \
}
        __gpio_port_output_speed(GPIOC, MEDIUM, 13);


/*******************************************************************************
        => GPIO（端口上拉/下拉寄存器）
        => GPIO port pull-up/pull-down register
*******************************************************************************/
        00      //无上拉或下拉
        01      //上拉
        10      //下拉
        11      //保留
//_____________________________________________________________
PIN             = 0..15         //引脚编号
//_____________________________________________________________
GPIOA->PUPDR &= ~(3 << PIN*2);  //（首先清除要设置的相应位）
GPIOA->PUPDR |=  (0 << PIN*2);  //无上拉或下拉
GPIOA->PUPDR |=  (1 << PIN*2);  //上拉
GPIOA->PUPDR |=  (2 << PIN*2);  //下拉
GPIOA->PUPDR |=  (3 << PIN*2);  //保留



/*******************************************************************************
        => GPIO（端口输入数据寄存器）
        => GPIO port input data register
*******************************************************************************/
//_____________________________________________________________
PIN             = 0..15         //引脚编号
//_____________________________________________________________
idr = GPIOA->IDR;       //读取IDR寄存器中的数据，存放到（idr）

__gpio_input_data(port, pin) {
        (port)->IDR;
}



/*******************************************************************************
        => GPIO（端口输出数据寄存器）
        => GPIO port output data register
*******************************************************************************/
GPIOA->ODR &= ~(1 << PIN);  //（首先清除要设置的相应位）
GPIOA->ODR |=  (0 << PIN);  //输出为（0）
GPIOA->ODR |=  (1 << PIN);  //输出为（1）
//_____________________________________________________________
// prot  (GPIOA, GPIOB, GPIOC ...)
// data  (0写“0”， 1写“1”)
// pin   (0..15)
//_____________________________________________________________
#define __gpio_output_data(port, data, pin) {   \
        (port)->ODR &= ~(1 << PIN);             \
        (port)->ODR |=  (data << PIN);          \
}



/*******************************************************************************
        => GPIO（端口置位/复位寄存器）
        => GPIO port set/reset register
*******************************************************************************/
//_____________________________________________________________
PIN             = 0..15         //引脚编号
//_____________________________________________________________
//高16位（写“1”，对相应的 ODRx 位进行复位）
//低16位（写“1”，对相应的 ODRx 位进行置位）
//_____________________________________________________________
GPIOA->BSRR &= ~(1 << PIN+16);  //（首先清除要设置的相应位）
GPIOA->BSRR |=  (1 << PIN+16);  //复位__高16位__
GPIOA->BSRR &= ~(1 << PIN   );  //（首先清除要设置的相应位）
GPIOA->BSRR |=  (1 << PIN   );  //置位__低16位__


#define __gpio_port_set(port, pin) {            \
        (port)->BSRR |=  (1 << PIN+16);         \
}
#define __gpio_port_reset(port, pin) {          \
        (port)->BSRR |=  (1 << PIN);            \
}
        __gpio_port_set(port, pin);
        __gpio_port_reset(port, pin);




/*******************************************************************************
        => GPIO（端口配置锁定寄存器）
        => GPIO port configuration lock register
*******************************************************************************/
//锁定键写序列:
        WR LCKR[16] = ‘1’ + LCKR[15:0]
        WR LCKR[16] = ‘0’ + LCKR[15:0]
        WR LCKR[16] = ‘1’ + LCKR[15:0]
        RD LCKR
        RD LCKR[16] = ‘1’(此读操作为可选操作,但它可确认锁定已激活)
//注意: 在锁定键写序列期间,不能更改 LCK[15:0] 的值
        1 锁定序列中的任何错误都将中止锁定操作。
        2 在任一端口位上的第一个锁定序列之后,对 LCKK 位的任何读访问都
          将返回“ 1 ”, 直到下一次 CPU 复位为止。
//位 15:0 LCKy:端口 x 锁定位 y (Port x lock bit y) (y= 0..15)
//这些位都是读 /写位,但只能在 LCKK 位等于“0”时执行写操作。
        0:端口配置未锁定
        1:端口配置已锁定
void gpio_pin_lock(port, pin)
{
        uint32_t porta;
        uint32_t retval;
        GPIOAA->LCKR |= (uint32_t)(0x00010000);         //写（1）
        GPIOAA->LCKR &= (uint32_t)(0xFFFEFFFF);         //写（0）
        GPIOAA->LCKR |= (uint32_t)(0x00010000);         //写（1）
        porta         = GPIOAA->LCKR;                   //读
        retval        = porta & (uint32_t)(0x00010000); //读取第（16）位
        if (retval != 0) {
                printf("端口已锁定");
        }    
}



/*******************************************************************************
        => GPIO（复用功能低位寄存器）
        => GPIO alternate function low register
*******************************************************************************/
|_________________________________________________________________.
| 0     1       2       3       4       5       6       7      *4 |
|_________________________________________________________________|
| 0     4       8       12      16      20      24      28        |
|_________________________________________________________________|
31:0    //AF0 ~ AF7
        //AFRLy:端口 x 位 y 的复用功能选择 
        (Alternate function selection for port x bit y) (y = 0..7)
        这些位通过软件写入,用于配置复用功能 I/O。
//AFLOW  = (0 ~ 7)
GPIOA->AFRL &= ~(15  << AFLOW*4);  //（首先清除要设置的相应位）
GPIOA->AFRL |=  (AFX << AFLOW*4);  //设置AFX=（0~15）



/*******************************************************************************
        => GPIO（复用功能高位寄存器）
        => GPIO alternate function hight register
*******************************************************************************/
//AFHIGH  = (8 ~ 15)
GPIOA->AFRH &= ~(15  << AFHIGH*4);  //（首先清除要设置的相应位）
GPIOA->AFRH |=  (AFX << AFHIGH*4);  //设置AFX=（0~15）
        
        
        
        
