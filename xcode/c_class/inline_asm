/*******************************************************************************
                => http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html
*******************************************************************************/
1 // 约束
___________________________________________________________
r           //Register
m           //Memory operand constraint(m)
Q
I
memory



2 // 约束修饰符
___________________________________________________________
"="     //表示此操作数只对该指令写；前一个值将被丢弃并替换为输出数据。
"&"     //表示此操作数是earlyclobber操作数，在使用输入操作数完成指
        令之前对其进行修改。因此，此操作数不能位于用作输入操作数或
        任何内存地址一部分的寄存器中。如果输入操作数在写入早期结果
        之前仅用作输入，则可以将其绑定到EarlyClober操作数。



+------------------------------+------------------------------------+
|       Intel Code             |      AT&T Code                     |
+------------------------------+------------------------------------+
| mov     eax,1                |  movl    $1,%eax                   |   
| mov     ebx,0ffh             |  movl    $0xff,%ebx                |   
| int     80h                  |  int     $0x80                     |   
| mov     ebx, eax             |  movl    %eax, %ebx                |
| mov     eax,[ecx]            |  movl    (%ecx),%eax               |
| mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | 
| mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |
| add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |
| lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |
| sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |
+------------------------------+------------------------------------+

        
        
/*******************************************************************************
                => 基本内联
*******************************************************************************/
__asm__ ("movl %eax, %ebx\n\t"
        "movl $56, %esi\n\t"
        "movl %ecx, $label(%edx,%ebx,$4)\n\t"
        "movb %ah, (%ebx)");
        
        
        
/*******************************************************************************
                => 扩展内联
*******************************************************************************/           
asm ( assembler template 
           : output operands                  /* optional */
           : input operands                   /* optional */
           : list of clobbered registers      /* optional */
           );


// GCC_扩展内联汇编语法如下：
___________________________________________________________
__asm__(汇编语句模板
           : 输出部分
           : 输入部分
           : 破坏描述部分);
//共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用":“格开，
//汇编语句模板必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需
//要用”:"格开，相应部分内容为空. 例如:
__asm__ __volatile__("cli": : :"memory")



/*******************************************************************************
                => 扩展内嵌汇编描述
*******************************************************************************/
__asm__ __violate__ ("movl %1, %0" 
                        : "=r" (result) 
                        : "m" (input));
__________________________________________________
1 "movl %1, %0"         //是指令模板；
2 "%0", "%1"            //代表指令的操作数，称为占位符;
3 "result"              //对应“%0”;
4 "input"               //对应“%1”;
__________________________________________________
注意对应顺序：第一个表达式对应"%0"；第二个表达式对应"%1"，
依次类推，操作数至多有10 个，分别用"%0","%1"…"%9"表示
在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求
// “result"前面的限制字符串是”=r"，其中"=“表示"result"是输出操作数，“r"表示需要
   将"result"与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄
   存器，而不是"result"本身，当然指令执行完后需要将寄存器中的值存入变量"result”，从
   表面上看好像是指令直接对"result"进行操作，实际上GCC做了隐式处理，这样我们可以少写一些指令。
// “input"前面的"r"表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算
   读者可以将上例中的两个"r”，都改为"m”(m表示操作数放在内存，而不是寄存器中)，编译后得到的结果是：
   movl input, result
