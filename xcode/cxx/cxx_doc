/*******************************************************************************
                                 C++ 引用
*******************************************************************************/
___________________________________________________________
引用： 给变量起别名
语法： 数据类型 &别名 = 原名
___________________________________________________________
#include <iostream>
using namespace std;
int main(void)
{
        int a  = 10;
        //创建引用（引用必须初始化，引用在初始化后，不可以改变）
        int &b = a;  
        cout << "Hello, world!" << endl;
        cout << "a = " << a << endl;
        cout << "b = " << a << endl;
        return 0;
}


//3种函数传递方式
___________________________________________________________
#include <iostream>
using namespace std;
//01-值传递
void mySwap01(int a, int b) 
{
        int tmp = a;
        a = b;
        b = tmp;
        cout << "Swap01_值传递" << endl;
        cout << "Swap01_a = " << a << endl;
        cout << "Swap01_b = " << b << endl;
}
//02-地址传递
void mySwap02(int *a, int *b) 
{
        int tmp = *a;
        *a = *b;
        *b = tmp;
        cout << "Swap02_地址传递" << endl;
        cout << "Swap02_*a = " << *a << endl;
        cout << "Swap02_*b = " << *b << endl;
}
//03-引用， 别名和原名可以是一样的
void mySwap03(int &a, int &b) 
{
        int tmp = a;
        a = b;
        b = tmp;
        cout << "Swap03_引用传递" << endl;
        cout << "Swap03_&a = " << a << endl;
        cout << "Swap03_&b = " << b << endl;
}
int main(void)
{
        int a = 10;
        int b = 20;
        //mySwap01(a, b);       //值传递（形参不会修饰实参）
        //mySwap02(&a, &b);     //地址传递（形参会修饰实参）
        mySwap03(a, b);         //引用传递（形参会修饰实参）
        cout << "BASE_A = " << a << endl;
        cout << "BASE_B = " << b << endl;
        return 0;
}


//函数的调用可以作为左值
___________________________________________________________
#include <iostream>
using namespace std;
//引用做函数的返回值
//1 不要返回局部变量的引用, 局部变量存放在栈区
//2 函数的调用可以作为左值
int& test01()
{
        //静态变量，存放在全局区，全局区的数据在程序结束后，系统释放
        static int a = 10;
        return a;
}
int main()
{
        int &ref = test01();
        cout << "ref = " << ref <<endl;
        test01() = 100;                 //a(原名) = 1000; ref(别名) = 1000
        cout << "ref = " << ref <<endl;
}


//引用的本质, 就是一个指针的常量
//引用一旦初始化之后， 不可以改变
___________________________________________________________
using namespace std;
//发现是引用， 转换为 (int * const ref = &a;)
void func(int& ref) {
        ref = 100; //ref是引用，转换为 (*ref = 100;)
}
int main() {
        int a = 10;
        
        //自动转换为 (int * const ref = &a;)
        //指针常量是指针指向不可改，也说明为什么引用不可更改
        int& ref = a;
        //内部发现ref是引用，自动帮我们转换为 (*ref = 20)
        ref = 20; 
        
        cout << "a:" << a << endl;
        cout << "ref:" << ref <<endl;
        func(a);
        return 0;
}



//常量引用
___________________________________________________________
#include <iostream>
using namespace std;
//常量引用
//使用场景：用来修饰形参，防止误操作
void showValue(const int& val) {
        //val = 10;//val值不可修改
        cout << "val = " << val << endl;
}
int main(void) {
        //加上const之后，编译器将代码修改为（int temp = 10; const int& ref = temp;）
        //引用必须引一块合法的内存空间， 此时原名找不到了， 只能使用别名
        //加入const之后，变为只读，不可以修改
        const int & ref = 10;
        
        int a = 100;
        showValue(a);
}


//函数的默认参数
注意事项：
1 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值。
2 如果函数的声明有默认参数，那么函数的实现就不能有默认参数
___________________________________________________________
#include <iostream>
using namespace std;

//如果我们自己传入数据，就用自己的数据，如果没有，那么就用默认值
int func(int a, int b = 20, int c = 30) {
        return a + b + c;
}
int main(void) {
        cout << func(10) << endl;
        return 0;
}
