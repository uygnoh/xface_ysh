/*******************************************************************************
        => AAPCS 规则
*******************************************************************************/
        AAPCS(Procedure Call Standard for the ARM Architecture)
        为了使单独编译的 C语言程序和汇编程序之间能够相互调用，必须为子程序之
        间的调用规定一定的规则。基本的AAPCS规定了在子程序调用的一些基本规则，
        包括下面3个方面：  寄存器的使用规则及其相应名称， 数据栈的使用规则，
        参数传递的规则



/*******************************************************************************
        => AAPCS 寄存器的使用规则及其相应名称
*******************************************************************************/
        1 // 子程序间通过寄存器（R0~R3）来传递参数，全局变量
          // 这时寄存器（R0 ~ R3）可以记作(A1-A4)
          // 被调用的子程序在返回前无需恢复寄存器（R0~R3）的内容。

        2 // 在子程序中，使用寄存器（R4~R11）来保存局部变量。
          // 这时寄存器（R4 ~ R11）可以记作（V1 ~ V8）

        3 // 寄存器R12用作过程调用时的临时寄存器(用于保存SP, 在函数返回时
          // 使用该寄存器出栈)，记作IP。

        4 // 寄存器R13用作数据栈指针，记作SP.在子程序中寄存器R13 不能用作
          // 其它用途。

        5 // 寄存器R14称为连接寄存器，记作LR。它用于保存子程序的返回地址。

        6 // 寄存器R15是程序计数器，记作PC




/*******************************************************************************
        => AAPCS 数据栈的使用规则
*******************************************************************************/
        AAPCS规定堆栈为FD类型，即满递减堆栈，并且堆栈的操作是 8 字节对齐。
        而对于汇编程序来说，如果目标文件包含了名部调用，则必须满足以下条件：
        1 外部接口的数据栈一定是 8位对齐的，也就是保证在进入该汇编代码后，
          直到该汇编程序调用外部代码之间，数据栈的栈指针变化为偶数个字。
        2 在汇编程序中使用 PRESERVE8伪指令操作告连接器，本汇编程序是8字节对齐的。
	  
	  


/*******************************************************************************
        => AAPCS 参数传递的规则
*******************************************************************************/
        对于参数个数可变的子程序，当参数不超过4个时，可以使用寄存器 R0~R3来
        进行参数传递，当参数超过4个时，还可以使数据栈来传递参数。

        在参数传递时，将所有参数看做是存放在连续的内存单元中的字数据。然后，
        依次将各字数据传送到寄存器R0,R1,R2,R3中，如果参数个数多于4个，将
        剩余的字数据传送到数据栈中。

        入栈的顺序与参数顺序相反，即最后一个字数据先入栈。



/*******************************************************************************
        => AAPCS 数据栈限制检查
*******************************************************************************/
        如果在程序设计期间能够准确计算出所需的内存总量，就不需要进行数据栈的
        检查，但是通常情况下这是很难做到的，这时需要进行数据栈的检查。

        在进行数据栈的检查时，使用寄器R10作为数据栈限制指针，这时R10又记作SL,
        用户在程序中有能控制该寄存器。

        在已经占有栈的最低地址和SL之间必须有256字节的空间。也就是说，SL所指的
        内存地址必须比已经占用的栈的最低地址低256个字节。

        当中断处理程序使用用户的数据栈时，在已经占用的栈的最低地址和SL之间
        除了必须保留的256个字节的内存单元外，还必须为中断处理预留足够的内存空间。

        用户在程序中不能修改SL的值，数据栈栈指针SP的值必须不小于SL的值。



/*******************************************************************************
        => 嵌入式C语言的数据存储方法
*******************************************************************************/
        //  微处理器的存储空间有 Flash ROM和RAM之分，一般会将常量，常数等存在
        Flash ROM中，不常被修改。而把变量，函数，堆栈等都存放在RAM中， 以
        方便在运行时改变。
        // 寄存器是微处理器中被频繁使用的存储空间，常用来存放做计算的操作数，因此
        一个程序被编译成二进制后，分别保存在不同的地方。


        // RAM 
        //___________
        零初始化数据
        初始化数据
        堆栈
        堆数据


        // Falsh ROM
        //___________
        常量数据
        初始化数据
        开始和运行库代码
        program.txt



/*******************************************************************************
        => 嵌入式C语言编写注意事项
*******************************************************************************/
        数据类型尽量考虑整形计算符号多加减，少乘，不除尽量采用移位运算代替乘除法
        变量尽量用局部变量，少用全局变量。全局变量全部存放在静态存储区，在程序开
        始执行时给全局变量分配存储区，程序执行完毕才释放。 全局变量存在于RAM中，
        而局部变量存在于堆栈中。如果定义的全局变量太多就有可能导致溢出。
        //注意变量名字的空间污染。
        子程序的嵌套越少越好。在子程序运行时，当调用下一个子程序时就需要开辟一个
        堆栈空间，直到执行到return语句。才会把这个堆栈去掉。
        循环体多用 do-while 少用 for， while从编译的代码可以看出，do-while 
        循环中需要一个空间存放退出地址。相对而言，do-while 循环所需的额外开销最少。



/*******************************************************************************
        => C语言与汇编语混合编程的方法
*******************************************************************************/
        // 在C语言中内嵌汇编指令
        1  不能直接向 PC寄存器赋值，程序跳转只能使用 B或BL 指令实现。
        2  在使用物理寄存器时，不要使用过于复杂的C表达式，以避免物理寄存器冲突。
        3  R12和R13可能被编译器用来存放中间编译结果，计算表达式值时可能将R0-R3,
           R12,R14用于子程序调用，因此要避免直接使用这些物理寄存器。
        4  一般不要直接指定物理寄存器，而让编译器进行分配。

        __asm
        }
	        instruction [;instruction]
	        ...
	        [instruction]
        }



/*******************************************************************************
        => 在汇编中使用C定义的全局变量
*******************************************************************************/
内嵌汇编不用单独编辑汇编语言文件，比较简洁，但是有诸多限制，当汇编代码
比较多时一般放在单独的汇编文件中。
这时就需要在汇编和 C之间进行一些数据的传递。最简单的办法就是使用全局变量。
使用 IMPORT 伪指令引入全局变量，并利用 LDR和STR指令根据全局变量的地址访问它们。

// 下面例子是一个汇编代码的函数，它读取全局变量global, 其加2后写回。
        AREA BIOS, CODE, READONLY
	        EXPORT ASM_SUM          // 输出到C语言中
	        IMPORT global           // 输入C语言中的全局变量
        ASM_SUM
	        LDR R1, =global
	        LDR R0, [R1]
	        ADD R0, R0, #2
	        STR R0, [R1]
	        MOV PC, LR
        END



/*******************************************************************************
        => 在C程序中调用汇编程序
*******************************************************************************/
        // C 程序调用汇编程序时需要做到以下两步：
        1  在 C程序中使用 extern 关键字声明外部函数（声明要调用的汇编子程序），
           即可调用此汇编子程序。

        2  在汇编程序中使 EXPORT 伪指令声明本子程序，使其它程序可以调用此子程序。
           另外，汇编程序设置要遵循 AAPCS规则，保证程序调用时参数的正确传递。

// C程序如下：
// ____________________________________________________________
        #include <stdio.h>
        extern void strcopy(char *d, const char *s);
        int main(void)
        {
	        const char *srcstr ="First string-source";
	        char *dststr ="Second string-destination";
	        strcopy(dststr, srcstr);
	        return 0;
        }


// 汇编程序如下：
// ____________________________________________________________
        AREA SCopy, CODE, READONLY
        ENTRY
        EXPORT strcopy
        strcopy
	        LDRB R2, [R1], #1
	        STRB R2, [R0], #1
	        CMP R2, #0
	        BNE strcopy
	        MOV PC, LR
        END



/*******************************************************************************
        => 在汇编程序中调用C程序
*******************************************************************************/
        int cFunction(int a, int b, int c) {
                return (a + b + c);
        }
        
        
        AREA asmfile, CODE, READONLY
        IMPORT cFunction
        ENTRY
                MOV     R0, #11
                MOV     R1, #22
                MOV     R2, #33
                BL      cFunction
        END
