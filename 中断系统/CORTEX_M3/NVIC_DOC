/*******************************************************************************
        => Cortex-M 位带区
*******************************************************************************/
// Cortex-M3 位带区
// ____________________________________________________________________
0x20000000 ~ 0x200FFFFF    映射的别名地址为:   0x22000000 ~ 0x23FFFFFF
0x40000000 ~ 0x400FFFFF    映射的别名地址为:   0x42000000 ~ 0x43FFFFFF



0x20000000      0x20000000.0    0x20000000.1    0x20000000.2    0x20000000.3
                0x20000000.4    0x20000000.5    0x20000000.6    0x20000000.7
0x20000001      0x20000001.0    0x20000001.1    0x20000001.2    0x20000001.3
                0x20000001.4    0x20000001.5    0x20000001.6    0x20000001.7
0x20000002      0x20000002.0    0x20000002.1    0x20000002.2    0x20000002.3
                0x20000002.4    0x20000002.5    0x20000002.6    0x20000002.7
0x20000003      0x20000003.0    0x20000003.1    0x20000003.2    0x20000003.3
                0x20000003.4    0x20000003.5    0x20000003.6    0x20000003.7
                ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
                ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
                ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
0x20000000      => 0x22000000   0x22000004      0x22000008      0x2200000C
                => 0x22000010   0x22000014      0x22000018      0x2200001C
0x20000001      => 0x22000020   0x22000024      0x22000028      0x2200002C
                => 0x22000030   0x22000034      0x22000038      0x2200003C
0x20000002      => 0x22000040   0x22000044      0x22000048      0x2200004C
                => 0x22000050   0x22000054      0x22000058      0x2200005C
0x20000003      => 0x22000060   0x22000064      0x22000068      0x2200006C
                => 0x22000070   0x22000074      0x22000078      0x2200007C



// 位带区映射公式
// ____________________________________________________________________
        bit_word_addr = 
                      bit_band_alias_base + (byte_offset * 32) + (bit_number * 4)
        bit_word_addr           // 是别名区中的字地址
        bit_band_alias_base     // 是别名区的基址，即起始地址
        byte_offset             // 是包含目标的字节在位带区里的序号
        bit_number              // 是位带区目标位所在字节中的位置（0~7）
//假设： 位带区SRAM地址（0x20000300）的字节中的bit(2), 其位带别名区的映射地址：
        0x22000000 + (0x300 * 32) + (2 * 4) = 0x22006008



// 要求对地址（0x20000000）中的Bit2设置
// ____________________________________________________________________
1 不使用位带区
        读取（0x20000000）单元值到寄存器
        寄存器的Bit2位设置
        寄存器的值写回（0x20000000）单元
        
        // 设置（0x22000000）单元中的Bit2位
        // ______________________________________
        LDR     R0, =0x20000000         // 建立地址
        LDR     R1, [R0]                // 读字单元
        ORR.W   R1, #0x04               // 修改位
        STR     R1, [R0]                // 写回
        
        // 清除（0x22000000）单元中的Bit2位
        // ______________________________________
        LDR     R0, =0x20000000         // 建立地址
        LDR     R1, [R0]                // 读字单元
        AND.W   R1, #0xFFFFFFFB         // Bit2清零
        STR     R1, [R0]                // 写回
  
2 使用位带区（0x22000008）
        // 设置（0x22000000）单元中的Bit2位
        // ______________________________________
        LDR     R0, =0x22000008         // 建立地址
        MOV     R1, #1                  // 建立数据
        STR     R1, [R0]                // 写入
        
        // 清除（0x22000000）单元中的Bit2位
        // ______________________________________
        LDR     R0, =0x22000008         // 建立地址
        MOV     R1, #0                  // 建立数据
        STR     R1, [R0]                // 写入
        
        
3  读取位带区
        // 不使用位带区
        // ______________________________________
        LDR     R0, =0x20000000         // 建立地址
        LDR     R1, [R0]                // 读字单元
        // R1   =从R1寄存器中提取位
        // #2   =提取位的起始地址
        // #1   =提取的位数
        UBFX.W  R1, R1, #2, #1          // 提取Bit2
        
        
        // 使用位带区
        // ______________________________________
        LDR     R0, =0x22000008         // 建立地址
        MOV     R1, [R0]                // 读取数据
        
        
        
/*******************************************************************************
        => Cortex-M 工作模态
*******************************************************************************/
        1 模态（1）， 特权级线程模态， Supper-Thread
        2 模态（2）， 用户级线程模态， User  -Thread
        3 模态（3）， 特权级处理模态， Supper-Handler
        // 当系统启动时处于（特权级线程模态） - Supper-Thread
        // ____________________________________________________
        特权级                     用户级
        Handler Mode               XXX
        Thread Mode             Thread Mode
        
        
        // 用户级 + 线程模式
        // ____________________________________________________
        禁止访问包含（配置寄存器）以及调试组件寄存器的系统控制空间（SCS）
        禁止使用MSR访问除APSR外的特殊功能寄存器
        代码不能修改CONTROL[0]来回到特权级
        它必须通过产生异常，并通过异常处理程序（处于特权级下）来修改CONTROL[0]
        
        
        // 特权级 + （处理模式 + 线程模式）
        // ____________________________________________________
        可以通过置位CONTROL[0]来进入用户级
        不管是任何原因产生了任何异常，处理器都将以行权级来运行其服务例程
        异常返回后将回到产生异常之前的特权级
        
        
        // CONTROL
        // ____________________________________________________
        CONTROL[1]      堆栈指针选择
            0           // 0 =选择主堆栈指针MSP（复位后默认值）
            1           // 1 =选择进程堆栈指针PSP
                        // Handler Mode 只允许使用MSP
        CONTROL[0]
            0           // 特权级线程模式
            1           // 用户级线程模式
                        // Handler Mode 永远都是特权级
        // ____________________________________________________
                        
                        
                        
        // 双堆栈      
        // ____________________________________________________
        CONTROL【0] = 0          // 特权级
        CONTROL[1] = 0          // MSP-使用主堆栈

        CONTROL【0] = 1          // 用户级
        CONTROL[1] = 1          // PSP-使用进程堆栈
        
        MRS     R0, MSP         // 读取主堆栈指针到R0
        MSR     MSP, R0         // 写入R0的值到主堆栈中
        MRS     R0, PSP         // 读取主进程指针到R0
        MSR     PSP, R0         // 写入R0的值到进程栈中
        MRS     R0, BASEPRI     // 读
        MRS     R0, FAULTMASK   // 读
        MRS     R0, BASEPRI     // 读
        MSR     BASEPRI, R0     // 写
        MSR     FAULTMASK, R0   // 写
        MSR     PRIMASK, R0     // 写

                        
                        
/*******************************************************************************
        => Cortex-M 异常与中断
*******************************************************************************/              
        0xE000E000      // NVIC基地址（字节，半字，字，访问）
        // ____________________________________________________
        
        
        
        0xE000ED00      // 优先级分组寄存器
        // ____________________________________________________
        
        
        
        CPSID   I       // PRIMASK=1
        CPSIE   I       // PRIMASK=0
        CPSID   F       // FAULTMASK=1
        CPSIE   F       // FAULTMASK=0



        // 异常
        // ____________________________________________________
        同步异常：是指与CPU当前执行的指令密切相关，造成CPU正常运行状态被
                 中止的系统事件（或称内部事件）， 如指令未定义，指令预取指
                 中止， 数据访问中止等。
        异步异常：则是由外部事件的触发而产生的，与CPU当前执行的指令无关，
                 故被称为异常异常。 复位，NMI属于异步异常。



        // 中断向量表
        // ____________________________________________________
        0x00000000      // MSP 的初值
        0x00000004      // 复位向量（PC初值）
        0x00000008      // NMI服务程序的入口地址
        0x0000000C      // 硬FAULT服务程序的入口地址
        
        

        // 启动流程（Cortex-M 满减栈）
        // ____________________________________________________
        0x20008000      .............   // MSP的初始值（0x20008000）
        0x20007FFC      第一个入栈的元素
        0x20007FF8      第二个入栈的元素
        ..........
        ..........
        ..........
        0x00000100      启动引导代码
        ..........
        ..........
        ..........
        0x00000004      0x00000101
        0x00000000      0x20008000
        
        
        
        // 向量表重定位
        // ____________________________________________________
        大多数微处理器， 地址0处应该存储引导代码（BootStrap）
        Cortex-M微处理器，地址0处为MSP的初值
        0xE000ED08      // 向量表偏移量寄存器
        [29]    TBLABSE // 0（向量表在Code区）， 1（向量表在RAM区）
        [28:7]  TBLOFF  // 向量表相对于Code区或RAM区的偏移地址
        
        
        
        // 向量表重定位起始地址计算与设置
        // ____________________________________________________
        1 先求出系统中共有多少个向量
        2 再把这个数字向上增大到2的整次幂，而起始地址必须对齐到字边界上
        3 例如： 一共有32个中断， 则共有 32+16（异常系统） = 48 个向量
          向上增大到2的整数次幂后值为64， 合法起始地址是 64*4 = 256 的
          整数倍， 可以是： 0x0, 0x100, 0x200
        
        
        
        // 向量表重定位必须包含
        // ____________________________________________________
        主堆栈指针MSP的值
        复位向量
        NMI
        硬FAULT服务



/*******************************************************************************
        => Cortex-M 异常与中断
*******************************************************************************/
        // 保护现场顺序
        // __________
                PC
                XPSR
                R0
                R1
                R2
                R3
                R12
                LR

        // 更新寄存器
        // __________
        1 更新堆栈指针SP（MSP， PSP）
        2 PSR状态寄存器，更新为中断号（IRQn）
        3 链接寄存器LR自动更新为-EXC_RETURN（特权级 + 工作模式）
        4 从向量表中找到对应的中断服务程序入口地址，更新程序计数器（PC）
        5 更新NVIC相关寄存器，（异常的挂起位被清除，活动位将被置位）
        特别注意！
        6 当前代码正在使用PSP，则压入PSP（线程堆栈），否则压入MSP（主堆栈）
        7 一旦进入了中断服务程序，将一直使用主堆栈（MSP）


        // 不带中断嵌套的服务程序
        // ___________________
        irq_handler
                ...
                ...
                BX R14


        // 带中断嵌套的服务程序
        // ___________________
        irq2_handler
                PUSH    {R0-R7, R12, R14}       // 保存寄存器列表
                ...                             // 中断处理
                ...
                POP     {R0-R7, R12, PC}        // 中断返回


        // 中断返回
        // ___________________
        1 Cortex-m微处理器通过<EXC_RETURN>写入PC识别返回动作
        2 根据LR中EXC_RETURN的值确定Cortex-m微处理器需要转入
          的工作模式，即即特权级别和所使用的堆栈（MSP， PSP）
        3 Cortex-M进入相应的工作模式
        4 从相应模式下的堆栈弹出<xPSR, PC， LR, R12, R3-R0>
          至相应的寄存器，从而返回先前的程序，（主程序或优先级别
          低的中断服务程序）
          
          
        // EXC_RETRUN
        // ___________________
        中断响应过程中，LR等寄存器压入栈后，LR的值自动更新为特殊
        的EXC_RETURN
        [31:4]  EXC_RETURN的标识，28位必须全为（1）
        [3]     0: 返回后进入Handler模式
                1: 返回后进入线程模式
        [2]     0: 从主堆栈中做出栈操作，返回后使用MSP
                1: 从进程堆栈中做出栈操作，返回后使用PSP
        [1]     保留，必须为（0）
        [0]     0: 返回ARM状态
                1: 返回Thumb-2状态，在Cortex-M中必须为（1）
        0xFFFFFFF1      // 返回Handler模式
        0xFFFFFFF9      // 返回特权线程模式，并使用主堆栈（MSP）
        0xFFFFFFFD      // 返回用户线程模式，并使用线程堆栈（PSP）
        
