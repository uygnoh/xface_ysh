###########################################################
###  Vimscript 基本映射
###########################################################
我们先从normal模式的键盘映射开始。
随意在文本中敲写几行文字，然后运行命令： 将光标置于文本中的某处，按下-。
注意Vim删除了当前光标下的字符，就好像你按了x一样, 我们本来就有个按键用于 "删除当前光标下的字符" 
    :map - x            % 将“-” 重新映射到 “x”
    :map - dd           % 将“-” 重新映射到 “dd”

% 特殊字符; 你可以使用<keyname>告诉Vim一个特殊的按键。
% 现在在键盘上按下Ctrl+d将执行dd命令。
:map <C-d> dd


% 特殊字符; 你可以使用<keyname>告诉Vim一个特殊的按键。
% 移动光标到一个单词上，按下空格键。Vim将高亮选中整个单词。
:map <Space> viw




###########################################################
###  Vimscript 模式映射
###########################################################
上一章中我们谈论了如何在Vim中映射按键。
我们使用的命令map在normal模式下工作。 
如果阅读本章之前你自己已经折腾了，
可能会注意到这个映射在visual模式一样工作。
你可以使用nmap、vmap和imap命令分别指定
映射仅在normal、visual、insert模式有效。


% 在normal模式下，按下\。Vim会删除当前行。
% 现在进入Visual模式，再次按下\。什么都不会发生，
% 因为我们告诉了Vim这个映射仅在normal 模式下工作（同时\的默认行为是什么都不做）。
:nmap \ dd

% 进入visual模式并选中一些文字，按下\。Vim将把选中文本转换成大写格式。
% 分别在normal模式和visual模式测试\按键，注意不同模式下的效应。
:vmap \ U


% 你可能猜想这个命令的作用是在insert模式下通过按键Ctrl+d删除整行。这个映射很实用， 
% 因为你不必每次都要为了删除某些行而切回到normal模式。
% 好的我们试一下。它并不如我们想象那般工作，而仅仅是在文件中添加了两个d字符！ 它压根就没用。
% 问题就在于Vim只按我们说的做。这个例子中，我们说：“当我按下<C-d>时，相当于我 按了两次d”。
% 而当你在insert模式下，按下两次d的作用就是输入两个字符d。
:imap <C-d> dd


% 要想让这个映射按我们的期望执行，我们需要更加明确的指令。修改映射并运行如下命令：
% <Esc>告诉Vim按下ESC按键，即退出insert模式。
% 现在再试试这个映射。它能够正常工作，但是注意你是如何回到normal模式的。
% 这是因为我们 告诉Vim<C-d>要退出insert模式并删除一行，但是我们没有告诉它再回到insert模式。
:imap <C-d> <Esc>dd


% 运行如下命令，修复映射问题：
% 结尾的i告诉Vim进入insert模式，至此我们的映射才最终完成。
:imap <C-d> <Esc>ddi




###########################################################
###  Vimscript 非递归映射
###########################################################
每一个*map系列的命令都有个对应的*noremap命令，
包括：*noremap/nnoremap、 vnoremap和inoremap
这些命令将不递归解释映射的内容, 
vim中键盘映射有三类：visual，insert和normal
inoremap是用于insert模式的非递归映射，
nnoremap是用于normal模式的非递归映射，
vnoremap是用于visual模式的非递归映射.

% 该何时使用这些非递归的映射命令呢？
% 答案是： 任何时候, 是的，没开玩笑， 任何时候 
% 在安装插件或添加新的自定义映射时使用*map系列命令纯属是给自己 找 麻烦。 
% 多敲几个字符以确保这个问题不会发生，救自己于火海。



% 一个更为复杂的Mapping
% 你已经见过很多简单的mappings了，是时候看看一些复杂的了。运行下面的命令：
    :nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel
%那是一个有趣的mappings！你自己可以先试试。
%进入normal模式，移动光标至一个单词， 输入<leader>" ,Vim将那个单词用双引号包围！
%它是如何工作的呢？我们拆分这个映射并逐个解释：
    viw<esc>a"<esc>hbi"<esc>lel

    viw     :高亮选中单词
    <esc>   :退出visual模式，此时光标会在单词的最后一个字符上
    a       :移动光标至当前位置之 后 并进入insert模式
    "       :插入一个 "
    <esc>   :返回到normal模式
    h       :左移一个字符
    b       :移动光标至单词头部
    i       :移动光标至当前位置之 前 并进入insert模式
    "       :插入一个"
    <esc>   :返回到normal模式
    l       :右移一个字符，光标置于单词的头部
    e       :移动光标至单词尾部
    l       :右移一个字符，置光标位置在第一个添加的引号上
% 记住：因为我们使用的是nnoremap而不是nmap，所以尽管你映射了字符序列中的字符 也不会有影响。
% Vim会将其中的字符按默认功能执行。希望你能看出Vim mappings的潜能及随之引发的阅读困难。



% ESC <=========> JK  [KEY-MAPPING]  减轻负担映射
% 让我们先创建一个mapping，这个mapping会为你的左手减轻很多负担。执行下面的命令：
% ok，现在进入插入模式然后敲击jk。Vim会返回到常用模式，就像你敲击了escape按键一样。
    :inoremap jk <esc>
% 这个命令会告诉Vim在插入模式下敲击escape按键后执行<nop>(no operation)，
% 这样escape按键在插入模式下就无效了。ok，现在你就_不得不_使用jk这个mapping来退出插入模式了。
    :inoremap <esc> <nop>



###########################################################  
###  % Operator-Pending映射
###########################################################
这一章我们将来探索Vim映射系统中另外一个神奇的部分：
“Operator-Pending映射”。
开始之前，我们先解释下这里面的几个词含义。
一个Operator（操作）就是一个命令，
你可以在这个命令的后面输入一个Movement（移动）命令，
然后Vim开始对文本执行前面的操作命令，
这个操作命令会从你当前所在的位置开始执行，
一直到这个移动命令会把你带到的位置结束。

% 常用到的Operator有d，y和c。例如：
按键    操作       移动
----   --------  -------------
dw     删除       到下一个单词
ci(    修改       在括号内
yt,    复制       到逗号


% Movement映射
% Vim允许你创建任何新的movements，这些movements可以跟所有命令一起工作。执行下面的命令：
    :onoremap p i(
% 在缓冲区中输入下面的文字：
    return person.get_pets(type="cat", fluffy_only=True)
把光标放到单词“cat”上，然后敲击dp。结果会发生什么？Vim会删除括号内的所有文字。
你可以把这个新建的movements当作“参数”。
onoremap命令会告诉Vim当它在等待一个要附加在operator后面的movement的时候，
如果这个movement是p的话，它会把它当作i(。所以当我们在运行dp的时候，
就象是在对Vim说“delete parameters”，而Vim会把它理解为“在括号内删除”。

% 我们现在可以立马对所有的operators使用这个新建的映射。
% 再次在缓冲区中输入上面的文字（或者直接把之前修改恢复一下）。
    return person.get_pets(type="cat", fluffy_only=True)
把光标放到单词“cat”上，然后敲击cp。这次又会发生什么？
Vim会删除括号中的所有文字，不过这一次删除之后Vim会处于插入模式，
这是因为你使用的是“change”，而不是“delete”。



% 再看一个示例。执行下面的命令：
    :onoremap b /return<cr>
现在把下面的文字输入到缓冲区：
def count(i):
    i += 1
    print i

    return foo
把光标放到第二行的i上，然后按下db。会发生生么？
Vim把整个函数体中直到return上面的内容都删除了，
return就是上面的映射使用Vim的通用查找得到的结果。



% 当你想搞清楚怎么定义一个新的operator-pending movement的时候，你可以从下面几个步骤来思考：
        1    在光标所在的位置开始。
        2    进入可视模式(charwise)。
        3    ... 把映射的按键放到这里 ...
        4   所有你想包含在movement中的文字都会被选中。
% 你所要做的工作就是在第三步中填上合适的按键。



% 改变开始位置
% 你可能已经从上面所学的东西中意识到一个了问题。
% 如果我们定义的movements都是从光标所在的位置开始的话，那么这就会限制我们做一些我们想使用movement来做的事情。
% 但是Vim并不会限制你去做你想做的事情，所以对于这个问题肯定有解决办法。执行下面的命令：
    :onoremap in( :<c-u>normal! f(vi(<cr>
% 这个命令看起来有些复杂，不过我们还是先试试它能干什么。将下面的文字输入缓冲区：
    print foo(bar)
把光标放到单词print上面，然后敲击cin(。Vim会删除括号内的内容然后进入插入模式，并且光标会停留在括号的中间。
你可以将这个映射理解为“在下一个括号内(inside next parentheses)”。
它会对当前行光标所在位置的下一个括号内的文本执行operator。

% 我们再创建一个“在上一个括号内(inside last parentheses)”的movement进行对照。
% （在这里使用“前一个(previous)“可能更准确，但这会覆盖“段落(paragraph)”movement）
    :onoremap il( :<c-u>normal! F)vi(<cr>
% 先试试确保这个命令可以工作。那么这些映射是怎么工作的呢？
% 首先，<c-u>比较特殊，可以先不用管（你只需要相信我这个东西可以让这个映射在任何情况下都能正常工作）。
% 如果我们删除它的话，这个映射会变成这个样子：
    :normal! F)vi(<cr>
:normal!会在后面的章节谈到，现在你只需要知道它可以在常用模式下模拟按下按键。
例如，运行:normal! dddd会删除两行，就像按下dddd。映射后面的<cr>是用来执行:normal!命令的。

% 那么现在我们可以认为这个映射的关键是运行下面这些按键组成的命令： 
% F)vi(  This is fairly simple: 这个命令很容易理解：
        F): 向后移动到最近的)字符。
        vi(: 进入可视模式选择括号内的所有内容。
% 这个movement结束在在可视模式下选择中我们想操作的文本，然后Vim会对选中的文本执行操作，就像通常情况一样。

% 一般规则
下面两条规则可以让你可以很直观的以多种方式创建operator-pending映射：
    如果你的operator-pending映射以在可视模式下选中文本结束，Vim会操作这些文本。
    否则，Vim会操作从光标的原始位置到一个新位置之间的文本。
    
    
% 练习
为"around next parentheses"和"around last
 parentheses"创建operator-pending映射
为打括号创建类似的in/around next/last的mappings。
阅读:help omap-info，看看你可不可以搞清楚<c-u>是干啥的。



###########################################################
###  %更多Operator-Pending映射
###########################################################
Operators和movements所包含的理念是Vim中的一个非常重要的概念，
也是Vim之所以这么高效的最大原因所在。
在这一章我们会在这一块做更多的实践，
这会让Vim变得更强大。
假设你现在在往Markdown中写入一些文字。
如果你没有用过Markdown，
不要紧，对于我们现在要做的事情而言，
它很简单。把下面的文字输入到一个文件中：

Topic One
=========

This is some text about topic one.

It has multiple paragraphs.

Topic Two
=========

This is some text about topic two.  It has only one paragraph.


% 使用=作为“下划线”的行会被Markdown当作标题。我们现在创建一些映射，
% 这些映射可以让我们通过movements定位到标题。运行下面的命令：
% 这个映射有些复杂。现在把你的光标放到文本中的某个位置（不要放到标题上）,然后敲击cih。
% Vim会删除光标所在章节的标题，然后保持在插入模式，这可以称为"修改所在的标题(change inside heading)"
    :onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
    

% 这里使用了一些我们之前从来没有见过的东西，所以我们有必要单独分析下每一部分的含义。
% 这个映射的第一部分，:onoremap ih是映射命令，这个我们很熟悉了，无需多言。
% <c-u>上一章讲过，我们现在也不深究。
% 接着看看剩下的部分：
    :execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>

Normal ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% :normal命令的后面会跟着一串字符，无论这些字符表示什么含义，
% :normal命令都会执行它们，就像是在常用模式下敲击这些字符一样。
% 我们会在后面的章节中谈论关于:normal的更多细节，由于这个它已经出现多次，
% 所以我觉得有必要现在做一个简单的说明，算是浅尝辄止吧。执行下面的命令：
% Vim会将光标跳转到文件的顶部。
:normal gg

% 现在执行下面的命令：Vim将缩进当前行。
% 那normal后面的!是干啥的呢？先别管，以后再说。
:normal >>



Execute ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% execute命令后面会跟着一个Vim脚本字符串（以后会深究它的细节），
% 然后把这个字符串当作一个命令执行。执行下面的命令：
% Vim会写文件，就像你已经输入了:write<cr>一样
:execute "write"

% 现在执行下面的命令：
% Vim会执行:normal! gg，这个会将光标跳转到文件的顶部，跟之前一样。
:execute "normal! gg"


% 现在问题来了，我们为什么要搞得这么蛋疼，
% 又是execute，又是normal!，直接执行normal!不就可以搞定么？
% 看看下面的命令，猜猜它会干啥：
:normal! gg/a<cr>

% 这个命令似乎会做下面的一些事情：
1    将光标跳转到文件的顶部。
2    准备搜索。
3    把“a”当作目标字符串进行搜索。
4    按下return键执行搜索。
你自己执行一下，Vim会将光标跳转到了文件顶部，然后。。没有然后了！
之所以会这样是由于normal!的一个问题，这问题是normal!不能识别“特殊字符”，
例如这里的<cr>。这个问题有很多办法可以搞定，最简单的就是使用execute，另外使用execute也会让脚本更易读。
当execute碰到任何你想让它执行的字符串的时候。它会先替换这个字符串中的所有特殊字符。
在这个示例中，\r是一个转义字符，它表示的是"回车符（carriage return）"。
两个反斜线也是一个转义字符，它会将一个反斜线当作一般字符放到字符串中。



% 如果我们按照上面的分析替换这个映射中的特殊字符，然后就可以搞清楚这个映射会怎么执行：
:normal! ?^==\+$<cr>:nohlsearch<cr>kvg_
                ^^^^           ^^^^
                 ||             ||
这里的<cr>实际上是一个回车符，而不是由4个字符——“左尖括号”，“c“，”r“和“右尖括号”组成的字符串。
所以现在normal!会执行这些字符，如同我们是在常用模式下敲击了它们一样。我们以回车符对这些字符进行拆分，
然后看看它们是怎么执行的：
        ?^==\+$
        :nohlsearch
        kvg_
% 第一部分
第一部分?^==\+$会向后搜索任何由两个或多个等号组成的行，这些行不会包含除等号外的任何其他字符。
这个命令执行后会让光标停留在符合搜索条件的行的行首。
之所以使用向后搜索，是因为当你想“修改所在的标题(change inside heading)”的时候，
而当前光标是位于某一节的文本上，那么你最可能想做的是修改_这_一节的标题，而不是下一节的标题。

% 第二部分
第二部分是:nohlsearch命令。这个命令只是简单的清除之前的搜索结果的高亮显示，防止这些高亮显示分散我们的注意。

% 第三部分
最后一部分是三个常用模式下的命令的序列：
    k：向上移动一行。第一部分已经将光标定位到了等号符号组成的行的第一个字符，
       所以执行这个命令后光标就会被定位到标题的第一个字符上。
    v：进入可视模式(characterwise)。
    g_：移动到当前行的最后一个非空字符上。这里没有使用$，是因为$会选中换行符号，这不是我们所想要的。





% 再来看一个映射。执行下面的命令：
% 把光标放到某一节的文字上，然后敲击cah试试看。这一次Vim不仅会删除这一节的标题，
% 而且还会删除跟这个标题相连的等号组成的行。
% 你可以把这个movement当作是“_环绕_这一节的标题(around this section's heading)“。
    :onoremap ah :<c-u>execute "normal! ?^==\\+\r:nohlsearch\rg_vk0"<cr>

% 这个映射有什么不同呢？让我们对照之前的映射看一下：
:onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
:onoremap ah :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rg_vk0"<cr>

%唯一的不同是映射的后面用于选择文本的部分：
    inside heading: kvg_
    around heading: g_vk0
% 其他的部分都是一模一样的，所以我们现在从将光标定位到等号组成的行的第一个字符的那个部分开始进行讲解：
    g_：移动到当前行（译注：等号组成的行）的最后一个非空字符。
    v：进入可视模式(characterwise)。
    k：向上移动一行。这会将光标移动到包含标题文字的行上。
    0：移动到这一行（译注：标题行）的第一个字符。
% 这一系列命令的执行结果就是在可视模式下同时选中标题的文字和等号组成的行，然后Vim会在这两行上执行相应的操作。




###########################################################
### % VIM MAP
###########################################################
% :map {lhs} {rhs} 
:map作用的模式中把键系列{lhs} 映射为{rhs}，{rhs}可进行映射扫描，也就是可递归映射
% :noremap 和:map命令相对，作用模式和命令格式都相同，只不过不允许再对{rhs}进行映射扫描，
也就是{lhs}定义后的映射就是{rhs}的键序列，不会再 对{rhs}键序列重新解释扫描。
它一般用于重定义一个命令，当然如果:map不需要递归映射的话，建议试用:noremap 
% :unmap是对应取消:map绑定的｛lhs｝，作用模式相同，命令格式 :unmap {lhs}。
:unmap td 
就是取消在其作用模式中td的绑定，比如之前td被绑定为:tabnew .<cr>，此时此绑定消失
% :nnorempa和:nmap的关系和:noremap和:map的关系一样，只是:nmap的非递归版 
% :mapclear时对应取消所有:map绑定的，慎用！ 
% :nmapclear是对应取消所有:map绑定的，慎用！ 
        map                 % 递归映射
        nore                % 表示非递归
        n                   % 表示在普通模式下生效
        v                   % 表示在可视模式下生效
        i                   % 表示在插入模式下生效
        c                   % 表示在命令行模式下生效
___________________________________________________________       
% 下表是map绑定中，对应的模式代号。现在先了解一下，等看完之后再回过头看这个模式代号就会明白了
% 字 符 模 式 ~ ; <Space> 普通、可视、选择和操作符等待 
        n                   % 普通 
        v                   % 可视和选择 
        s                   % 选择 
        x                   % 可视 
        o                   % 操作符等待 
        !                   % 插入和命令行 
        i                   % 插入 
        l                   % 插入、命令行和 Lang-Arg 模式的 ":lmap" 映射 
        c                   % 命令行 

___________________________________________________________

@递归映射        @非递归映射        @删除映射        @清楚映射
map             noremap          unmap           mapclear                               
nmap            nnoremap         nunmap          nmapclear
vmap            vnoremap         vunmap          vmapclear
imap            inoremap         iunmap          imapclear
cmap            cnoremap         cunmap          cmapclear
___________________________________________________________

% 看 完以上，应该可以发现一个规律，前4个是一组，后4个时一组，
% 后一组比前一组多一个n就是指只作用于普通模式。其中每组内*nore*是其对应的非递归 版、
% *un*是取消绑定某个<lhs>绑定、clear后缀是取消所有绑定。发现了这个规律，再翻到前面的模式代号表，
% 你大体可以猜到 vmap、xmap、smap、omap是什么意思了吧，以及相对应的nore版本、un版本、clear版本。 
% :map  {lhs} {rhs}
% 另外----------------------
{rhs} 之前可能显示一个特殊字符: 
    * 表示它不可重映射 
    & 表示仅脚本的局部映射可以被重映射 
    @ 表示缓冲区的局部映射 
% 到这一步你可以轻松的长吸一口气，因为相关的命令已经都了解了，
% 记不住没关系，可以随时:help map一下。不过别急，后面还有map更多的选项等着去攻克。 
___________________________________________________________
特殊参数： 它们必须映射命令的后边，在其他任何参数的前面。
1. <buffer> 
2. <silent> 
3. <special> 
4. <script> 
5. <expr> 
6. <unique> 

<buffer>如果这些映射命令的第一个参数是<buffer>，映射将只局限于当前缓冲区（也就是你此时正编辑的文件）内。
比如 :map <buffer> ,w /a<CR> 
它的意思时在当前缓冲区里定义键绑定，“,w”将在当前缓冲区里查找字符a。同样你可以在其他缓冲区里定义： 
:map <buffer> ,w /b<CR> 
% 比如我经常打开多个标签(:tabedit)，想要在各自标签里定义",w"键绑定，
那么你只要在每个标签页里分别定义就可，其作用域也只在各自的标签里。
同样要清除这些缓冲区的键绑定也要加上<buffer>参数，比如： 
:unmap <buffer> ,w 
:mapclear <buffer> 


<silent>是指执行键绑定时不在命令行上回显，比如： 
:map <silent> ,w /abcd<CR> 
你在输入,w查找abcd时，命令行上不会显示/abcd，如果没有<silent>参数就会显示出来 


<special>一般用于定义特殊键怕有副作用的场合。比如： 
:map <special> <F12> /Header<CR> 


<unique>一般用于定义新的键映射或者缩写命令的同时检查是否该键已经被映射，如果该映射或者缩写已经存在，则该命令会失败 


<expr>. 如果定义新映射的第一个参数是<expr>，那么参数会作为表达式来进行计算，结果使用实际使用的<rhs>，例如： 
:inoremap <expr> . InsertDot() 
这可以用来检查光标之前的文本并在一定条件下启动全能 (omni) 补全。 
___________________________________________________________

% <Leader> mapleader 
mapleader变量对所有map映射命令起效，它的作用是将参数<leader>替换成mapleader变量的值，比如： 
:map <Leader>A oanother line<Esc> 
如果mapleader变量没有设置，则用默认的反斜杠代替，因此这个映射等效于： 
:map \A oanother line<Esc> 
意思时输入\A键时，在下一行输入another line并返回到普通模式。 
% 如果设置了mapleader变量，比如： 
let mapleader = "," 
% 那么就等效于： 
:map ,A oanother line<Esc> 

% 设置mapleader和maplocalleader时最好区分开，不要出现冲突
<LocalLeader> maplocalleader 
<LocalLeader>和<Leader>类似，只不过它只作用于缓冲区。 

___________________________________________________________


% map KEY KEYSTROKES
<F1> .. <F12>   Function Keys   功能键
<BS>            Backspace       退格键
<CR>            Enter           回车键
<Return>        Enter           回车键
<Esc>           Escape          逃出
<Space>         Space           空格键
<Up>            Up arrow        向上方向箭头
<Down>          Down arrow      向下方向箭头 
<Left>          Left arrow      向左方向箭头
<Right>         Right arrow     向右方向箭头
<Insert>        Insert          插入
<Del>           Delete          删除
<Home>          Home            家
<End>           End             结束
<PageUp>        Page-Up         向上翻页
<PageDown>      Page-Down       向下翻页
<Tab>           Tab             制表
<bar>           '|'
<C-x>           大写C配合x，意味着ctrl+x组合键
<S-x>           大写S配合x，意味着shift+x组合键
<A-x>           大写A配合x，意味着alt+x组合键




