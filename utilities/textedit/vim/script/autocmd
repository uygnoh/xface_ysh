###########################################################
###  autocmd!  自动命令
###########################################################
现在我们谈论一个跟映射一样重要的东西：自动命令。
自动命令可以让Vim自动执行某些指定的命令，
这些指定的命令会在某些事件发生的时候执行。我们先看一个例子。
使用:edit foo打开一个新文件，然后立即使用:quit关闭。
查看你的硬盘，你会发现这个文件并不存在。
这是因为在你第一次保存这个文件之前，Vim_实际上_并没有真正创建它。


% 让我们对Vim做一些改变，使得Vim可以在你开始编辑文件的时候就创建它们。执行下面的命令：
% 这里面有很多需要进一步说明的，不过在此之前我建议你先感受下它是怎么工作的。
% 执行:edit foo，使用:quit关闭，然后查看硬盘。这个时候文件会存在（当然文件内容为空）。
% 你只有关闭Vim才能删除这个自动命令。我们会在后面的章节说明如何避免这种情况。
    :autocmd BufNewFile * :write

% 自动命令结构, 让我们来深入分析下我们刚才创建的自动命令：
:autocmd BufNewFile * :write
         ^          ^ ^
         |          | |
         |          | 要执行的命令
         |          |
         |          用于事件过滤的“模式（pattern）”
         |
         要监听的“事件”
% 这个命令的第一部分是我们想监听的事件的类型。Vim提供了_很多_可以监听的事件。这些事件包括：
        1    开始编辑一个当前并不存在的文件。
        2    读取一个文件，不管这个文件是否存在。
        3    改变一个缓冲区的filetype设置。
        4    在某段时间内不按下键盘上面的某个按键。
        5    进入插入模式。
        6    退出插入模式。

% 上面只举出了可用事件里面的很小一部分。还有很多其他的事件，你可以利用这些事件来做一些有趣的事情。
% 这个自动命令的下一部分是一个“模式”，这个模式可以进一步限定你要执行的命令的执行范围。
% 新开一个Vim实例，执行下面的命令：
    :autocmd BufNewFile *.txt :write
这个跟之前的那个自动命令基本一样，不过这个自动命令只对后缀为.txt的文件有效，
也就是说当你新建的文件为txt文件的时候，Vim会在文件创建的时候自动执行write命令将文件保存到硬盘上。
试试执行:edit bar，然后执行:quit，再执行:edit bar.txt，然后再执行:quit。
你会发现Vim会自动创建bar.txt，但不会创建bar，因为它的后缀名不是txt，不跟模式匹配。
这个自动命令的最后一部分是事件发生时我们想执行的命令。
这个部分很容易理解，跟我们执行其他命令一样，除了不能在这个命令中使用特殊的字符，
例如<cr>。我们会在本书后面的章节中谈论如何突破这个限制，现在你只需要遵守它就可以。    
    
    
    
% 再来一个示例
% 我们再定义一个自动命令，这次使用一个不同的事件。执行下面的命令：  
    :autocmd BufWritePre *.html :normal gg=G
这里用到了normal命令，我会在本书的后面的章节里面讲到它，这可能有点超前，
不过我觉得这是一个很好的使用自动命令的示例，所以请大家先忍受一下。
创建一个名为foo.html的新文件。用Vim编辑它，并输入下面的文本，请保证输入的文本完全一致，包括空白符：
    
<html>
<body>
 <p>Hello!</p>
                 </body>
                  </html>
                      
执行:w保存这个文件。看看会发生了什么？Vim似乎在文件保存之前重新进行了文本缩进处理。
ok，请先相信我文本缩进处理是:normal gg=G干的，先别纠结于为什么:normal gg=G可以干这个。
我们_应该_把注意力放在自动命令上。这个自动命令里面用到的事件是BufWritePre，
这个事件会在你保存_任何_字符到文件之前触发。
我们使用了*.html这个模式，这个模式会保证命令只会在编辑html文件的时候被执行。
这就是自动命令强大的地方，因为它可以专门针对特定类型的文件来执行我们想要执行的命令。ok，让我们继续探索它吧。    
    
    
    
% 多个事件
% 你可以创建一个绑定_多个_事件的自动命令，这些事件使用逗号分隔开。执行下面的命令：
    :autocmd BufWritePre,BufRead *.html :normal gg=G    
        
这个跟上面的自动命令基本一样，不同的是它会让Vim不仅在写html文件的时候进行缩进处理，
读html文件的时候也会进行缩进处理。如果你有些同事不喜欢把HTML文件格式搞得漂亮点，那么这个命令会很有用。
在Vim脚本编程中有一个不成文的规定，你应该同时使用 BufRead和BufNewFile
（译注：这里不是BufWritePre）这两个事件来运行命令，
这样当你打开某个类型的文件，不论这个文件是否存在命令都会执行。

% 下面的命令会使得无论你在什么时候编辑HTML文件自动换行都会被关闭
    :autocmd BufNewFile,BufRead *.html setlocal nowrap
 
    
    
 
% FileType事件
% 最有用的事件是FileType事件。这个事件会在Vim设置一个缓冲区的filetype的时候触发。
% 让我们针对不同文件类型设置一些有用的映射。运行命令：   
% 打开一个Javascript文件（后缀为.js的文件）,将光标移动到某一行，敲击<localleader>c，光标所在的那一行会被注释掉
% 现在打开一个Python文件（后缀为.py的文件）,将光标移动到某一行，敲击<localleader>c，同样的那一行会被注释掉
    :autocmd FileType javascript nnoremap <buffer> <localleader>c I//<esc>
    :autocmd FileType python     nnoremap <buffer> <localleader>c I#<esc>



     
% 练习
浏览:help autocmd-events查看自动命令可以绑定的所有事件。
你不需要现在就记住每一个事件。仅仅只需要了解下你可以使用这些事件做哪些事情。
创建一些FileType自动命令使用setlocal对你喜欢的文件类型做一些设置。
你可以针对不同的文件类型设置wrap、list、 spell和number这些选项。
对一些你会经常处理的文件类型创建一些类似“注释掉这一行”的命令。
把所有这些自动命令写到你的~/.vimrc文件里面。
记住使用前面章节中提到过的快速编辑和加载~/.vimrc文件的映射来做这个事情，这是必须的！    



###########################################################
###  Vimscript 本地缓冲区缩写
###########################################################
现在以同样的方式来学习本地缓冲区的缩写 

% 打开你的foo和bar这两个文件，切换到foo，然后执行下面的命令：
    :iabbrev <buffer> --- &mdash;
% 在文件foo下进入插入模式输入下面的文本：
% 在foo中 Vim会为你将---替换为“&mdash;“。
% 在bar中替换不会发生，这是因为我们所定义的缩写被设置为只用于foo的本地缓冲区。
    Hello --- world.



% 自动命令和缩写
% 使用本地缓冲区的缩写和自动命令来创建一个简单的“snippet”系统。
% 打开一个Javascript文件然后输入iff缩写。然后再打开一个Python文件试试。
% Vim会依据文件类型在当前行执行合适的缩写。
% 执行下面的命令：
    :autocmd FileType python     :iabbrev <buffer> iff if:<left>
    :autocmd FileType javascript :iabbrev <buffer> iff if ()<left>


% 练习
% 为你经常编辑的文件创建更多的针对不同类型的文件的“snippet”缩写。
你可以为绝大多数语言创建return的缩写，为javascript创建function的缩写，
以及为HTML文件创建&ldquo;和&rdquo;的缩写。
将你创建的snippets加入到你的~/.vimrc文件中。
记住：最好的学习使用这些snippets的方法是_禁用_之前你做这些事情的方式。
执行 :iabbrev <buffer> return NOPENOPENOPE 会_强迫_你使用缩写，
这个命令在你输入return的时候不会输出任何东西。为了节省学习的时间，
为你刚才创建的snippets都创建一个上面的缩写来_强迫_你使用你创建的snippets。




###########################################################
###  Vimscript 自动命令组 
###########################################################
% 前面几章我们学习了自动命令。执行下面命令：
    :autocmd BufWrite * :echom "Writing buffer!"
现在使用:write命令将当前缓冲区写入文件，
然后执行:messages命令查看消息日志。
你会看到Writing buffer!在消息列表中。
然后将当前缓冲区写入文件，执行:messages查看消息日志。
你会看到Writing buffer!在消息列表中出现了两次。

% 现在再次执行上面的自动命令：
    :autocmd BufWrite * :echom "Writing buffer!"
再次将当前缓冲区写入文件并执行:messages命令。
你会看到Writing buffer!在消息列表中出现了_4_次，这是怎么回事？
这是因为当你以上面的方式创建第二个自动命令的时候，Vim没办法知道你是想替换第一个自动命令。
在上面的示例中，Vim创建了两个_不同_的自动命令，并且这两个命令刚好做同样的事情。


% 这会有什么问题？
既然你现在知道了Vim可能创建两个完全一样的自动命令，你可能会想：“有什么大不了？只要别这么干就可以！”。
问题是当你加载你的~/.vimrc文件的时候，Vim会重新读取整个文件，包括你所定义的任何自动命令！
这就意味着每次你加载你的~/.vimrc文件的时候，Vim都会复制之前的自动命令，
这会降低Vim的运行速度，因为它会一次又一次地执行相同的命令。


% 你可以执行下面的命令模拟这种情况：
    :autocmd BufWrite * :sleep 200m
现在将当前缓冲区写入文件。你可能注意到Vim在写入文件的时候有点缓慢，
当然也你可能注意不到。现在执行上面的自动命令三次：
    :autocmd BufWrite * :sleep 200m
    :autocmd BufWrite * :sleep 200m
    :autocmd BufWrite * :sleep 200m
再次写文件。这次会更明显。
当然你不会创建任何只是进行sleep而不做任何事情的自动命令，
不过一个使用Vim的老鸟的~/.vimrc文件可以轻易达到1000行，
其中会有很多自动命令。再加上安装的插件中的自动命令，这肯定会影响Vim的速度。


% 把自动命令放到组中（Grouping Autocommands）
对于这个问题，Vim有一个解决方案。这个解决方案的第一步是将相关的自动命令收集起来放到一个已命名的组（groups）中。
%新开一个Vim实例，这样可以清除之前所创建的自动命令。然后运行下面的命令：
    :augroup testgroup
    :    autocmd BufWrite * :echom "Foo"
    :    autocmd BufWrite * :echom "Bar"
    :augroup END
中间两行的缩进没有什么含义，如果你不想输入的话可以不输。
将一个缓冲区写入文件然后执行:messages。你应该可以在消息日志列表中看到Foo和Bar。现在执行下面的命令：
    :augroup testgroup
    :    autocmd BufWrite * :echom "Baz"
    :augroup END
当你再次将缓冲区写入文件的时候猜猜会发生什么。
ok，你也许已经有结果了，重新写入缓冲区，然后执行:messages命令，看看你猜对了没。



% 清除自动命令组
% 当你写入文件的时候发生什么了？猜对了么？
% 如果你认为Vim会替换那个组，那么你猜错了。不要紧，很多人刚开始的时候都会这么想（我也是）。
% 当你多次使用augroup的时候，Vim每次都会组合那些组。
% 如果你想清除一个组，你可以把autocmd!这个命令包含在组里面。执行下面的命令：
    :augroup testgroup
    :    autocmd!
    :    autocmd BufWrite * :echom "Cats"
    :augroup END
现在试试写入文件然后执行:messages查看消息日志。这次Vim只会输出Cats在消息列表中。



% 在Vimrc中使用自动命令
% 既然我们现在知道了怎么把自动命令放到一个组里面以及怎么清除这些组，
% 我们可以使用这种方式将自动命令添加到~/.vimrc中，这样每次加载它的时候就不会复制自动命令了。
% 添加下面的命令到你的~/.vimrc文件中：
    augroup filetype_html
        autocmd!
        autocmd FileType html nnoremap <buffer> <localleader>f Vatzf
    augroup END
当进入filetype_html这个组的时候，我们会立即清除这个组，然后定义一个自动命令，
然后退出这个组。当我们再次加载~/.vimrc文件的时候，清除组命令会阻止Vim添加一个一模一样的自动命令。


% 练习
查看你的~/.vimrc文件，然后把所有的自动命令用上面组的方式包裹起来。
如果你觉得有必要，可以把多个自动命令放到一个组里面。
想想上一节的示例中的自动命令是干啥的。
阅读:help autocmd-groups。

