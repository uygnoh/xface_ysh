###########################################################
###  AAPCS规则
###########################################################
% AAPCS(Procedure Call Standard for the ARM Architecture)
为了使单独编译的 C语言程序和汇编程序之间能够相互调用，必须为子程序之
间的调用规定一定的规则。基本的AAPCS规定了在子程序调用的一些基本规则，
包括下面3个方面：  寄存器的使用规则及其相应名称， 数据栈的使用规则，
参数传递的规则



############################################################
### % 寄存器的使用规则及其相应名称
############################################################
1 R0~R3(相当于全局变量)子程序通过寄存器 R0~R3来传递参数，这时寄存器
  R0~R3可以记作A1-A4被调用的子程序在返回前无需恢复寄存器R0~R3的内容。

2 R4~R11(相当于局部变量)在子程序中，使用寄存器R4~R11来保存局部变量。
  这时寄存器R4~R11可以记作V1-V8

3 R12寄存器R12用作过程调用时的临时寄存器(用于保存SP, 在函数返回时
  使用该寄存器出栈)，记作IP。

4 R13寄存器R13用作数据栈指针，记作SP.在子程序中寄存器R13 不能用作
  其它用途。

5 R14寄存器R14称为连接寄存器，记作LR。它用于保存子程序的返回地址。

6 R15寄存器R15是程序计数器，记作PC



###########################################################
###  % 数据栈的使用规则
###########################################################
AAPCS规定堆栈为FD类型，即满递减堆栈，并且堆栈的操作是 8 字节对齐。
而对于汇编程序来说，如果目标文件包含了名部调用，则必须满足以下条件：
1 外部接口的数据栈一定是 8位对齐的，也就是保证在进入该汇编代码后，
  直到该汇编程序调用外部代码之间，数据栈的栈指针变化为偶数个字。
2 在汇编程序中使用 PRESERVE8伪指令操作告连接器，本汇编程序是8字节对齐的。
	  
	  

###########################################################
###  % 参数传递的规则
###########################################################
对于参数个数可变的子程序，当参数不超过4个时，可以使用寄存器 R0~R3来
进行参数传递，当参数超过4个时，还可以使数据栈来传递参数。

在参数传递时，将所有参数看做是存放在连续的内存单元中的字数据。然后，
依次将各字数据传送到寄存器R0,R1,R2,R3中，如果参数个数多于4个，将
剩余的字数据传送到数据栈中。

入栈的顺序与参数顺序相反，即最后一个字数据先入栈。



###########################################################
###  % 数据栈限制检查
###########################################################
如果在程序设计期间能够准确计算出所需的内存总量，就不需要进行数据栈的
检查，但是通常情况下这是很难做到的，这时需要进行数据栈的检查。

在进行数据栈的检查时，使用寄器R10作为数据栈限制指针，这时R10又记作SL,
用户在程序中有能控制该寄存器。

在已经占有栈的最低地址和SL之间必须有256字节的空间。也就是说，SL所指的
内存地址必须比已经占用的栈的最低地址低256个字节。

当中断处理程序使用用户的数据栈时，在已经占用的栈的最低地址和SL之间
除了必须保留的256个字节的内存单元外，还必须为中断处理预留足够的内存空间。

用户在程序中不能修改SL的值，数据栈栈指针SP的值必须不小于SL的值。



###########################################################
### % 嵌入式C语言的数据存储方法
###########################################################
% 微处理器的存储空间有 Flash ROM和RAM之分，一般会将常量，常数等存在
  Flash ROM中，不常被修改。而把变量，函数，堆栈等都存放在RAM中， 以
  方便在运行时改变。
% 寄存器是微处理器中被频繁使用的存储空间，常用来存放做计算的操作数，因此
  一个程序被编译成二进制后，分别保存在不同的地方。


% RAM 
_____________________________
零初始化数据
初始化数据
堆栈
堆数据


% Falsh ROM
_____________________________
常量数据
初始化数据
开始和运行库代码
program.txt



###########################################################
### % 嵌入式C语言编写注意事项
###########################################################
数据 类型尽量考虑整形计算符号多加减，少乘，不除尽量采用移位运算代替乘除法
变量尽量用局部变量，少用全局变量。全局变量全部存放在静态存储区，在程序开
始执行时给全局变量分配存储区，程序执行完毕才释放。 全局变量存在于RAM中，
而局部变量存在于堆栈中。如果定义的全局变量太多就有可能导致溢出。
% 注意变量名字的空间污染。
子程序的嵌套越少越好。在子程序运行时，当调用下一个子程序时就需要开辟一个
堆栈空间，直到执行到return语句。才会把这个堆栈去掉。
循环体多用 do-while 少用 for， while从编译的代码可以看出，do-while 
循环中需要一个空间存放退出地址。相对而言，do-while 循环所需的额外开销最少。




###########################################################
###  C语言与汇编语混合编程的方法
###########################################################
% 在C语言中内嵌汇编指令
1  不能直接向 PC寄存器赋值，程序跳转只能使用 B或BL 指令实现。

2  在使用物理寄存器时，不要使用过于复杂的C表达式，以避免物理寄存器冲突。

3  R12和R13可能被编译器用来存放中间编译结果，计算表达式值时可能将R0-R3,
   R12,R14用于子程序调用，因此要避免直接使用这些物理寄存器。

4  一般不要直接指定物理寄存器，而让编译器进行分配。
—————————————————————————————————————————————————
__asm
}
	instruction [;instruction]
	...
	[instruction]
}



############################################################
### % 在汇编中使用C定义的全局变量
############################################################
内嵌汇编不用单独编辑汇编语言文件，比较简洁，但是有诸多限制，当汇编代码
比较多时一般放在单独的汇编文件中。

这时就需要在汇编和 C之间进行一些数据的传递。最简单的办法就是使用全局变量。

使用 IMPORT 伪指令引入全局变量，并利用 LDR和STR指令根据全局变量的地址访问它们。

% 下面例子是一个汇编代码的函数，它读取全局变量 ABC,其加2后写回。
AREA ABC, CODE, READONLY
	EXPORT asmsub
	IMPORT ABC
asmsub
	LDR R1, =ABC
	LDR R0, [R1]
	ADD R0, R0, #2
	STR R0, [R1]
	MOV PC, LR
END



############################################################
### % 在C 程序中调用汇编程序
############################################################
C 程序调用汇编程序时需要做到以下两步：
——————————————————————————————————————
1 在 C程序中使用 extern 关键字声明外部函数（声明要调用的汇编子程序），
 即可调用此汇编子程序。
——————————————————————————————————————
2 在汇编程序中使 EXPORT 伪指令声明本子程序，使其它程序可以调用此子程序。
  另外，汇编程序设置要遵循 AAPCS规则，保证程序调用时参数的正确传递。
——————————————————————————————————————
% 1 C程序如下：
#include <stdio.h>
extern void strcopy(char *d, const char *s);
int main(void)
{
	const char *srcstr ="First string-source";
	char *dststr ="Second string-destination";
	strcopy(dststr, srcstr);
	return 0;
}

% 2 汇编程序如下：
AREA SCopy, CODE, READONLY
ENTRY
EXPORT strcopy
strcopy
	LDRB R2, [R1], #1
	STRB R2, [R0], #1
	CMP R2, #0
	BNE strcopy
	MOV PC, LR
END




############################################################
### % 在汇编程序中调用 C程序
############################################################
汇编程序的设置要遵循AAPCS规则，即前4个参数通过R0-R3传递，后面的参数
通过堆栈传递，保证程序调用时参数的正确传递。

在汇编程序中使用IMPORT伪指令声明将在调用的C程序函数。在调用C程序时，
要正确设置入口参数，然后使用BL调用。

1 汇编程序调用C程序的C函数代码如下：
——————————————————————————————————————
int cFun(int a, int b, int c)
{
    return (a+b+c);
}

2 汇编程序调用C程序的汇编程序代码如下；
——————————————————————————————————————
AREA asmfile, CODE, READONLY
IMPORT cFun
ENTRY
    MOV R0, #11
    MOV R1, #22
    MOV R2, #33
    BL cFun
END



###########################################################
###  嵌入式C语言一些常用的用法
###########################################################
——————————————————————————————————————
% Define是C语言中的预处理指令，用于宏定义。
#define 标示符 字符串


——————————————————————————————————————
% ifdef条件编译
#ifdef 标识符
    程序段1
#else
    程序段2
#endif

——————————————————————————————————————
% 位运算操作
按位与             &
按位或             |
按位取反           ~
按位异或           ^
按位左移           <<
按位右移           >>


——————————————————————————————————————
% extern变量申明
C语言中，extern可以放在变量或函数之前，以表示该变量或函数的定义
在别的文件中，提示编译器在其它模块中寻找其定义。

通过extern申明变量可以有多次，但是该变量的定义只能有一次。该申明
的变量事实上就是全局变量。
% 例如：
extern u16 USART_RX_STA;    //申明的USART_RX_STA在其它文件中定义


___________________________________________________________
% typedef 类型别名

typedef struct {
    __IO uint32_t MOD;
    __IO uint32_t OTY;
    ...
} GPIO_TypeDef;
//GPIO_TypeDefo 为该结构体的别名




###############################################################################
### % ARM汇编语言伪指令
###############################################################################
% 指令-------->指令性语句 ↝处理器执行
% 伪指令------>指示性语句 ↝汇编器处理

% 指令有相应的操作码，而伪指令没有
一般指令是在程序运行时由CPU执行，而伪指令是在源程序汇编时由汇编程序来处理

伪指令在源程序中的作用是为完成汇编程序作各种准备工作的，
这些伪指令仅在汇编过程中起作用，
旦汇编结束，伪指令的使命就完成了。



###########################################################
###  数据定义伪指令
###########################################################
% 字节单元定义伪指令 DCB
格式：标号 DCB 表达式

功能：DCB伪指令用分配一片连续的字节存储单元，
      并用伪指令指定的表达式初始化。
注意：表达式可以为 0～255 的数字或字符串。
      DCB也可能用 “=”代替。
例如：
	str DCB "this is a test!" ;分配连续的字节存储单元
                              ;并初始化


% 半字单元定义伪指令 DCW （或DCWU）
格式：标号 DCW （或DCWU） 表达式

功能：DCW(或DCWU）伪指令用于分配一片连续的半字单元
      并用伪指令中指定的表达式初始化。
注意：表达式可以为和序标号或数字表达式。
      用DCW分配的存储单元是半字对齐的，
      而用DCWU 分配的存储单元并不严格半字对齐。
例如：
	data_test DCW 1, 2, 3,  ;分配连续的半字存储单元
                                ;并初始化


% 字单元定义伪指令 DCD （或DCDU)
格式：标号 DCD(或DCDU) 表达式

功能：DCD（或DCDU)伪指令作于分配一片连续的字存储单元
      并用伪指令中指定的表达式初始化。
注意：表达式可以为程序标号或数字表达式。
      DCD也可以用 “&” 代替。
      作DCD分配的存储单元是字对齐的，
      而用DCDU分配的存储单元并不严格字对齐。
例如：
	datatest DCD 2, 1, 5  ;分配连续的字存储单元
                              ;并初始化

% 双精度定义伪指令DCFD(或DCFDU)
格式：标号 DCFD(或DCFDU) 表达式

功能：DCFD(或DCFDU) 伪指令用于双精度浮点数
      分配一片连续的存储单元并用伪指令中指定的表达式初始化。
      每个双精度浮点数占用 2个字存储单元。
注意：用DCFD分配的存储单元是字对齐的，
      而用DCFDU分配的存储单元并不严格字对齐。
例如：
	FDataTest DCFD 5E13, -4E2 ;分配连续的字存储单元
                              ;并初始化为指定的双精度

% 单精度数定义伪指令 DCFS(或DCFSU)
格式：标号 DCFS(或DCFSU) 表达式

功能：DCFS(或DCFSU) 伪指令用于为单精度浮点数
      分配一片连续的字存储单元并用伪指令指定的表达式初始化。
注意:每个单精度浮点数占用 1个字单元。
     用DCFS分配的存储单元是字对齐的，
     而用DCFSU分配的存储单元并不严格字对齐。
例如：
	FDataTest DCSD 3E15, -4E2 ;分配连续的字存储单元
                                  ;并初始化为指定的单精度数      

% 双字单元定义伪指令 DCQ （或DCQU)
格式：标号 DCQ(或DCQU) 表达式

功能：DCQ(或DCQU)伪指令作于分配一片以 8 个字节为单位的连续存储单元
      并用伪指令中指定的表达式初始化。
注意：表达式可以为程序标号或数字表达式。
      作DCQ分配的存储单元是字对齐的，
      而用DCQU分配的存储单元并不严格字对齐。
例如：
	datatest DCQ 226      ;分配连续的字存储单元
                          ;并初始化指定的值

% 存储区域定义伪指令
格式：标号 SPACE 表达式

功能：SPACE 伪指令用于分配一片连续的存储区域并初始化为 0。
注意：表达式在分配的字节数。
      SPACE也可以用 “%” 代替。
例如：
	datetest SPACE 256 ;分配连续256个字节的存储单元
                       ;并初始化为 0

% 首在址定义伪指令
格式：MAP 表达式{，基地址寄存器}

功能：MAP伪指令用于定义一个结构的内存表的首地址
      MAP也可以用 “^”代替
注意：表达式可以为程序中的标号或数学表达式，
      基地址寄存器为可选项
      当基地址寄存器不存在时表达式的值即为内存表的首地址
      当该项存在时，内存表的首地址为表达式的值与基址寄存器的和
      MAP伪指令通常与FIELD伪指令配合使用来定义结构化的内存表。
例如：
	MAP 0x100, R0 ;定义结构化内存表首地址为
                  ;0x100+R0

% 数据定义伪指令 FIELD
格式：标号 表达式

功能：用于定义结构化内存表中数据的域，
      也可以用 “#”代替
      值为当前数据域在内存表中所占的字节数
注意：该常与 MAP伪指令配合使用定义结构化的内存表
      MAP伪指令定义内存表的首地址，
      FIELD伪指令定义内存表中的各个数据域，
      并可以为每一个数据域指定一个标号供其它的指令引用
      此外两个伪指令仅定义数据结构，并不实际分配存储单元。
例如：
MAP 0x100  ;定义结构化内存表的首地址0x100
A FIELD 8  ;定义A长度为8字节，位置为0x100
B FIELD 16 ;定义B长度为16字节，位置为0x108
C FIELD 32 ;定义C长度为32字节，位置为0x118



###########################################################
###  符号定义伪指令
###########################################################
% 全局变量定义伪指令
格式：GBLA GBLL GBLS 全局变量名

功能：GBLA伪指令用于定义一个全局数字变量，初始化为 0
      GBLL伪指令用于定义一个全局逻辑变量，初始化为 FALSE（假）
      GBLS伪指令用于定义一个全局的字符串变量，初始化为 空
注意：由于这三条伪指令用于定义全局变量，因此整个程序范围内变量名必须唯一。
例如：
	GBLA Test1          ;定义一个全局数字变量，名为Test1
	GBLL Test2          ;定义一个全局逻辑变量，名为Test2
	GBLS Test3          ;定义一个全局字符串变量，名为Test3
	

% 局部变量定义伪指令 LCLA,LCll,LCLS
格式：LCLA(LCLL,LCLS) 局部变量名



% 变量赋值伪指令 SETA,SETL,SETS
例如：
	LCLA test7		    ;声明一个局部数字变量，变量名为test7
	test7 SETA 0x1234	;将该变量赋值为0x1234
	LCLL test8		    ;声明一个局部逻辑变量，变量名为test8
	test8 SETL {TRUE}	;将变量赋值为真


% 寄存器列表定义伪指令 RLIST
格式：名称 RLIST {寄存器列表}

功能：RLIST 伪指令可用于对一个通用寄存器列表定义名称，
      使用该伪指令定义的名称可以在ARM指令 LDM/STM中使用
注意：在LDM/STM指令中，列表中的寄存器访问次序为根据
      寄存器的编号由低到高，而与列表寄存器排列无关。
例如：
RegList RLIST {R0-R5,R8,R10} ;将寄存器列表名称定义为RegList，
                             ;可以在ARM指令LDM/STM中通过该名称访问寄存器列表



###########################################################
###  汇编结构伪指令
###########################################################
% 段定义伪指令 AREA
格式：AREA 段名 属性1, 属性2, ......

ARM中只有两种段：代码段和数据段

功能：AREA伪指令用于定义一个代码段或数据段，
      其中，段名若以数字开头，则该段名需要用 “|“括起来
      例如：|1_test|
注意：一个汇编程序至少包含一个段，
     当程序太长时，也可以将程序分为多个代码段或数据段。

属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。

CODE 属性：        用于定义代码段，默认为 READONLY
DATA 属性：        用于定义数据段，默认为 READWRITE
READONLY 属性：    指定本段为只读，代码段默认为 READONLY
READWRITE 属性：   指定本段可读可写，义数据段默认为 READWRITE
ALIGN 属性：       使用方式为 ALIGN表达式。
                   在默认时，ELF(可执行连接文件）的代码段和数据段是按字对齐的。
                   表达式的取值范围为 0～31 ，相应的对齐方式为 2表达式次方。
COMMON 属性：      该属性定义一个通用的段，不包含任何的用户代码和数据。
                   各源文件中同名的 COMMON段共享同一段存储单元。


% ALIGN 伪指令
格式：ALIGN {表达式{，偏移量}}

功能：ALIGN伪指令可以通过添加填充字节的方式，使当前位置满足一定的对齐方式。
      其中，表达式的值用于指定对齐方式，可能取值为 2 的幂，如1,2,4,8,16等。
      若未指定表达式，则将当前位置对齐到下一个字的位置。
      偏移量也为一个表达式，若使用该字段，则当前位置的对齐方式为：
            2 的表达式次幂 + 偏移量。
例如：
	AREA Init, CODE, READONLY, ALIGN=3
   ;ALIGN=3，指定后面的指令为 8 字节对齐方式。
   


% CODE16,CODE32状态切换伪指令



% 程序入口伪指令 ENTRY
格式：ENTRY

功能：ENTRY 伪指令用于指定汇编程序的入口点。
注意：在一个完整的汇编程序中至少要有一个 ENTRY,
      当有多个 ENTRY时，程序的真正入口点由链接器指定。
      但在一个源文件中最多只能有一个ENTRY,也可以没有。
例如：
	AREA Init, CODE, READONLY
	ENTRY	;指定程序的入口点


% 程序结束伪指令 END
格式：END

功能：END用于通知编译器已经到了源程序的结尾。



% 标号输出伪指令 EXPORT(或GLOBAL)
格式：EXPORT 标号 {[WEAK]}

功能：EXPORT伪指令用于在程序中声明一个全局的标号，
      该标号可以在其它文件中引用。
注意：EXPORT可以用GLOBAL代替，标号在程序中区分大小写。
      WEAK 选项，声明其它同名标号优先于该标号被引
例如：
AREA Init, CODE, READONLY
EXPORT Main0 ;声明一个全局引用的标号Main0


% 标号输入伪指令 IMPORT
格式：IMPORT 标号 {[WEAK]}

功能：IMPORT伪指令用于通知编译器要使用的标号在其它源文件中的定义，
      但要在当前源文件中引用，且无论当前源文件是否引用该标号，
      该标号均会被加入到当前源文件的符号表中。
注意：标号在程序中区分大小写，
      WEAK 选项，表示当所有的源文件都没有定义这样一个标号时，
      编译器也不会给出错误信息。
在多数情况下将该标号置为0,若该标号为 B或BL指令引用，
则将B或BL指令置为 NOP操作。

例如：
AREA Init, CODE, READONLY
IMPORT Main1 ;通知编译器当前文件在引用标号Main1,
             ;但Main1在其它源文件中定义。


% 标号引入伪指令 EXTERN
格式：EXTERN 标号 {[WEAK]} 

功能：EXTERN伪指令用于通知编译器在使用的标号在其它的源文件中定义，
      但要在当前源文件中引用，
      与IMPORT 不同的是
      如果当前源文件实际并未引用该标号，
      该标号就不会加入到当前源文件的符号表中。
      


% 源文件包含伪指令 GET(或INCLUDE)
格式：GET 文件名

功能：GET伪指令用于将一个源文件包含到当前的源文件中，
      并将被包含的源文件在当前位置时行汇编处理，
      可以使用INCLUDE代替GET。
GET file1.s             ;通知编译器当前源文件包含文件file1.s
GET /tmp/file2.s        ;通知编译器当前源文件包含文件/tmp/file2.s



% 目标文件包含伪指令 INCBIN
格式：INCBIN 文件名

功能：INCBIN伪指令用于将一个目标文件或数据文件包含到当前的源文件中，
被包含的文件不作任何变动的存放在当前文件中，编译器从其后开始继续处理。

INCBIN file a1.dat      ;通知编译器当前源文件包含文件a1.dat
INCBIN /tmp/file a1.txt ;通知编译器当前源文件包含文件a1.txt




###########################################################
###  汇编控制伪指令
###########################################################
% 1.1 条件控制伪指令 IF, ELSE, ENDIF
格式：
IF 逻辑表达式
	指令序列1
ELSE 
	指令序列2
ENDIF

功能：该指令能根据条件的成立与否决定是否执行某个指令序列。
      当IF后面的逻辑表达式为真，
      则执行指令序列1,
      否则执行指令序列2

% 1.2 循环控制伪指令 WHILE, WEND
格式：
WHILE 逻辑表达式
	指令序列
WEND
功能：该组伪指令能根据条件的成立与否决定是否循环执行某个指序列。
      当WHILE后面的逻辑表达式为真，则执行指令序列，
      该指令序列执行完毕后，再判断逻辑表达式的值，
      若为真则继续执行，一直到逻辑表达式的值为假。

% 1.3 宏定义伪指令 MACRO, MEND 
格式：
MACRO 
	$标号 宏名 $参数1, $参数2, ...
	指令序列
MEND

功能：MACRO，MEND,伪指令可以将一段代码定义为一个整体，称为宏。
      然后可以通过宏指令多次调用该段代码。
注意：$标号在宏指令展开时，标号会替换为用户定义的符号。
      宏指令可以使使用一个或多个参数，
      当宏指令被展开时，这些参数被相应的值替换。
说明：宏指令的使用方式和功能与子程序有些相似，
      子程序可以提供模块化的程序设计，节省存储空间并提高运行速度。
      但在使用子程序结构时需要保护现场，从而增加了系统的开销。
      因此，在代码较短 且需要传递参数较多时，可以使用宏指令代替子程序。

包含在MACRO和MEND 之间的指令序列称为宏定义体。
在宏定义体的第一行应该声明宏的原型（包含宏名，所需的参数），
然后就可以在汇编程序中通过宏名来调用该指令序列。

% 1.4 宏退出伪指令 MEXIT
格式：MEXIT
功能：MEXIT用于从宏定义中退出去。



###########################################################
###  其它常用伪指令
###########################################################
1.等效定义伪指令 EQU
格式：名称 EQU 表达式{，类型}
功能：EQU伪指令用于为程序中的常量，标号等定义一个等效的字符名称。
      类似于C语言中的 #define .
      其中EQU可以用”*“代替。
注意：名称EQU伪指令定义的字符名称，
      当表达式为 32位常量时，可指定表达式的数据类型，
       以下有 3 种数据类型：
       CODE16, CODE32,DATA.
例如：
Test EQU 10		;定义标号Test的值为10
addr EQU 0xff,CODE32    ;定义Addr的值为0xff，且
                        ;该处为32位的ARM指令。

2 别名定义伪指令 RN
格式：名称 RN 表达式
功能：RN 伪指令用于给一个寄存器定义一个别名。
注意：采用这种方式可以方便程序员记忆寄存器的功能。
      其中，名称为给寄存器定义的别名，
      表达式为寄存器的编码。
例如：
Temp RN R0
;将R0定义一个别名为Temp.

% ROUT伪指令
格式：{名称} ROUT
功能：用于给一个局部变量定义作用范围。
注意：在程序中未使用该伪指令时，
      局部变量的作用范围为所在的AREA,
      而使用ROUT伪指令后，
      局部变量的作用范围为当前 ROUT和下一个ROUT 之间。






